var pp = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all2) => {
    for (var name9 in all2)
      __defProp(target, name9, { get: all2[name9], enumerable: true });
  };
  var __copyProps = (to, from3, except, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // node_modules/netmask/lib/netmask.js
  var require_netmask = __commonJS({
    "node_modules/netmask/lib/netmask.js"(exports) {
      (function() {
        var Netmask2, atob2, chr, chr0, chrA, chra, ip2long, long2ip;
        long2ip = function(long) {
          var a2, b, c2, d2;
          a2 = (long & 255 << 24) >>> 24;
          b = (long & 255 << 16) >>> 16;
          c2 = (long & 255 << 8) >>> 8;
          d2 = long & 255;
          return [a2, b, c2, d2].join(".");
        };
        ip2long = function(ip) {
          var b, c2, i2, j, n2, ref;
          b = [];
          for (i2 = j = 0; j <= 3; i2 = ++j) {
            if (ip.length === 0) {
              break;
            }
            if (i2 > 0) {
              if (ip[0] !== ".") {
                throw new Error("Invalid IP");
              }
              ip = ip.substring(1);
            }
            ref = atob2(ip), n2 = ref[0], c2 = ref[1];
            ip = ip.substring(c2);
            b.push(n2);
          }
          if (ip.length !== 0) {
            throw new Error("Invalid IP");
          }
          switch (b.length) {
            case 1:
              if (b[0] > 4294967295) {
                throw new Error("Invalid IP");
              }
              return b[0] >>> 0;
            case 2:
              if (b[0] > 255 || b[1] > 16777215) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1]) >>> 0;
            case 3:
              if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
            case 4:
              if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
            default:
              throw new Error("Invalid IP");
          }
        };
        chr = function(b) {
          return b.charCodeAt(0);
        };
        chr0 = chr("0");
        chra = chr("a");
        chrA = chr("A");
        atob2 = function(s2) {
          var base3, dmax, i2, n2, start2;
          n2 = 0;
          base3 = 10;
          dmax = "9";
          i2 = 0;
          if (s2.length > 1 && s2[i2] === "0") {
            if (s2[i2 + 1] === "x" || s2[i2 + 1] === "X") {
              i2 += 2;
              base3 = 16;
            } else if ("0" <= s2[i2 + 1] && s2[i2 + 1] <= "9") {
              i2++;
              base3 = 8;
              dmax = "7";
            }
          }
          start2 = i2;
          while (i2 < s2.length) {
            if ("0" <= s2[i2] && s2[i2] <= dmax) {
              n2 = n2 * base3 + (chr(s2[i2]) - chr0) >>> 0;
            } else if (base3 === 16) {
              if ("a" <= s2[i2] && s2[i2] <= "f") {
                n2 = n2 * base3 + (10 + chr(s2[i2]) - chra) >>> 0;
              } else if ("A" <= s2[i2] && s2[i2] <= "F") {
                n2 = n2 * base3 + (10 + chr(s2[i2]) - chrA) >>> 0;
              } else {
                break;
              }
            } else {
              break;
            }
            if (n2 > 4294967295) {
              throw new Error("too large");
            }
            i2++;
          }
          if (i2 === start2) {
            throw new Error("empty octet");
          }
          return [n2, i2];
        };
        Netmask2 = (function() {
          function Netmask3(net, mask) {
            var error, i2, j, ref;
            if (typeof net !== "string") {
              throw new Error("Missing `net' parameter");
            }
            if (!mask) {
              ref = net.split("/", 2), net = ref[0], mask = ref[1];
            }
            if (!mask) {
              mask = 32;
            }
            if (typeof mask === "string" && mask.indexOf(".") > -1) {
              try {
                this.maskLong = ip2long(mask);
              } catch (error1) {
                error = error1;
                throw new Error("Invalid mask: " + mask);
              }
              for (i2 = j = 32; j >= 0; i2 = --j) {
                if (this.maskLong === 4294967295 << 32 - i2 >>> 0) {
                  this.bitmask = i2;
                  break;
                }
              }
            } else if (mask || mask === 0) {
              this.bitmask = parseInt(mask, 10);
              this.maskLong = 0;
              if (this.bitmask > 0) {
                this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
              }
            } else {
              throw new Error("Invalid mask: empty");
            }
            try {
              this.netLong = (ip2long(net) & this.maskLong) >>> 0;
            } catch (error1) {
              error = error1;
              throw new Error("Invalid net address: " + net);
            }
            if (!(this.bitmask <= 32)) {
              throw new Error("Invalid mask for ip4: " + mask);
            }
            this.size = Math.pow(2, 32 - this.bitmask);
            this.base = long2ip(this.netLong);
            this.mask = long2ip(this.maskLong);
            this.hostmask = long2ip(~this.maskLong);
            this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
            this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
            this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
          }
          Netmask3.prototype.contains = function(ip) {
            if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
              ip = new Netmask3(ip);
            }
            if (ip instanceof Netmask3) {
              return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
            } else {
              return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
            }
          };
          Netmask3.prototype.next = function(count) {
            if (count == null) {
              count = 1;
            }
            return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
          };
          Netmask3.prototype.forEach = function(fn) {
            var index, lastLong, long;
            long = ip2long(this.first);
            lastLong = ip2long(this.last);
            index = 0;
            while (long <= lastLong) {
              fn(long2ip(long), long, index);
              index++;
              long++;
            }
          };
          Netmask3.prototype.toString = function() {
            return this.base + "/" + this.bitmask;
          };
          return Netmask3;
        })();
        exports.ip2long = ip2long;
        exports.long2ip = long2ip;
        exports.Netmask = Netmask2;
      }).call(exports);
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener2(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names2 = [], events, name9;
        if (this._eventsCount === 0) return names2;
        for (name9 in events = this._events) {
          if (has.call(events, name9)) names2.push(prefix ? name9.slice(1) : name9);
        }
        if (Object.getOwnPropertySymbols) {
          return names2.concat(Object.getOwnPropertySymbols(events));
        }
        return names2;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length4 = listeners.length, j;
          for (i2 = 0; i2 < length4; i2++) {
            if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener2(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener2(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length4 = listeners.length; i2 < length4; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
              events.push(listeners[i2]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/hashlru/index.js
  var require_hashlru = __commonJS({
    "node_modules/hashlru/index.js"(exports, module) {
      module.exports = function(max2) {
        if (!max2) throw Error("hashlru must have a max value, of type number, greater than 0");
        var size = 0, cache3 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
        function update(key, value2) {
          cache3[key] = value2;
          size++;
          if (size >= max2) {
            size = 0;
            _cache = cache3;
            cache3 = /* @__PURE__ */ Object.create(null);
          }
        }
        return {
          has: function(key) {
            return cache3[key] !== void 0 || _cache[key] !== void 0;
          },
          remove: function(key) {
            if (cache3[key] !== void 0)
              cache3[key] = void 0;
            if (_cache[key] !== void 0)
              _cache[key] = void 0;
          },
          get: function(key) {
            var v = cache3[key];
            if (v !== void 0) return v;
            if ((v = _cache[key]) !== void 0) {
              update(key, v);
              return v;
            }
          },
          set: function(key, value2) {
            if (cache3[key] !== void 0) cache3[key] = value2;
            else update(key, value2);
          },
          clear: function() {
            cache3 = /* @__PURE__ */ Object.create(null);
            _cache = /* @__PURE__ */ Object.create(null);
          }
        };
      };
    }
  });

  // node_modules/timestamp-nano/dist/timestamp.min.js
  var require_timestamp_min = __commonJS({
    "node_modules/timestamp-nano/dist/timestamp.min.js"(exports, module) {
      var Timestamp = (function() {
        "undefined" != typeof module && (module.exports = d2);
        var l2 = 86400, s2 = 3200, T = 146097 * s2 / 400, e2 = l2 * T, f2 = 1e3 * e2, c2 = 864e13, g = 4294967296, h = 1e6, u = "000000000", m2 = Math.trunc || function(n3) {
          var t3 = n3 - n3 % 1;
          return 0 == t3 && (n3 < 0 || 0 === n3 && 1 / n3 != 1 / 0) ? -0 : t3;
        }, n2 = d2.prototype, o2 = (d2.fromDate = function(n3) {
          return new d2(+n3);
        }, d2.fromInt64BE = r2(0, 1, 2, 3, 0, 4), d2.fromInt64LE = r2(3, 2, 1, 0, 4, 0), d2.fromString = function(n3) {
          var e3, r3 = new d2(), n3 = (n3 += "").replace(/^\s*[+\-]?\d+/, function(n4) {
            var n4 = +n4, t3 = 1970 + (n4 - 1970) % 400;
            return r3.year = n4 - t3, t3;
          }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(n4, t3, r4) {
            return t3 < 0 && (r4 *= -1), e3 = 6e4 * (60 * +t3 + +r4), "";
          }).replace(/\.\d+$/, function(n4) {
            return r3.nano = +(n4 + u).substr(1, 9), "";
          }).split(/\D+/);
          1 < n3.length ? n3[1]-- : n3[1] = 0;
          if (r3.time = e3 = Date.UTC.apply(Date, n3) - (e3 || 0), isNaN(e3)) throw new TypeError("Invalid Date");
          return p2(r3);
        }, d2.fromTimeT = function(n3) {
          return y(n3, 0);
        }, n2.year = 0, n2.time = 0, n2.nano = 0, n2.addNano = function(n3) {
          return this.nano += +n3 || 0, this;
        }, n2.getNano = function() {
          var n3 = p2(this);
          return (n3.time % 1e3 * h + +n3.nano + 1e9) % 1e9;
        }, n2.getTimeT = function() {
          var n3 = p2(this), t3 = Math.floor(n3.time / 1e3), n3 = n3.year;
          n3 && (t3 += n3 * T * l2 / s2);
          return t3;
        }, n2.getYear = function() {
          return this.toDate().getUTCFullYear() + this.year;
        }, n2.toDate = function() {
          return M(p2(this).time);
        }, n2.toJSON = function() {
          return this.toString().replace(/0{1,6}Z$/, "Z");
        }, n2.toString = function(n3) {
          var t3 = this, r3 = t3.toDate(), u2 = { H: function() {
            return C(r3.getUTCHours());
          }, L: function() {
            return D(r3.getUTCMilliseconds(), 3);
          }, M: function() {
            return C(r3.getUTCMinutes());
          }, N: function() {
            return D(t3.getNano(), 9);
          }, S: function() {
            return C(r3.getUTCSeconds());
          }, Y: function() {
            var n4 = t3.getYear();
            return 999999 < n4 ? "+" + n4 : 9999 < n4 ? "+" + D(n4, 6) : 0 <= n4 ? D(n4, 4) : -999999 <= n4 ? "-" + D(-n4, 6) : n4;
          }, a: function() {
            return a2[r3.getUTCDay()];
          }, b: function() {
            return i2[r3.getUTCMonth()];
          }, d: function() {
            return C(r3.getUTCDate());
          }, e: function() {
            return (function(n4) {
              return (9 < n4 ? "" : " ") + (0 | n4);
            })(r3.getUTCDate());
          }, m: function() {
            return C(r3.getUTCMonth() + 1);
          } };
          return (function e3(n4) {
            return n4.replace(/%./g, function(n5) {
              var t4 = n5[1], r4 = v[t4], t4 = u2[t4];
              return r4 ? e3(r4) : t4 ? t4() : n5;
            });
          })(n3 || o2);
        }, n2.writeInt64BE = t2(0, 1, 2, 3, 0, 4), n2.writeInt64LE = t2(3, 2, 1, 0, 4, 0), "%Y-%m-%dT%H:%M:%S.%NZ"), i2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], a2 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], v = { "%": "%", F: "%Y-%m-%d", n: "\n", R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
        return d2;
        function d2(n3, t3, r3) {
          var e3 = this;
          if (!(e3 instanceof d2)) return new d2(n3, t3, r3);
          e3.time = +n3 || 0, e3.nano = +t3 || 0, e3.year = +r3 || 0, p2(e3);
        }
        function p2(n3) {
          var t3, r3, e3, u2 = n3.year, o3 = n3.time, i3 = n3.nano, a3 = ((i3 < 0 || h <= i3) && (i3 -= (r3 = Math.floor(i3 / h)) * h, o3 += r3, r3 = 1), u2 % s2);
          return (o3 < -c2 || c2 < o3 || a3) && ((t3 = m2(o3 / f2)) && (u2 += t3 * s2, o3 -= t3 * f2), (e3 = M(o3)).setUTCFullYear(a3 + e3.getUTCFullYear()), e3 = (o3 = +e3) + (t3 = m2((u2 -= a3) / s2)) * f2, t3 && -c2 <= e3 && e3 <= c2 && (u2 -= t3 * s2, o3 = e3), r3 = 1), r3 && (n3.year = u2, n3.time = o3, n3.nano = i3), n3;
        }
        function M(n3) {
          var t3 = /* @__PURE__ */ new Date(0);
          return t3.setTime(n3), t3;
        }
        function y(n3, t3) {
          n3 = +n3 || 0;
          var r3 = m2((t3 = (t3 | 0) * g) / e2) + m2(n3 / e2), t3 = t3 % e2 + n3 % e2, n3 = m2(t3 / e2);
          return n3 && (r3 += n3, t3 -= n3 * e2), new d2(1e3 * t3, 0, r3 * s2);
        }
        function t2(e3, u2, o3, i3, a3, f3) {
          return function(n3, t3) {
            var r3 = p2(this);
            n3 = n3 || new Array(8);
            w(n3, t3 |= 0);
            var e4 = Math.floor(r3.time / 1e3), r3 = r3.year * (T * l2 / s2), u3 = m2(r3 / g) + m2(e4 / g), r3 = r3 % g + e4 % g, e4 = Math.floor(r3 / g);
            e4 && (u3 += e4, r3 -= e4 * g);
            return c3(n3, t3 + a3, u3), c3(n3, t3 + f3, r3), n3;
          };
          function c3(n3, t3, r3) {
            n3[t3 + e3] = r3 >> 24 & 255, n3[t3 + u2] = r3 >> 16 & 255, n3[t3 + o3] = r3 >> 8 & 255, n3[t3 + i3] = 255 & r3;
          }
        }
        function r2(r3, e3, u2, o3, i3, a3) {
          return function(n3, t3) {
            w(n3, t3 |= 0);
            var r4 = f3(n3, t3 + i3);
            return y(f3(n3, t3 + a3), r4);
          };
          function f3(n3, t3) {
            return 16777216 * n3[t3 + r3] + (n3[t3 + e3] << 16 | n3[t3 + u2] << 8 | n3[t3 + o3]);
          }
        }
        function w(n3, t3) {
          n3 = n3 && n3.length;
          if (null == n3) throw new TypeError("Invalid Buffer");
          if (n3 < t3 + 8) throw new RangeError("Out of range");
        }
        function C(n3) {
          return (9 < n3 ? "" : "0") + (0 | n3);
        }
        function D(n3, t3) {
          return (u + (0 | n3)).substr(-t3);
        }
      })();
    }
  });

  // node_modules/truncate-utf8-bytes/lib/truncate.js
  var require_truncate = __commonJS({
    "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports, module) {
      "use strict";
      function isHighSurrogate(codePoint) {
        return codePoint >= 55296 && codePoint <= 56319;
      }
      function isLowSurrogate(codePoint) {
        return codePoint >= 56320 && codePoint <= 57343;
      }
      module.exports = function truncate(getLength, string2, byteLength) {
        if (typeof string2 !== "string") {
          throw new Error("Input must be string");
        }
        var charLength = string2.length;
        var curByteLength = 0;
        var codePoint;
        var segment;
        for (var i2 = 0; i2 < charLength; i2 += 1) {
          codePoint = string2.charCodeAt(i2);
          segment = string2[i2];
          if (isHighSurrogate(codePoint) && isLowSurrogate(string2.charCodeAt(i2 + 1))) {
            i2 += 1;
            segment += string2[i2];
          }
          curByteLength += getLength(segment);
          if (curByteLength === byteLength) {
            return string2.slice(0, i2 + 1);
          } else if (curByteLength > byteLength) {
            return string2.slice(0, i2 - segment.length + 1);
          }
        }
        return string2;
      };
    }
  });

  // node_modules/utf8-byte-length/browser.js
  var require_browser = __commonJS({
    "node_modules/utf8-byte-length/browser.js"(exports, module) {
      "use strict";
      function isHighSurrogate(codePoint) {
        return codePoint >= 55296 && codePoint <= 56319;
      }
      function isLowSurrogate(codePoint) {
        return codePoint >= 56320 && codePoint <= 57343;
      }
      module.exports = function getByteLength(string2) {
        if (typeof string2 !== "string") {
          throw new Error("Input must be string");
        }
        var charLength = string2.length;
        var byteLength = 0;
        var codePoint = null;
        var prevCodePoint = null;
        for (var i2 = 0; i2 < charLength; i2++) {
          codePoint = string2.charCodeAt(i2);
          if (isLowSurrogate(codePoint)) {
            if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
              byteLength += 1;
            } else {
              byteLength += 3;
            }
          } else if (codePoint <= 127) {
            byteLength += 1;
          } else if (codePoint >= 128 && codePoint <= 2047) {
            byteLength += 2;
          } else if (codePoint >= 2048 && codePoint <= 65535) {
            byteLength += 3;
          }
          prevCodePoint = codePoint;
        }
        return byteLength;
      };
    }
  });

  // node_modules/truncate-utf8-bytes/browser.js
  var require_browser2 = __commonJS({
    "node_modules/truncate-utf8-bytes/browser.js"(exports, module) {
      "use strict";
      var truncate = require_truncate();
      var getLength = require_browser();
      module.exports = truncate.bind(null, getLength);
    }
  });

  // node_modules/sanitize-filename/index.js
  var require_sanitize_filename = __commonJS({
    "node_modules/sanitize-filename/index.js"(exports, module) {
      "use strict";
      var truncate = require_browser2();
      var illegalRe = /[\/\?<>\\:\*\|"]/g;
      var controlRe = /[\x00-\x1f\x80-\x9f]/g;
      var reservedRe = /^\.+$/;
      var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
      var windowsTrailingRe = /[\. ]+$/;
      function sanitize2(input, replacement) {
        if (typeof input !== "string") {
          throw new Error("Input must be string");
        }
        var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
        return truncate(sanitized, 255);
      }
      module.exports = function(input, options2) {
        var replacement = options2 && options2.replacement || "";
        var output = sanitize2(input, replacement);
        if (replacement === "") {
          return output;
        }
        return sanitize2(output, "");
      };
    }
  });

  // node_modules/pvtsutils/build/index.js
  var require_build = __commonJS({
    "node_modules/pvtsutils/build/index.js"(exports) {
      "use strict";
      var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
      var BufferSourceConverter6 = class _BufferSourceConverter {
        static isArrayBuffer(data) {
          return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
        }
        static toArrayBuffer(data) {
          if (this.isArrayBuffer(data)) {
            return data;
          }
          if (data.byteLength === data.buffer.byteLength) {
            return data.buffer;
          }
          if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
            return data.buffer;
          }
          return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
        }
        static toUint8Array(data) {
          return this.toView(data, Uint8Array);
        }
        static toView(data, type) {
          if (data.constructor === type) {
            return data;
          }
          if (this.isArrayBuffer(data)) {
            return new type(data);
          }
          if (this.isArrayBufferView(data)) {
            return new type(data.buffer, data.byteOffset, data.byteLength);
          }
          throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        static isBufferSource(data) {
          return this.isArrayBufferView(data) || this.isArrayBuffer(data);
        }
        static isArrayBufferView(data) {
          return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
        }
        static isEqual(a2, b) {
          const aView = _BufferSourceConverter.toUint8Array(a2);
          const bView = _BufferSourceConverter.toUint8Array(b);
          if (aView.length !== bView.byteLength) {
            return false;
          }
          for (let i2 = 0; i2 < aView.length; i2++) {
            if (aView[i2] !== bView[i2]) {
              return false;
            }
          }
          return true;
        }
        static concat(...args) {
          let buffers;
          if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
            buffers = args[0];
          } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
            buffers = args[0];
          } else {
            if (args[args.length - 1] instanceof Function) {
              buffers = args.slice(0, args.length - 1);
            } else {
              buffers = args;
            }
          }
          let size = 0;
          for (const buffer2 of buffers) {
            size += buffer2.byteLength;
          }
          const res = new Uint8Array(size);
          let offset = 0;
          for (const buffer2 of buffers) {
            const view = this.toUint8Array(buffer2);
            res.set(view, offset);
            offset += view.length;
          }
          if (args[args.length - 1] instanceof Function) {
            return this.toView(res, args[args.length - 1]);
          }
          return res.buffer;
        }
      };
      var STRING_TYPE = "string";
      var HEX_REGEX = /^[0-9a-f\s]+$/i;
      var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
      var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
      var Utf8Converter = class {
        static fromString(text) {
          const s2 = unescape(encodeURIComponent(text));
          const uintArray = new Uint8Array(s2.length);
          for (let i2 = 0; i2 < s2.length; i2++) {
            uintArray[i2] = s2.charCodeAt(i2);
          }
          return uintArray.buffer;
        }
        static toString(buffer2) {
          const buf2 = BufferSourceConverter6.toUint8Array(buffer2);
          let encodedString = "";
          for (let i2 = 0; i2 < buf2.length; i2++) {
            encodedString += String.fromCharCode(buf2[i2]);
          }
          const decodedString = decodeURIComponent(escape(encodedString));
          return decodedString;
        }
      };
      var Utf16Converter = class {
        static toString(buffer2, littleEndian = false) {
          const arrayBuffer = BufferSourceConverter6.toArrayBuffer(buffer2);
          const dataView2 = new DataView(arrayBuffer);
          let res = "";
          for (let i2 = 0; i2 < arrayBuffer.byteLength; i2 += 2) {
            const code8 = dataView2.getUint16(i2, littleEndian);
            res += String.fromCharCode(code8);
          }
          return res;
        }
        static fromString(text, littleEndian = false) {
          const res = new ArrayBuffer(text.length * 2);
          const dataView2 = new DataView(res);
          for (let i2 = 0; i2 < text.length; i2++) {
            dataView2.setUint16(i2 * 2, text.charCodeAt(i2), littleEndian);
          }
          return res;
        }
      };
      var Convert5 = class _Convert {
        static isHex(data) {
          return typeof data === STRING_TYPE && HEX_REGEX.test(data);
        }
        static isBase64(data) {
          return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
        }
        static isBase64Url(data) {
          return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
        }
        static ToString(buffer2, enc = "utf8") {
          const buf2 = BufferSourceConverter6.toUint8Array(buffer2);
          switch (enc.toLowerCase()) {
            case "utf8":
              return this.ToUtf8String(buf2);
            case "binary":
              return this.ToBinary(buf2);
            case "hex":
              return this.ToHex(buf2);
            case "base64":
              return this.ToBase64(buf2);
            case "base64url":
              return this.ToBase64Url(buf2);
            case "utf16le":
              return Utf16Converter.toString(buf2, true);
            case "utf16":
            case "utf16be":
              return Utf16Converter.toString(buf2);
            default:
              throw new Error(`Unknown type of encoding '${enc}'`);
          }
        }
        static FromString(str, enc = "utf8") {
          if (!str) {
            return new ArrayBuffer(0);
          }
          switch (enc.toLowerCase()) {
            case "utf8":
              return this.FromUtf8String(str);
            case "binary":
              return this.FromBinary(str);
            case "hex":
              return this.FromHex(str);
            case "base64":
              return this.FromBase64(str);
            case "base64url":
              return this.FromBase64Url(str);
            case "utf16le":
              return Utf16Converter.fromString(str, true);
            case "utf16":
            case "utf16be":
              return Utf16Converter.fromString(str);
            default:
              throw new Error(`Unknown type of encoding '${enc}'`);
          }
        }
        static ToBase64(buffer2) {
          const buf2 = BufferSourceConverter6.toUint8Array(buffer2);
          if (typeof btoa !== "undefined") {
            const binary = this.ToString(buf2, "binary");
            return btoa(binary);
          } else {
            return Buffer.from(buf2).toString("base64");
          }
        }
        static FromBase64(base642) {
          const formatted = this.formatString(base642);
          if (!formatted) {
            return new ArrayBuffer(0);
          }
          if (!_Convert.isBase64(formatted)) {
            throw new TypeError("Argument 'base64Text' is not Base64 encoded");
          }
          if (typeof atob !== "undefined") {
            return this.FromBinary(atob(formatted));
          } else {
            return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
          }
        }
        static FromBase64Url(base64url2) {
          const formatted = this.formatString(base64url2);
          if (!formatted) {
            return new ArrayBuffer(0);
          }
          if (!_Convert.isBase64Url(formatted)) {
            throw new TypeError("Argument 'base64url' is not Base64Url encoded");
          }
          return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
        }
        static ToBase64Url(data) {
          return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
        }
        static FromUtf8String(text, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
          switch (encoding) {
            case "ascii":
              return this.FromBinary(text);
            case "utf8":
              return Utf8Converter.fromString(text);
            case "utf16":
            case "utf16be":
              return Utf16Converter.fromString(text);
            case "utf16le":
            case "usc2":
              return Utf16Converter.fromString(text, true);
            default:
              throw new Error(`Unknown type of encoding '${encoding}'`);
          }
        }
        static ToUtf8String(buffer2, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
          switch (encoding) {
            case "ascii":
              return this.ToBinary(buffer2);
            case "utf8":
              return Utf8Converter.toString(buffer2);
            case "utf16":
            case "utf16be":
              return Utf16Converter.toString(buffer2);
            case "utf16le":
            case "usc2":
              return Utf16Converter.toString(buffer2, true);
            default:
              throw new Error(`Unknown type of encoding '${encoding}'`);
          }
        }
        static FromBinary(text) {
          const stringLength = text.length;
          const resultView = new Uint8Array(stringLength);
          for (let i2 = 0; i2 < stringLength; i2++) {
            resultView[i2] = text.charCodeAt(i2);
          }
          return resultView.buffer;
        }
        static ToBinary(buffer2) {
          const buf2 = BufferSourceConverter6.toUint8Array(buffer2);
          let res = "";
          for (let i2 = 0; i2 < buf2.length; i2++) {
            res += String.fromCharCode(buf2[i2]);
          }
          return res;
        }
        static ToHex(buffer2) {
          const buf2 = BufferSourceConverter6.toUint8Array(buffer2);
          let result = "";
          const len = buf2.length;
          for (let i2 = 0; i2 < len; i2++) {
            const byte = buf2[i2];
            if (byte < 16) {
              result += "0";
            }
            result += byte.toString(16);
          }
          return result;
        }
        static FromHex(hexString) {
          let formatted = this.formatString(hexString);
          if (!formatted) {
            return new ArrayBuffer(0);
          }
          if (!_Convert.isHex(formatted)) {
            throw new TypeError("Argument 'hexString' is not HEX encoded");
          }
          if (formatted.length % 2) {
            formatted = `0${formatted}`;
          }
          const res = new Uint8Array(formatted.length / 2);
          for (let i2 = 0; i2 < formatted.length; i2 = i2 + 2) {
            const c2 = formatted.slice(i2, i2 + 2);
            res[i2 / 2] = parseInt(c2, 16);
          }
          return res.buffer;
        }
        static ToUtf16String(buffer2, littleEndian = false) {
          return Utf16Converter.toString(buffer2, littleEndian);
        }
        static FromUtf16String(text, littleEndian = false) {
          return Utf16Converter.fromString(text, littleEndian);
        }
        static Base64Padding(base642) {
          const padCount = 4 - base642.length % 4;
          if (padCount < 4) {
            for (let i2 = 0; i2 < padCount; i2++) {
              base642 += "=";
            }
          }
          return base642;
        }
        static formatString(data) {
          return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
        }
      };
      Convert5.DEFAULT_UTF8_ENCODING = "utf8";
      function assign(target, ...sources) {
        const res = arguments[0];
        for (let i2 = 1; i2 < arguments.length; i2++) {
          const obj = arguments[i2];
          for (const prop in obj) {
            res[prop] = obj[prop];
          }
        }
        return res;
      }
      function combine2(...buf2) {
        const totalByteLength = buf2.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
        const res = new Uint8Array(totalByteLength);
        let currentPos = 0;
        buf2.map((item) => new Uint8Array(item)).forEach((arr) => {
          for (const item2 of arr) {
            res[currentPos++] = item2;
          }
        });
        return res.buffer;
      }
      function isEqual3(bytes1, bytes2) {
        if (!(bytes1 && bytes2)) {
          return false;
        }
        if (bytes1.byteLength !== bytes2.byteLength) {
          return false;
        }
        const b1 = new Uint8Array(bytes1);
        const b2 = new Uint8Array(bytes2);
        for (let i2 = 0; i2 < bytes1.byteLength; i2++) {
          if (b1[i2] !== b2[i2]) {
            return false;
          }
        }
        return true;
      }
      exports.BufferSourceConverter = BufferSourceConverter6;
      exports.Convert = Convert5;
      exports.assign = assign;
      exports.combine = combine2;
      exports.isEqual = isEqual3;
    }
  });

  // node_modules/cookie/dist/index.js
  var require_dist = __commonJS({
    "node_modules/cookie/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = parse3;
      exports.serialize = serialize;
      var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
      var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
      var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
      var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
      var __toString = Object.prototype.toString;
      var NullObject = /* @__PURE__ */ (() => {
        const C = function() {
        };
        C.prototype = /* @__PURE__ */ Object.create(null);
        return C;
      })();
      function parse3(str, options2) {
        const obj = new NullObject();
        const len = str.length;
        if (len < 2)
          return obj;
        const dec = options2?.decode || decode16;
        let index = 0;
        do {
          const eqIdx = str.indexOf("=", index);
          if (eqIdx === -1)
            break;
          const colonIdx = str.indexOf(";", index);
          const endIdx = colonIdx === -1 ? len : colonIdx;
          if (eqIdx > endIdx) {
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
          }
          const keyStartIdx = startIndex(str, index, eqIdx);
          const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
          const key = str.slice(keyStartIdx, keyEndIdx);
          if (obj[key] === void 0) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value2 = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value2;
          }
          index = endIdx + 1;
        } while (index < len);
        return obj;
      }
      function startIndex(str, index, max2) {
        do {
          const code8 = str.charCodeAt(index);
          if (code8 !== 32 && code8 !== 9)
            return index;
        } while (++index < max2);
        return max2;
      }
      function endIndex(str, index, min) {
        while (index > min) {
          const code8 = str.charCodeAt(--index);
          if (code8 !== 32 && code8 !== 9)
            return index + 1;
        }
        return min;
      }
      function serialize(name9, val, options2) {
        const enc = options2?.encode || encodeURIComponent;
        if (!cookieNameRegExp.test(name9)) {
          throw new TypeError(`argument name is invalid: ${name9}`);
        }
        const value2 = enc(val);
        if (!cookieValueRegExp.test(value2)) {
          throw new TypeError(`argument val is invalid: ${val}`);
        }
        let str = name9 + "=" + value2;
        if (!options2)
          return str;
        if (options2.maxAge !== void 0) {
          if (!Number.isInteger(options2.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options2.maxAge}`);
          }
          str += "; Max-Age=" + options2.maxAge;
        }
        if (options2.domain) {
          if (!domainValueRegExp.test(options2.domain)) {
            throw new TypeError(`option domain is invalid: ${options2.domain}`);
          }
          str += "; Domain=" + options2.domain;
        }
        if (options2.path) {
          if (!pathValueRegExp.test(options2.path)) {
            throw new TypeError(`option path is invalid: ${options2.path}`);
          }
          str += "; Path=" + options2.path;
        }
        if (options2.expires) {
          if (!isDate(options2.expires) || !Number.isFinite(options2.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options2.expires}`);
          }
          str += "; Expires=" + options2.expires.toUTCString();
        }
        if (options2.httpOnly) {
          str += "; HttpOnly";
        }
        if (options2.secure) {
          str += "; Secure";
        }
        if (options2.partitioned) {
          str += "; Partitioned";
        }
        if (options2.priority) {
          const priority = typeof options2.priority === "string" ? options2.priority.toLowerCase() : void 0;
          switch (priority) {
            case "low":
              str += "; Priority=Low";
              break;
            case "medium":
              str += "; Priority=Medium";
              break;
            case "high":
              str += "; Priority=High";
              break;
            default:
              throw new TypeError(`option priority is invalid: ${options2.priority}`);
          }
        }
        if (options2.sameSite) {
          const sameSite = typeof options2.sameSite === "string" ? options2.sameSite.toLowerCase() : options2.sameSite;
          switch (sameSite) {
            case true:
            case "strict":
              str += "; SameSite=Strict";
              break;
            case "lax":
              str += "; SameSite=Lax";
              break;
            case "none":
              str += "; SameSite=None";
              break;
            default:
              throw new TypeError(`option sameSite is invalid: ${options2.sameSite}`);
          }
        }
        return str;
      }
      function decode16(str) {
        if (str.indexOf("%") === -1)
          return str;
        try {
          return decodeURIComponent(str);
        } catch (e2) {
          return str;
        }
      }
      function isDate(val) {
        return __toString.call(val) === "[object Date]";
      }
    }
  });

  // node_modules/reflect-metadata/Reflect.js
  var require_Reflect = __commonJS({
    "node_modules/reflect-metadata/Reflect.js"() {
      var Reflect2;
      (function(Reflect3) {
        (function(factory) {
          var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
          var exporter3 = makeExporter(Reflect3);
          if (typeof root.Reflect !== "undefined") {
            exporter3 = makeExporter(root.Reflect, exporter3);
          }
          factory(exporter3, root);
          if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect3;
          }
          function makeExporter(target, previous) {
            return function(key, value2) {
              Object.defineProperty(target, key, { configurable: true, writable: true, value: value2 });
              if (previous)
                previous(key, value2);
            };
          }
          function functionThis() {
            try {
              return Function("return this;")();
            } catch (_) {
            }
          }
          function indirectEvalThis() {
            try {
              return (void 0, eval)("(function() { return this; })()");
            } catch (_) {
            }
          }
          function sloppyModeThis() {
            return functionThis() || indirectEvalThis();
          }
        })(function(exporter3, root) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var supportsSymbol = typeof Symbol === "function";
          var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
          var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
          var supportsCreate = typeof Object.create === "function";
          var supportsProto = { __proto__: [] } instanceof Array;
          var downLevel = !supportsCreate && !supportsProto;
          var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate ? function() {
              return MakeDictionary(/* @__PURE__ */ Object.create(null));
            } : supportsProto ? function() {
              return MakeDictionary({ __proto__: null });
            } : function() {
              return MakeDictionary({});
            },
            has: downLevel ? function(map2, key) {
              return hasOwn.call(map2, key);
            } : function(map2, key) {
              return key in map2;
            },
            get: downLevel ? function(map2, key) {
              return hasOwn.call(map2, key) ? map2[key] : void 0;
            } : function(map2, key) {
              return map2[key];
            }
          };
          var functionPrototype = Object.getPrototypeOf(Function);
          var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
          var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
          var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
          var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
          var metadataRegistry = GetOrCreateMetadataRegistry();
          var metadataProvider = CreateMetadataProvider(metadataRegistry);
          function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsObject(target))
                throw new TypeError();
              if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
              if (IsNull(attributes))
                attributes = void 0;
              propertyKey = ToPropertyKey(propertyKey);
              return DecorateProperty(decorators, target, propertyKey, attributes);
            } else {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsConstructor(target))
                throw new TypeError();
              return DecorateConstructor(decorators, target);
            }
          }
          exporter3("decorate", decorate);
          function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
              if (!IsObject(target))
                throw new TypeError();
              if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
              OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
          }
          exporter3("metadata", metadata);
          function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          exporter3("defineMetadata", defineMetadata);
          function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
          }
          exporter3("hasMetadata", hasMetadata);
          function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter3("hasOwnMetadata", hasOwnMetadata);
          function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
          }
          exporter3("getMetadata", getMetadata);
          function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter3("getOwnMetadata", getOwnMetadata);
          function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
          }
          exporter3("getMetadataKeys", getMetadataKeys);
          function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
          }
          exporter3("getOwnMetadataKeys", getOwnMetadataKeys);
          function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            var provider = GetMetadataProvider(
              target,
              propertyKey,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
          }
          exporter3("deleteMetadata", deleteMetadata);
          function DecorateConstructor(decorators, target) {
            for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
              var decorator = decorators[i2];
              var decorated = decorator(target);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                  throw new TypeError();
                target = decorated;
              }
            }
            return target;
          }
          function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
              var decorator = decorators[i2];
              var decorated = decorator(target, propertyKey, descriptor);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject(decorated))
                  throw new TypeError();
                descriptor = decorated;
              }
            }
            return descriptor;
          }
          function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn2)
              return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
              return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
          }
          function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var provider = GetMetadataProvider(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
          }
          function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn2)
              return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
              return OrdinaryGetMetadata(MetadataKey, parent, P);
            return void 0;
          }
          function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var provider = GetMetadataProvider(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return;
            return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
          }
          function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var provider = GetMetadataProvider(
              O,
              P,
              /*Create*/
              true
            );
            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
          }
          function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
              return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
              return ownKeys;
            if (ownKeys.length <= 0)
              return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
              var key = ownKeys_1[_i];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            for (var _a4 = 0, parentKeys_1 = parentKeys; _a4 < parentKeys_1.length; _a4++) {
              var key = parentKeys_1[_a4];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            return keys;
          }
          function OrdinaryOwnMetadataKeys(O, P) {
            var provider = GetMetadataProvider(
              O,
              P,
              /*create*/
              false
            );
            if (!provider) {
              return [];
            }
            return provider.OrdinaryOwnMetadataKeys(O, P);
          }
          function Type2(x) {
            if (x === null)
              return 1;
            switch (typeof x) {
              case "undefined":
                return 0;
              case "boolean":
                return 2;
              case "string":
                return 3;
              case "symbol":
                return 4;
              case "number":
                return 5;
              case "object":
                return x === null ? 1 : 6;
              default:
                return 6;
            }
          }
          function IsUndefined(x) {
            return x === void 0;
          }
          function IsNull(x) {
            return x === null;
          }
          function IsSymbol(x) {
            return typeof x === "symbol";
          }
          function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
          }
          function ToPrimitive(input, PreferredType) {
            switch (Type2(input)) {
              case 0:
                return input;
              case 1:
                return input;
              case 2:
                return input;
              case 3:
                return input;
              case 4:
                return input;
              case 5:
                return input;
            }
            var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== void 0) {
              var result = exoticToPrim.call(input, hint);
              if (IsObject(result))
                throw new TypeError();
              return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
          }
          function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
              var toString_1 = O.toString;
              if (IsCallable(toString_1)) {
                var result = toString_1.call(O);
                if (!IsObject(result))
                  return result;
              }
              var valueOf = O.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                  return result;
              }
            } else {
              var valueOf = O.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                  return result;
              }
              var toString_2 = O.toString;
              if (IsCallable(toString_2)) {
                var result = toString_2.call(O);
                if (!IsObject(result))
                  return result;
              }
            }
            throw new TypeError();
          }
          function ToBoolean(argument) {
            return !!argument;
          }
          function ToString(argument) {
            return "" + argument;
          }
          function ToPropertyKey(argument) {
            var key = ToPrimitive(
              argument,
              3
              /* String */
            );
            if (IsSymbol(key))
              return key;
            return ToString(key);
          }
          function IsArray(argument) {
            return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
          }
          function IsCallable(argument) {
            return typeof argument === "function";
          }
          function IsConstructor(argument) {
            return typeof argument === "function";
          }
          function IsPropertyKey(argument) {
            switch (Type2(argument)) {
              case 3:
                return true;
              case 4:
                return true;
              default:
                return false;
            }
          }
          function SameValueZero(x, y) {
            return x === y || x !== x && y !== y;
          }
          function GetMethod(V2, P) {
            var func = V2[P];
            if (func === void 0 || func === null)
              return void 0;
            if (!IsCallable(func))
              throw new TypeError();
            return func;
          }
          function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
              throw new TypeError();
            var iterator = method.call(obj);
            if (!IsObject(iterator))
              throw new TypeError();
            return iterator;
          }
          function IteratorValue(iterResult) {
            return iterResult.value;
          }
          function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
          }
          function IteratorClose(iterator) {
            var f2 = iterator["return"];
            if (f2)
              f2.call(iterator);
          }
          function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
              return proto;
            if (proto !== functionPrototype)
              return proto;
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
              return proto;
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
              return proto;
            if (constructor === O)
              return proto;
            return constructor;
          }
          function CreateMetadataRegistry() {
            var fallback;
            if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
              fallback = CreateFallbackProvider(root.Reflect);
            }
            var first2;
            var second3;
            var rest;
            var targetProviderMap = new _WeakMap();
            var registry2 = {
              registerProvider,
              getProvider,
              setProvider
            };
            return registry2;
            function registerProvider(provider) {
              if (!Object.isExtensible(registry2)) {
                throw new Error("Cannot add provider to a frozen registry.");
              }
              switch (true) {
                case fallback === provider:
                  break;
                case IsUndefined(first2):
                  first2 = provider;
                  break;
                case first2 === provider:
                  break;
                case IsUndefined(second3):
                  second3 = provider;
                  break;
                case second3 === provider:
                  break;
                default:
                  if (rest === void 0)
                    rest = new _Set();
                  rest.add(provider);
                  break;
              }
            }
            function getProviderNoCache(O, P) {
              if (!IsUndefined(first2)) {
                if (first2.isProviderFor(O, P))
                  return first2;
                if (!IsUndefined(second3)) {
                  if (second3.isProviderFor(O, P))
                    return first2;
                  if (!IsUndefined(rest)) {
                    var iterator = GetIterator(rest);
                    while (true) {
                      var next = IteratorStep(iterator);
                      if (!next) {
                        return void 0;
                      }
                      var provider = IteratorValue(next);
                      if (provider.isProviderFor(O, P)) {
                        IteratorClose(iterator);
                        return provider;
                      }
                    }
                  }
                }
              }
              if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
                return fallback;
              }
              return void 0;
            }
            function getProvider(O, P) {
              var providerMap = targetProviderMap.get(O);
              var provider;
              if (!IsUndefined(providerMap)) {
                provider = providerMap.get(P);
              }
              if (!IsUndefined(provider)) {
                return provider;
              }
              provider = getProviderNoCache(O, P);
              if (!IsUndefined(provider)) {
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O, providerMap);
                }
                providerMap.set(P, provider);
              }
              return provider;
            }
            function hasProvider(provider) {
              if (IsUndefined(provider))
                throw new TypeError();
              return first2 === provider || second3 === provider || !IsUndefined(rest) && rest.has(provider);
            }
            function setProvider(O, P, provider) {
              if (!hasProvider(provider)) {
                throw new Error("Metadata provider not registered.");
              }
              var existingProvider = getProvider(O, P);
              if (existingProvider !== provider) {
                if (!IsUndefined(existingProvider)) {
                  return false;
                }
                var providerMap = targetProviderMap.get(O);
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O, providerMap);
                }
                providerMap.set(P, provider);
              }
              return true;
            }
          }
          function GetOrCreateMetadataRegistry() {
            var metadataRegistry2;
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
              metadataRegistry2 = root.Reflect[registrySymbol];
            }
            if (IsUndefined(metadataRegistry2)) {
              metadataRegistry2 = CreateMetadataRegistry();
            }
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
              Object.defineProperty(root.Reflect, registrySymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: metadataRegistry2
              });
            }
            return metadataRegistry2;
          }
          function CreateMetadataProvider(registry2) {
            var metadata2 = new _WeakMap();
            var provider = {
              isProviderFor: function(O, P) {
                var targetMetadata = metadata2.get(O);
                if (IsUndefined(targetMetadata))
                  return false;
                return targetMetadata.has(P);
              },
              OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
              OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
              OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
              OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
              OrdinaryDeleteMetadata
            };
            metadataRegistry.registerProvider(provider);
            return provider;
            function GetOrCreateMetadataMap(O, P, Create) {
              var targetMetadata = metadata2.get(O);
              var createdTargetMetadata = false;
              if (IsUndefined(targetMetadata)) {
                if (!Create)
                  return void 0;
                targetMetadata = new _Map();
                metadata2.set(O, targetMetadata);
                createdTargetMetadata = true;
              }
              var metadataMap = targetMetadata.get(P);
              if (IsUndefined(metadataMap)) {
                if (!Create)
                  return void 0;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
                if (!registry2.setProvider(O, P, provider)) {
                  targetMetadata.delete(P);
                  if (createdTargetMetadata) {
                    metadata2.delete(O);
                  }
                  throw new Error("Wrong provider for target.");
                }
              }
              return metadataMap;
            }
            function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
              var metadataMap = GetOrCreateMetadataMap(
                O,
                P,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              return ToBoolean(metadataMap.has(MetadataKey));
            }
            function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
              var metadataMap = GetOrCreateMetadataMap(
                O,
                P,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return void 0;
              return metadataMap.get(MetadataKey);
            }
            function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
              var metadataMap = GetOrCreateMetadataMap(
                O,
                P,
                /*Create*/
                true
              );
              metadataMap.set(MetadataKey, MetadataValue);
            }
            function OrdinaryOwnMetadataKeys2(O, P) {
              var keys = [];
              var metadataMap = GetOrCreateMetadataMap(
                O,
                P,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return keys;
              var keysObj = metadataMap.keys();
              var iterator = GetIterator(keysObj);
              var k = 0;
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  keys.length = k;
                  return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                  keys[k] = nextValue;
                } catch (e2) {
                  try {
                    IteratorClose(iterator);
                  } finally {
                    throw e2;
                  }
                }
                k++;
              }
            }
            function OrdinaryDeleteMetadata(MetadataKey, O, P) {
              var metadataMap = GetOrCreateMetadataMap(
                O,
                P,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              if (!metadataMap.delete(MetadataKey))
                return false;
              if (metadataMap.size === 0) {
                var targetMetadata = metadata2.get(O);
                if (!IsUndefined(targetMetadata)) {
                  targetMetadata.delete(P);
                  if (targetMetadata.size === 0) {
                    metadata2.delete(targetMetadata);
                  }
                }
              }
              return true;
            }
          }
          function CreateFallbackProvider(reflect) {
            var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
            var metadataOwner = new _WeakMap();
            var provider = {
              isProviderFor: function(O, P) {
                var metadataPropertySet = metadataOwner.get(O);
                if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
                  return true;
                }
                if (getOwnMetadataKeys2(O, P).length) {
                  if (IsUndefined(metadataPropertySet)) {
                    metadataPropertySet = new _Set();
                    metadataOwner.set(O, metadataPropertySet);
                  }
                  metadataPropertySet.add(P);
                  return true;
                }
                return false;
              },
              OrdinaryDefineOwnMetadata: defineMetadata2,
              OrdinaryHasOwnMetadata: hasOwnMetadata2,
              OrdinaryGetOwnMetadata: getOwnMetadata2,
              OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
              OrdinaryDeleteMetadata: deleteMetadata2
            };
            return provider;
          }
          function GetMetadataProvider(O, P, Create) {
            var registeredProvider = metadataRegistry.getProvider(O, P);
            if (!IsUndefined(registeredProvider)) {
              return registeredProvider;
            }
            if (Create) {
              if (metadataRegistry.setProvider(O, P, metadataProvider)) {
                return metadataProvider;
              }
              throw new Error("Illegal state.");
            }
            return void 0;
          }
          function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (
              /** @class */
              (function() {
                function MapIterator2(keys, values, selector) {
                  this._index = 0;
                  this._keys = keys;
                  this._values = values;
                  this._selector = selector;
                }
                MapIterator2.prototype["@@iterator"] = function() {
                  return this;
                };
                MapIterator2.prototype[iteratorSymbol] = function() {
                  return this;
                };
                MapIterator2.prototype.next = function() {
                  var index = this._index;
                  if (index >= 0 && index < this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                      this._index = -1;
                      this._keys = arraySentinel;
                      this._values = arraySentinel;
                    } else {
                      this._index++;
                    }
                    return { value: result, done: false };
                  }
                  return { value: void 0, done: true };
                };
                MapIterator2.prototype.throw = function(error) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  throw error;
                };
                MapIterator2.prototype.return = function(value2) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  return { value: value2, done: true };
                };
                return MapIterator2;
              })()
            );
            var Map2 = (
              /** @class */
              (function() {
                function Map3() {
                  this._keys = [];
                  this._values = [];
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                Object.defineProperty(Map3.prototype, "size", {
                  get: function() {
                    return this._keys.length;
                  },
                  enumerable: true,
                  configurable: true
                });
                Map3.prototype.has = function(key) {
                  return this._find(
                    key,
                    /*insert*/
                    false
                  ) >= 0;
                };
                Map3.prototype.get = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  return index >= 0 ? this._values[index] : void 0;
                };
                Map3.prototype.set = function(key, value2) {
                  var index = this._find(
                    key,
                    /*insert*/
                    true
                  );
                  this._values[index] = value2;
                  return this;
                };
                Map3.prototype.delete = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  if (index >= 0) {
                    var size = this._keys.length;
                    for (var i2 = index + 1; i2 < size; i2++) {
                      this._keys[i2 - 1] = this._keys[i2];
                      this._values[i2 - 1] = this._values[i2];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (SameValueZero(key, this._cacheKey)) {
                      this._cacheKey = cacheSentinel;
                      this._cacheIndex = -2;
                    }
                    return true;
                  }
                  return false;
                };
                Map3.prototype.clear = function() {
                  this._keys.length = 0;
                  this._values.length = 0;
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                };
                Map3.prototype.keys = function() {
                  return new MapIterator(this._keys, this._values, getKey);
                };
                Map3.prototype.values = function() {
                  return new MapIterator(this._keys, this._values, getValue);
                };
                Map3.prototype.entries = function() {
                  return new MapIterator(this._keys, this._values, getEntry);
                };
                Map3.prototype["@@iterator"] = function() {
                  return this.entries();
                };
                Map3.prototype[iteratorSymbol] = function() {
                  return this.entries();
                };
                Map3.prototype._find = function(key, insert) {
                  if (!SameValueZero(this._cacheKey, key)) {
                    this._cacheIndex = -1;
                    for (var i2 = 0; i2 < this._keys.length; i2++) {
                      if (SameValueZero(this._keys[i2], key)) {
                        this._cacheIndex = i2;
                        break;
                      }
                    }
                  }
                  if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(void 0);
                  }
                  return this._cacheIndex;
                };
                return Map3;
              })()
            );
            return Map2;
            function getKey(key, _) {
              return key;
            }
            function getValue(_, value2) {
              return value2;
            }
            function getEntry(key, value2) {
              return [key, value2];
            }
          }
          function CreateSetPolyfill() {
            var Set3 = (
              /** @class */
              (function() {
                function Set4() {
                  this._map = new _Map();
                }
                Object.defineProperty(Set4.prototype, "size", {
                  get: function() {
                    return this._map.size;
                  },
                  enumerable: true,
                  configurable: true
                });
                Set4.prototype.has = function(value2) {
                  return this._map.has(value2);
                };
                Set4.prototype.add = function(value2) {
                  return this._map.set(value2, value2), this;
                };
                Set4.prototype.delete = function(value2) {
                  return this._map.delete(value2);
                };
                Set4.prototype.clear = function() {
                  this._map.clear();
                };
                Set4.prototype.keys = function() {
                  return this._map.keys();
                };
                Set4.prototype.values = function() {
                  return this._map.keys();
                };
                Set4.prototype.entries = function() {
                  return this._map.entries();
                };
                Set4.prototype["@@iterator"] = function() {
                  return this.keys();
                };
                Set4.prototype[iteratorSymbol] = function() {
                  return this.keys();
                };
                return Set4;
              })()
            );
            return Set3;
          }
          function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (
              /** @class */
              (function() {
                function WeakMap2() {
                  this._key = CreateUniqueKey();
                }
                WeakMap2.prototype.has = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.has(table, this._key) : false;
                };
                WeakMap2.prototype.get = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.get(table, this._key) : void 0;
                };
                WeakMap2.prototype.set = function(target, value2) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    true
                  );
                  table[this._key] = value2;
                  return this;
                };
                WeakMap2.prototype.delete = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? delete table[this._key] : false;
                };
                WeakMap2.prototype.clear = function() {
                  this._key = CreateUniqueKey();
                };
                return WeakMap2;
              })()
            );
            function CreateUniqueKey() {
              var key;
              do
                key = "@@WeakMap@@" + CreateUUID();
              while (HashMap.has(keys, key));
              keys[key] = true;
              return key;
            }
            function GetOrCreateWeakMapTable(target, create6) {
              if (!hasOwn.call(target, rootKey)) {
                if (!create6)
                  return void 0;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
              }
              return target[rootKey];
            }
            function FillRandomBytes(buffer2, size) {
              for (var i2 = 0; i2 < size; ++i2)
                buffer2[i2] = Math.random() * 255 | 0;
              return buffer2;
            }
            function GenRandomBytes(size) {
              if (typeof Uint8Array === "function") {
                var array = new Uint8Array(size);
                if (typeof crypto !== "undefined") {
                  crypto.getRandomValues(array);
                } else if (typeof msCrypto !== "undefined") {
                  msCrypto.getRandomValues(array);
                } else {
                  FillRandomBytes(array, size);
                }
                return array;
              }
              return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
              var data = GenRandomBytes(UUID_SIZE);
              data[6] = data[6] & 79 | 64;
              data[8] = data[8] & 191 | 128;
              var result = "";
              for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                  result += "-";
                if (byte < 16)
                  result += "0";
                result += byte.toString(16).toLowerCase();
              }
              return result;
            }
          }
          function MakeDictionary(obj) {
            obj.__ = void 0;
            delete obj.__;
            return obj;
          }
        });
      })(Reflect2 || (Reflect2 = {}));
    }
  });

  // node_modules/varint/encode.js
  var require_encode = __commonJS({
    "node_modules/varint/encode.js"(exports, module) {
      module.exports = encode17;
      var MSB4 = 128;
      var REST4 = 127;
      var MSBALL2 = ~REST4;
      var INT2 = Math.pow(2, 31);
      function encode17(num, out, offset) {
        if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
          encode17.bytes = 0;
          throw new RangeError("Could not encode varint");
        }
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT2) {
          out[offset++] = num & 255 | MSB4;
          num /= 128;
        }
        while (num & MSBALL2) {
          out[offset++] = num & 255 | MSB4;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode17.bytes = offset - oldOffset + 1;
        return out;
      }
    }
  });

  // node_modules/varint/decode.js
  var require_decode = __commonJS({
    "node_modules/varint/decode.js"(exports, module) {
      module.exports = read4;
      var MSB4 = 128;
      var REST4 = 127;
      function read4(buf2, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l2 = buf2.length;
        do {
          if (counter >= l2 || shift > 49) {
            read4.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf2[counter++];
          res += shift < 28 ? (b & REST4) << shift : (b & REST4) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB4);
        read4.bytes = counter - offset;
        return res;
      }
    }
  });

  // node_modules/varint/length.js
  var require_length = __commonJS({
    "node_modules/varint/length.js"(exports, module) {
      var N13 = Math.pow(2, 7);
      var N23 = Math.pow(2, 14);
      var N33 = Math.pow(2, 21);
      var N43 = Math.pow(2, 28);
      var N53 = Math.pow(2, 35);
      var N63 = Math.pow(2, 42);
      var N73 = Math.pow(2, 49);
      var N82 = Math.pow(2, 56);
      var N92 = Math.pow(2, 63);
      module.exports = function(value2) {
        return value2 < N13 ? 1 : value2 < N23 ? 2 : value2 < N33 ? 3 : value2 < N43 ? 4 : value2 < N53 ? 5 : value2 < N63 ? 6 : value2 < N73 ? 7 : value2 < N82 ? 8 : value2 < N92 ? 9 : 10;
      };
    }
  });

  // node_modules/varint/index.js
  var require_varint = __commonJS({
    "node_modules/varint/index.js"(exports, module) {
      module.exports = {
        encode: require_encode(),
        decode: require_decode(),
        encodingLength: require_length()
      };
    }
  });

  // node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
  var require_murmurHash3js = __commonJS({
    "node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports, module) {
      (function(root, undefined2) {
        "use strict";
        var library = {
          "version": "3.0.0",
          "x86": {},
          "x64": {},
          "inputValidation": true
        };
        function _validBytes(bytes) {
          if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
            return false;
          }
          for (var i2 = 0; i2 < bytes.length; i2++) {
            if (!Number.isInteger(bytes[i2]) || bytes[i2] < 0 || bytes[i2] > 255) {
              return false;
            }
          }
          return true;
        }
        function _x86Multiply(m2, n2) {
          return (m2 & 65535) * n2 + (((m2 >>> 16) * n2 & 65535) << 16);
        }
        function _x86Rotl(m2, n2) {
          return m2 << n2 | m2 >>> 32 - n2;
        }
        function _x86Fmix(h) {
          h ^= h >>> 16;
          h = _x86Multiply(h, 2246822507);
          h ^= h >>> 13;
          h = _x86Multiply(h, 3266489909);
          h ^= h >>> 16;
          return h;
        }
        function _x64Add(m2, n2) {
          m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
          n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
          var o2 = [0, 0, 0, 0];
          o2[3] += m2[3] + n2[3];
          o2[2] += o2[3] >>> 16;
          o2[3] &= 65535;
          o2[2] += m2[2] + n2[2];
          o2[1] += o2[2] >>> 16;
          o2[2] &= 65535;
          o2[1] += m2[1] + n2[1];
          o2[0] += o2[1] >>> 16;
          o2[1] &= 65535;
          o2[0] += m2[0] + n2[0];
          o2[0] &= 65535;
          return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
        }
        function _x64Multiply(m2, n2) {
          m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
          n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
          var o2 = [0, 0, 0, 0];
          o2[3] += m2[3] * n2[3];
          o2[2] += o2[3] >>> 16;
          o2[3] &= 65535;
          o2[2] += m2[2] * n2[3];
          o2[1] += o2[2] >>> 16;
          o2[2] &= 65535;
          o2[2] += m2[3] * n2[2];
          o2[1] += o2[2] >>> 16;
          o2[2] &= 65535;
          o2[1] += m2[1] * n2[3];
          o2[0] += o2[1] >>> 16;
          o2[1] &= 65535;
          o2[1] += m2[2] * n2[2];
          o2[0] += o2[1] >>> 16;
          o2[1] &= 65535;
          o2[1] += m2[3] * n2[1];
          o2[0] += o2[1] >>> 16;
          o2[1] &= 65535;
          o2[0] += m2[0] * n2[3] + m2[1] * n2[2] + m2[2] * n2[1] + m2[3] * n2[0];
          o2[0] &= 65535;
          return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
        }
        function _x64Rotl(m2, n2) {
          n2 %= 64;
          if (n2 === 32) {
            return [m2[1], m2[0]];
          } else if (n2 < 32) {
            return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2 | m2[0] >>> 32 - n2];
          } else {
            n2 -= 32;
            return [m2[1] << n2 | m2[0] >>> 32 - n2, m2[0] << n2 | m2[1] >>> 32 - n2];
          }
        }
        function _x64LeftShift(m2, n2) {
          n2 %= 64;
          if (n2 === 0) {
            return m2;
          } else if (n2 < 32) {
            return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2];
          } else {
            return [m2[1] << n2 - 32, 0];
          }
        }
        function _x64Xor(m2, n2) {
          return [m2[0] ^ n2[0], m2[1] ^ n2[1]];
        }
        function _x64Fmix(h) {
          h = _x64Xor(h, [0, h[0] >>> 1]);
          h = _x64Multiply(h, [4283543511, 3981806797]);
          h = _x64Xor(h, [0, h[0] >>> 1]);
          h = _x64Multiply(h, [3301882366, 444984403]);
          h = _x64Xor(h, [0, h[0] >>> 1]);
          return h;
        }
        library.x86.hash32 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 4;
          var blocks = bytes.length - remainder;
          var h1 = seed;
          var k1 = 0;
          var c1 = 3432918353;
          var c2 = 461845907;
          for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
            k1 = bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 13);
            h1 = _x86Multiply(h1, 5) + 3864292196;
          }
          k1 = 0;
          switch (remainder) {
            case 3:
              k1 ^= bytes[i2 + 2] << 16;
            case 2:
              k1 ^= bytes[i2 + 1] << 8;
            case 1:
              k1 ^= bytes[i2];
              k1 = _x86Multiply(k1, c1);
              k1 = _x86Rotl(k1, 15);
              k1 = _x86Multiply(k1, c2);
              h1 ^= k1;
          }
          h1 ^= bytes.length;
          h1 = _x86Fmix(h1);
          return h1 >>> 0;
        };
        library.x86.hash128 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 16;
          var blocks = bytes.length - remainder;
          var h1 = seed;
          var h2 = seed;
          var h3 = seed;
          var h4 = seed;
          var k1 = 0;
          var k2 = 0;
          var k3 = 0;
          var k4 = 0;
          var c1 = 597399067;
          var c2 = 2869860233;
          var c3 = 951274213;
          var c4 = 2716044179;
          for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
            k1 = bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24;
            k2 = bytes[i2 + 4] | bytes[i2 + 5] << 8 | bytes[i2 + 6] << 16 | bytes[i2 + 7] << 24;
            k3 = bytes[i2 + 8] | bytes[i2 + 9] << 8 | bytes[i2 + 10] << 16 | bytes[i2 + 11] << 24;
            k4 = bytes[i2 + 12] | bytes[i2 + 13] << 8 | bytes[i2 + 14] << 16 | bytes[i2 + 15] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 19);
            h1 += h2;
            h1 = _x86Multiply(h1, 5) + 1444728091;
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
            h2 = _x86Rotl(h2, 17);
            h2 += h3;
            h2 = _x86Multiply(h2, 5) + 197830471;
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
            h3 = _x86Rotl(h3, 15);
            h3 += h4;
            h3 = _x86Multiply(h3, 5) + 2530024501;
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
            h4 = _x86Rotl(h4, 13);
            h4 += h1;
            h4 = _x86Multiply(h4, 5) + 850148119;
          }
          k1 = 0;
          k2 = 0;
          k3 = 0;
          k4 = 0;
          switch (remainder) {
            case 15:
              k4 ^= bytes[i2 + 14] << 16;
            case 14:
              k4 ^= bytes[i2 + 13] << 8;
            case 13:
              k4 ^= bytes[i2 + 12];
              k4 = _x86Multiply(k4, c4);
              k4 = _x86Rotl(k4, 18);
              k4 = _x86Multiply(k4, c1);
              h4 ^= k4;
            case 12:
              k3 ^= bytes[i2 + 11] << 24;
            case 11:
              k3 ^= bytes[i2 + 10] << 16;
            case 10:
              k3 ^= bytes[i2 + 9] << 8;
            case 9:
              k3 ^= bytes[i2 + 8];
              k3 = _x86Multiply(k3, c3);
              k3 = _x86Rotl(k3, 17);
              k3 = _x86Multiply(k3, c4);
              h3 ^= k3;
            case 8:
              k2 ^= bytes[i2 + 7] << 24;
            case 7:
              k2 ^= bytes[i2 + 6] << 16;
            case 6:
              k2 ^= bytes[i2 + 5] << 8;
            case 5:
              k2 ^= bytes[i2 + 4];
              k2 = _x86Multiply(k2, c2);
              k2 = _x86Rotl(k2, 16);
              k2 = _x86Multiply(k2, c3);
              h2 ^= k2;
            case 4:
              k1 ^= bytes[i2 + 3] << 24;
            case 3:
              k1 ^= bytes[i2 + 2] << 16;
            case 2:
              k1 ^= bytes[i2 + 1] << 8;
            case 1:
              k1 ^= bytes[i2];
              k1 = _x86Multiply(k1, c1);
              k1 = _x86Rotl(k1, 15);
              k1 = _x86Multiply(k1, c2);
              h1 ^= k1;
          }
          h1 ^= bytes.length;
          h2 ^= bytes.length;
          h3 ^= bytes.length;
          h4 ^= bytes.length;
          h1 += h2;
          h1 += h3;
          h1 += h4;
          h2 += h1;
          h3 += h1;
          h4 += h1;
          h1 = _x86Fmix(h1);
          h2 = _x86Fmix(h2);
          h3 = _x86Fmix(h3);
          h4 = _x86Fmix(h4);
          h1 += h2;
          h1 += h3;
          h1 += h4;
          h2 += h1;
          h3 += h1;
          h4 += h1;
          return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
        };
        library.x64.hash128 = function(bytes, seed) {
          if (library.inputValidation && !_validBytes(bytes)) {
            return undefined2;
          }
          seed = seed || 0;
          var remainder = bytes.length % 16;
          var blocks = bytes.length - remainder;
          var h1 = [0, seed];
          var h2 = [0, seed];
          var k1 = [0, 0];
          var k2 = [0, 0];
          var c1 = [2277735313, 289559509];
          var c2 = [1291169091, 658871167];
          for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
            k1 = [bytes[i2 + 4] | bytes[i2 + 5] << 8 | bytes[i2 + 6] << 16 | bytes[i2 + 7] << 24, bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24];
            k2 = [bytes[i2 + 12] | bytes[i2 + 13] << 8 | bytes[i2 + 14] << 16 | bytes[i2 + 15] << 24, bytes[i2 + 8] | bytes[i2 + 9] << 8 | bytes[i2 + 10] << 16 | bytes[i2 + 11] << 24];
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
            h1 = _x64Rotl(h1, 27);
            h1 = _x64Add(h1, h2);
            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
            h2 = _x64Rotl(h2, 31);
            h2 = _x64Add(h2, h1);
            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
          }
          k1 = [0, 0];
          k2 = [0, 0];
          switch (remainder) {
            case 15:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 14]], 48));
            case 14:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 13]], 40));
            case 13:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 12]], 32));
            case 12:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 11]], 24));
            case 11:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 10]], 16));
            case 10:
              k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 9]], 8));
            case 9:
              k2 = _x64Xor(k2, [0, bytes[i2 + 8]]);
              k2 = _x64Multiply(k2, c2);
              k2 = _x64Rotl(k2, 33);
              k2 = _x64Multiply(k2, c1);
              h2 = _x64Xor(h2, k2);
            case 8:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 7]], 56));
            case 7:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 6]], 48));
            case 6:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 5]], 40));
            case 5:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 4]], 32));
            case 4:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 3]], 24));
            case 3:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 2]], 16));
            case 2:
              k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 1]], 8));
            case 1:
              k1 = _x64Xor(k1, [0, bytes[i2]]);
              k1 = _x64Multiply(k1, c1);
              k1 = _x64Rotl(k1, 31);
              k1 = _x64Multiply(k1, c2);
              h1 = _x64Xor(h1, k1);
          }
          h1 = _x64Xor(h1, [0, bytes.length]);
          h2 = _x64Xor(h2, [0, bytes.length]);
          h1 = _x64Add(h1, h2);
          h2 = _x64Add(h2, h1);
          h1 = _x64Fmix(h1);
          h2 = _x64Fmix(h2);
          h1 = _x64Add(h1, h2);
          h2 = _x64Add(h2, h1);
          return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
        };
        if (typeof exports !== "undefined") {
          if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = library;
          }
          exports.murmurHash3 = library;
        } else if (typeof define === "function" && define.amd) {
          define([], function() {
            return library;
          });
        } else {
          library._murmurHash3 = root.murmurHash3;
          library.noConflict = function() {
            root.murmurHash3 = library._murmurHash3;
            library._murmurHash3 = undefined2;
            library.noConflict = undefined2;
            return library;
          };
          root.murmurHash3 = library;
        }
      })(exports);
    }
  });

  // node_modules/murmurhash3js-revisited/index.js
  var require_murmurhash3js_revisited = __commonJS({
    "node_modules/murmurhash3js-revisited/index.js"(exports, module) {
      module.exports = require_murmurHash3js();
    }
  });

  // node_modules/sparse-array/index.js
  var require_sparse_array = __commonJS({
    "node_modules/sparse-array/index.js"(exports, module) {
      "use strict";
      var BITS_PER_BYTE = 7;
      module.exports = class SparseArray {
        constructor() {
          this._bitArrays = [];
          this._data = [];
          this._length = 0;
          this._changedLength = false;
          this._changedData = false;
        }
        set(index, value2) {
          let pos = this._internalPositionFor(index, false);
          if (value2 === void 0) {
            if (pos !== -1) {
              this._unsetInternalPos(pos);
              this._unsetBit(index);
              this._changedLength = true;
              this._changedData = true;
            }
          } else {
            let needsSort = false;
            if (pos === -1) {
              pos = this._data.length;
              this._setBit(index);
              this._changedData = true;
            } else {
              needsSort = true;
            }
            this._setInternalPos(pos, index, value2, needsSort);
            this._changedLength = true;
          }
        }
        unset(index) {
          this.set(index, void 0);
        }
        get(index) {
          this._sortData();
          const pos = this._internalPositionFor(index, true);
          if (pos === -1) {
            return void 0;
          }
          return this._data[pos][1];
        }
        push(value2) {
          this.set(this.length, value2);
          return this.length;
        }
        get length() {
          this._sortData();
          if (this._changedLength) {
            const last2 = this._data[this._data.length - 1];
            this._length = last2 ? last2[0] + 1 : 0;
            this._changedLength = false;
          }
          return this._length;
        }
        forEach(iterator) {
          let i2 = 0;
          while (i2 < this.length) {
            iterator(this.get(i2), i2, this);
            i2++;
          }
        }
        map(iterator) {
          let i2 = 0;
          let mapped = new Array(this.length);
          while (i2 < this.length) {
            mapped[i2] = iterator(this.get(i2), i2, this);
            i2++;
          }
          return mapped;
        }
        reduce(reducer, initialValue) {
          let i2 = 0;
          let acc = initialValue;
          while (i2 < this.length) {
            const value2 = this.get(i2);
            acc = reducer(acc, value2, i2);
            i2++;
          }
          return acc;
        }
        find(finder) {
          let i2 = 0, found, last2;
          while (i2 < this.length && !found) {
            last2 = this.get(i2);
            found = finder(last2);
            i2++;
          }
          return found ? last2 : void 0;
        }
        _internalPositionFor(index, noCreate) {
          const bytePos = this._bytePosFor(index, noCreate);
          if (bytePos >= this._bitArrays.length) {
            return -1;
          }
          const byte = this._bitArrays[bytePos];
          const bitPos = index - bytePos * BITS_PER_BYTE;
          const exists2 = (byte & 1 << bitPos) > 0;
          if (!exists2) {
            return -1;
          }
          const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
          const mask = ~(4294967295 << bitPos + 1);
          const bytePopCount = popCount(byte & mask);
          const arrayPos = previousPopCount + bytePopCount - 1;
          return arrayPos;
        }
        _bytePosFor(index, noCreate) {
          const bytePos = Math.floor(index / BITS_PER_BYTE);
          const targetLength = bytePos + 1;
          while (!noCreate && this._bitArrays.length < targetLength) {
            this._bitArrays.push(0);
          }
          return bytePos;
        }
        _setBit(index) {
          const bytePos = this._bytePosFor(index, false);
          this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
        }
        _unsetBit(index) {
          const bytePos = this._bytePosFor(index, false);
          this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
        }
        _setInternalPos(pos, index, value2, needsSort) {
          const data = this._data;
          const elem = [index, value2];
          if (needsSort) {
            this._sortData();
            data[pos] = elem;
          } else {
            if (data.length) {
              if (data[data.length - 1][0] >= index) {
                data.push(elem);
              } else if (data[0][0] <= index) {
                data.unshift(elem);
              } else {
                const randomIndex = Math.round(data.length / 2);
                this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
              }
            } else {
              this._data.push(elem);
            }
            this._changedData = true;
            this._changedLength = true;
          }
        }
        _unsetInternalPos(pos) {
          this._data.splice(pos, 1);
        }
        _sortData() {
          if (this._changedData) {
            this._data.sort(sortInternal);
          }
          this._changedData = false;
        }
        bitField() {
          const bytes = [];
          let pendingBitsForResultingByte = 8;
          let pendingBitsForNewByte = 0;
          let resultingByte = 0;
          let newByte;
          const pending = this._bitArrays.slice();
          while (pending.length || pendingBitsForNewByte) {
            if (pendingBitsForNewByte === 0) {
              newByte = pending.shift();
              pendingBitsForNewByte = 7;
            }
            const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
            const mask = ~(255 << usingBits);
            const masked = newByte & mask;
            resultingByte |= masked << 8 - pendingBitsForResultingByte;
            newByte = newByte >>> usingBits;
            pendingBitsForNewByte -= usingBits;
            pendingBitsForResultingByte -= usingBits;
            if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
              bytes.push(resultingByte);
              resultingByte = 0;
              pendingBitsForResultingByte = 8;
            }
          }
          for (var i2 = bytes.length - 1; i2 > 0; i2--) {
            const value2 = bytes[i2];
            if (value2 === 0) {
              bytes.pop();
            } else {
              break;
            }
          }
          return bytes;
        }
        compactArray() {
          this._sortData();
          return this._data.map(valueOnly);
        }
      };
      function popCountReduce(count, byte) {
        return count + popCount(byte);
      }
      function popCount(_v) {
        let v = _v;
        v = v - (v >> 1 & 1431655765);
        v = (v & 858993459) + (v >> 2 & 858993459);
        return (v + (v >> 4) & 252645135) * 16843009 >> 24;
      }
      function sortInternal(a2, b) {
        return a2[0] - b[0];
      }
      function valueOnly(elem) {
        return elem[1];
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer2, offset, isLE2, mLen, nBytes) {
        var e2, m2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i2 = isLE2 ? nBytes - 1 : 0;
        var d2 = isLE2 ? -1 : 1;
        var s2 = buffer2[offset + i2];
        i2 += d2;
        e2 = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
        }
        m2 = e2 & (1 << -nBits) - 1;
        e2 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
        }
        if (e2 === 0) {
          e2 = 1 - eBias;
        } else if (e2 === eMax) {
          return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m2 = m2 + Math.pow(2, mLen);
          e2 = e2 - eBias;
        }
        return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
      };
      exports.write = function(buffer2, value2, offset, isLE2, mLen, nBytes) {
        var e2, m2, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i2 = isLE2 ? 0 : nBytes - 1;
        var d2 = isLE2 ? 1 : -1;
        var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
        value2 = Math.abs(value2);
        if (isNaN(value2) || value2 === Infinity) {
          m2 = isNaN(value2) ? 1 : 0;
          e2 = eMax;
        } else {
          e2 = Math.floor(Math.log(value2) / Math.LN2);
          if (value2 * (c2 = Math.pow(2, -e2)) < 1) {
            e2--;
            c2 *= 2;
          }
          if (e2 + eBias >= 1) {
            value2 += rt / c2;
          } else {
            value2 += rt * Math.pow(2, 1 - eBias);
          }
          if (value2 * c2 >= 2) {
            e2++;
            c2 /= 2;
          }
          if (e2 + eBias >= eMax) {
            m2 = 0;
            e2 = eMax;
          } else if (e2 + eBias >= 1) {
            m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
            e2 = e2 + eBias;
          } else {
            m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e2 = 0;
          }
        }
        for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
        }
        e2 = e2 << mLen | m2;
        eLen += mLen;
        for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
        }
        buffer2[offset + i2 - d2] |= s2 * 128;
      };
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports, module) {
      var s2 = 1e3;
      var m2 = s2 * 60;
      var h = m2 * 60;
      var d2 = h * 24;
      var w = d2 * 7;
      var y = d2 * 365.25;
      module.exports = function(val, options2) {
        options2 = options2 || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse3(val);
        } else if (type === "number" && isFinite(val)) {
          return options2.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse3(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n2 = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n2 * y;
          case "weeks":
          case "week":
          case "w":
            return n2 * w;
          case "days":
          case "day":
          case "d":
            return n2 * d2;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n2 * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n2 * m2;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n2 * s2;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n2;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d2) {
          return Math.round(ms / d2) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m2) {
          return Math.round(ms / m2) + "m";
        }
        if (msAbs >= s2) {
          return Math.round(ms / s2) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d2) {
          return plural(ms, msAbs, d2, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m2) {
          return plural(ms, msAbs, m2, "minute");
        }
        if (msAbs >= s2) {
          return plural(ms, msAbs, s2, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n2, name9) {
        var isPlural = msAbs >= n2 * 1.5;
        return Math.round(ms / n2) + " " + name9 + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports, module) {
      function setup2(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce2;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace2) {
          let hash = 0;
          for (let i2 = 0; i2 < namespace2.length; i2++) {
            hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace2) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug2(...args) {
            if (!debug2.enabled) {
              return;
            }
            const self2 = debug2;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format3];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug2.namespace = namespace2;
          debug2.useColors = createDebug.useColors();
          debug2.color = createDebug.selectColor(namespace2);
          debug2.extend = extend;
          debug2.destroy = createDebug.destroy;
          Object.defineProperty(debug2, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace2);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug2);
          }
          return debug2;
        }
        function extend(namespace2, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          const split2 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
          for (const ns of split2) {
            if (ns[0] === "-") {
              createDebug.skips.push(ns.slice(1));
            } else {
              createDebug.names.push(ns);
            }
          }
        }
        function matchesTemplate(search, template) {
          let searchIndex = 0;
          let templateIndex = 0;
          let starIndex = -1;
          let matchIndex = 0;
          while (searchIndex < search.length) {
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
              if (template[templateIndex] === "*") {
                starIndex = templateIndex;
                matchIndex = searchIndex;
                templateIndex++;
              } else {
                searchIndex++;
                templateIndex++;
              }
            } else if (starIndex !== -1) {
              templateIndex = starIndex + 1;
              matchIndex++;
              searchIndex = matchIndex;
            } else {
              return false;
            }
          }
          while (templateIndex < template.length && template[templateIndex] === "*") {
            templateIndex++;
          }
          return templateIndex === template.length;
        }
        function disable() {
          const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace2) => "-" + namespace2)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name9) {
          for (const skip of createDebug.skips) {
            if (matchesTemplate(name9, skip)) {
              return false;
            }
          }
          for (const ns of createDebug.names) {
            if (matchesTemplate(name9, ns)) {
              return true;
            }
          }
          return false;
        }
        function coerce2(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup2;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser3 = __commonJS({
    "node_modules/debug/src/browser.js"(exports, module) {
      exports.formatArgs = formatArgs2;
      exports.save = save2;
      exports.load = load2;
      exports.useColors = useColors2;
      exports.storage = localstorage2();
      exports.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors2() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m2;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs2(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c2 = "color: " + this.color;
        args.splice(1, 0, c2, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c2);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save2(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load2() {
        let r2;
        try {
          r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
        } catch (error) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = process.env.DEBUG;
        }
        return r2;
      }
      function localstorage2() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/iso-constants/index.browser.js
  var require_index_browser = __commonJS({
    "node_modules/iso-constants/index.browser.js"(exports, module) {
      "use strict";
      module.exports = {
        "RTLD_LAZY": 1,
        "RTLD_NOW": 2,
        "RTLD_GLOBAL": 256,
        "RTLD_LOCAL": 0,
        "RTLD_DEEPBIND": 8,
        "E2BIG": 7,
        "EACCES": 13,
        "EADDRINUSE": 98,
        "EADDRNOTAVAIL": 99,
        "EAFNOSUPPORT": 97,
        "EAGAIN": 11,
        "EALREADY": 114,
        "EBADF": 9,
        "EBADMSG": 74,
        "EBUSY": 16,
        "ECANCELED": 125,
        "ECHILD": 10,
        "ECONNABORTED": 103,
        "ECONNREFUSED": 111,
        "ECONNRESET": 104,
        "EDEADLK": 35,
        "EDESTADDRREQ": 89,
        "EDOM": 33,
        "EDQUOT": 122,
        "EEXIST": 17,
        "EFAULT": 14,
        "EFBIG": 27,
        "EHOSTUNREACH": 113,
        "EIDRM": 43,
        "EILSEQ": 84,
        "EINPROGRESS": 115,
        "EINTR": 4,
        "EINVAL": 22,
        "EIO": 5,
        "EISCONN": 106,
        "EISDIR": 21,
        "ELOOP": 40,
        "EMFILE": 24,
        "EMLINK": 31,
        "EMSGSIZE": 90,
        "EMULTIHOP": 72,
        "ENAMETOOLONG": 36,
        "ENETDOWN": 100,
        "ENETRESET": 102,
        "ENETUNREACH": 101,
        "ENFILE": 23,
        "ENOBUFS": 105,
        "ENODATA": 61,
        "ENODEV": 19,
        "ENOENT": 2,
        "ENOEXEC": 8,
        "ENOLCK": 37,
        "ENOLINK": 67,
        "ENOMEM": 12,
        "ENOMSG": 42,
        "ENOPROTOOPT": 92,
        "ENOSPC": 28,
        "ENOSR": 63,
        "ENOSTR": 60,
        "ENOSYS": 38,
        "ENOTCONN": 107,
        "ENOTDIR": 20,
        "ENOTEMPTY": 39,
        "ENOTSOCK": 88,
        "ENOTSUP": 95,
        "ENOTTY": 25,
        "ENXIO": 6,
        "EOPNOTSUPP": 95,
        "EOVERFLOW": 75,
        "EPERM": 1,
        "EPIPE": 32,
        "EPROTO": 71,
        "EPROTONOSUPPORT": 93,
        "EPROTOTYPE": 91,
        "ERANGE": 34,
        "EROFS": 30,
        "ESPIPE": 29,
        "ESRCH": 3,
        "ESTALE": 116,
        "ETIME": 62,
        "ETIMEDOUT": 110,
        "ETXTBSY": 26,
        "EWOULDBLOCK": 11,
        "EXDEV": 18,
        "PRIORITY_LOW": 19,
        "PRIORITY_BELOW_NORMAL": 10,
        "PRIORITY_NORMAL": 0,
        "PRIORITY_ABOVE_NORMAL": -7,
        "PRIORITY_HIGH": -14,
        "PRIORITY_HIGHEST": -20,
        "SIGHUP": 1,
        "SIGINT": 2,
        "SIGQUIT": 3,
        "SIGILL": 4,
        "SIGTRAP": 5,
        "SIGABRT": 6,
        "SIGIOT": 6,
        "SIGBUS": 7,
        "SIGFPE": 8,
        "SIGKILL": 9,
        "SIGUSR1": 10,
        "SIGSEGV": 11,
        "SIGUSR2": 12,
        "SIGPIPE": 13,
        "SIGALRM": 14,
        "SIGTERM": 15,
        "SIGCHLD": 17,
        "SIGSTKFLT": 16,
        "SIGCONT": 18,
        "SIGSTOP": 19,
        "SIGTSTP": 20,
        "SIGTTIN": 21,
        "SIGTTOU": 22,
        "SIGURG": 23,
        "SIGXCPU": 24,
        "SIGXFSZ": 25,
        "SIGVTALRM": 26,
        "SIGPROF": 27,
        "SIGWINCH": 28,
        "SIGIO": 29,
        "SIGPOLL": 29,
        "SIGPWR": 30,
        "SIGSYS": 31,
        "UV_FS_SYMLINK_DIR": 1,
        "UV_FS_SYMLINK_JUNCTION": 2,
        "O_RDONLY": 0,
        "O_WRONLY": 1,
        "O_RDWR": 2,
        "UV_DIRENT_UNKNOWN": 0,
        "UV_DIRENT_FILE": 1,
        "UV_DIRENT_DIR": 2,
        "UV_DIRENT_LINK": 3,
        "UV_DIRENT_FIFO": 4,
        "UV_DIRENT_SOCKET": 5,
        "UV_DIRENT_CHAR": 6,
        "UV_DIRENT_BLOCK": 7,
        "EXTENSIONLESS_FORMAT_JAVASCRIPT": 0,
        "EXTENSIONLESS_FORMAT_WASM": 1,
        "S_IFMT": 61440,
        "S_IFREG": 32768,
        "S_IFDIR": 16384,
        "S_IFCHR": 8192,
        "S_IFBLK": 24576,
        "S_IFIFO": 4096,
        "S_IFLNK": 40960,
        "S_IFSOCK": 49152,
        "O_CREAT": 64,
        "O_EXCL": 128,
        "UV_FS_O_FILEMAP": 0,
        "O_NOCTTY": 256,
        "O_TRUNC": 512,
        "O_APPEND": 1024,
        "O_DIRECTORY": 65536,
        "O_NOATIME": 262144,
        "O_NOFOLLOW": 131072,
        "O_SYNC": 1052672,
        "O_DSYNC": 4096,
        "O_DIRECT": 16384,
        "O_NONBLOCK": 2048,
        "S_IRWXU": 448,
        "S_IRUSR": 256,
        "S_IWUSR": 128,
        "S_IXUSR": 64,
        "S_IRWXG": 56,
        "S_IRGRP": 32,
        "S_IWGRP": 16,
        "S_IXGRP": 8,
        "S_IRWXO": 7,
        "S_IROTH": 4,
        "S_IWOTH": 2,
        "S_IXOTH": 1,
        "F_OK": 0,
        "R_OK": 4,
        "W_OK": 2,
        "X_OK": 1,
        "UV_FS_COPYFILE_EXCL": 1,
        "COPYFILE_EXCL": 1,
        "UV_FS_COPYFILE_FICLONE": 2,
        "COPYFILE_FICLONE": 2,
        "UV_FS_COPYFILE_FICLONE_FORCE": 4,
        "COPYFILE_FICLONE_FORCE": 4,
        "OPENSSL_VERSION_NUMBER": 805306624,
        "SSL_OP_ALL": 2147485776,
        "SSL_OP_ALLOW_NO_DHE_KEX": 1024,
        "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
        "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
        "SSL_OP_CISCO_ANYCONNECT": 32768,
        "SSL_OP_COOKIE_EXCHANGE": 8192,
        "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
        "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
        "SSL_OP_LEGACY_SERVER_CONNECT": 4,
        "SSL_OP_NO_COMPRESSION": 131072,
        "SSL_OP_NO_ENCRYPT_THEN_MAC": 524288,
        "SSL_OP_NO_QUERY_MTU": 4096,
        "SSL_OP_NO_RENEGOTIATION": 1073741824,
        "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
        "SSL_OP_NO_SSLv2": 0,
        "SSL_OP_NO_SSLv3": 33554432,
        "SSL_OP_NO_TICKET": 16384,
        "SSL_OP_NO_TLSv1": 67108864,
        "SSL_OP_NO_TLSv1_1": 268435456,
        "SSL_OP_NO_TLSv1_2": 134217728,
        "SSL_OP_NO_TLSv1_3": 536870912,
        "SSL_OP_PRIORITIZE_CHACHA": 2097152,
        "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
        "ENGINE_METHOD_RSA": 1,
        "ENGINE_METHOD_DSA": 2,
        "ENGINE_METHOD_DH": 4,
        "ENGINE_METHOD_RAND": 8,
        "ENGINE_METHOD_EC": 2048,
        "ENGINE_METHOD_CIPHERS": 64,
        "ENGINE_METHOD_DIGESTS": 128,
        "ENGINE_METHOD_PKEY_METHS": 512,
        "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
        "ENGINE_METHOD_ALL": 65535,
        "ENGINE_METHOD_NONE": 0,
        "DH_CHECK_P_NOT_SAFE_PRIME": 2,
        "DH_CHECK_P_NOT_PRIME": 1,
        "DH_UNABLE_TO_CHECK_GENERATOR": 4,
        "DH_NOT_SUITABLE_GENERATOR": 8,
        "RSA_PKCS1_PADDING": 1,
        "RSA_NO_PADDING": 3,
        "RSA_PKCS1_OAEP_PADDING": 4,
        "RSA_X931_PADDING": 5,
        "RSA_PKCS1_PSS_PADDING": 6,
        "RSA_PSS_SALTLEN_DIGEST": -1,
        "RSA_PSS_SALTLEN_MAX_SIGN": -2,
        "RSA_PSS_SALTLEN_AUTO": -2,
        "defaultCoreCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
        "TLS1_VERSION": 769,
        "TLS1_1_VERSION": 770,
        "TLS1_2_VERSION": 771,
        "TLS1_3_VERSION": 772,
        "POINT_CONVERSION_COMPRESSED": 2,
        "POINT_CONVERSION_UNCOMPRESSED": 4,
        "POINT_CONVERSION_HYBRID": 6
      };
    }
  });

  // src/index.js
  var index_exports = {};
  __export(index_exports, {
    Ipfs: () => Ipfs,
    Owner: () => Owner,
    User: () => User
  });

  // node_modules/@libp2p/interface/dist/src/connection.js
  var connectionSymbol = Symbol.for("@libp2p/connection");

  // node_modules/@libp2p/interface/dist/src/content-routing.js
  var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

  // node_modules/@libp2p/interface/dist/src/errors.js
  var AbortError = class extends Error {
    static name = "AbortError";
    constructor(message2 = "The operation was aborted") {
      super(message2);
      this.name = "AbortError";
    }
  };
  var UnexpectedPeerError = class extends Error {
    static name = "UnexpectedPeerError";
    constructor(message2 = "Unexpected Peer") {
      super(message2);
      this.name = "UnexpectedPeerError";
    }
  };
  var InvalidCryptoExchangeError = class extends Error {
    static name = "InvalidCryptoExchangeError";
    constructor(message2 = "Invalid crypto exchange") {
      super(message2);
      this.name = "InvalidCryptoExchangeError";
    }
  };
  var InvalidParametersError = class extends Error {
    static name = "InvalidParametersError";
    constructor(message2 = "Invalid parameters") {
      super(message2);
      this.name = "InvalidParametersError";
    }
  };
  var InvalidPublicKeyError = class extends Error {
    static name = "InvalidPublicKeyError";
    constructor(message2 = "Invalid public key") {
      super(message2);
      this.name = "InvalidPublicKeyError";
    }
  };
  var InvalidPrivateKeyError = class extends Error {
    static name = "InvalidPrivateKeyError";
    constructor(message2 = "Invalid private key") {
      super(message2);
      this.name = "InvalidPrivateKeyError";
    }
  };
  var UnsupportedOperationError = class extends Error {
    static name = "UnsupportedOperationError";
    constructor(message2 = "Unsupported operation") {
      super(message2);
      this.name = "UnsupportedOperationError";
    }
  };
  var ConnectionClosedError = class extends Error {
    static name = "ConnectionClosedError";
    constructor(message2 = "The connection is closed") {
      super(message2);
      this.name = "ConnectionClosedError";
    }
  };
  var ConnectionFailedError = class extends Error {
    static name = "ConnectionFailedError";
    constructor(message2 = "Connection failed") {
      super(message2);
      this.name = "ConnectionFailedError";
    }
  };
  var MuxerClosedError = class extends Error {
    static name = "MuxerClosedError";
    constructor(message2 = "The muxer is closed") {
      super(message2);
      this.name = "MuxerClosedError";
    }
  };
  var StreamResetError = class extends Error {
    static name = "StreamResetError";
    constructor(message2 = "The stream has been reset") {
      super(message2);
      this.name = "StreamResetError";
    }
  };
  var StreamStateError = class extends Error {
    static name = "StreamStateError";
    constructor(message2 = "The stream is in an invalid state") {
      super(message2);
      this.name = "StreamStateError";
    }
  };
  var StreamBufferError = class extends Error {
    static name = "StreamBufferError";
    constructor(message2 = "The stream buffer was full") {
      super(message2);
      this.name = "StreamBufferError";
    }
  };
  var NotFoundError = class extends Error {
    static name = "NotFoundError";
    constructor(message2 = "Not found") {
      super(message2);
      this.name = "NotFoundError";
    }
  };
  var InvalidPeerIdError = class extends Error {
    static name = "InvalidPeerIdError";
    constructor(message2 = "Invalid PeerID") {
      super(message2);
      this.name = "InvalidPeerIdError";
    }
  };
  var InvalidMultiaddrError = class extends Error {
    static name = "InvalidMultiaddrError";
    constructor(message2 = "Invalid multiaddr") {
      super(message2);
      this.name = "InvalidMultiaddrError";
    }
  };
  var InvalidCIDError = class extends Error {
    static name = "InvalidCIDError";
    constructor(message2 = "Invalid CID") {
      super(message2);
      this.name = "InvalidCIDError";
    }
  };
  var InvalidMultihashError = class extends Error {
    static name = "InvalidMultihashError";
    constructor(message2 = "Invalid Multihash") {
      super(message2);
      this.name = "InvalidMultihashError";
    }
  };
  var UnsupportedProtocolError = class extends Error {
    static name = "UnsupportedProtocolError";
    constructor(message2 = "Unsupported protocol error") {
      super(message2);
      this.name = "UnsupportedProtocolError";
    }
  };
  var InvalidMessageError = class extends Error {
    static name = "InvalidMessageError";
    constructor(message2 = "Invalid message") {
      super(message2);
      this.name = "InvalidMessageError";
    }
  };
  var ProtocolError = class extends Error {
    static name = "ProtocolError";
    constructor(message2 = "Protocol error") {
      super(message2);
      this.name = "ProtocolError";
    }
  };
  var TimeoutError = class extends Error {
    static name = "TimeoutError";
    constructor(message2 = "Timed out") {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var NotStartedError = class extends Error {
    static name = "NotStartedError";
    constructor(message2 = "Not started") {
      super(message2);
      this.name = "NotStartedError";
    }
  };
  var DialError = class extends Error {
    static name = "DialError";
    constructor(message2 = "Dial error") {
      super(message2);
      this.name = "DialError";
    }
  };
  var ListenError = class extends Error {
    static name = "ListenError";
    constructor(message2 = "Listen error") {
      super(message2);
      this.name = "ListenError";
    }
  };
  var LimitedConnectionError = class extends Error {
    static name = "LimitedConnectionError";
    constructor(message2 = "Limited connection") {
      super(message2);
      this.name = "LimitedConnectionError";
    }
  };
  var TooManyInboundProtocolStreamsError = class extends Error {
    static name = "TooManyInboundProtocolStreamsError";
    constructor(message2 = "Too many inbound protocol streams") {
      super(message2);
      this.name = "TooManyInboundProtocolStreamsError";
    }
  };
  var TooManyOutboundProtocolStreamsError = class extends Error {
    static name = "TooManyOutboundProtocolStreamsError";
    constructor(message2 = "Too many outbound protocol streams") {
      super(message2);
      this.name = "TooManyOutboundProtocolStreamsError";
    }
  };
  var UnsupportedKeyTypeError = class extends Error {
    static name = "UnsupportedKeyTypeError";
    constructor(message2 = "Unsupported key type") {
      super(message2);
      this.name = "UnsupportedKeyTypeError";
    }
  };

  // node_modules/@libp2p/interface/dist/src/events.js
  var StreamMessageEvent = class extends Event {
    data;
    constructor(data, eventInitDict) {
      super("message", eventInitDict);
      this.data = data;
    }
  };
  var StreamCloseEvent = class extends Event {
    error;
    local;
    constructor(local, error, eventInitDict) {
      super("close", eventInitDict);
      this.error = error;
      this.local = local;
    }
  };
  var StreamAbortEvent = class extends StreamCloseEvent {
    constructor(error, eventInitDict) {
      super(true, error, eventInitDict);
    }
  };
  var StreamResetEvent = class extends StreamCloseEvent {
    constructor(error, eventInitDict) {
      super(false, error, eventInitDict);
    }
  };

  // node_modules/@libp2p/interface/dist/src/keys.js
  function isPublicKey(key) {
    if (key == null) {
      return false;
    }
    return (key.type === "RSA" || key.type === "Ed25519" || key.type === "secp256k1" || key.type === "ECDSA") && key.raw instanceof Uint8Array && typeof key.equals === "function" && typeof key.toMultihash === "function" && typeof key.toCID === "function" && typeof key.verify === "function";
  }

  // node_modules/@libp2p/interface/dist/src/peer-discovery.js
  var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

  // node_modules/@libp2p/interface/dist/src/peer-id.js
  var peerIdSymbol = Symbol.for("@libp2p/peer-id");
  function isPeerId(other) {
    return Boolean(other?.[peerIdSymbol]);
  }

  // node_modules/@libp2p/interface/dist/src/peer-routing.js
  var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

  // node_modules/@libp2p/interface/dist/src/peer-store.js
  var KEEP_ALIVE = "keep-alive";

  // node_modules/@libp2p/interface/dist/src/startable.js
  function isStartable(obj) {
    return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
  }
  async function start(...objs) {
    const startables = [];
    for (const obj of objs) {
      if (isStartable(obj)) {
        startables.push(obj);
      }
    }
    await Promise.all(startables.map(async (s2) => {
      if (s2.beforeStart != null) {
        await s2.beforeStart();
      }
    }));
    await Promise.all(startables.map(async (s2) => {
      await s2.start();
    }));
    await Promise.all(startables.map(async (s2) => {
      if (s2.afterStart != null) {
        await s2.afterStart();
      }
    }));
  }
  async function stop(...objs) {
    const startables = [];
    for (const obj of objs) {
      if (isStartable(obj)) {
        startables.push(obj);
      }
    }
    await Promise.all(startables.map(async (s2) => {
      if (s2.beforeStop != null) {
        await s2.beforeStop();
      }
    }));
    await Promise.all(startables.map(async (s2) => {
      await s2.stop();
    }));
    await Promise.all(startables.map(async (s2) => {
      if (s2.afterStop != null) {
        await s2.afterStop();
      }
    }));
  }

  // node_modules/@libp2p/interface/dist/src/transport.js
  var transportSymbol = Symbol.for("@libp2p/transport");
  var FaultTolerance;
  (function(FaultTolerance2) {
    FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
    FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
  })(FaultTolerance || (FaultTolerance = {}));

  // node_modules/main-event/dist/src/events.browser.js
  function setMaxListeners() {
  }

  // node_modules/main-event/dist/src/index.js
  var TypedEventEmitter = class extends EventTarget {
    #listeners = /* @__PURE__ */ new Map();
    constructor() {
      super();
      setMaxListeners(Infinity, this);
    }
    listenerCount(type) {
      const listeners = this.#listeners.get(type);
      if (listeners == null) {
        return 0;
      }
      return listeners.length;
    }
    addEventListener(type, listener, options2) {
      super.addEventListener(type, listener, options2);
      let list = this.#listeners.get(type);
      if (list == null) {
        list = [];
        this.#listeners.set(type, list);
      }
      list.push({
        callback: listener,
        once: (options2 !== true && options2 !== false && options2?.once) ?? false
      });
    }
    removeEventListener(type, listener, options2) {
      super.removeEventListener(type.toString(), listener ?? null, options2);
      let list = this.#listeners.get(type);
      if (list == null) {
        return;
      }
      list = list.filter(({ callback }) => callback !== listener);
      this.#listeners.set(type, list);
    }
    dispatchEvent(event) {
      const result = super.dispatchEvent(event);
      let list = this.#listeners.get(event.type);
      if (list == null) {
        return result;
      }
      list = list.filter(({ once }) => !once);
      this.#listeners.set(event.type, list);
      return result;
    }
    safeDispatchEvent(type, detail = {}) {
      return this.dispatchEvent(new CustomEvent(type, detail));
    }
  };

  // node_modules/@libp2p/interface/dist/src/index.js
  var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
  var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

  // node_modules/any-signal/dist/src/index.js
  function anySignal(signals) {
    const controller = new globalThis.AbortController();
    function onAbort() {
      controller.abort();
      for (const signal2 of signals) {
        if (signal2?.removeEventListener != null) {
          signal2.removeEventListener("abort", onAbort);
        }
      }
    }
    for (const signal2 of signals) {
      if (signal2?.aborted === true) {
        onAbort();
        break;
      }
      if (signal2?.addEventListener != null) {
        signal2.addEventListener("abort", onAbort);
      }
    }
    function clear() {
      for (const signal2 of signals) {
        if (signal2?.removeEventListener != null) {
          signal2.removeEventListener("abort", onAbort);
        }
      }
    }
    const signal = controller.signal;
    signal.clear = clear;
    return signal;
  }

  // node_modules/progress-events/dist/src/index.js
  var CustomProgressEvent = class extends Event {
    type;
    detail;
    constructor(type, detail) {
      super(type);
      this.type = type;
      this.detail = detail;
    }
  };

  // node_modules/@libp2p/crypto/dist/src/errors.js
  var SigningError = class extends Error {
    constructor(message2 = "An error occurred while signing a message") {
      super(message2);
      this.name = "SigningError";
    }
  };
  var VerificationError = class extends Error {
    constructor(message2 = "An error occurred while verifying a message") {
      super(message2);
      this.name = "VerificationError";
    }
  };
  var WebCryptoMissingError = class extends Error {
    constructor(message2 = "Missing Web Crypto API") {
      super(message2);
      this.name = "WebCryptoMissingError";
    }
  };

  // node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
  var webcrypto_browser_default = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if (nativeCrypto?.subtle == null) {
        throw new WebCryptoMissingError("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
      }
      return nativeCrypto;
    }
  };

  // node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
  var webcrypto_default = webcrypto_browser_default;

  // node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports = {};
  __export(base58_exports, {
    base58btc: () => base58btc,
    base58flickr: () => base58flickr
  });

  // node_modules/multiformats/dist/src/bytes.js
  var bytes_exports = {};
  __export(bytes_exports, {
    coerce: () => coerce,
    empty: () => empty,
    equals: () => equals,
    fromHex: () => fromHex,
    fromString: () => fromString,
    isBinary: () => isBinary,
    toHex: () => toHex,
    toString: () => toString
  });
  var empty = new Uint8Array(0);
  function toHex(d2) {
    return d2.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
  }
  function fromHex(hex) {
    const hexes2 = hex.match(/../g);
    return hexes2 != null ? new Uint8Array(hexes2.map((b) => parseInt(b, 16))) : empty;
  }
  function equals(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce(o2) {
    if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") {
      return o2;
    }
    if (o2 instanceof ArrayBuffer) {
      return new Uint8Array(o2);
    }
    if (ArrayBuffer.isView(o2)) {
      return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function isBinary(o2) {
    return o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
  }
  function fromString(str) {
    return new TextEncoder().encode(str);
  }
  function toString(b) {
    return new TextDecoder().decode(b);
  }

  // node_modules/multiformats/dist/src/vendor/base-x.js
  function base(ALPHABET, name9) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET.length; i2++) {
      var x = ALPHABET.charAt(i2);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode17(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length4 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i3;
        pbegin++;
      }
      var it2 = size - length4;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length4 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i3;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length4;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode16(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name9} character`);
    }
    return {
      encode: encode17,
      decodeUnsafe,
      decode: decode16
    };
  }
  var src = base;
  var _brrp__multiformats_scope_baseX = src;
  var base_x_default = _brrp__multiformats_scope_baseX;

  // node_modules/multiformats/dist/src/bases/base.js
  var Encoder = class {
    name;
    prefix;
    baseEncode;
    constructor(name9, prefix, baseEncode) {
      this.name = name9;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name9, prefix, baseDecode) {
      this.name = name9;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or(this, decoder);
    }
  };
  var ComposedDecoder = class {
    decoders;
    constructor(decoders3) {
      this.decoders = decoders3;
    }
    or(decoder) {
      return or(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or(left, right) {
    return new ComposedDecoder({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name9, prefix, baseEncode, baseDecode) {
      this.name = name9;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name9, prefix, baseEncode);
      this.decoder = new Decoder(name9, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from({ name: name9, prefix, encode: encode17, decode: decode16 }) {
    return new Codec(name9, prefix, encode17, decode16);
  }
  function baseX({ name: name9, prefix, alphabet: alphabet2 }) {
    const { encode: encode17, decode: decode16 } = base_x_default(alphabet2, name9);
    return from({
      prefix,
      name: name9,
      encode: encode17,
      decode: (text) => coerce(decode16(text))
    });
  }
  function decode(string2, alphabetIdx, bitsPerChar, name9) {
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer2 = 0;
    let written = 0;
    for (let i2 = 0; i2 < end; ++i2) {
      const value2 = alphabetIdx[string2[i2]];
      if (value2 === void 0) {
        throw new SyntaxError(`Non-${name9} character`);
      }
      buffer2 = buffer2 << bitsPerChar | value2;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer2 >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || (255 & buffer2 << 8 - bits2) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode(data, alphabet2, bitsPerChar) {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer2 = 0;
    for (let i2 = 0; i2 < data.length; ++i2) {
      buffer2 = buffer2 << 8 | data[i2];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet2[mask & buffer2 >> bits2];
      }
    }
    if (bits2 !== 0) {
      out += alphabet2[mask & buffer2 << bitsPerChar - bits2];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx(alphabet2) {
    const alphabetIdx = {};
    for (let i2 = 0; i2 < alphabet2.length; ++i2) {
      alphabetIdx[alphabet2[i2]] = i2;
    }
    return alphabetIdx;
  }
  function rfc4648({ name: name9, prefix, bitsPerChar, alphabet: alphabet2 }) {
    const alphabetIdx = createAlphabetIdx(alphabet2);
    return from({
      prefix,
      name: name9,
      encode(input) {
        return encode(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode(input, alphabetIdx, bitsPerChar, name9);
      }
    });
  }

  // node_modules/multiformats/dist/src/bases/base58.js
  var base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports = {};
  __export(base32_exports, {
    base32: () => base32,
    base32hex: () => base32hex,
    base32hexpad: () => base32hexpad,
    base32hexpadupper: () => base32hexpadupper,
    base32hexupper: () => base32hexupper,
    base32pad: () => base32pad,
    base32padupper: () => base32padupper,
    base32upper: () => base32upper,
    base32z: () => base32z
  });
  var base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports = {};
  __export(base36_exports, {
    base36: () => base36,
    base36upper: () => base36upper
  });
  var base36 = baseX({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper = baseX({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // node_modules/multiformats/dist/src/hashes/digest.js
  var digest_exports = {};
  __export(digest_exports, {
    Digest: () => Digest,
    create: () => create,
    decode: () => decode4,
    equals: () => equals2,
    hasCode: () => hasCode
  });

  // node_modules/multiformats/dist/src/vendor/varint.js
  var encode_1 = encode2;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode2(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode2.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode2 = read;
  var MSB$1 = 128;
  var REST$1 = 127;
  function read(buf2, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l2 = buf2.length;
    do {
      if (counter >= l2) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf2[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read.bytes = counter - offset;
    return res;
  }
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value2) {
    return value2 < N1 ? 1 : value2 < N2 ? 2 : value2 < N3 ? 3 : value2 < N4 ? 4 : value2 < N5 ? 5 : value2 < N6 ? 6 : value2 < N7 ? 7 : value2 < N8 ? 8 : value2 < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode2,
    encodingLength: length
  };
  var _brrp_varint = varint;
  var varint_default = _brrp_varint;

  // node_modules/multiformats/dist/src/varint.js
  function decode3(data, offset = 0) {
    const code8 = varint_default.decode(data, offset);
    return [code8, varint_default.decode.bytes];
  }
  function encodeTo(int, target, offset = 0) {
    varint_default.encode(int, target, offset);
    return target;
  }
  function encodingLength(int) {
    return varint_default.encodingLength(int);
  }

  // node_modules/multiformats/dist/src/hashes/digest.js
  function create(code8, digest2) {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength(code8);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code8, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest2, digestOffset);
    return new Digest(code8, size, digest2, bytes);
  }
  function decode4(multihash) {
    const bytes = coerce(multihash);
    const [code8, sizeOffset] = decode3(bytes);
    const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
    const digest2 = bytes.subarray(sizeOffset + digestOffset);
    if (digest2.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code8, size, digest2, bytes);
  }
  function equals2(a2, b) {
    if (a2 === b) {
      return true;
    } else {
      const data = b;
      return a2.code === data.code && a2.size === data.size && data.bytes instanceof Uint8Array && equals(a2.bytes, data.bytes);
    }
  }
  var Digest = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code8, size, digest2, bytes) {
      this.code = code8;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes;
    }
  };
  function hasCode(digest2, code8) {
    return digest2.code === code8;
  }

  // node_modules/multiformats/dist/src/cid.js
  function format(link, base3) {
    const { bytes, version: version3 } = link;
    switch (version3) {
      case 0:
        return toStringV0(bytes, baseCache(link), base3 ?? base58btc.encoder);
      default:
        return toStringV1(bytes, baseCache(link), base3 ?? base32.encoder);
    }
  }
  var cache = /* @__PURE__ */ new WeakMap();
  function baseCache(cid) {
    const baseCache2 = cache.get(cid);
    if (baseCache2 == null) {
      const baseCache3 = /* @__PURE__ */ new Map();
      cache.set(cid, baseCache3);
      return baseCache3;
    }
    return baseCache2;
  }
  var CID = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version3, code8, multihash, bytes) {
      this.code = code8;
      this.version = version3;
      this.multihash = multihash;
      this.bytes = bytes;
      this["/"] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code8, multihash } = this;
          if (code8 !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code8, digest: digest2 } = this.multihash;
          const multihash = create(code8, digest2);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self2, other) {
      const unknown = other;
      return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
    }
    toString(base3) {
      return format(this, base3);
    }
    toJSON() {
      return { "/": format(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value2 = input;
      if (value2 instanceof _CID) {
        return value2;
      } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
        const { version: version3, code: code8, multihash, bytes } = value2;
        return new _CID(version3, code8, multihash, bytes ?? encodeCID(version3, code8, multihash.bytes));
      } else if (value2[cidSymbol] === true) {
        const { version: version3, multihash, code: code8 } = value2;
        const digest2 = decode4(multihash);
        return _CID.create(version3, code8, digest2);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version3, code8, digest2) {
      if (typeof code8 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest2.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version3) {
        case 0: {
          if (code8 !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new _CID(version3, code8, digest2, digest2.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID(version3, code8, digest2.bytes);
          return new _CID(version3, code8, digest2, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest2) {
      return _CID.create(0, DAG_PB_CODE, digest2);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code8, digest2) {
      return _CID.create(1, code8, digest2);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes) {
      const [cid, remainder] = _CID.decodeFirst(bytes);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes) {
      const specs = _CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
      return [cid, bytes.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i2, length4] = decode3(initialBytes.subarray(offset));
        offset += length4;
        return i2;
      };
      let version3 = next();
      let codec = DAG_PB_CODE;
      if (version3 === 18) {
        version3 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version3 !== 0 && version3 !== 1) {
        throw new RangeError(`Invalid CID version ${version3}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version3, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base3) {
      const [prefix, bytes] = parseCIDtoBytes(source, base3);
      const cid = _CID.decode(bytes);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes(source, base3) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base3 ?? base58btc;
        return [
          base58btc.prefix,
          decoder.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder = base3 ?? base58btc;
        return [base58btc.prefix, decoder.decode(source)];
      }
      case base32.prefix: {
        const decoder = base3 ?? base32;
        return [base32.prefix, decoder.decode(source)];
      }
      case base36.prefix: {
        const decoder = base3 ?? base36;
        return [base36.prefix, decoder.decode(source)];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base3.decode(source)];
      }
    }
  }
  function toStringV0(bytes, cache3, base3) {
    const { prefix } = base3;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes).slice(1);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV1(bytes, cache3, base3) {
    const { prefix } = base3;
    const cid = cache3.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes);
      cache3.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE = 112;
  var SHA_256_CODE = 18;
  function encodeCID(version3, code8, multihash) {
    const codeOffset = encodingLength(version3);
    const hashOffset = codeOffset + encodingLength(code8);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version3, bytes, 0);
    encodeTo(code8, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  }
  var cidSymbol = Symbol.for("@ipld/js-cid/CID");

  // node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports = {};
  __export(identity_exports, {
    identity: () => identity
  });
  var code = 0;
  var name = "identity";
  var encode3 = coerce;
  function digest(input, options2) {
    if (options2?.truncate != null && options2.truncate !== input.byteLength) {
      if (options2.truncate < 0 || options2.truncate > input.byteLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
      }
      input = input.subarray(0, options2.truncate);
    }
    return create(code, encode3(input));
  }
  var identity = { code, name, encode: encode3, digest };

  // node_modules/uint8arrays/dist/src/equals.js
  function equals3(a2, b) {
    if (a2 === b) {
      return true;
    }
    if (a2.byteLength !== b.byteLength) {
      return false;
    }
    for (let i2 = 0; i2 < a2.byteLength; i2++) {
      if (a2[i2] !== b[i2]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/uint8arrays/dist/src/alloc.js
  function alloc(size = 0) {
    return new Uint8Array(size);
  }
  function allocUnsafe(size = 0) {
    return new Uint8Array(size);
  }

  // node_modules/uint8arrays/dist/src/util/as-uint8array.js
  function asUint8Array(buf2) {
    return buf2;
  }

  // node_modules/uint8arrays/dist/src/concat.js
  function concat(arrays, length4) {
    if (length4 == null) {
      length4 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = allocUnsafe(length4);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array(output);
  }

  // node_modules/uint8arraylist/dist/src/index.js
  var symbol = Symbol.for("@achingbrain/uint8arraylist");
  function findBufAndOffset(bufs, index) {
    if (index == null || index < 0) {
      throw new RangeError("index is out of bounds");
    }
    let offset = 0;
    for (const buf2 of bufs) {
      const bufEnd = offset + buf2.byteLength;
      if (index < bufEnd) {
        return {
          buf: buf2,
          index: index - offset
        };
      }
      offset = bufEnd;
    }
    throw new RangeError("index is out of bounds");
  }
  function isUint8ArrayList(value2) {
    return Boolean(value2?.[symbol]);
  }
  var Uint8ArrayList = class _Uint8ArrayList {
    bufs;
    length;
    [symbol] = true;
    constructor(...data) {
      this.bufs = [];
      this.length = 0;
      if (data.length > 0) {
        this.appendAll(data);
      }
    }
    *[Symbol.iterator]() {
      yield* this.bufs;
    }
    get byteLength() {
      return this.length;
    }
    /**
     * Add one or more `bufs` to the end of this Uint8ArrayList
     */
    append(...bufs) {
      this.appendAll(bufs);
    }
    /**
     * Add all `bufs` to the end of this Uint8ArrayList
     */
    appendAll(bufs) {
      let length4 = 0;
      for (const buf2 of bufs) {
        if (buf2 instanceof Uint8Array) {
          length4 += buf2.byteLength;
          this.bufs.push(buf2);
        } else if (isUint8ArrayList(buf2)) {
          length4 += buf2.byteLength;
          this.bufs.push(...buf2.bufs);
        } else {
          throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      this.length += length4;
    }
    /**
     * Add one or more `bufs` to the start of this Uint8ArrayList
     */
    prepend(...bufs) {
      this.prependAll(bufs);
    }
    /**
     * Add all `bufs` to the start of this Uint8ArrayList
     */
    prependAll(bufs) {
      let length4 = 0;
      for (const buf2 of bufs.reverse()) {
        if (buf2 instanceof Uint8Array) {
          length4 += buf2.byteLength;
          this.bufs.unshift(buf2);
        } else if (isUint8ArrayList(buf2)) {
          length4 += buf2.byteLength;
          this.bufs.unshift(...buf2.bufs);
        } else {
          throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      this.length += length4;
    }
    /**
     * Read the value at `index`
     */
    get(index) {
      const res = findBufAndOffset(this.bufs, index);
      return res.buf[res.index];
    }
    /**
     * Set the value at `index` to `value`
     */
    set(index, value2) {
      const res = findBufAndOffset(this.bufs, index);
      res.buf[res.index] = value2;
    }
    /**
     * Copy bytes from `buf` to the index specified by `offset`
     */
    write(buf2, offset = 0) {
      if (buf2 instanceof Uint8Array) {
        for (let i2 = 0; i2 < buf2.length; i2++) {
          this.set(offset + i2, buf2[i2]);
        }
      } else if (isUint8ArrayList(buf2)) {
        for (let i2 = 0; i2 < buf2.length; i2++) {
          this.set(offset + i2, buf2.get(i2));
        }
      } else {
        throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    /**
     * Remove bytes from the front of the pool
     */
    consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0) {
        return;
      }
      if (bytes === this.byteLength) {
        this.bufs = [];
        this.length = 0;
        return;
      }
      while (this.bufs.length > 0) {
        if (bytes >= this.bufs[0].byteLength) {
          bytes -= this.bufs[0].byteLength;
          this.length -= this.bufs[0].byteLength;
          this.bufs.shift();
        } else {
          this.bufs[0] = this.bufs[0].subarray(bytes);
          this.length -= bytes;
          break;
        }
      }
    }
    /**
     * Extracts a section of an array and returns a new array.
     *
     * This is a copy operation as it is with Uint8Arrays and Arrays
     * - note this is different to the behaviour of Node Buffers.
     */
    slice(beginInclusive, endExclusive) {
      const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
      return concat(bufs, length4);
    }
    /**
     * Returns a alloc from the given start and end element index.
     *
     * In the best case where the data extracted comes from a single Uint8Array
     * internally this is a no-copy operation otherwise it is a copy operation.
     */
    subarray(beginInclusive, endExclusive) {
      const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
      if (bufs.length === 1) {
        return bufs[0];
      }
      return concat(bufs, length4);
    }
    /**
     * Returns a allocList from the given start and end element index.
     *
     * This is a no-copy operation.
     */
    sublist(beginInclusive, endExclusive) {
      const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
      const list = new _Uint8ArrayList();
      list.length = length4;
      list.bufs = [...bufs];
      return list;
    }
    _subList(beginInclusive, endExclusive) {
      beginInclusive = beginInclusive ?? 0;
      endExclusive = endExclusive ?? this.length;
      if (beginInclusive < 0) {
        beginInclusive = this.length + beginInclusive;
      }
      if (endExclusive < 0) {
        endExclusive = this.length + endExclusive;
      }
      if (beginInclusive < 0 || endExclusive > this.length) {
        throw new RangeError("index is out of bounds");
      }
      if (beginInclusive === endExclusive) {
        return { bufs: [], length: 0 };
      }
      if (beginInclusive === 0 && endExclusive === this.length) {
        return { bufs: this.bufs, length: this.length };
      }
      const bufs = [];
      let offset = 0;
      for (let i2 = 0; i2 < this.bufs.length; i2++) {
        const buf2 = this.bufs[i2];
        const bufStart = offset;
        const bufEnd = bufStart + buf2.byteLength;
        offset = bufEnd;
        if (beginInclusive >= bufEnd) {
          continue;
        }
        const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
        const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
        if (sliceStartInBuf && sliceEndsInBuf) {
          if (beginInclusive === bufStart && endExclusive === bufEnd) {
            bufs.push(buf2);
            break;
          }
          const start2 = beginInclusive - bufStart;
          bufs.push(buf2.subarray(start2, start2 + (endExclusive - beginInclusive)));
          break;
        }
        if (sliceStartInBuf) {
          if (beginInclusive === 0) {
            bufs.push(buf2);
            continue;
          }
          bufs.push(buf2.subarray(beginInclusive - bufStart));
          continue;
        }
        if (sliceEndsInBuf) {
          if (endExclusive === bufEnd) {
            bufs.push(buf2);
            break;
          }
          bufs.push(buf2.subarray(0, endExclusive - bufStart));
          break;
        }
        bufs.push(buf2);
      }
      return { bufs, length: endExclusive - beginInclusive };
    }
    indexOf(search, offset = 0) {
      if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
        throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
      }
      const needle = search instanceof Uint8Array ? search : search.subarray();
      offset = Number(offset ?? 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const M = needle.byteLength;
      if (M === 0) {
        throw new TypeError("search must be at least 1 byte long");
      }
      const radix = 256;
      const rightmostPositions = new Int32Array(radix);
      for (let c2 = 0; c2 < radix; c2++) {
        rightmostPositions[c2] = -1;
      }
      for (let j = 0; j < M; j++) {
        rightmostPositions[needle[j]] = j;
      }
      const right = rightmostPositions;
      const lastIndex = this.byteLength - needle.byteLength;
      const lastPatIndex = needle.byteLength - 1;
      let skip;
      for (let i2 = offset; i2 <= lastIndex; i2 += skip) {
        skip = 0;
        for (let j = lastPatIndex; j >= 0; j--) {
          const char = this.get(i2 + j);
          if (needle[j] !== char) {
            skip = Math.max(1, j - right[char]);
            break;
          }
        }
        if (skip === 0) {
          return i2;
        }
      }
      return -1;
    }
    getInt8(byteOffset) {
      const buf2 = this.subarray(byteOffset, byteOffset + 1);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getInt8(0);
    }
    setInt8(byteOffset, value2) {
      const buf2 = allocUnsafe(1);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setInt8(0, value2);
      this.write(buf2, byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
      const buf2 = this.subarray(byteOffset, byteOffset + 2);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getInt16(0, littleEndian);
    }
    setInt16(byteOffset, value2, littleEndian) {
      const buf2 = alloc(2);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setInt16(0, value2, littleEndian);
      this.write(buf2, byteOffset);
    }
    getInt32(byteOffset, littleEndian) {
      const buf2 = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getInt32(0, littleEndian);
    }
    setInt32(byteOffset, value2, littleEndian) {
      const buf2 = alloc(4);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setInt32(0, value2, littleEndian);
      this.write(buf2, byteOffset);
    }
    getBigInt64(byteOffset, littleEndian) {
      const buf2 = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getBigInt64(0, littleEndian);
    }
    setBigInt64(byteOffset, value2, littleEndian) {
      const buf2 = alloc(8);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setBigInt64(0, value2, littleEndian);
      this.write(buf2, byteOffset);
    }
    getUint8(byteOffset) {
      const buf2 = this.subarray(byteOffset, byteOffset + 1);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getUint8(0);
    }
    setUint8(byteOffset, value2) {
      const buf2 = allocUnsafe(1);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setUint8(0, value2);
      this.write(buf2, byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
      const buf2 = this.subarray(byteOffset, byteOffset + 2);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getUint16(0, littleEndian);
    }
    setUint16(byteOffset, value2, littleEndian) {
      const buf2 = alloc(2);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setUint16(0, value2, littleEndian);
      this.write(buf2, byteOffset);
    }
    getUint32(byteOffset, littleEndian) {
      const buf2 = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getUint32(0, littleEndian);
    }
    setUint32(byteOffset, value2, littleEndian) {
      const buf2 = alloc(4);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setUint32(0, value2, littleEndian);
      this.write(buf2, byteOffset);
    }
    getBigUint64(byteOffset, littleEndian) {
      const buf2 = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getBigUint64(0, littleEndian);
    }
    setBigUint64(byteOffset, value2, littleEndian) {
      const buf2 = alloc(8);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setBigUint64(0, value2, littleEndian);
      this.write(buf2, byteOffset);
    }
    getFloat32(byteOffset, littleEndian) {
      const buf2 = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getFloat32(0, littleEndian);
    }
    setFloat32(byteOffset, value2, littleEndian) {
      const buf2 = alloc(4);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setFloat32(0, value2, littleEndian);
      this.write(buf2, byteOffset);
    }
    getFloat64(byteOffset, littleEndian) {
      const buf2 = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      return view.getFloat64(0, littleEndian);
    }
    setFloat64(byteOffset, value2, littleEndian) {
      const buf2 = alloc(8);
      const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      view.setFloat64(0, value2, littleEndian);
      this.write(buf2, byteOffset);
    }
    equals(other) {
      if (other == null) {
        return false;
      }
      if (!(other instanceof _Uint8ArrayList)) {
        return false;
      }
      if (other.bufs.length !== this.bufs.length) {
        return false;
      }
      for (let i2 = 0; i2 < this.bufs.length; i2++) {
        if (!equals3(this.bufs[i2], other.bufs[i2])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
     * method if you know the total size of all the Uint8Arrays ahead of time.
     */
    static fromUint8Arrays(bufs, length4) {
      const list = new _Uint8ArrayList();
      list.bufs = bufs;
      if (length4 == null) {
        length4 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
      }
      list.length = length4;
      return list;
    }
  };

  // node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports = {};
  __export(base10_exports, {
    base10: () => base10
  });
  var base10 = baseX({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports = {};
  __export(base16_exports, {
    base16: () => base16,
    base16upper: () => base16upper
  });
  var base16 = rfc4648({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper = rfc4648({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports = {};
  __export(base2_exports, {
    base2: () => base2
  });
  var base2 = rfc4648({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports = {};
  __export(base256emoji_exports, {
    base256emoji: () => base256emoji
  });
  var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
    p2[i2] = c2;
    return p2;
  }, []);
  var alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
    const codePoint = c2.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c2}`);
    }
    p2[codePoint] = i2;
    return p2;
  }, []);
  function encode4(data) {
    return data.reduce((p2, c2) => {
      p2 += alphabetBytesToChars[c2];
      return p2;
    }, "");
  }
  function decode5(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji = from({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode4,
    decode: decode5
  });

  // node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports = {};
  __export(base64_exports, {
    base64: () => base64,
    base64pad: () => base64pad,
    base64url: () => base64url,
    base64urlpad: () => base64urlpad
  });
  var base64 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports = {};
  __export(base8_exports, {
    base8: () => base8
  });
  var base8 = rfc4648({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports2 = {};
  __export(identity_exports2, {
    identity: () => identity2
  });
  var identity2 = from({
    prefix: "\0",
    name: "identity",
    encode: (buf2) => toString(buf2),
    decode: (str) => fromString(str)
  });

  // node_modules/multiformats/dist/src/codecs/json.js
  var json_exports = {};
  __export(json_exports, {
    code: () => code2,
    decode: () => decode6,
    encode: () => encode5,
    name: () => name2
  });
  var textEncoder = new TextEncoder();
  var textDecoder = new TextDecoder();
  var name2 = "json";
  var code2 = 512;
  function encode5(node) {
    return textEncoder.encode(JSON.stringify(node));
  }
  function decode6(data) {
    return JSON.parse(textDecoder.decode(data));
  }

  // node_modules/multiformats/dist/src/codecs/raw.js
  var raw_exports = {};
  __export(raw_exports, {
    code: () => code3,
    decode: () => decode7,
    encode: () => encode6,
    name: () => name3
  });
  var name3 = "raw";
  var code3 = 85;
  function encode6(node) {
    return coerce(node);
  }
  function decode7(data) {
    return coerce(data);
  }

  // node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports = {};
  __export(sha2_browser_exports, {
    sha256: () => sha256,
    sha512: () => sha512
  });

  // node_modules/multiformats/dist/src/hashes/hasher.js
  var DEFAULT_MIN_DIGEST_LENGTH = 20;
  function from2({ name: name9, code: code8, encode: encode17, minDigestLength, maxDigestLength }) {
    return new Hasher(name9, code8, encode17, minDigestLength, maxDigestLength);
  }
  var Hasher = class {
    name;
    code;
    encode;
    minDigestLength;
    maxDigestLength;
    constructor(name9, code8, encode17, minDigestLength, maxDigestLength) {
      this.name = name9;
      this.code = code8;
      this.encode = encode17;
      this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
      this.maxDigestLength = maxDigestLength;
    }
    digest(input, options2) {
      if (options2?.truncate != null) {
        if (options2.truncate < this.minDigestLength) {
          throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
        }
        if (this.maxDigestLength != null && options2.truncate > this.maxDigestLength) {
          throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
        }
      }
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        if (result instanceof Uint8Array) {
          return createDigest(result, this.code, options2?.truncate);
        }
        return result.then((digest2) => createDigest(digest2, this.code, options2?.truncate));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  function createDigest(digest2, code8, truncate) {
    if (truncate != null && truncate !== digest2.byteLength) {
      if (truncate > digest2.byteLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${digest2.byteLength}`);
      }
      digest2 = digest2.subarray(0, truncate);
    }
    return create(code8, digest2);
  }

  // node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha(name9) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
  }
  var sha256 = from2({
    name: "sha2-256",
    code: 18,
    encode: sha("SHA-256")
  });
  var sha512 = from2({
    name: "sha2-512",
    code: 19,
    encode: sha("SHA-512")
  });

  // node_modules/multiformats/dist/src/basics.js
  var bases = { ...identity_exports2, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
  var hashes = { ...sha2_browser_exports, ...identity_exports };

  // node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec(name9, prefix, encode17, decode16) {
    return {
      name: name9,
      prefix,
      encoder: {
        name: name9,
        prefix,
        encode: encode17
      },
      decoder: {
        decode: decode16
      }
    };
  }
  var string = createCodec("utf8", "u", (buf2) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf2);
  }, (str) => {
    const encoder2 = new TextEncoder();
    return encoder2.encode(str.substring(1));
  });
  var ascii = createCodec("ascii", "a", (buf2) => {
    let string2 = "a";
    for (let i2 = 0; i2 < buf2.length; i2++) {
      string2 += String.fromCharCode(buf2[i2]);
    }
    return string2;
  }, (str) => {
    str = str.substring(1);
    const buf2 = allocUnsafe(str.length);
    for (let i2 = 0; i2 < str.length; i2++) {
      buf2[i2] = str.charCodeAt(i2);
    }
    return buf2;
  });
  var BASES = {
    utf8: string,
    "utf-8": string,
    hex: bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases
  };
  var bases_default = BASES;

  // node_modules/uint8arrays/dist/src/from-string.js
  function fromString2(string2, encoding = "utf8") {
    const base3 = bases_default[encoding];
    if (base3 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.decoder.decode(`${base3.prefix}${string2}`);
  }

  // node_modules/uint8arrays/dist/src/to-string.js
  function toString2(array, encoding = "utf8") {
    const base3 = bases_default[encoding];
    if (base3 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.encoder.encode(array).substring(1);
  }

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
  var TAG_MASK = parseInt("11111", 2);
  var LONG_LENGTH_MASK = parseInt("10000000", 2);
  var LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
  var decoders = {
    0: readSequence,
    1: readSequence,
    2: readInteger,
    3: readBitString,
    4: readOctetString,
    5: readNull,
    6: readObjectIdentifier,
    16: readSequence,
    22: readSequence,
    48: readSequence
  };
  function decodeDer(buf2, context = { offset: 0 }) {
    const tag = buf2[context.offset] & TAG_MASK;
    context.offset++;
    if (decoders[tag] != null) {
      return decoders[tag](buf2, context);
    }
    throw new Error("No decoder for tag " + tag);
  }
  function readLength(buf2, context) {
    let length4 = 0;
    if ((buf2[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
      const count = buf2[context.offset] & LONG_LENGTH_BYTES_MASK;
      let str = "0x";
      context.offset++;
      for (let i2 = 0; i2 < count; i2++, context.offset++) {
        str += buf2[context.offset].toString(16).padStart(2, "0");
      }
      length4 = parseInt(str, 16);
    } else {
      length4 = buf2[context.offset];
      context.offset++;
    }
    return length4;
  }
  function readSequence(buf2, context) {
    readLength(buf2, context);
    const entries = [];
    while (true) {
      if (context.offset >= buf2.byteLength) {
        break;
      }
      const result = decodeDer(buf2, context);
      if (result === null) {
        break;
      }
      entries.push(result);
    }
    return entries;
  }
  function readInteger(buf2, context) {
    const length4 = readLength(buf2, context);
    const start2 = context.offset;
    const end = context.offset + length4;
    const vals = [];
    for (let i2 = start2; i2 < end; i2++) {
      if (i2 === start2 && buf2[i2] === 0) {
        continue;
      }
      vals.push(buf2[i2]);
    }
    context.offset += length4;
    return Uint8Array.from(vals);
  }
  function readObjectIdentifier(buf2, context) {
    const count = readLength(buf2, context);
    const finalOffset = context.offset + count;
    const byte = buf2[context.offset];
    context.offset++;
    let val1 = 0;
    let val2 = 0;
    if (byte < 40) {
      val1 = 0;
      val2 = byte;
    } else if (byte < 80) {
      val1 = 1;
      val2 = byte - 40;
    } else {
      val1 = 2;
      val2 = byte - 80;
    }
    let oid = `${val1}.${val2}`;
    let num = [];
    while (context.offset < finalOffset) {
      const byte2 = buf2[context.offset];
      context.offset++;
      num.push(byte2 & 127);
      if (byte2 < 128) {
        num.reverse();
        let val = 0;
        for (let i2 = 0; i2 < num.length; i2++) {
          val += num[i2] << i2 * 7;
        }
        oid += `.${val}`;
        num = [];
      }
    }
    return oid;
  }
  function readNull(buf2, context) {
    context.offset++;
    return null;
  }
  function readBitString(buf2, context) {
    const length4 = readLength(buf2, context);
    const unusedBits = buf2[context.offset];
    context.offset++;
    const bytes = buf2.subarray(context.offset, context.offset + length4 - 1);
    context.offset += length4;
    if (unusedBits !== 0) {
      throw new Error("Unused bits in bit string is unimplemented");
    }
    return bytes;
  }
  function readOctetString(buf2, context) {
    const length4 = readLength(buf2, context);
    const bytes = buf2.subarray(context.offset, context.offset + length4);
    context.offset += length4;
    return bytes;
  }
  function encodeNumber(value2) {
    let number = value2.toString(16);
    if (number.length % 2 === 1) {
      number = "0" + number;
    }
    const array = new Uint8ArrayList();
    for (let i2 = 0; i2 < number.length; i2 += 2) {
      array.append(Uint8Array.from([parseInt(`${number[i2]}${number[i2 + 1]}`, 16)]));
    }
    return array;
  }
  function encodeLength(bytes) {
    if (bytes.byteLength < 128) {
      return Uint8Array.from([bytes.byteLength]);
    }
    const length4 = encodeNumber(bytes.byteLength);
    return new Uint8ArrayList(Uint8Array.from([
      length4.byteLength | LONG_LENGTH_MASK
    ]), length4);
  }
  function encodeInteger(value2) {
    const contents = new Uint8ArrayList();
    const mask = 128;
    const positive2 = (value2.subarray()[0] & mask) === mask;
    if (positive2) {
      contents.append(Uint8Array.from([0]));
    }
    contents.append(value2);
    return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
  }
  function encodeBitString(value2) {
    const unusedBits = Uint8Array.from([0]);
    const contents = new Uint8ArrayList(unusedBits, value2);
    return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
  }
  function encodeOctetString(value2) {
    return new Uint8ArrayList(Uint8Array.from([4]), encodeLength(value2), value2);
  }
  function encodeSequence(values, tag = 48) {
    const output = new Uint8ArrayList();
    for (const buf2 of values) {
      output.append(buf2);
    }
    return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength(output), output);
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
  var ECDSA_P_256_OID = "1.2.840.10045.3.1.7";
  var ECDSA_P_384_OID = "1.3.132.0.34";
  var ECDSA_P_521_OID = "1.3.132.0.35";
  async function generateECDSAKey(curve = "P-256") {
    const keyPair = await crypto.subtle.generateKey({
      name: "ECDSA",
      namedCurve: curve
    }, true, ["sign", "verify"]);
    return {
      publicKey: await crypto.subtle.exportKey("jwk", keyPair.publicKey),
      privateKey: await crypto.subtle.exportKey("jwk", keyPair.privateKey)
    };
  }
  async function hashAndSign(key, msg, options2) {
    const privateKey = await crypto.subtle.importKey("jwk", key, {
      name: "ECDSA",
      namedCurve: key.crv ?? "P-256"
    }, false, ["sign"]);
    options2?.signal?.throwIfAborted();
    const signature = await crypto.subtle.sign({
      name: "ECDSA",
      hash: {
        name: "SHA-256"
      }
    }, privateKey, msg.subarray());
    options2?.signal?.throwIfAborted();
    return new Uint8Array(signature, 0, signature.byteLength);
  }
  async function hashAndVerify(key, sig, msg, options2) {
    const publicKey2 = await crypto.subtle.importKey("jwk", key, {
      name: "ECDSA",
      namedCurve: key.crv ?? "P-256"
    }, false, ["verify"]);
    options2?.signal?.throwIfAborted();
    const result = await crypto.subtle.verify({
      name: "ECDSA",
      hash: {
        name: "SHA-256"
      }
    }, publicKey2, sig, msg.subarray());
    options2?.signal?.throwIfAborted();
    return result;
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
  var OID_256 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
  var OID_384 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
  var OID_521 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
  var P_256_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-256"
  };
  var P_384_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-384"
  };
  var P_521_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-521"
  };
  var P_256_KEY_LENGTH = 32;
  var P_384_KEY_LENGTH = 48;
  var P_521_KEY_LENGTH = 66;
  function unmarshalECDSAPrivateKey(bytes) {
    const message2 = decodeDer(bytes);
    return pkiMessageToECDSAPrivateKey(message2);
  }
  function pkiMessageToECDSAPrivateKey(message2) {
    const privateKey = message2[1];
    const d2 = toString2(privateKey, "base64url");
    const coordinates = message2[2][1][0];
    const offset = 1;
    let x;
    let y;
    if (privateKey.byteLength === P_256_KEY_LENGTH) {
      x = toString2(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
      y = toString2(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
      return new ECDSAPrivateKey({
        ...P_256_KEY_JWK,
        key_ops: ["sign"],
        d: d2,
        x,
        y
      });
    }
    if (privateKey.byteLength === P_384_KEY_LENGTH) {
      x = toString2(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
      y = toString2(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
      return new ECDSAPrivateKey({
        ...P_384_KEY_JWK,
        key_ops: ["sign"],
        d: d2,
        x,
        y
      });
    }
    if (privateKey.byteLength === P_521_KEY_LENGTH) {
      x = toString2(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
      y = toString2(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
      return new ECDSAPrivateKey({
        ...P_521_KEY_JWK,
        key_ops: ["sign"],
        d: d2,
        x,
        y
      });
    }
    throw new InvalidParametersError(`Private key length was wrong length, got ${privateKey.byteLength}, expected 32, 48 or 66`);
  }
  function unmarshalECDSAPublicKey(bytes) {
    const message2 = decodeDer(bytes);
    return pkiMessageToECDSAPublicKey(message2);
  }
  function pkiMessageToECDSAPublicKey(message2) {
    const coordinates = message2[1][1][0];
    const offset = 1;
    let x;
    let y;
    if (coordinates.byteLength === P_256_KEY_LENGTH * 2 + 1) {
      x = toString2(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
      y = toString2(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_256_KEY_JWK,
        key_ops: ["verify"],
        x,
        y
      });
    }
    if (coordinates.byteLength === P_384_KEY_LENGTH * 2 + 1) {
      x = toString2(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
      y = toString2(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_384_KEY_JWK,
        key_ops: ["verify"],
        x,
        y
      });
    }
    if (coordinates.byteLength === P_521_KEY_LENGTH * 2 + 1) {
      x = toString2(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
      y = toString2(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_521_KEY_JWK,
        key_ops: ["verify"],
        x,
        y
      });
    }
    throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
  }
  function privateKeyToPKIMessage(privateKey) {
    return encodeSequence([
      encodeInteger(Uint8Array.from([1])),
      // header
      encodeOctetString(fromString2(privateKey.d ?? "", "base64url")),
      // body
      encodeSequence([
        getOID(privateKey.crv)
      ], 160),
      encodeSequence([
        encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString2(privateKey.x ?? "", "base64url"), fromString2(privateKey.y ?? "", "base64url")))
      ], 161)
    ]).subarray();
  }
  function publicKeyToPKIMessage(publicKey2) {
    return encodeSequence([
      encodeInteger(Uint8Array.from([1])),
      // header
      encodeSequence([
        getOID(publicKey2.crv)
      ], 160),
      encodeSequence([
        encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString2(publicKey2.x ?? "", "base64url"), fromString2(publicKey2.y ?? "", "base64url")))
      ], 161)
    ]).subarray();
  }
  function getOID(curve) {
    if (curve === "P-256") {
      return OID_256;
    }
    if (curve === "P-384") {
      return OID_384;
    }
    if (curve === "P-521") {
      return OID_521;
    }
    throw new InvalidParametersError(`Invalid curve ${curve}`);
  }
  async function generateECDSAKeyPair(curve = "P-256") {
    const key = await generateECDSAKey(curve);
    return new ECDSAPrivateKey(key.privateKey);
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
  var ECDSAPublicKey = class {
    type = "ECDSA";
    jwk;
    _raw;
    constructor(jwk) {
      this.jwk = jwk;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = publicKeyToPKIMessage(this.jwk);
      }
      return this._raw;
    }
    toMultihash() {
      return identity.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    async verify(data, sig, options2) {
      return hashAndVerify(this.jwk, sig, data, options2);
    }
  };
  var ECDSAPrivateKey = class {
    type = "ECDSA";
    jwk;
    publicKey;
    _raw;
    constructor(jwk) {
      this.jwk = jwk;
      this.publicKey = new ECDSAPublicKey({
        crv: jwk.crv,
        ext: jwk.ext,
        key_ops: ["verify"],
        kty: "EC",
        x: jwk.x,
        y: jwk.y
      });
    }
    get raw() {
      if (this._raw == null) {
        this._raw = privateKeyToPKIMessage(this.jwk);
      }
      return this._raw;
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    async sign(message2, options2) {
      return hashAndSign(this.jwk, message2, options2);
    }
  };

  // node_modules/@noble/hashes/utils.js
  function isBytes(a2) {
    return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
  }
  function anumber(n2, title = "") {
    if (!Number.isSafeInteger(n2) || n2 < 0) {
      const prefix = title && `"${title}" `;
      throw new Error(`${prefix}expected integer >= 0, got ${n2}`);
    }
  }
  function abytes(value2, length4, title = "") {
    const bytes = isBytes(value2);
    const len = value2?.length;
    const needsLen = length4 !== void 0;
    if (!bytes || needsLen && len !== length4) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length4}` : "";
      const got = bytes ? `length=${len}` : `type=${typeof value2}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value2;
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash must wrapped by utils.createHasher");
    anumber(h.outputLen);
    anumber(h.blockLen);
  }
  function aexists(instance2, checkFinished = true) {
    if (instance2.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance2.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance2) {
    abytes(out, void 0, "digestInto() output");
    const min = instance2.outputLen;
    if (out.length < min) {
      throw new Error('"digestInto() output" expected to be of length >=' + min);
    }
  }
  function clean(...arrays) {
    for (let i2 = 0; i2 < arrays.length; i2++) {
      arrays[i2].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word2, shift) {
    return word2 << 32 - shift | word2 >>> shift;
  }
  function rotl(word2, shift) {
    return word2 << shift | word2 >>> 32 - shift >>> 0;
  }
  var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
  function bytesToHex(bytes) {
    abytes(bytes);
    if (hasHexBuiltin)
      return bytes.toHex();
    let hex = "";
    for (let i2 = 0; i2 < bytes.length; i2++) {
      hex += hexes[bytes[i2]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  var nextTick = async () => {
  };
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i2 = 0; i2 < iters; i2++) {
      cb(i2);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await nextTick();
      ts += diff;
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function kdfInputToBytes(data, errorTitle = "") {
    if (typeof data === "string")
      return utf8ToBytes(data);
    return abytes(data, void 0, errorTitle);
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i2 = 0; i2 < arrays.length; i2++) {
      const a2 = arrays[i2];
      abytes(a2);
      sum += a2.length;
    }
    const res = new Uint8Array(sum);
    for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
      const a2 = arrays[i2];
      res.set(a2, pad);
      pad += a2.length;
    }
    return res;
  }
  function checkOpts(defaults2, opts) {
    if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
      throw new Error("options must be object or undefined");
    const merged = Object.assign(defaults2, opts);
    return merged;
  }
  function createHasher(hashCons, info = {}) {
    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
    const tmp = hashCons(void 0);
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    Object.assign(hashC, info);
    return Object.freeze(hashC);
  }
  function randomBytes(bytesLength = 32) {
    const cr = typeof globalThis === "object" ? globalThis.crypto : null;
    if (typeof cr?.getRandomValues !== "function")
      throw new Error("crypto.getRandomValues must be defined");
    return cr.getRandomValues(new Uint8Array(bytesLength));
  }
  var oidNist = (suffix) => ({
    oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
  });

  // node_modules/@noble/hashes/_md.js
  function Chi(a2, b, c2) {
    return a2 & b ^ ~a2 & c2;
  }
  function Maj(a2, b, c2) {
    return a2 & b ^ a2 & c2 ^ b & c2;
  }
  var HashMD = class {
    blockLen;
    outputLen;
    padOffset;
    isLE;
    // For partial updates less than block size
    buffer;
    view;
    finished = false;
    length = 0;
    pos = 0;
    destroyed = false;
    constructor(blockLen, outputLen, padOffset, isLE2) {
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      abytes(data);
      const { view, buffer: buffer2, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          const dataView2 = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView2, pos);
          continue;
        }
        buffer2.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer2[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i2 = pos; i2 < blockLen; i2++)
        buffer2[i2] = 0;
      view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen must be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i2 = 0; i2 < outLen; i2++)
        oview.setUint32(4 * i2, state[i2], isLE2);
    }
    digest() {
      const { buffer: buffer2, outputLen } = this;
      this.digestInto(buffer2);
      const res = buffer2.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to ||= new this.constructor();
      to.set(...this.get());
      const { blockLen, buffer: buffer2, length: length4, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length4;
      to.pos = pos;
      if (length4 % blockLen)
        to.buffer.set(buffer2);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);

  // node_modules/@noble/hashes/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n2, le = false) {
    if (le)
      return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
    return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i2 = 0; i2 < len; i2++) {
      const { h, l: l2 } = fromBig(lst[i2], le);
      [Ah[i2], Al[i2]] = [h, l2];
    }
    return [Ah, Al];
  }
  var shrSH = (h, _l, s2) => h >>> s2;
  var shrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
  var rotrSH = (h, l2, s2) => h >>> s2 | l2 << 32 - s2;
  var rotrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
  var rotrBH = (h, l2, s2) => h << 64 - s2 | l2 >>> s2 - 32;
  var rotrBL = (h, l2, s2) => h >>> s2 - 32 | l2 << 64 - s2;
  function add(Ah, Al, Bh, Bl2) {
    const l2 = (Al >>> 0) + (Bl2 >>> 0);
    return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
  }
  var add3L = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

  // node_modules/@noble/hashes/sha2.js
  var SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA2_32B = class extends HashMD {
    constructor(outputLen) {
      super(64, outputLen, 8, false);
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4)
        SHA256_W[i2] = view.getUint32(offset, false);
      for (let i2 = 16; i2 < 64; i2++) {
        const W15 = SHA256_W[i2 - 15];
        const W2 = SHA256_W[i2 - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i2 = 0; i2 < 64; i2++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var _SHA256 = class extends SHA2_32B {
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    A = SHA256_IV[0] | 0;
    B = SHA256_IV[1] | 0;
    C = SHA256_IV[2] | 0;
    D = SHA256_IV[3] | 0;
    E = SHA256_IV[4] | 0;
    F = SHA256_IV[5] | 0;
    G = SHA256_IV[6] | 0;
    H = SHA256_IV[7] | 0;
    constructor() {
      super(32);
    }
  };
  var K512 = /* @__PURE__ */ (() => split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n2) => BigInt(n2))))();
  var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA2_64B = class extends HashMD {
    constructor(outputLen) {
      super(128, outputLen, 16, false);
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl2 | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4) {
        SHA512_W_H[i2] = view.getUint32(offset);
        SHA512_W_L[i2] = view.getUint32(offset += 4);
      }
      for (let i2 = 16; i2 < 80; i2++) {
        const W15h = SHA512_W_H[i2 - 15] | 0;
        const W15l = SHA512_W_L[i2 - 15] | 0;
        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i2 - 2] | 0;
        const W2l = SHA512_W_L[i2 - 2] | 0;
        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
        const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
        SHA512_W_H[i2] = SUMh | 0;
        SHA512_W_L[i2] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i2 = 0; i2 < 80; i2++) {
        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl2 ^ Al & Cl ^ Bl2 & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl2 | 0;
        Bh = Ah | 0;
        Bl2 = Al | 0;
        const All = add3L(T1l, sigma0l, MAJl);
        Ah = add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl2 } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var _SHA512 = class extends SHA2_64B {
    Ah = SHA512_IV[0] | 0;
    Al = SHA512_IV[1] | 0;
    Bh = SHA512_IV[2] | 0;
    Bl = SHA512_IV[3] | 0;
    Ch = SHA512_IV[4] | 0;
    Cl = SHA512_IV[5] | 0;
    Dh = SHA512_IV[6] | 0;
    Dl = SHA512_IV[7] | 0;
    Eh = SHA512_IV[8] | 0;
    El = SHA512_IV[9] | 0;
    Fh = SHA512_IV[10] | 0;
    Fl = SHA512_IV[11] | 0;
    Gh = SHA512_IV[12] | 0;
    Gl = SHA512_IV[13] | 0;
    Hh = SHA512_IV[14] | 0;
    Hl = SHA512_IV[15] | 0;
    constructor() {
      super(64);
    }
  };
  var sha2562 = /* @__PURE__ */ createHasher(
    () => new _SHA256(),
    /* @__PURE__ */ oidNist(1)
  );
  var sha5122 = /* @__PURE__ */ createHasher(
    () => new _SHA512(),
    /* @__PURE__ */ oidNist(3)
  );

  // node_modules/@noble/curves/utils.js
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  function abool(value2, title = "") {
    if (typeof value2 !== "boolean") {
      const prefix = title && `"${title}" `;
      throw new Error(prefix + "expected boolean, got type=" + typeof value2);
    }
    return value2;
  }
  function abignumber(n2) {
    if (typeof n2 === "bigint") {
      if (!isPosBig(n2))
        throw new Error("positive bigint expected, got " + n2);
    } else
      anumber(n2);
    return n2;
  }
  function numberToHexUnpadded(num) {
    const hex = abignumber(num).toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n : BigInt("0x" + hex);
  }
  function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
  }
  function bytesToNumberLE(bytes) {
    return hexToNumber(bytesToHex(copyBytes(abytes(bytes)).reverse()));
  }
  function numberToBytesBE(n2, len) {
    anumber(len);
    n2 = abignumber(n2);
    const res = hexToBytes(n2.toString(16).padStart(len * 2, "0"));
    if (res.length !== len)
      throw new Error("number too large");
    return res;
  }
  function numberToBytesLE(n2, len) {
    return numberToBytesBE(n2, len).reverse();
  }
  function copyBytes(bytes) {
    return Uint8Array.from(bytes);
  }
  var isPosBig = (n2) => typeof n2 === "bigint" && _0n <= n2;
  function inRange(n2, min, max2) {
    return isPosBig(n2) && isPosBig(min) && isPosBig(max2) && min <= n2 && n2 < max2;
  }
  function aInRange(title, n2, min, max2) {
    if (!inRange(n2, min, max2))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max2 + ", got " + n2);
  }
  function bitLen(n2) {
    let len;
    for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
      ;
    return len;
  }
  var bitMask = (n2) => (_1n << BigInt(n2)) - _1n;
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    anumber(hashLen, "hashLen");
    anumber(qByteLen, "qByteLen");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n = (len) => new Uint8Array(len);
    const NULL = Uint8Array.of();
    const byte0 = Uint8Array.of(0);
    const byte1 = Uint8Array.of(1);
    const _maxDrbgIters = 1e3;
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i2 = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i2 = 0;
    };
    const h = (...msgs) => hmacFn(k, concatBytes(v, ...msgs));
    const reseed = (seed = NULL) => {
      k = h(byte0, seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(byte1, seed);
      v = h();
    };
    const gen = () => {
      if (i2++ >= _maxDrbgIters)
        throw new Error("drbg: tried max amount of iterations");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function validateObject(object, fields = {}, optFields = {}) {
    if (!object || typeof object !== "object")
      throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    const iter = (f2, isOpt) => Object.entries(f2).forEach(([k, v]) => checkField(k, v, isOpt));
    iter(fields, false);
    iter(optFields, true);
  }
  function memoized(fn) {
    const map2 = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map2.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map2.set(arg, computed);
      return computed;
    };
  }

  // node_modules/@noble/curves/abstract/modular.js
  var _0n2 = /* @__PURE__ */ BigInt(0);
  var _1n2 = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _3n = /* @__PURE__ */ BigInt(3);
  var _4n = /* @__PURE__ */ BigInt(4);
  var _5n = /* @__PURE__ */ BigInt(5);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _8n = /* @__PURE__ */ BigInt(8);
  var _9n = /* @__PURE__ */ BigInt(9);
  var _16n = /* @__PURE__ */ BigInt(16);
  function mod(a2, b) {
    const result = a2 % b;
    return result >= _0n2 ? result : b + result;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number, modulo) {
    if (number === _0n2)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n2)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a2 = mod(number, modulo);
    let b = modulo;
    let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
    while (a2 !== _0n2) {
      const q = b / a2;
      const r2 = b % a2;
      const m2 = x - u * q;
      const n2 = y - v * q;
      b = a2, a2 = r2, x = u, y = v, u = m2, v = n2;
    }
    const gcd = b;
    if (gcd !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function assertIsSquare(Fp, root, n2) {
    if (!Fp.eql(Fp.sqr(root), n2))
      throw new Error("Cannot find square root");
  }
  function sqrt3mod4(Fp, n2) {
    const p1div4 = (Fp.ORDER + _1n2) / _4n;
    const root = Fp.pow(n2, p1div4);
    assertIsSquare(Fp, root, n2);
    return root;
  }
  function sqrt5mod8(Fp, n2) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n22 = Fp.mul(n2, _2n);
    const v = Fp.pow(n22, p5div8);
    const nv = Fp.mul(n2, v);
    const i2 = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i2, Fp.ONE));
    assertIsSquare(Fp, root, n2);
    return root;
  }
  function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
    const c2 = tn(Fp_, c1);
    const c3 = tn(Fp_, Fp_.neg(c1));
    const c4 = (P + _7n) / _16n;
    return (Fp, n2) => {
      let tv1 = Fp.pow(n2, c4);
      let tv2 = Fp.mul(tv1, c1);
      const tv3 = Fp.mul(tv1, c2);
      const tv4 = Fp.mul(tv1, c3);
      const e1 = Fp.eql(Fp.sqr(tv2), n2);
      const e2 = Fp.eql(Fp.sqr(tv3), n2);
      tv1 = Fp.cmov(tv1, tv2, e1);
      tv2 = Fp.cmov(tv4, tv3, e2);
      const e3 = Fp.eql(Fp.sqr(tv2), n2);
      const root = Fp.cmov(tv1, tv2, e3);
      assertIsSquare(Fp, root, n2);
      return root;
    };
  }
  function tonelliShanks(P) {
    if (P < _3n)
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n2;
    let S = 0;
    while (Q % _2n === _0n2) {
      Q /= _2n;
      S++;
    }
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1)
      return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n2) / _2n;
    return function tonelliSlow(Fp, n2) {
      if (Fp.is0(n2))
        return n2;
      if (FpLegendre(Fp, n2) !== 1)
        throw new Error("Cannot find square root");
      let M = S;
      let c2 = Fp.mul(Fp.ONE, cc);
      let t2 = Fp.pow(n2, Q);
      let R = Fp.pow(n2, Q1div2);
      while (!Fp.eql(t2, Fp.ONE)) {
        if (Fp.is0(t2))
          return Fp.ZERO;
        let i2 = 1;
        let t_tmp = Fp.sqr(t2);
        while (!Fp.eql(t_tmp, Fp.ONE)) {
          i2++;
          t_tmp = Fp.sqr(t_tmp);
          if (i2 === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n2 << BigInt(M - i2 - 1);
        const b = Fp.pow(c2, exponent);
        M = i2;
        c2 = Fp.sqr(b);
        t2 = Fp.mul(t2, c2);
        R = Fp.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n)
      return sqrt3mod4;
    if (P % _8n === _5n)
      return sqrt5mod8;
    if (P % _16n === _9n)
      return sqrt9mod16(P);
    return tonelliShanks(P);
  }
  var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS.reduce((map2, val) => {
      map2[val] = "function";
      return map2;
    }, initial);
    validateObject(field, opts);
    return field;
  }
  function FpPow(Fp, num, power) {
    if (power < _0n2)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n2)
      return Fp.ONE;
    if (power === _1n2)
      return num;
    let p2 = Fp.ONE;
    let d2 = num;
    while (power > _0n2) {
      if (power & _1n2)
        p2 = Fp.mul(p2, d2);
      d2 = Fp.sqr(d2);
      power >>= _1n2;
    }
    return p2;
  }
  function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num, i2) => {
      if (Fp.is0(num))
        return acc;
      inverted[i2] = acc;
      return Fp.mul(acc, num);
    }, Fp.ONE);
    const invertedAcc = Fp.inv(multipliedAcc);
    nums.reduceRight((acc, num, i2) => {
      if (Fp.is0(num))
        return acc;
      inverted[i2] = Fp.mul(acc, inverted[i2]);
      return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre(Fp, n2) {
    const p1mod2 = (Fp.ORDER - _1n2) / _2n;
    const powered = Fp.pow(n2, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero2 = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero2 && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero2 ? 0 : -1;
  }
  function nLength(n2, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  var _Field = class {
    ORDER;
    BITS;
    BYTES;
    isLE;
    ZERO = _0n2;
    ONE = _1n2;
    _lengths;
    _sqrt;
    // cached sqrt
    _mod;
    constructor(ORDER, opts = {}) {
      if (ORDER <= _0n2)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      this.isLE = false;
      if (opts != null && typeof opts === "object") {
        if (typeof opts.BITS === "number")
          _nbitLength = opts.BITS;
        if (typeof opts.sqrt === "function")
          this.sqrt = opts.sqrt;
        if (typeof opts.isLE === "boolean")
          this.isLE = opts.isLE;
        if (opts.allowedLengths)
          this._lengths = opts.allowedLengths?.slice();
        if (typeof opts.modFromBytes === "boolean")
          this._mod = opts.modFromBytes;
      }
      const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);
      if (nByteLength > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      this.ORDER = ORDER;
      this.BITS = nBitLength;
      this.BYTES = nByteLength;
      this._sqrt = void 0;
      Object.preventExtensions(this);
    }
    create(num) {
      return mod(num, this.ORDER);
    }
    isValid(num) {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < this.ORDER;
    }
    is0(num) {
      return num === _0n2;
    }
    // is valid and invertible
    isValidNot0(num) {
      return !this.is0(num) && this.isValid(num);
    }
    isOdd(num) {
      return (num & _1n2) === _1n2;
    }
    neg(num) {
      return mod(-num, this.ORDER);
    }
    eql(lhs, rhs) {
      return lhs === rhs;
    }
    sqr(num) {
      return mod(num * num, this.ORDER);
    }
    add(lhs, rhs) {
      return mod(lhs + rhs, this.ORDER);
    }
    sub(lhs, rhs) {
      return mod(lhs - rhs, this.ORDER);
    }
    mul(lhs, rhs) {
      return mod(lhs * rhs, this.ORDER);
    }
    pow(num, power) {
      return FpPow(this, num, power);
    }
    div(lhs, rhs) {
      return mod(lhs * invert(rhs, this.ORDER), this.ORDER);
    }
    // Same as above, but doesn't normalize
    sqrN(num) {
      return num * num;
    }
    addN(lhs, rhs) {
      return lhs + rhs;
    }
    subN(lhs, rhs) {
      return lhs - rhs;
    }
    mulN(lhs, rhs) {
      return lhs * rhs;
    }
    inv(num) {
      return invert(num, this.ORDER);
    }
    sqrt(num) {
      if (!this._sqrt)
        this._sqrt = FpSqrt(this.ORDER);
      return this._sqrt(this, num);
    }
    toBytes(num) {
      return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);
    }
    fromBytes(bytes, skipValidation = false) {
      abytes(bytes);
      const { _lengths: allowedLengths, BYTES, isLE: isLE2, ORDER, _mod: modFromBytes } = this;
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      if (modFromBytes)
        scalar = mod(scalar, ORDER);
      if (!skipValidation) {
        if (!this.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    }
    // TODO: we don't need it here, move out to separate fn
    invertBatch(lst) {
      return FpInvertBatch(this, lst);
    }
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov(a2, b, condition) {
      return condition ? b : a2;
    }
  };
  function Field(ORDER, opts = {}) {
    return new _Field(ORDER, opts);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length4 = getFieldBytesLength(fieldOrder);
    return length4 + Math.ceil(length4 / 2);
  }
  function mapHashToField(key, fieldOrder, isLE2 = false) {
    abytes(key);
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
    const reduced = mod(num, fieldOrder - _1n2) + _1n2;
    return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }

  // node_modules/@noble/curves/abstract/curve.js
  var _0n3 = /* @__PURE__ */ BigInt(0);
  var _1n3 = /* @__PURE__ */ BigInt(1);
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c2, points) {
    const invertedZs = FpInvertBatch(c2.Fp, points.map((p2) => p2.Z));
    return points.map((p2, i2) => c2.fromAffine(p2.toAffine(invertedZs[i2])));
  }
  function validateW(W, bits2) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits2)
      throw new Error("invalid window size, expected [1.." + bits2 + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask = bitMask(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask, maxNumber, shiftBy };
  }
  function calcOffsets(n2, window2, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n2 & mask);
    let nextN = n2 >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n3;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function assert0(n2) {
    if (n2 !== _0n3)
      throw new Error("invalid wNAF");
  }
  var wNAF = class {
    BASE;
    ZERO;
    Fn;
    bits;
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits2) {
      this.BASE = Point.BASE;
      this.ZERO = Point.ZERO;
      this.Fn = Point.Fn;
      this.bits = bits2;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n2, p2 = this.ZERO) {
      let d2 = elm;
      while (n2 > _0n3) {
        if (n2 & _1n3)
          p2 = p2.add(d2);
        d2 = d2.double();
        n2 >>= _1n3;
      }
      return p2;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
      const { windows, windowSize } = calcWOpts(W, this.bits);
      const points = [];
      let p2 = point;
      let base3 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p2;
        points.push(base3);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base3 = base3.add(p2);
          points.push(base3);
        }
        p2 = base3.double();
      }
      return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      if (!this.Fn.isValid(n2))
        throw new Error("invalid scalar");
      let p2 = this.ZERO;
      let f2 = this.BASE;
      const wo = calcWOpts(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p2 = p2.add(negateCt(isNeg, precomputes[offset]));
        }
      }
      assert0(n2);
      return { p: p2, f: f2 };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n2, acc = this.ZERO) {
      const wo = calcWOpts(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n2 === _0n3)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n2);
      return acc;
    }
    getPrecomputes(W, point, transform) {
      let comp = pointPrecomputes.get(point);
      if (!comp) {
        comp = this.precomputeWindow(point, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes.set(point, comp);
        }
      }
      return comp;
    }
    cached(point, scalar, transform) {
      const W = getW(point);
      return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
      const W = getW(point);
      if (W === 1)
        return this._unsafeLadder(point, scalar, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
      validateW(W, this.bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
    hasCache(elm) {
      return getW(elm) !== 1;
    }
  };
  function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while (k1 > _0n3 || k2 > _0n3) {
      if (k1 & _1n3)
        p1 = p1.add(acc);
      if (k2 & _1n3)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n3;
      k2 >>= _1n3;
    }
    return { p1, p2 };
  }
  function createField(order, field, isLE2) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      validateField(field);
      return field;
    } else {
      return Field(order, { isLE: isLE2 });
    }
  }
  function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === void 0)
      FpFnLE = type === "edwards";
    if (!CURVE || typeof CURVE !== "object")
      throw new Error(`expected valid ${type} CURVE object`);
    for (const p2 of ["p", "n", "h"]) {
      const val = CURVE[p2];
      if (!(typeof val === "bigint" && val > _0n3))
        throw new Error(`CURVE.${p2} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b2 = type === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b2];
    for (const p2 of params) {
      if (!Fp.isValid(CURVE[p2]))
        throw new Error(`CURVE.${p2} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp, Fn };
  }
  function createKeygen(randomSecretKey, getPublicKey) {
    return function keygen(seed) {
      const secretKey = randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey(secretKey) };
    };
  }

  // node_modules/@noble/curves/abstract/edwards.js
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var _2n2 = BigInt(2);
  var _8n2 = BigInt(8);
  function isEdValidXY(Fp, CURVE, x, y) {
    const x2 = Fp.sqr(x);
    const y2 = Fp.sqr(y);
    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
    return Fp.eql(left, right);
  }
  function edwards(params, extraOpts = {}) {
    const validated = createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor } = CURVE;
    validateObject(extraOpts, {}, { uvRatio: "function" });
    const MASK2 = _2n2 << BigInt(Fn.BYTES * 8) - _1n4;
    const modP = (n2) => Fp.create(n2);
    const uvRatio2 = extraOpts.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
      } catch (e2) {
        return { isValid: false, value: _0n4 };
      }
    });
    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    function acoord(title, n2, banZero = false) {
      const min = banZero ? _1n4 : _0n4;
      aInRange("coordinate " + title, n2, min, MASK2);
      return n2;
    }
    function aedpoint(other) {
      if (!(other instanceof Point))
        throw new Error("EdwardsPoint expected");
    }
    const toAffineMemo = memoized((p2, iz) => {
      const { X, Y, Z } = p2;
      const is0 = p2.is0();
      if (iz == null)
        iz = is0 ? _8n2 : Fp.inv(Z);
      const x = modP(X * iz);
      const y = modP(Y * iz);
      const zz = Fp.mul(Z, iz);
      if (is0)
        return { x: _0n4, y: _1n4 };
      if (zz !== _1n4)
        throw new Error("invZ was invalid");
      return { x, y };
    });
    const assertValidMemo = memoized((p2) => {
      const { a: a2, d: d2 } = CURVE;
      if (p2.is0())
        throw new Error("bad point: ZERO");
      const { X, Y, Z, T } = p2;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z2 = modP(Z * Z);
      const Z4 = modP(Z2 * Z2);
      const aX2 = modP(X2 * a2);
      const left = modP(Z2 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point {
      // base / generator point
      static BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
      // zero / infinity / identity point
      static ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
      // 0, 1, 1, 0
      // math field
      static Fp = Fp;
      // scalar field
      static Fn = Fn;
      X;
      Y;
      Z;
      T;
      constructor(X, Y, Z, T) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y);
        this.Z = acoord("z", Z, true);
        this.T = acoord("t", T);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE;
      }
      static fromAffine(p2) {
        if (p2 instanceof Point)
          throw new Error("extended point not allowed");
        const { x, y } = p2 || {};
        acoord("x", x);
        acoord("y", y);
        return new Point(x, y, _1n4, modP(x * y));
      }
      // Uses algo from RFC8032 5.1.3.
      static fromBytes(bytes, zip215 = false) {
        const len = Fp.BYTES;
        const { a: a2, d: d2 } = CURVE;
        bytes = copyBytes(abytes(bytes, len, "point"));
        abool(zip215, "zip215");
        const normed = copyBytes(bytes);
        const lastByte = bytes[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y = bytesToNumberLE(normed);
        const max2 = zip215 ? MASK2 : Fp.ORDER;
        aInRange("point.y", y, _0n4, max2);
        const y2 = modP(y * y);
        const u = modP(y2 - _1n4);
        const v = modP(d2 * y2 - a2);
        let { isValid: isValid2, value: x } = uvRatio2(u, v);
        if (!isValid2)
          throw new Error("bad point: invalid y coordinate");
        const isXOdd = (x & _1n4) === _1n4;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n4 && isLastByteOdd)
          throw new Error("bad point: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point.fromAffine({ x, y });
      }
      static fromHex(hex, zip215 = false) {
        return Point.fromBytes(hexToBytes(hex), zip215);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_2n2);
        return this;
      }
      // Useful in fromAffine() - not for fromBytes(), which always created valid points.
      assertValidity() {
        assertValidMemo(this);
      }
      // Compare one point to another.
      equals(other) {
        aedpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      negate() {
        return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a: a2 } = CURVE;
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n2 * modP(Z1 * Z1));
        const D = modP(a2 * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G);
        return new Point(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        aedpoint(other);
        const { a: a2, d: d2 } = CURVE;
        const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
        const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d2 * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G = D + C;
        const H = modP(B - a2 * A);
        const X3 = modP(E * F);
        const Y3 = modP(G * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G);
        return new Point(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      // Constant-time multiplication.
      multiply(scalar) {
        if (!Fn.isValidNot0(scalar))
          throw new Error("invalid scalar: expected 1 <= sc < curve.n");
        const { p: p2, f: f2 } = wnaf.cached(this, scalar, (p3) => normalizeZ(Point, p3));
        return normalizeZ(Point, [p2, f2])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      // Accepts optional accumulator to merge with multiply (important for sparse scalars)
      multiplyUnsafe(scalar, acc = Point.ZERO) {
        if (!Fn.isValid(scalar))
          throw new Error("invalid scalar: expected 0 <= sc < curve.n");
        if (scalar === _0n4)
          return Point.ZERO;
        if (this.is0() || scalar === _1n4)
          return this;
        return wnaf.unsafe(this, scalar, (p2) => normalizeZ(Point, p2), acc);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafe(this, CURVE.n).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      clearCofactor() {
        if (cofactor === _1n4)
          return this;
        return this.multiplyUnsafe(cofactor);
      }
      toBytes() {
        const { x, y } = this.toAffine();
        const bytes = Fp.toBytes(y);
        bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
        return bytes;
      }
      toHex() {
        return bytesToHex(this.toBytes());
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    const wnaf = new wNAF(Point, Fn.BITS);
    Point.BASE.precompute(8);
    return Point;
  }
  function eddsa(Point, cHash, eddsaOpts = {}) {
    if (typeof cHash !== "function")
      throw new Error('"hash" function param is required');
    validateObject(eddsaOpts, {}, {
      adjustScalarBytes: "function",
      randomBytes: "function",
      domain: "function",
      prehash: "function",
      mapToCurve: "function"
    });
    const { prehash } = eddsaOpts;
    const { BASE, Fp, Fn } = Point;
    const randomBytes4 = eddsaOpts.randomBytes || randomBytes;
    const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
    const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
      abool(phflag, "phflag");
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function modN_LE(hash) {
      return Fn.create(bytesToNumberLE(hash));
    }
    function getPrivateScalar(key) {
      const len = lengths.secretKey;
      abytes(key, lengths.secretKey, "secretKey");
      const hashed = abytes(cHash(key), 2 * len, "hashedSecretKey");
      const head = adjustScalarBytes2(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      return { head, prefix, scalar };
    }
    function getExtendedPublicKey(secretKey) {
      const { head, prefix, scalar } = getPrivateScalar(secretKey);
      const point = BASE.multiply(scalar);
      const pointBytes = point.toBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(secretKey) {
      return getExtendedPublicKey(secretKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = concatBytes(...msgs);
      return modN_LE(cHash(domain(msg, abytes(context, void 0, "context"), !!prehash)));
    }
    function sign(msg, secretKey, options2 = {}) {
      msg = abytes(msg, void 0, "message");
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
      const r2 = hashDomainToScalar(options2.context, prefix, msg);
      const R = BASE.multiply(r2).toBytes();
      const k = hashDomainToScalar(options2.context, R, pointBytes, msg);
      const s2 = Fn.create(r2 + k * scalar);
      if (!Fn.isValid(s2))
        throw new Error("sign failed: invalid s");
      const rs = concatBytes(R, Fn.toBytes(s2));
      return abytes(rs, lengths.signature, "result");
    }
    const verifyOpts = { zip215: true };
    function verify(sig, msg, publicKey2, options2 = verifyOpts) {
      const { context, zip215 } = options2;
      const len = lengths.signature;
      sig = abytes(sig, len, "signature");
      msg = abytes(msg, void 0, "message");
      publicKey2 = abytes(publicKey2, lengths.publicKey, "publicKey");
      if (zip215 !== void 0)
        abool(zip215, "zip215");
      if (prehash)
        msg = prehash(msg);
      const mid = len / 2;
      const r2 = sig.subarray(0, mid);
      const s2 = bytesToNumberLE(sig.subarray(mid, len));
      let A, R, SB;
      try {
        A = Point.fromBytes(publicKey2, zip215);
        R = Point.fromBytes(r2, zip215);
        SB = BASE.multiplyUnsafe(s2);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().is0();
    }
    const _size = Fp.BYTES;
    const lengths = {
      secretKey: _size,
      publicKey: _size,
      signature: 2 * _size,
      seed: _size
    };
    function randomSecretKey(seed = randomBytes4(lengths.seed)) {
      return abytes(seed, lengths.seed, "seed");
    }
    function isValidSecretKey(key) {
      return isBytes(key) && key.length === Fn.BYTES;
    }
    function isValidPublicKey(key, zip215) {
      try {
        return !!Point.fromBytes(key, zip215);
      } catch (error) {
        return false;
      }
    }
    const utils = {
      getExtendedPublicKey,
      randomSecretKey,
      isValidSecretKey,
      isValidPublicKey,
      /**
       * Converts ed public key to x public key. Uses formula:
       * - ed25519:
       *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
       *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
       * - ed448:
       *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
       *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
       */
      toMontgomery(publicKey2) {
        const { y } = Point.fromBytes(publicKey2);
        const size = lengths.publicKey;
        const is25519 = size === 32;
        if (!is25519 && size !== 57)
          throw new Error("only defined for 25519 and 448");
        const u = is25519 ? Fp.div(_1n4 + y, _1n4 - y) : Fp.div(y - _1n4, y + _1n4);
        return Fp.toBytes(u);
      },
      toMontgomerySecret(secretKey) {
        const size = lengths.secretKey;
        abytes(secretKey, size);
        const hashed = cHash(secretKey.subarray(0, size));
        return adjustScalarBytes2(hashed).subarray(0, size);
      }
    };
    return Object.freeze({
      keygen: createKeygen(randomSecretKey, getPublicKey),
      getPublicKey,
      sign,
      verify,
      utils,
      Point,
      lengths
    });
  }

  // node_modules/@noble/curves/abstract/montgomery.js
  var _0n5 = BigInt(0);
  var _1n5 = BigInt(1);
  var _2n3 = BigInt(2);
  function validateOpts(curve) {
    validateObject(curve, {
      adjustScalarBytes: "function",
      powPminus2: "function"
    });
    return Object.freeze({ ...curve });
  }
  function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P, type, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type === "x25519";
    if (!is25519 && type !== "x448")
      throw new Error("invalid type");
    const randomBytes_ = rand || randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
    const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;
    const maxScalar = minScalar + maxAdded + _1n5;
    const modP = (n2) => mod(n2, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
      return numberToBytesLE(modP(u), fieldLen);
    }
    function decodeU(u) {
      const _u = copyBytes(abytes(u, fieldLen, "uCoordinate"));
      if (is25519)
        _u[31] &= 127;
      return modP(bytesToNumberLE(_u));
    }
    function decodeScalar(scalar) {
      return bytesToNumberLE(adjustScalarBytes2(copyBytes(abytes(scalar, fieldLen, "scalar"))));
    }
    function scalarMult(scalar, u) {
      const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
      if (pu === _0n5)
        throw new Error("invalid private or public key received");
      return encodeU(pu);
    }
    function scalarMultBase(scalar) {
      return scalarMult(scalar, GuBytes);
    }
    const getPublicKey = scalarMultBase;
    const getSharedSecret = scalarMult;
    function cswap(swap, x_2, x_3) {
      const dummy = modP(swap * (x_2 - x_3));
      x_2 = modP(x_2 - dummy);
      x_3 = modP(x_3 + dummy);
      return { x_2, x_3 };
    }
    function montgomeryLadder(u, scalar) {
      aInRange("u", u, _0n5, P);
      aInRange("scalar", scalar, minScalar, maxScalar);
      const k = scalar;
      const x_1 = u;
      let x_2 = _1n5;
      let z_2 = _0n5;
      let x_3 = u;
      let z_3 = _1n5;
      let swap = _0n5;
      for (let t2 = BigInt(montgomeryBits - 1); t2 >= _0n5; t2--) {
        const k_t = k >> t2 & _1n5;
        swap ^= k_t;
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        swap = k_t;
        const A = x_2 + z_2;
        const AA = modP(A * A);
        const B = x_2 - z_2;
        const BB = modP(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = modP(D * A);
        const CB = modP(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = modP(dacb * dacb);
        z_3 = modP(x_1 * modP(da_cb * da_cb));
        x_2 = modP(AA * BB);
        z_2 = modP(E * (AA + modP(a24 * E)));
      }
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      const z2 = powPminus2(z_2);
      return modP(x_2 * z2);
    }
    const lengths = {
      secretKey: fieldLen,
      publicKey: fieldLen,
      seed: fieldLen
    };
    const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
      abytes(seed, lengths.seed, "seed");
      return seed;
    };
    const utils = { randomSecretKey };
    return Object.freeze({
      keygen: createKeygen(randomSecretKey, getPublicKey),
      getSharedSecret,
      getPublicKey,
      scalarMult,
      scalarMultBase,
      utils,
      GuBytes: GuBytes.slice(),
      lengths
    });
  }

  // node_modules/@noble/curves/ed25519.js
  var _1n6 = BigInt(1);
  var _2n4 = BigInt(2);
  var _3n2 = /* @__PURE__ */ BigInt(3);
  var _5n2 = BigInt(5);
  var _8n3 = BigInt(8);
  var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
  var ed25519_CURVE = /* @__PURE__ */ (() => ({
    p: ed25519_CURVE_p,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n3,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  }))();
  function ed25519_pow_2_252_3(x) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE_p;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n4, P) * b2 % P;
    const b5 = pow2(b4, _1n6, P) * x % P;
    const b10 = pow2(b5, _5n2, P) * b5 % P;
    const b20 = pow2(b10, _10n, P) * b10 % P;
    const b40 = pow2(b20, _20n, P) * b20 % P;
    const b80 = pow2(b40, _40n, P) * b40 % P;
    const b160 = pow2(b80, _80n, P) * b80 % P;
    const b240 = pow2(b160, _80n, P) * b80 % P;
    const b250 = pow2(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
  }
  var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  function uvRatio(u, v) {
    const P = ed25519_CURVE_p;
    const v3 = mod(v * v * v, P);
    const v7 = mod(v3 * v3 * v, P);
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow, P);
    const vx2 = mod(v * x * x, P);
    const root1 = x;
    const root2 = mod(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u, P);
    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE(x, P))
      x = mod(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var ed25519_Point = /* @__PURE__ */ edwards(ed25519_CURVE, { uvRatio });
  function ed(opts) {
    return eddsa(ed25519_Point, sha5122, Object.assign({ adjustScalarBytes }, opts));
  }
  var ed25519 = /* @__PURE__ */ ed({});
  var x25519 = /* @__PURE__ */ (() => {
    const P = ed25519_CURVE_p;
    return montgomery({
      P,
      type: "x25519",
      powPminus2: (x) => {
        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
        return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);
      },
      adjustScalarBytes
    });
  })();

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
  var PUBLIC_KEY_BYTE_LENGTH = 32;
  var PRIVATE_KEY_BYTE_LENGTH = 64;
  var KEYS_BYTE_LENGTH = 32;
  var ed25519Supported;
  var webCryptoEd25519SupportedPromise = (async () => {
    try {
      await webcrypto_default.get().subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
      return true;
    } catch {
      return false;
    }
  })();
  function generateKey() {
    const privateKeyRaw = ed25519.utils.randomSecretKey();
    const publicKey2 = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys(privateKeyRaw, publicKey2);
    return {
      privateKey,
      publicKey: publicKey2
    };
  }
  async function hashAndSignWebCrypto(privateKey, msg) {
    let privateKeyRaw;
    if (privateKey.length === PRIVATE_KEY_BYTE_LENGTH) {
      privateKeyRaw = privateKey.subarray(0, 32);
    } else {
      privateKeyRaw = privateKey;
    }
    const jwk = {
      crv: "Ed25519",
      kty: "OKP",
      x: toString2(privateKey.subarray(32), "base64url"),
      d: toString2(privateKeyRaw, "base64url"),
      ext: true,
      key_ops: ["sign"]
    };
    const key = await webcrypto_default.get().subtle.importKey("jwk", jwk, { name: "Ed25519" }, true, ["sign"]);
    const sig = await webcrypto_default.get().subtle.sign({ name: "Ed25519" }, key, msg instanceof Uint8Array ? msg : msg.subarray());
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  function hashAndSignNoble(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
    return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
  }
  async function hashAndSign2(privateKey, msg) {
    if (ed25519Supported == null) {
      ed25519Supported = await webCryptoEd25519SupportedPromise;
    }
    if (ed25519Supported) {
      return hashAndSignWebCrypto(privateKey, msg);
    }
    return hashAndSignNoble(privateKey, msg);
  }
  async function hashAndVerifyWebCrypto(publicKey2, sig, msg) {
    if (publicKey2.buffer instanceof ArrayBuffer) {
      const key = await webcrypto_default.get().subtle.importKey("raw", publicKey2.buffer, { name: "Ed25519" }, false, ["verify"]);
      const isValid2 = await webcrypto_default.get().subtle.verify({ name: "Ed25519" }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray());
      return isValid2;
    }
    throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
  }
  function hashAndVerifyNoble(publicKey2, sig, msg) {
    return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey2);
  }
  async function hashAndVerify2(publicKey2, sig, msg) {
    if (ed25519Supported == null) {
      ed25519Supported = await webCryptoEd25519SupportedPromise;
    }
    if (ed25519Supported) {
      return hashAndVerifyWebCrypto(publicKey2, sig, msg);
    }
    return hashAndVerifyNoble(publicKey2, sig, msg);
  }
  function concatKeys(privateKeyRaw, publicKey2) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
    for (let i2 = 0; i2 < KEYS_BYTE_LENGTH; i2++) {
      privateKey[i2] = privateKeyRaw[i2];
      privateKey[KEYS_BYTE_LENGTH + i2] = publicKey2[i2];
    }
    return privateKey;
  }

  // node_modules/@libp2p/crypto/dist/src/util.js
  function isPromise(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
  var Ed25519PublicKey = class {
    type = "Ed25519";
    raw;
    constructor(key) {
      this.raw = ensureEd25519Key(key, PUBLIC_KEY_BYTE_LENGTH);
    }
    toMultihash() {
      return identity.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    verify(data, sig, options2) {
      options2?.signal?.throwIfAborted();
      const result = hashAndVerify2(this.raw, sig, data);
      if (isPromise(result)) {
        return result.then((res) => {
          options2?.signal?.throwIfAborted();
          return res;
        });
      }
      return result;
    }
  };
  var Ed25519PrivateKey = class {
    type = "Ed25519";
    raw;
    publicKey;
    // key       - 64 byte Uint8Array containing private key
    // publicKey - 32 byte Uint8Array containing public key
    constructor(key, publicKey2) {
      this.raw = ensureEd25519Key(key, PRIVATE_KEY_BYTE_LENGTH);
      this.publicKey = new Ed25519PublicKey(publicKey2);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    sign(message2, options2) {
      options2?.signal?.throwIfAborted();
      const sig = hashAndSign2(this.raw, message2);
      if (isPromise(sig)) {
        return sig.then((res) => {
          options2?.signal?.throwIfAborted();
          return res;
        });
      }
      options2?.signal?.throwIfAborted();
      return sig;
    }
  };

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
  function unmarshalEd25519PrivateKey(bytes) {
    if (bytes.length > PRIVATE_KEY_BYTE_LENGTH) {
      bytes = ensureEd25519Key(bytes, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
      const privateKeyBytes2 = bytes.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
      const publicKeyBytes2 = bytes.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes.length);
      return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
    }
    bytes = ensureEd25519Key(bytes, PRIVATE_KEY_BYTE_LENGTH);
    const privateKeyBytes = bytes.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes = bytes.subarray(PUBLIC_KEY_BYTE_LENGTH);
    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
  }
  function unmarshalEd25519PublicKey(bytes) {
    bytes = ensureEd25519Key(bytes, PUBLIC_KEY_BYTE_LENGTH);
    return new Ed25519PublicKey(bytes);
  }
  async function generateEd25519KeyPair() {
    const { privateKey, publicKey: publicKey2 } = generateKey();
    return new Ed25519PrivateKey(privateKey, publicKey2);
  }
  function ensureEd25519Key(key, length4) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length4) {
      throw new InvalidParametersError(`Key must be a Uint8Array of length ${length4}, got ${key.length}`);
    }
    return key;
  }

  // node_modules/uint8-varint/dist/src/index.js
  var N12 = Math.pow(2, 7);
  var N22 = Math.pow(2, 14);
  var N32 = Math.pow(2, 21);
  var N42 = Math.pow(2, 28);
  var N52 = Math.pow(2, 35);
  var N62 = Math.pow(2, 42);
  var N72 = Math.pow(2, 49);
  var MSB2 = 128;
  var REST2 = 127;
  function encodingLength2(value2) {
    if (value2 < N12) {
      return 1;
    }
    if (value2 < N22) {
      return 2;
    }
    if (value2 < N32) {
      return 3;
    }
    if (value2 < N42) {
      return 4;
    }
    if (value2 < N52) {
      return 5;
    }
    if (value2 < N62) {
      return 6;
    }
    if (value2 < N72) {
      return 7;
    }
    if (Number.MAX_SAFE_INTEGER != null && value2 > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    return 8;
  }
  function encodeUint8Array(value2, buf2, offset = 0) {
    switch (encodingLength2(value2)) {
      case 8: {
        buf2[offset++] = value2 & 255 | MSB2;
        value2 /= 128;
      }
      case 7: {
        buf2[offset++] = value2 & 255 | MSB2;
        value2 /= 128;
      }
      case 6: {
        buf2[offset++] = value2 & 255 | MSB2;
        value2 /= 128;
      }
      case 5: {
        buf2[offset++] = value2 & 255 | MSB2;
        value2 /= 128;
      }
      case 4: {
        buf2[offset++] = value2 & 255 | MSB2;
        value2 >>>= 7;
      }
      case 3: {
        buf2[offset++] = value2 & 255 | MSB2;
        value2 >>>= 7;
      }
      case 2: {
        buf2[offset++] = value2 & 255 | MSB2;
        value2 >>>= 7;
      }
      case 1: {
        buf2[offset++] = value2 & 255;
        value2 >>>= 7;
        break;
      }
      default:
        throw new Error("unreachable");
    }
    return buf2;
  }
  function encodeUint8ArrayList(value2, buf2, offset = 0) {
    switch (encodingLength2(value2)) {
      case 8: {
        buf2.set(offset++, value2 & 255 | MSB2);
        value2 /= 128;
      }
      case 7: {
        buf2.set(offset++, value2 & 255 | MSB2);
        value2 /= 128;
      }
      case 6: {
        buf2.set(offset++, value2 & 255 | MSB2);
        value2 /= 128;
      }
      case 5: {
        buf2.set(offset++, value2 & 255 | MSB2);
        value2 /= 128;
      }
      case 4: {
        buf2.set(offset++, value2 & 255 | MSB2);
        value2 >>>= 7;
      }
      case 3: {
        buf2.set(offset++, value2 & 255 | MSB2);
        value2 >>>= 7;
      }
      case 2: {
        buf2.set(offset++, value2 & 255 | MSB2);
        value2 >>>= 7;
      }
      case 1: {
        buf2.set(offset++, value2 & 255);
        value2 >>>= 7;
        break;
      }
      default:
        throw new Error("unreachable");
    }
    return buf2;
  }
  function decodeUint8Array(buf2, offset) {
    let b = buf2[offset];
    let res = 0;
    res += b & REST2;
    if (b < MSB2) {
      return res;
    }
    b = buf2[offset + 1];
    res += (b & REST2) << 7;
    if (b < MSB2) {
      return res;
    }
    b = buf2[offset + 2];
    res += (b & REST2) << 14;
    if (b < MSB2) {
      return res;
    }
    b = buf2[offset + 3];
    res += (b & REST2) << 21;
    if (b < MSB2) {
      return res;
    }
    b = buf2[offset + 4];
    res += (b & REST2) * N42;
    if (b < MSB2) {
      return res;
    }
    b = buf2[offset + 5];
    res += (b & REST2) * N52;
    if (b < MSB2) {
      return res;
    }
    b = buf2[offset + 6];
    res += (b & REST2) * N62;
    if (b < MSB2) {
      return res;
    }
    b = buf2[offset + 7];
    res += (b & REST2) * N72;
    if (b < MSB2) {
      return res;
    }
    throw new RangeError("Could not decode varint");
  }
  function decodeUint8ArrayList(buf2, offset) {
    let b = buf2.get(offset);
    let res = 0;
    res += b & REST2;
    if (b < MSB2) {
      return res;
    }
    b = buf2.get(offset + 1);
    res += (b & REST2) << 7;
    if (b < MSB2) {
      return res;
    }
    b = buf2.get(offset + 2);
    res += (b & REST2) << 14;
    if (b < MSB2) {
      return res;
    }
    b = buf2.get(offset + 3);
    res += (b & REST2) << 21;
    if (b < MSB2) {
      return res;
    }
    b = buf2.get(offset + 4);
    res += (b & REST2) * N42;
    if (b < MSB2) {
      return res;
    }
    b = buf2.get(offset + 5);
    res += (b & REST2) * N52;
    if (b < MSB2) {
      return res;
    }
    b = buf2.get(offset + 6);
    res += (b & REST2) * N62;
    if (b < MSB2) {
      return res;
    }
    b = buf2.get(offset + 7);
    res += (b & REST2) * N72;
    if (b < MSB2) {
      return res;
    }
    throw new RangeError("Could not decode varint");
  }
  function encode7(value2, buf2, offset = 0) {
    if (buf2 == null) {
      buf2 = allocUnsafe(encodingLength2(value2));
    }
    if (buf2 instanceof Uint8Array) {
      return encodeUint8Array(value2, buf2, offset);
    } else {
      return encodeUint8ArrayList(value2, buf2, offset);
    }
  }
  function decode8(buf2, offset = 0) {
    if (buf2 instanceof Uint8Array) {
      return decodeUint8Array(buf2, offset);
    } else {
      return decodeUint8ArrayList(buf2, offset);
    }
  }

  // node_modules/protons-runtime/dist/src/utils/float.js
  var f32 = new Float32Array([-0]);
  var f8b = new Uint8Array(f32.buffer);
  function writeFloatLE(val, buf2, pos) {
    f32[0] = val;
    buf2[pos] = f8b[0];
    buf2[pos + 1] = f8b[1];
    buf2[pos + 2] = f8b[2];
    buf2[pos + 3] = f8b[3];
  }
  function readFloatLE(buf2, pos) {
    f8b[0] = buf2[pos];
    f8b[1] = buf2[pos + 1];
    f8b[2] = buf2[pos + 2];
    f8b[3] = buf2[pos + 3];
    return f32[0];
  }
  var f64 = new Float64Array([-0]);
  var d8b = new Uint8Array(f64.buffer);
  function writeDoubleLE(val, buf2, pos) {
    f64[0] = val;
    buf2[pos] = d8b[0];
    buf2[pos + 1] = d8b[1];
    buf2[pos + 2] = d8b[2];
    buf2[pos + 3] = d8b[3];
    buf2[pos + 4] = d8b[4];
    buf2[pos + 5] = d8b[5];
    buf2[pos + 6] = d8b[6];
    buf2[pos + 7] = d8b[7];
  }
  function readDoubleLE(buf2, pos) {
    d8b[0] = buf2[pos];
    d8b[1] = buf2[pos + 1];
    d8b[2] = buf2[pos + 2];
    d8b[3] = buf2[pos + 3];
    d8b[4] = buf2[pos + 4];
    d8b[5] = buf2[pos + 5];
    d8b[6] = buf2[pos + 6];
    d8b[7] = buf2[pos + 7];
    return f64[0];
  }

  // node_modules/protons-runtime/dist/src/utils/longbits.js
  var MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
  var MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
  var LongBits = class _LongBits {
    lo;
    hi;
    constructor(lo, hi) {
      this.lo = lo | 0;
      this.hi = hi | 0;
    }
    /**
     * Converts this long bits to a possibly unsafe JavaScript number
     */
    toNumber(unsigned = false) {
      if (!unsigned && this.hi >>> 31 > 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }
    /**
     * Converts this long bits to a bigint
     */
    toBigInt(unsigned = false) {
      if (unsigned) {
        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
      }
      if (this.hi >>> 31 !== 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(BigInt(lo) + (BigInt(hi) << 32n));
      }
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    /**
     * Converts this long bits to a string
     */
    toString(unsigned = false) {
      return this.toBigInt(unsigned).toString();
    }
    /**
     * Zig-zag encodes this long bits
     */
    zzEncode() {
      const mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }
    /**
     * Zig-zag decodes this long bits
     */
    zzDecode() {
      const mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }
    /**
     * Calculates the length of this longbits when encoded as a varint.
     */
    length() {
      const part0 = this.lo;
      const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
      const part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromBigInt(value2) {
      if (value2 === 0n) {
        return zero;
      }
      if (value2 < MAX_SAFE_NUMBER_INTEGER && value2 > MIN_SAFE_NUMBER_INTEGER) {
        return this.fromNumber(Number(value2));
      }
      const negative = value2 < 0n;
      if (negative) {
        value2 = -value2;
      }
      let hi = value2 >> 32n;
      let lo = value2 - (hi << 32n);
      if (negative) {
        hi = ~hi | 0n;
        lo = ~lo | 0n;
        if (++lo > TWO_32) {
          lo = 0n;
          if (++hi > TWO_32) {
            hi = 0n;
          }
        }
      }
      return new _LongBits(Number(lo), Number(hi));
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromNumber(value2) {
      if (value2 === 0) {
        return zero;
      }
      const sign = value2 < 0;
      if (sign) {
        value2 = -value2;
      }
      let lo = value2 >>> 0;
      let hi = (value2 - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295) {
            hi = 0;
          }
        }
      }
      return new _LongBits(lo, hi);
    }
    /**
     * Constructs new long bits from a number, long or string
     */
    static from(value2) {
      if (typeof value2 === "number") {
        return _LongBits.fromNumber(value2);
      }
      if (typeof value2 === "bigint") {
        return _LongBits.fromBigInt(value2);
      }
      if (typeof value2 === "string") {
        return _LongBits.fromBigInt(BigInt(value2));
      }
      return value2.low != null || value2.high != null ? new _LongBits(value2.low >>> 0, value2.high >>> 0) : zero;
    }
  };
  var zero = new LongBits(0, 0);
  zero.toBigInt = function() {
    return 0n;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var TWO_32 = 4294967296n;

  // node_modules/protons-runtime/dist/src/utils/utf8.js
  function length2(string2) {
    let len = 0;
    let c2 = 0;
    for (let i2 = 0; i2 < string2.length; ++i2) {
      c2 = string2.charCodeAt(i2);
      if (c2 < 128) {
        len += 1;
      } else if (c2 < 2048) {
        len += 2;
      } else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
        ++i2;
        len += 4;
      } else {
        len += 3;
      }
    }
    return len;
  }
  function read2(buffer2, start2, end) {
    const len = end - start2;
    if (len < 1) {
      return "";
    }
    let parts;
    const chunk = [];
    let i2 = 0;
    let t2;
    while (start2 < end) {
      t2 = buffer2[start2++];
      if (t2 < 128) {
        chunk[i2++] = t2;
      } else if (t2 > 191 && t2 < 224) {
        chunk[i2++] = (t2 & 31) << 6 | buffer2[start2++] & 63;
      } else if (t2 > 239 && t2 < 365) {
        t2 = ((t2 & 7) << 18 | (buffer2[start2++] & 63) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63) - 65536;
        chunk[i2++] = 55296 + (t2 >> 10);
        chunk[i2++] = 56320 + (t2 & 1023);
      } else {
        chunk[i2++] = (t2 & 15) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63;
      }
      if (i2 > 8191) {
        (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (parts != null) {
      if (i2 > 0) {
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      }
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  }
  function write(string2, buffer2, offset) {
    const start2 = offset;
    let c1;
    let c2;
    for (let i2 = 0; i2 < string2.length; ++i2) {
      c1 = string2.charCodeAt(i2);
      if (c1 < 128) {
        buffer2[offset++] = c1;
      } else if (c1 < 2048) {
        buffer2[offset++] = c1 >> 6 | 192;
        buffer2[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i2;
        buffer2[offset++] = c1 >> 18 | 240;
        buffer2[offset++] = c1 >> 12 & 63 | 128;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      } else {
        buffer2[offset++] = c1 >> 12 | 224;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start2;
  }

  // node_modules/protons-runtime/dist/src/utils/reader.js
  function indexOutOfRange(reader2, writeLength) {
    return RangeError(`index out of range: ${reader2.pos} + ${writeLength ?? 1} > ${reader2.len}`);
  }
  function readFixed32End(buf2, end) {
    return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
  }
  var Uint8ArrayReader = class {
    buf;
    pos;
    len;
    _slice = Uint8Array.prototype.subarray;
    constructor(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    /**
     * Reads a varint as an unsigned 32 bit value
     */
    uint32() {
      let value2 = 4294967295;
      value2 = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value2;
      }
      value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value2;
      }
      value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value2;
      }
      value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value2;
      }
      value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return value2;
      }
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value2;
    }
    /**
     * Reads a varint as a signed 32 bit value
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Reads a zig-zag encoded varint as a signed 32 bit value
     */
    sint32() {
      const value2 = this.uint32();
      return value2 >>> 1 ^ -(value2 & 1) | 0;
    }
    /**
     * Reads a varint as a boolean
     */
    bool() {
      return this.uint32() !== 0;
    }
    /**
     * Reads fixed 32 bits as an unsigned 32 bit integer
     */
    fixed32() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const res = readFixed32End(this.buf, this.pos += 4);
      return res;
    }
    /**
     * Reads fixed 32 bits as a signed 32 bit integer
     */
    sfixed32() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const res = readFixed32End(this.buf, this.pos += 4) | 0;
      return res;
    }
    /**
     * Reads a float (32 bit) as a number
     */
    float() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const value2 = readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value2;
    }
    /**
     * Reads a double (64 bit float) as a number
     */
    double() {
      if (this.pos + 8 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const value2 = readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value2;
    }
    /**
     * Reads a sequence of bytes preceded by its length as a varint
     */
    bytes() {
      const length4 = this.uint32();
      const start2 = this.pos;
      const end = this.pos + length4;
      if (end > this.len) {
        throw indexOutOfRange(this, length4);
      }
      this.pos += length4;
      return start2 === end ? new Uint8Array(0) : this.buf.subarray(start2, end);
    }
    /**
     * Reads a string preceded by its byte length as a varint
     */
    string() {
      const bytes = this.bytes();
      return read2(bytes, 0, bytes.length);
    }
    /**
     * Skips the specified number of bytes if specified, otherwise skips a varint
     */
    skip(length4) {
      if (typeof length4 === "number") {
        if (this.pos + length4 > this.len) {
          throw indexOutOfRange(this, length4);
        }
        this.pos += length4;
      } else {
        do {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
        } while ((this.buf[this.pos++] & 128) !== 0);
      }
      return this;
    }
    /**
     * Skips the next element of the specified wire type
     */
    skipType(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
      }
      return this;
    }
    readLongVarint() {
      const bits2 = new LongBits(0, 0);
      let i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits2;
          }
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits2;
        }
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
          bits2.lo = (bits2.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits2;
          }
        }
        bits2.lo = (bits2.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits2;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits2;
          }
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
          bits2.hi = (bits2.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits2;
          }
        }
      }
      throw Error("invalid varint encoding");
    }
    readFixed64() {
      if (this.pos + 8 > this.len) {
        throw indexOutOfRange(this, 8);
      }
      const lo = readFixed32End(this.buf, this.pos += 4);
      const hi = readFixed32End(this.buf, this.pos += 4);
      return new LongBits(lo, hi);
    }
    /**
     * Reads a varint as a signed 64 bit value
     */
    int64() {
      return this.readLongVarint().toBigInt();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    int64Number() {
      return this.readLongVarint().toNumber();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a string
     */
    int64String() {
      return this.readLongVarint().toString();
    }
    /**
     * Reads a varint as an unsigned 64 bit value
     */
    uint64() {
      return this.readLongVarint().toBigInt(true);
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    uint64Number() {
      const value2 = decodeUint8Array(this.buf, this.pos);
      this.pos += encodingLength2(value2);
      return value2;
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a string
     */
    uint64String() {
      return this.readLongVarint().toString(true);
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value
     */
    sint64() {
      return this.readLongVarint().zzDecode().toBigInt();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * possibly unsafe JavaScript number
     */
    sint64Number() {
      return this.readLongVarint().zzDecode().toNumber();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * string
     */
    sint64String() {
      return this.readLongVarint().zzDecode().toString();
    }
    /**
     * Reads fixed 64 bits
     */
    fixed64() {
      return this.readFixed64().toBigInt();
    }
    /**
     * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
     */
    fixed64Number() {
      return this.readFixed64().toNumber();
    }
    /**
     * Reads fixed 64 bits returned as a string
     */
    fixed64String() {
      return this.readFixed64().toString();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits
     */
    sfixed64() {
      return this.readFixed64().toBigInt();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
     * JavaScript number
     */
    sfixed64Number() {
      return this.readFixed64().toNumber();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a string
     */
    sfixed64String() {
      return this.readFixed64().toString();
    }
  };
  function createReader(buf2) {
    return new Uint8ArrayReader(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
  }

  // node_modules/protons-runtime/dist/src/decode.js
  function decodeMessage(buf2, codec, opts) {
    const reader2 = createReader(buf2);
    return codec.decode(reader2, void 0, opts);
  }

  // node_modules/protons-runtime/dist/src/utils/pool.js
  function pool(size) {
    const SIZE = size ?? 8192;
    const MAX = SIZE >>> 1;
    let slab;
    let offset = SIZE;
    return function poolAlloc(size2) {
      if (size2 < 1 || size2 > MAX) {
        return allocUnsafe(size2);
      }
      if (offset + size2 > SIZE) {
        slab = allocUnsafe(SIZE);
        offset = 0;
      }
      const buf2 = slab.subarray(offset, offset += size2);
      if ((offset & 7) !== 0) {
        offset = (offset | 7) + 1;
      }
      return buf2;
    };
  }

  // node_modules/protons-runtime/dist/src/utils/writer.js
  var Op = class {
    /**
     * Function to call
     */
    fn;
    /**
     * Value byte length
     */
    len;
    /**
     * Next operation
     */
    next;
    /**
     * Value to write
     */
    val;
    constructor(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
  };
  function noop() {
  }
  var State = class {
    /**
     * Current head
     */
    head;
    /**
     * Current tail
     */
    tail;
    /**
     * Current buffer length
     */
    len;
    /**
     * Next state
     */
    next;
    constructor(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
  };
  var bufferPool = pool();
  function alloc2(size) {
    if (globalThis.Buffer != null) {
      return allocUnsafe(size);
    }
    return bufferPool(size);
  }
  var Uint8ArrayWriter = class {
    /**
     * Current length
     */
    len;
    /**
     * Operations head
     */
    head;
    /**
     * Operations tail
     */
    tail;
    /**
     * Linked forked states
     */
    states;
    constructor() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    /**
     * Pushes a new operation to the queue
     */
    _push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }
    /**
     * Writes an unsigned 32 bit value as a varint
     */
    uint32(value2) {
      this.len += (this.tail = this.tail.next = new VarintOp((value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5, value2)).len;
      return this;
    }
    /**
     * Writes a signed 32 bit value as a varint`
     */
    int32(value2) {
      return value2 < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value2)) : this.uint32(value2);
    }
    /**
     * Writes a 32 bit value as a varint, zig-zag encoded
     */
    sint32(value2) {
      return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64(value2) {
      const bits2 = LongBits.fromBigInt(value2);
      return this._push(writeVarint64, bits2.length(), bits2);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64Number(value2) {
      return this._push(encodeUint8Array, encodingLength2(value2), value2);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64String(value2) {
      return this.uint64(BigInt(value2));
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64(value2) {
      return this.uint64(value2);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64Number(value2) {
      return this.uint64Number(value2);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64String(value2) {
      return this.uint64String(value2);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64(value2) {
      const bits2 = LongBits.fromBigInt(value2).zzEncode();
      return this._push(writeVarint64, bits2.length(), bits2);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64Number(value2) {
      const bits2 = LongBits.fromNumber(value2).zzEncode();
      return this._push(writeVarint64, bits2.length(), bits2);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64String(value2) {
      return this.sint64(BigInt(value2));
    }
    /**
     * Writes a boolish value as a varint
     */
    bool(value2) {
      return this._push(writeByte, 1, value2 ? 1 : 0);
    }
    /**
     * Writes an unsigned 32 bit value as fixed 32 bits
     */
    fixed32(value2) {
      return this._push(writeFixed32, 4, value2 >>> 0);
    }
    /**
     * Writes a signed 32 bit value as fixed 32 bits
     */
    sfixed32(value2) {
      return this.fixed32(value2);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64(value2) {
      const bits2 = LongBits.fromBigInt(value2);
      return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64Number(value2) {
      const bits2 = LongBits.fromNumber(value2);
      return this._push(writeFixed32, 4, bits2.lo)._push(writeFixed32, 4, bits2.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64String(value2) {
      return this.fixed64(BigInt(value2));
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64(value2) {
      return this.fixed64(value2);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64Number(value2) {
      return this.fixed64Number(value2);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64String(value2) {
      return this.fixed64String(value2);
    }
    /**
     * Writes a float (32 bit)
     */
    float(value2) {
      return this._push(writeFloatLE, 4, value2);
    }
    /**
     * Writes a double (64 bit float).
     *
     * @function
     * @param {number} value - Value to write
     * @returns {Writer} `this`
     */
    double(value2) {
      return this._push(writeDoubleLE, 8, value2);
    }
    /**
     * Writes a sequence of bytes
     */
    bytes(value2) {
      const len = value2.length >>> 0;
      if (len === 0) {
        return this._push(writeByte, 1, 0);
      }
      return this.uint32(len)._push(writeBytes, len, value2);
    }
    /**
     * Writes a string
     */
    string(value2) {
      const len = length2(value2);
      return len !== 0 ? this.uint32(len)._push(write, len, value2) : this._push(writeByte, 1, 0);
    }
    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     */
    fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    }
    /**
     * Resets this instance to the last state
     */
    reset() {
      if (this.states != null) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    }
    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     */
    ldelim() {
      const head = this.head;
      const tail = this.tail;
      const len = this.len;
      this.reset().uint32(len);
      if (len !== 0) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }
    /**
     * Finishes the write operation
     */
    finish() {
      let head = this.head.next;
      const buf2 = alloc2(this.len);
      let pos = 0;
      while (head != null) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    }
  };
  function writeByte(val, buf2, pos) {
    buf2[pos] = val & 255;
  }
  function writeVarint32(val, buf2, pos) {
    while (val > 127) {
      buf2[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf2[pos] = val;
  }
  var VarintOp = class extends Op {
    next;
    constructor(len, val) {
      super(writeVarint32, len, val);
      this.next = void 0;
    }
  };
  function writeVarint64(val, buf2, pos) {
    while (val.hi !== 0) {
      buf2[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf2[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf2[pos++] = val.lo;
  }
  function writeFixed32(val, buf2, pos) {
    buf2[pos] = val & 255;
    buf2[pos + 1] = val >>> 8 & 255;
    buf2[pos + 2] = val >>> 16 & 255;
    buf2[pos + 3] = val >>> 24;
  }
  function writeBytes(val, buf2, pos) {
    buf2.set(val, pos);
  }
  if (globalThis.Buffer != null) {
    Uint8ArrayWriter.prototype.bytes = function(value2) {
      const len = value2.length >>> 0;
      this.uint32(len);
      if (len > 0) {
        this._push(writeBytesBuffer, len, value2);
      }
      return this;
    };
    Uint8ArrayWriter.prototype.string = function(value2) {
      const len = globalThis.Buffer.byteLength(value2);
      this.uint32(len);
      if (len > 0) {
        this._push(writeStringBuffer, len, value2);
      }
      return this;
    };
  }
  function writeBytesBuffer(val, buf2, pos) {
    buf2.set(val, pos);
  }
  function writeStringBuffer(val, buf2, pos) {
    if (val.length < 40) {
      write(val, buf2, pos);
    } else if (buf2.utf8Write != null) {
      buf2.utf8Write(val, pos);
    } else {
      buf2.set(fromString2(val), pos);
    }
  }
  function createWriter() {
    return new Uint8ArrayWriter();
  }

  // node_modules/protons-runtime/dist/src/encode.js
  function encodeMessage(message2, codec) {
    const w = createWriter();
    codec.encode(message2, w, {
      lengthDelimited: false
    });
    return w.finish();
  }

  // node_modules/protons-runtime/dist/src/codec.js
  var CODEC_TYPES;
  (function(CODEC_TYPES2) {
    CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
    CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
    CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
    CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
  })(CODEC_TYPES || (CODEC_TYPES = {}));
  function createCodec2(name9, type, encode17, decode16) {
    return {
      name: name9,
      type,
      encode: encode17,
      decode: decode16
    };
  }

  // node_modules/protons-runtime/dist/src/codecs/enum.js
  function enumeration(v) {
    function findValue(val) {
      if (v[val.toString()] == null) {
        throw new Error("Invalid enum value");
      }
      return v[val];
    }
    const encode17 = function enumEncode(val, writer) {
      const enumValue = findValue(val);
      writer.int32(enumValue);
    };
    const decode16 = function enumDecode(reader2) {
      const val = reader2.int32();
      return findValue(val);
    };
    return createCodec2("enum", CODEC_TYPES.VARINT, encode17, decode16);
  }

  // node_modules/protons-runtime/dist/src/codecs/message.js
  function message(encode17, decode16) {
    return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode17, decode16);
  }

  // node_modules/protons-runtime/dist/src/index.js
  var MaxLengthError = class extends Error {
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    code = "ERR_MAX_LENGTH";
    name = "MaxLengthError";
  };
  var MaxSizeError = class extends Error {
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    code = "ERR_MAX_SIZE";
    name = "MaxSizeError";
  };

  // node_modules/@libp2p/crypto/dist/src/keys/keys.js
  var KeyType;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["secp256k1"] = "secp256k1";
    KeyType2["ECDSA"] = "ECDSA";
  })(KeyType || (KeyType = {}));
  var __KeyTypeValues;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["secp256k1"] = 2] = "secp256k1";
    __KeyTypeValues2[__KeyTypeValues2["ECDSA"] = 3] = "ECDSA";
  })(__KeyTypeValues || (__KeyTypeValues = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues);
    };
  })(KeyType || (KeyType = {}));
  var PublicKey;
  (function(PublicKey3) {
    let _codec;
    PublicKey3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.Type = KeyType.codec().decode(reader2);
                break;
              }
              case 2: {
                obj.Data = reader2.bytes();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey3.encode = (obj) => {
      return encodeMessage(obj, PublicKey3.codec());
    };
    PublicKey3.decode = (buf2, opts) => {
      return decodeMessage(buf2, PublicKey3.codec(), opts);
    };
  })(PublicKey || (PublicKey = {}));
  var PrivateKey;
  (function(PrivateKey3) {
    let _codec;
    PrivateKey3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            KeyType.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.Type = KeyType.codec().decode(reader2);
                break;
              }
              case 2: {
                obj.Data = reader2.bytes();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey3.encode = (obj) => {
      return encodeMessage(obj, PrivateKey3.codec());
    };
    PrivateKey3.decode = (buf2, opts) => {
      return decodeMessage(buf2, PrivateKey3.codec(), opts);
    };
  })(PrivateKey || (PrivateKey = {}));

  // node_modules/@libp2p/crypto/dist/src/random-bytes.js
  function randomBytes2(length4) {
    if (isNaN(length4) || length4 <= 0) {
      throw new InvalidParametersError("random bytes length must be a Number bigger than 0");
    }
    return randomBytes(length4);
  }

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
    generateRSAKeyPair: () => generateRSAKeyPair,
    jwkToJWKKeyPair: () => jwkToJWKKeyPair,
    jwkToPkcs1: () => jwkToPkcs1,
    jwkToPkix: () => jwkToPkix,
    jwkToRSAPrivateKey: () => jwkToRSAPrivateKey,
    pkcs1MessageToJwk: () => pkcs1MessageToJwk,
    pkcs1MessageToRSAPrivateKey: () => pkcs1MessageToRSAPrivateKey,
    pkcs1ToJwk: () => pkcs1ToJwk,
    pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey,
    pkixMessageToJwk: () => pkixMessageToJwk,
    pkixMessageToRSAPublicKey: () => pkixMessageToRSAPublicKey,
    pkixToJwk: () => pkixToJwk,
    pkixToRSAPublicKey: () => pkixToRSAPublicKey
  });

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
  var RSAPublicKey = class {
    type = "RSA";
    jwk;
    _raw;
    _multihash;
    constructor(jwk, digest2) {
      this.jwk = jwk;
      this._multihash = digest2;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = utils_exports.jwkToPkix(this.jwk);
      }
      return this._raw;
    }
    toMultihash() {
      return this._multihash;
    }
    toCID() {
      return CID.createV1(114, this._multihash);
    }
    toString() {
      return base58btc.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    verify(data, sig, options2) {
      return hashAndVerify3(this.jwk, sig, data, options2);
    }
  };
  var RSAPrivateKey = class {
    type = "RSA";
    jwk;
    _raw;
    publicKey;
    constructor(jwk, publicKey2) {
      this.jwk = jwk;
      this.publicKey = publicKey2;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = utils_exports.jwkToPkcs1(this.jwk);
      }
      return this._raw;
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    sign(message2, options2) {
      return hashAndSign3(this.jwk, message2, options2);
    }
  };

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
  var MAX_RSA_KEY_SIZE = 8192;
  var SHA2_256_CODE = 18;
  var MAX_RSA_JWK_SIZE = 1062;
  var RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
    48,
    13,
    6,
    9,
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    1,
    5,
    0
  ]);
  function pkcs1ToJwk(bytes) {
    const message2 = decodeDer(bytes);
    return pkcs1MessageToJwk(message2);
  }
  function pkcs1MessageToJwk(message2) {
    return {
      n: toString2(message2[1], "base64url"),
      e: toString2(message2[2], "base64url"),
      d: toString2(message2[3], "base64url"),
      p: toString2(message2[4], "base64url"),
      q: toString2(message2[5], "base64url"),
      dp: toString2(message2[6], "base64url"),
      dq: toString2(message2[7], "base64url"),
      qi: toString2(message2[8], "base64url"),
      kty: "RSA"
    };
  }
  function jwkToPkcs1(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new InvalidParametersError("JWK was missing components");
    }
    return encodeSequence([
      encodeInteger(Uint8Array.from([0])),
      encodeInteger(fromString2(jwk.n, "base64url")),
      encodeInteger(fromString2(jwk.e, "base64url")),
      encodeInteger(fromString2(jwk.d, "base64url")),
      encodeInteger(fromString2(jwk.p, "base64url")),
      encodeInteger(fromString2(jwk.q, "base64url")),
      encodeInteger(fromString2(jwk.dp, "base64url")),
      encodeInteger(fromString2(jwk.dq, "base64url")),
      encodeInteger(fromString2(jwk.qi, "base64url"))
    ]).subarray();
  }
  function pkixToJwk(bytes) {
    const message2 = decodeDer(bytes, {
      offset: 0
    });
    return pkixMessageToJwk(message2);
  }
  function pkixMessageToJwk(message2) {
    const keys = decodeDer(message2[1], {
      offset: 0
    });
    return {
      kty: "RSA",
      n: toString2(keys[0], "base64url"),
      e: toString2(keys[1], "base64url")
    };
  }
  function jwkToPkix(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new InvalidParametersError("JWK was missing components");
    }
    const subjectPublicKeyInfo = encodeSequence([
      RSA_ALGORITHM_IDENTIFIER,
      encodeBitString(encodeSequence([
        encodeInteger(fromString2(jwk.n, "base64url")),
        encodeInteger(fromString2(jwk.e, "base64url"))
      ]))
    ]);
    return subjectPublicKeyInfo.subarray();
  }
  function pkcs1ToRSAPrivateKey(bytes) {
    const message2 = decodeDer(bytes);
    return pkcs1MessageToRSAPrivateKey(message2);
  }
  function pkcs1MessageToRSAPrivateKey(message2) {
    const jwk = pkcs1MessageToJwk(message2);
    return jwkToRSAPrivateKey(jwk);
  }
  function pkixToRSAPublicKey(bytes, digest2) {
    if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {
      throw new InvalidPublicKeyError("Key size is too large");
    }
    const message2 = decodeDer(bytes, {
      offset: 0
    });
    return pkixMessageToRSAPublicKey(message2, bytes, digest2);
  }
  function pkixMessageToRSAPublicKey(message2, bytes, digest2) {
    const jwk = pkixMessageToJwk(message2);
    if (digest2 == null) {
      const hash = sha2562(PublicKey.encode({
        Type: KeyType.RSA,
        Data: bytes
      }));
      digest2 = create(SHA2_256_CODE, hash);
    }
    return new RSAPublicKey(jwk, digest2);
  }
  function jwkToRSAPrivateKey(jwk) {
    if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {
      throw new InvalidParametersError("Key size is too large");
    }
    const keys = jwkToJWKKeyPair(jwk);
    const hash = sha2562(PublicKey.encode({
      Type: KeyType.RSA,
      Data: jwkToPkix(keys.publicKey)
    }));
    const digest2 = create(SHA2_256_CODE, hash);
    return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest2));
  }
  async function generateRSAKeyPair(bits2) {
    if (bits2 > MAX_RSA_KEY_SIZE) {
      throw new InvalidParametersError("Key size is too large");
    }
    const keys = await generateRSAKey(bits2);
    const hash = sha2562(PublicKey.encode({
      Type: KeyType.RSA,
      Data: jwkToPkix(keys.publicKey)
    }));
    const digest2 = create(SHA2_256_CODE, hash);
    return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest2));
  }
  function jwkToJWKKeyPair(key) {
    if (key == null) {
      throw new InvalidParametersError("Missing key parameter");
    }
    return {
      privateKey: key,
      publicKey: {
        kty: key.kty,
        n: key.n,
        e: key.e
      }
    };
  }

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
  async function generateRSAKey(bits2, options2) {
    const pair = await webcrypto_default.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits2,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    options2?.signal?.throwIfAborted();
    const keys = await exportKey(pair, options2);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign3(key, msg, options2) {
    const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    options2?.signal?.throwIfAborted();
    const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
    options2?.signal?.throwIfAborted();
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify3(key, sig, msg, options2) {
    const publicKey2 = await webcrypto_default.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    options2?.signal?.throwIfAborted();
    const result = await webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey2, sig, msg instanceof Uint8Array ? msg : msg.subarray());
    options2?.signal?.throwIfAborted();
    return result;
  }
  async function exportKey(pair, options2) {
    if (pair.privateKey == null || pair.publicKey == null) {
      throw new InvalidParametersError("Private and public key are required");
    }
    const result = await Promise.all([
      webcrypto_default.get().subtle.exportKey("jwk", pair.privateKey),
      webcrypto_default.get().subtle.exportKey("jwk", pair.publicKey)
    ]);
    options2?.signal?.throwIfAborted();
    return result;
  }
  function rsaKeySize(jwk) {
    if (jwk.kty !== "RSA") {
      throw new InvalidParametersError("invalid key type");
    } else if (jwk.n == null) {
      throw new InvalidParametersError("invalid key modulus");
    }
    const bytes = fromString2(jwk.n, "base64url");
    return bytes.length * 8;
  }

  // node_modules/@noble/hashes/hmac.js
  var _HMAC = class {
    oHash;
    iHash;
    blockLen;
    outputLen;
    finished = false;
    destroyed = false;
    constructor(hash, key) {
      ahash(hash);
      abytes(key, void 0, "key");
      this.iHash = hash.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
      for (let i2 = 0; i2 < pad.length; i2++)
        pad[i2] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash.create();
      for (let i2 = 0; i2 < pad.length; i2++)
        pad[i2] ^= 54 ^ 92;
      this.oHash.update(pad);
      clean(pad);
    }
    update(buf2) {
      aexists(this);
      this.iHash.update(buf2);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen, "output");
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to ||= Object.create(Object.getPrototypeOf(this), {});
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash, key, message2) => new _HMAC(hash, key).update(message2).digest();
  hmac.create = (hash, key) => new _HMAC(hash, key);

  // node_modules/@noble/curves/abstract/weierstrass.js
  var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n5) / den;
  function _splitEndoScalar(k, basis, n2) {
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n2);
    const c2 = divNearest(-b1 * k, n2);
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n6;
    const k2neg = k2 < _0n6;
    if (k1neg)
      k1 = -k1;
    if (k2neg)
      k2 = -k2;
    const MAX_NUM = bitMask(Math.ceil(bitLen(n2) / 2)) + _1n7;
    if (k1 < _0n6 || k1 >= MAX_NUM || k2 < _0n6 || k2 >= MAX_NUM) {
      throw new Error("splitScalar (endomorphism): failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
  function validateSigFormat(format3) {
    if (!["compact", "recovered", "der"].includes(format3))
      throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format3;
  }
  function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
      optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
    }
    abool(optsn.lowS, "lowS");
    abool(optsn.prehash, "prehash");
    if (optsn.format !== void 0)
      validateSigFormat(optsn.format);
    return optsn;
  }
  var DERErr = class extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  };
  var DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
        const t2 = numberToHexUnpadded(tag);
        return t2 + lenLen + len + data;
      },
      // v - value, l - left bytes (unparsed)
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first2 = data[pos++];
        const isLong = !!(first2 & 128);
        let length4 = 0;
        if (!isLong)
          length4 = first2;
        else {
          const lenLen = first2 & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length4 = length4 << 8 | b;
          pos += lenLen;
          if (length4 < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length4);
        if (v.length !== length4)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length4) };
      }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
      encode(num) {
        const { Err: E } = DER;
        if (num < _0n6)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return bytesToNumberBE(data);
      }
    },
    toSig(bytes) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = abytes(bytes, void 0, "signature");
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  var _0n6 = BigInt(0);
  var _1n7 = BigInt(1);
  var _2n5 = BigInt(2);
  var _3n3 = BigInt(3);
  var _4n2 = BigInt(4);
  function weierstrass(params, extraOpts = {}) {
    const validated = createCurveFields("weierstrass", params, extraOpts);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    validateObject(extraOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object"
    });
    const { endo } = extraOpts;
    if (endo) {
      if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
      }
    }
    const lengths = getWLengths(Fp, Fn);
    function assertCompressionIsSupported() {
      if (!Fp.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes(_c, point, isCompressed) {
      const { x, y } = point.toAffine();
      const bx = Fp.toBytes(x);
      abool(isCompressed, "isCompressed");
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp.isOdd(y);
        return concatBytes(pprefix(hasEvenY), bx);
      } else {
        return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y));
      }
    }
    function pointFromBytes(bytes) {
      abytes(bytes, void 0, "Point");
      const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
      const length4 = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (length4 === comp && (head === 2 || head === 3)) {
        const x = Fp.fromBytes(tail);
        if (!Fp.isValid(x))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp.sqrt(y2);
        } catch (sqrtError) {
          const err2 = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err2);
        }
        assertCompressionIsSupported();
        const evenY = Fp.isOdd(y);
        const evenH = (head & 1) === 1;
        if (evenH !== evenY)
          y = Fp.neg(y);
        return { x, y };
      } else if (length4 === uncomp && head === 4) {
        const L = Fp.BYTES;
        const x = Fp.fromBytes(tail.subarray(0, L));
        const y = Fp.fromBytes(tail.subarray(L, L * 2));
        if (!isValidXY(x, y))
          throw new Error("bad point: is not on curve");
        return { x, y };
      } else {
        throw new Error(`bad point: got length ${length4}, expected compressed=${comp} or uncompressed=${uncomp}`);
      }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
      const x2 = Fp.sqr(x);
      const x3 = Fp.mul(x2, x);
      return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
    }
    function isValidXY(x, y) {
      const left = Fp.sqr(y);
      const right = weierstrassEquation(x);
      return Fp.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n3), _4n2);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n2, banZero = false) {
      if (!Fp.isValid(n2) || banZero && Fp.is0(n2))
        throw new Error(`bad point coordinate ${title}`);
      return n2;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point))
        throw new Error("Weierstrass Point expected");
    }
    function splitEndoScalarN(k) {
      if (!endo || !endo.basises)
        throw new Error("no endo");
      return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    const toAffineMemo = memoized((p2, iz) => {
      const { X, Y, Z } = p2;
      if (Fp.eql(Z, Fp.ONE))
        return { x: X, y: Y };
      const is0 = p2.is0();
      if (iz == null)
        iz = is0 ? Fp.ONE : Fp.inv(Z);
      const x = Fp.mul(X, iz);
      const y = Fp.mul(Y, iz);
      const zz = Fp.mul(Z, iz);
      if (is0)
        return { x: Fp.ZERO, y: Fp.ZERO };
      if (!Fp.eql(zz, Fp.ONE))
        throw new Error("invZ was invalid");
      return { x, y };
    });
    const assertValidMemo = memoized((p2) => {
      if (p2.is0()) {
        if (extraOpts.allowInfinityPoint && !Fp.is0(p2.Y))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p2.toAffine();
      if (!Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y))
        throw new Error("bad point: equation left != right");
      if (!p2.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
      k1p = negateCt(k1neg, k1p);
      k2p = negateCt(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point {
      // base / generator point
      static BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      // zero / infinity / identity point
      static ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      // 0, 1, 0
      // math field
      static Fp = Fp;
      // scalar field
      static Fn = Fn;
      X;
      Y;
      Z;
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(X, Y, Z) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y, true);
        this.Z = acoord("z", Z);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE;
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p2) {
        const { x, y } = p2 || {};
        if (!p2 || !Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("invalid affine point");
        if (p2 instanceof Point)
          throw new Error("projective point not allowed");
        if (Fp.is0(x) && Fp.is0(y))
          return Point.ZERO;
        return new Point(x, y, Fp.ONE);
      }
      static fromBytes(bytes) {
        const P = Point.fromAffine(decodePoint(abytes(bytes, void 0, "point")));
        P.assertValidity();
        return P;
      }
      static fromHex(hex) {
        return Point.fromBytes(hexToBytes(hex));
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_3n3);
        return this;
      }
      // TODO: return `this`
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp.isOdd(y);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
        const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point(this.X, Fp.neg(this.Y), this.Z);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: a2, b } = CURVE;
        const b3 = Fp.mul(b, _3n3);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
        let t0 = Fp.mul(X1, X1);
        let t1 = Fp.mul(Y1, Y1);
        let t2 = Fp.mul(Z1, Z1);
        let t3 = Fp.mul(X1, Y1);
        t3 = Fp.add(t3, t3);
        Z3 = Fp.mul(X1, Z1);
        Z3 = Fp.add(Z3, Z3);
        X3 = Fp.mul(a2, Z3);
        Y3 = Fp.mul(b3, t2);
        Y3 = Fp.add(X3, Y3);
        X3 = Fp.sub(t1, Y3);
        Y3 = Fp.add(t1, Y3);
        Y3 = Fp.mul(X3, Y3);
        X3 = Fp.mul(t3, X3);
        Z3 = Fp.mul(b3, Z3);
        t2 = Fp.mul(a2, t2);
        t3 = Fp.sub(t0, t2);
        t3 = Fp.mul(a2, t3);
        t3 = Fp.add(t3, Z3);
        Z3 = Fp.add(t0, t0);
        t0 = Fp.add(Z3, t0);
        t0 = Fp.add(t0, t2);
        t0 = Fp.mul(t0, t3);
        Y3 = Fp.add(Y3, t0);
        t2 = Fp.mul(Y1, Z1);
        t2 = Fp.add(t2, t2);
        t0 = Fp.mul(t2, t3);
        X3 = Fp.sub(X3, t0);
        Z3 = Fp.mul(t2, t1);
        Z3 = Fp.add(Z3, Z3);
        Z3 = Fp.add(Z3, Z3);
        return new Point(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
        const a2 = CURVE.a;
        const b3 = Fp.mul(CURVE.b, _3n3);
        let t0 = Fp.mul(X1, X2);
        let t1 = Fp.mul(Y1, Y2);
        let t2 = Fp.mul(Z1, Z2);
        let t3 = Fp.add(X1, Y1);
        let t4 = Fp.add(X2, Y2);
        t3 = Fp.mul(t3, t4);
        t4 = Fp.add(t0, t1);
        t3 = Fp.sub(t3, t4);
        t4 = Fp.add(X1, Z1);
        let t5 = Fp.add(X2, Z2);
        t4 = Fp.mul(t4, t5);
        t5 = Fp.add(t0, t2);
        t4 = Fp.sub(t4, t5);
        t5 = Fp.add(Y1, Z1);
        X3 = Fp.add(Y2, Z2);
        t5 = Fp.mul(t5, X3);
        X3 = Fp.add(t1, t2);
        t5 = Fp.sub(t5, X3);
        Z3 = Fp.mul(a2, t4);
        X3 = Fp.mul(b3, t2);
        Z3 = Fp.add(X3, Z3);
        X3 = Fp.sub(t1, Z3);
        Z3 = Fp.add(t1, Z3);
        Y3 = Fp.mul(X3, Z3);
        t1 = Fp.add(t0, t0);
        t1 = Fp.add(t1, t0);
        t2 = Fp.mul(a2, t2);
        t4 = Fp.mul(b3, t4);
        t1 = Fp.add(t1, t2);
        t2 = Fp.sub(t0, t2);
        t2 = Fp.mul(a2, t2);
        t4 = Fp.add(t4, t2);
        t0 = Fp.mul(t1, t4);
        Y3 = Fp.add(Y3, t0);
        t0 = Fp.mul(t5, t4);
        X3 = Fp.mul(t3, X3);
        X3 = Fp.sub(X3, t0);
        t0 = Fp.mul(t3, t1);
        Z3 = Fp.mul(t5, Z3);
        Z3 = Fp.add(Z3, t0);
        return new Point(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo2 } = extraOpts;
        if (!Fn.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul = (n2) => wnaf.cached(this, n2, (p2) => normalizeZ(Point, p2));
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
          const { p: k1p, f: k1f } = mul(k1);
          const { p: k2p, f: k2f } = mul(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p: p2, f: f2 } = mul(scalar);
          point = p2;
          fake = f2;
        }
        return normalizeZ(Point, [point, fake])[0];
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed secret key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo2 } = extraOpts;
        const p2 = this;
        if (!Fn.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n6 || p2.is0())
          return Point.ZERO;
        if (sc === _1n7)
          return p2;
        if (wnaf.hasCache(this))
          return this.multiply(sc);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
          const { p1, p2: p22 } = mulEndoUnsafe(Point, p2, k1, k2);
          return finishEndo(endo2.beta, p1, p22, k1neg, k2neg);
        } else {
          return wnaf.unsafe(p2, sc);
        }
      }
      /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */
      isTorsionFree() {
        const { isTorsionFree } = extraOpts;
        if (cofactor === _1n7)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point, this);
        return wnaf.unsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = extraOpts;
        if (cofactor === _1n7)
          return this;
        if (clearCofactor)
          return clearCofactor(Point, this);
        return this.multiplyUnsafe(cofactor);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      toBytes(isCompressed = true) {
        abool(isCompressed, "isCompressed");
        this.assertValidity();
        return encodePoint(Point, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    const bits2 = Fn.BITS;
    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits2 / 2) : bits2);
    Point.BASE.precompute(8);
    return Point;
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function getWLengths(Fp, Fn) {
    return {
      secretKey: Fn.BYTES,
      publicKey: 1 + Fp.BYTES,
      publicKeyUncompressed: 1 + 2 * Fp.BYTES,
      publicKeyHasPrefix: true,
      signature: 2 * Fn.BYTES
    };
  }
  function ecdh(Point, ecdhOpts = {}) {
    const { Fn } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });
    function isValidSecretKey(secretKey) {
      try {
        const num = Fn.fromBytes(secretKey);
        return Fn.isValidNot0(num);
      } catch (error) {
        return false;
      }
    }
    function isValidPublicKey(publicKey2, isCompressed) {
      const { publicKey: comp, publicKeyUncompressed } = lengths;
      try {
        const l2 = publicKey2.length;
        if (isCompressed === true && l2 !== comp)
          return false;
        if (isCompressed === false && l2 !== publicKeyUncompressed)
          return false;
        return !!Point.fromBytes(publicKey2);
      } catch (error) {
        return false;
      }
    }
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
      return mapHashToField(abytes(seed, lengths.seed, "seed"), Fn.ORDER);
    }
    function getPublicKey(secretKey, isCompressed = true) {
      return Point.BASE.multiply(Fn.fromBytes(secretKey)).toBytes(isCompressed);
    }
    function isProbPub(item) {
      const { secretKey, publicKey: publicKey2, publicKeyUncompressed } = lengths;
      if (!isBytes(item))
        return void 0;
      if ("_lengths" in Fn && Fn._lengths || secretKey === publicKey2)
        return void 0;
      const l2 = abytes(item, void 0, "key").length;
      return l2 === publicKey2 || l2 === publicKeyUncompressed;
    }
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
      if (isProbPub(secretKeyA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicKeyB) === false)
        throw new Error("second arg must be public key");
      const s2 = Fn.fromBytes(secretKeyA);
      const b = Point.fromBytes(publicKeyB);
      return b.multiply(s2).toBytes(isCompressed);
    }
    const utils = {
      isValidSecretKey,
      isValidPublicKey,
      randomSecretKey
    };
    const keygen = createKeygen(randomSecretKey, getPublicKey);
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
  }
  function ecdsa(Point, hash, ecdsaOpts = {}) {
    ahash(hash);
    validateObject(ecdsaOpts, {}, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    ecdsaOpts = Object.assign({}, ecdsaOpts);
    const randomBytes4 = ecdsaOpts.randomBytes || randomBytes;
    const hmac2 = ecdsaOpts.hmac || ((key, msg) => hmac(hash, key, msg));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
      prehash: true,
      lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : true,
      format: "compact",
      extraEntropy: false
    };
    const hasLargeCofactor = CURVE_ORDER * _2n5 < Fp.ORDER;
    function isBiggerThanHalfOrder(number) {
      const HALF = CURVE_ORDER >> _1n7;
      return number > HALF;
    }
    function validateRS(title, num) {
      if (!Fn.isValidNot0(num))
        throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
      return num;
    }
    function assertSmallCofactor() {
      if (hasLargeCofactor)
        throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
    }
    function validateSigLength(bytes, format3) {
      validateSigFormat(format3);
      const size = lengths.signature;
      const sizer = format3 === "compact" ? size : format3 === "recovered" ? size + 1 : void 0;
      return abytes(bytes, sizer);
    }
    class Signature2 {
      r;
      s;
      recovery;
      constructor(r2, s2, recovery) {
        this.r = validateRS("r", r2);
        this.s = validateRS("s", s2);
        if (recovery != null) {
          assertSmallCofactor();
          if (![0, 1, 2, 3].includes(recovery))
            throw new Error("invalid recovery id");
          this.recovery = recovery;
        }
        Object.freeze(this);
      }
      static fromBytes(bytes, format3 = defaultSigOpts.format) {
        validateSigLength(bytes, format3);
        let recid;
        if (format3 === "der") {
          const { r: r3, s: s3 } = DER.toSig(abytes(bytes));
          return new Signature2(r3, s3);
        }
        if (format3 === "recovered") {
          recid = bytes[0];
          format3 = "compact";
          bytes = bytes.subarray(1);
        }
        const L = lengths.signature / 2;
        const r2 = bytes.subarray(0, L);
        const s2 = bytes.subarray(L, L * 2);
        return new Signature2(Fn.fromBytes(r2), Fn.fromBytes(s2), recid);
      }
      static fromHex(hex, format3) {
        return this.fromBytes(hexToBytes(hex), format3);
      }
      assertRecovery() {
        const { recovery } = this;
        if (recovery == null)
          throw new Error("invalid recovery id: must be present");
        return recovery;
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(messageHash) {
        const { r: r2, s: s2 } = this;
        const recovery = this.assertRecovery();
        const radj = recovery === 2 || recovery === 3 ? r2 + CURVE_ORDER : r2;
        if (!Fp.isValid(radj))
          throw new Error("invalid recovery id: sig.r+curve.n != R.x");
        const x = Fp.toBytes(radj);
        const R = Point.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));
        const ir = Fn.inv(radj);
        const h = bits2int_modN(abytes(messageHash, void 0, "msgHash"));
        const u1 = Fn.create(-h * ir);
        const u2 = Fn.create(s2 * ir);
        const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("invalid recovery: point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      toBytes(format3 = defaultSigOpts.format) {
        validateSigFormat(format3);
        if (format3 === "der")
          return hexToBytes(DER.hexFromSig(this));
        const { r: r2, s: s2 } = this;
        const rb = Fn.toBytes(r2);
        const sb = Fn.toBytes(s2);
        if (format3 === "recovered") {
          assertSmallCofactor();
          return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);
        }
        return concatBytes(rb, sb);
      }
      toHex(format3) {
        return bytesToHex(this.toBytes(format3));
      }
    }
    const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
      if (bytes.length > 8192)
        throw new Error("input is too large");
      const num = bytesToNumberBE(bytes);
      const delta = bytes.length * 8 - fnBits;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
      return Fn.create(bits2int(bytes));
    };
    const ORDER_MASK = bitMask(fnBits);
    function int2octets(num) {
      aInRange("num < 2^" + fnBits, num, _0n6, ORDER_MASK);
      return Fn.toBytes(num);
    }
    function validateMsgAndHash(message2, prehash) {
      abytes(message2, void 0, "message");
      return prehash ? abytes(hash(message2), void 0, "prehashed message") : message2;
    }
    function prepSig(message2, secretKey, opts) {
      const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
      message2 = validateMsgAndHash(message2, prehash);
      const h1int = bits2int_modN(message2);
      const d2 = Fn.fromBytes(secretKey);
      if (!Fn.isValidNot0(d2))
        throw new Error("invalid private key");
      const seedArgs = [int2octets(d2), int2octets(h1int)];
      if (extraEntropy != null && extraEntropy !== false) {
        const e2 = extraEntropy === true ? randomBytes4(lengths.secretKey) : extraEntropy;
        seedArgs.push(abytes(e2, void 0, "extraEntropy"));
      }
      const seed = concatBytes(...seedArgs);
      const m2 = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn.isValidNot0(k))
          return;
        const ik = Fn.inv(k);
        const q = Point.BASE.multiply(k).toAffine();
        const r2 = Fn.create(q.x);
        if (r2 === _0n6)
          return;
        const s2 = Fn.create(ik * Fn.create(m2 + r2 * d2));
        if (s2 === _0n6)
          return;
        let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n7);
        let normS = s2;
        if (lowS && isBiggerThanHalfOrder(s2)) {
          normS = Fn.neg(s2);
          recovery ^= 1;
        }
        return new Signature2(r2, normS, hasLargeCofactor ? void 0 : recovery);
      }
      return { seed, k2sig };
    }
    function sign(message2, secretKey, opts = {}) {
      const { seed, k2sig } = prepSig(message2, secretKey, opts);
      const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac2);
      const sig = drbg(seed, k2sig);
      return sig.toBytes(opts.format);
    }
    function verify(signature, message2, publicKey2, opts = {}) {
      const { lowS, prehash, format: format3 } = validateSigOpts(opts, defaultSigOpts);
      publicKey2 = abytes(publicKey2, void 0, "publicKey");
      message2 = validateMsgAndHash(message2, prehash);
      if (!isBytes(signature)) {
        const end = signature instanceof Signature2 ? ", use sig.toBytes()" : "";
        throw new Error("verify expects Uint8Array signature" + end);
      }
      validateSigLength(signature, format3);
      try {
        const sig = Signature2.fromBytes(signature, format3);
        const P = Point.fromBytes(publicKey2);
        if (lowS && sig.hasHighS())
          return false;
        const { r: r2, s: s2 } = sig;
        const h = bits2int_modN(message2);
        const is2 = Fn.inv(s2);
        const u1 = Fn.create(h * is2);
        const u2 = Fn.create(r2 * is2);
        const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
          return false;
        const v = Fn.create(R.x);
        return v === r2;
      } catch (e2) {
        return false;
      }
    }
    function recoverPublicKey(signature, message2, opts = {}) {
      const { prehash } = validateSigOpts(opts, defaultSigOpts);
      message2 = validateMsgAndHash(message2, prehash);
      return Signature2.fromBytes(signature, "recovered").recoverPublicKey(message2).toBytes();
    }
    return Object.freeze({
      keygen,
      getPublicKey,
      getSharedSecret,
      utils,
      lengths,
      Point,
      sign,
      verify,
      recoverPublicKey,
      Signature: Signature2,
      hash
    });
  }

  // node_modules/@noble/curves/secp256k1.js
  var secp256k1_CURVE = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  var secp256k1_ENDO = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [
      [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
      [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
    ]
  };
  var _2n6 = /* @__PURE__ */ BigInt(2);
  function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n4, P) * b3 % P;
    const b9 = pow2(b6, _3n4, P) * b3 % P;
    const b11 = pow2(b9, _2n6, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n4, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n6, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
  var Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {
    Fp: Fpk1,
    endo: secp256k1_ENDO
  });
  var secp256k1 = /* @__PURE__ */ ecdsa(Pointk1, sha2562);

  // node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
  var PRIVATE_KEY_BYTE_LENGTH2 = 32;
  function hashAndSign4(key, msg, options2) {
    const p2 = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if (isPromise(p2)) {
      return p2.then(({ digest: digest2 }) => {
        options2?.signal?.throwIfAborted();
        return secp256k1.sign(digest2, key, {
          prehash: false,
          format: "der"
        });
      }).catch((err2) => {
        if (err2.name === "AbortError") {
          throw err2;
        }
        throw new SigningError(String(err2));
      });
    }
    try {
      return secp256k1.sign(p2.digest, key, {
        prehash: false,
        format: "der"
      });
    } catch (err2) {
      throw new SigningError(String(err2));
    }
  }
  function hashAndVerify4(key, sig, msg, options2) {
    const p2 = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if (isPromise(p2)) {
      return p2.then(({ digest: digest2 }) => {
        options2?.signal?.throwIfAborted();
        return secp256k1.verify(sig, digest2, key, {
          prehash: false,
          format: "der"
        });
      }).catch((err2) => {
        if (err2.name === "AbortError") {
          throw err2;
        }
        throw new VerificationError(String(err2));
      });
    }
    try {
      options2?.signal?.throwIfAborted();
      return secp256k1.verify(sig, p2.digest, key, {
        prehash: false,
        format: "der"
      });
    } catch (err2) {
      throw new VerificationError(String(err2));
    }
  }

  // node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
  var Secp256k1PublicKey = class {
    type = "secp256k1";
    raw;
    _key;
    constructor(key) {
      this._key = validateSecp256k1PublicKey(key);
      this.raw = compressSecp256k1PublicKey(this._key);
    }
    toMultihash() {
      return identity.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    verify(data, sig, options2) {
      return hashAndVerify4(this._key, sig, data, options2);
    }
  };
  var Secp256k1PrivateKey = class {
    type = "secp256k1";
    raw;
    publicKey;
    constructor(key, publicKey2) {
      this.raw = validateSecp256k1PrivateKey(key);
      this.publicKey = new Secp256k1PublicKey(publicKey2 ?? computeSecp256k1PublicKey(key));
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    sign(message2, options2) {
      return hashAndSign4(this.raw, message2, options2);
    }
  };

  // node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
  function unmarshalSecp256k1PrivateKey(bytes) {
    return new Secp256k1PrivateKey(bytes);
  }
  function unmarshalSecp256k1PublicKey(bytes) {
    return new Secp256k1PublicKey(bytes);
  }
  async function generateSecp256k1KeyPair() {
    const privateKeyBytes = generateSecp256k1PrivateKey();
    return new Secp256k1PrivateKey(privateKeyBytes);
  }
  function compressSecp256k1PublicKey(key) {
    return secp256k1.Point.fromBytes(key).toBytes();
  }
  function validateSecp256k1PrivateKey(key) {
    try {
      secp256k1.getPublicKey(key, true);
      return key;
    } catch (err2) {
      throw new InvalidPrivateKeyError(String(err2));
    }
  }
  function validateSecp256k1PublicKey(key) {
    try {
      secp256k1.Point.fromBytes(key);
      return key;
    } catch (err2) {
      throw new InvalidPublicKeyError(String(err2));
    }
  }
  function computeSecp256k1PublicKey(privateKey) {
    try {
      return secp256k1.getPublicKey(privateKey, true);
    } catch (err2) {
      throw new InvalidPrivateKeyError(String(err2));
    }
  }
  function generateSecp256k1PrivateKey() {
    return secp256k1.utils.randomSecretKey();
  }

  // node_modules/@libp2p/crypto/dist/src/keys/index.js
  async function generateKeyPair(type, bits2) {
    if (type === "Ed25519") {
      return generateEd25519KeyPair();
    }
    if (type === "secp256k1") {
      return generateSecp256k1KeyPair();
    }
    if (type === "RSA") {
      return generateRSAKeyPair(toBits(bits2));
    }
    if (type === "ECDSA") {
      return generateECDSAKeyPair(toCurve(bits2));
    }
    throw new UnsupportedKeyTypeError();
  }
  function publicKeyFromProtobuf(buf2, digest2) {
    const { Type: Type2, Data: Data2 } = PublicKey.decode(buf2);
    const data = Data2 ?? new Uint8Array();
    switch (Type2) {
      case KeyType.RSA:
        return pkixToRSAPublicKey(data, digest2);
      case KeyType.Ed25519:
        return unmarshalEd25519PublicKey(data);
      case KeyType.secp256k1:
        return unmarshalSecp256k1PublicKey(data);
      case KeyType.ECDSA:
        return unmarshalECDSAPublicKey(data);
      default:
        throw new UnsupportedKeyTypeError();
    }
  }
  function publicKeyFromMultihash(digest2) {
    const { Type: Type2, Data: Data2 } = PublicKey.decode(digest2.digest);
    const data = Data2 ?? new Uint8Array();
    switch (Type2) {
      case KeyType.Ed25519:
        return unmarshalEd25519PublicKey(data);
      case KeyType.secp256k1:
        return unmarshalSecp256k1PublicKey(data);
      case KeyType.ECDSA:
        return unmarshalECDSAPublicKey(data);
      default:
        throw new UnsupportedKeyTypeError();
    }
  }
  function publicKeyToProtobuf(key) {
    return PublicKey.encode({
      Type: KeyType[key.type],
      Data: key.raw
    });
  }
  function privateKeyFromProtobuf(buf2) {
    const decoded = PrivateKey.decode(buf2);
    const data = decoded.Data ?? new Uint8Array();
    switch (decoded.Type) {
      case KeyType.RSA:
        return pkcs1ToRSAPrivateKey(data);
      case KeyType.Ed25519:
        return unmarshalEd25519PrivateKey(data);
      case KeyType.secp256k1:
        return unmarshalSecp256k1PrivateKey(data);
      case KeyType.ECDSA:
        return unmarshalECDSAPrivateKey(data);
      default:
        throw new UnsupportedKeyTypeError();
    }
  }
  function privateKeyFromRaw(buf2) {
    if (buf2.byteLength === PRIVATE_KEY_BYTE_LENGTH) {
      return unmarshalEd25519PrivateKey(buf2);
    } else if (buf2.byteLength === PRIVATE_KEY_BYTE_LENGTH2) {
      return unmarshalSecp256k1PrivateKey(buf2);
    }
    const message2 = decodeDer(buf2);
    const ecdsaOid = message2[2]?.[0];
    if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {
      return pkiMessageToECDSAPrivateKey(message2);
    }
    if (message2.length > 8) {
      return pkcs1MessageToRSAPrivateKey(message2);
    }
    throw new InvalidParametersError("Could not extract private key from raw bytes");
  }
  function privateKeyToProtobuf(key) {
    return PrivateKey.encode({
      Type: KeyType[key.type],
      Data: key.raw
    });
  }
  function toBits(bits2) {
    if (bits2 == null) {
      return 2048;
    }
    return parseInt(bits2, 10);
  }
  function toCurve(curve) {
    if (curve === "P-256" || curve == null) {
      return "P-256";
    }
    if (curve === "P-384") {
      return "P-384";
    }
    if (curve === "P-521") {
      return "P-521";
    }
    throw new InvalidParametersError("Unsupported curve, should be P-256, P-384 or P-521");
  }
  async function privateKeyToCryptoKeyPair(privateKey) {
    if (privateKey.type === "RSA") {
      return {
        privateKey: await crypto.subtle.importKey("jwk", privateKey.jwk, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, true, ["sign"]),
        publicKey: await crypto.subtle.importKey("jwk", privateKey.publicKey.jwk, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, true, ["verify"])
      };
    }
    if (privateKey.type === "ECDSA") {
      return {
        privateKey: await crypto.subtle.importKey("jwk", privateKey.jwk, {
          name: "ECDSA",
          namedCurve: privateKey.jwk.crv ?? "P-256"
        }, true, ["sign"]),
        publicKey: await crypto.subtle.importKey("jwk", privateKey.publicKey.jwk, {
          name: "ECDSA",
          namedCurve: privateKey.publicKey.jwk.crv ?? "P-256"
        }, true, ["verify"])
      };
    }
    throw new InvalidParametersError("Only RSA and ECDSA keys are supported");
  }

  // node_modules/@noble/hashes/legacy.js
  var SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ]);
  var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
  var _SHA1 = class extends HashMD {
    A = SHA1_IV[0] | 0;
    B = SHA1_IV[1] | 0;
    C = SHA1_IV[2] | 0;
    D = SHA1_IV[3] | 0;
    E = SHA1_IV[4] | 0;
    constructor() {
      super(64, 20, 8, false);
    }
    get() {
      const { A, B, C, D, E } = this;
      return [A, B, C, D, E];
    }
    set(A, B, C, D, E) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4)
        SHA1_W[i2] = view.getUint32(offset, false);
      for (let i2 = 16; i2 < 80; i2++)
        SHA1_W[i2] = rotl(SHA1_W[i2 - 3] ^ SHA1_W[i2 - 8] ^ SHA1_W[i2 - 14] ^ SHA1_W[i2 - 16], 1);
      let { A, B, C, D, E } = this;
      for (let i2 = 0; i2 < 80; i2++) {
        let F, K2;
        if (i2 < 20) {
          F = Chi(B, C, D);
          K2 = 1518500249;
        } else if (i2 < 40) {
          F = B ^ C ^ D;
          K2 = 1859775393;
        } else if (i2 < 60) {
          F = Maj(B, C, D);
          K2 = 2400959708;
        } else {
          F = B ^ C ^ D;
          K2 = 3395469782;
        }
        const T = rotl(A, 5) + F + E + K2 + SHA1_W[i2] | 0;
        E = D;
        D = C;
        C = rotl(B, 30);
        B = A;
        A = T;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      this.set(A, B, C, D, E);
    }
    roundClean() {
      clean(SHA1_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var sha1 = /* @__PURE__ */ createHasher(() => new _SHA1());

  // node_modules/@noble/hashes/pbkdf2.js
  function pbkdf2Init(hash, _password, _salt, _opts) {
    ahash(hash);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c: c2, dkLen, asyncTick } = opts;
    anumber(c2, "c");
    anumber(dkLen, "dkLen");
    anumber(asyncTick, "asyncTick");
    if (c2 < 1)
      throw new Error("iterations (c) must be >= 1");
    const password = kdfInputToBytes(_password, "password");
    const salt = kdfInputToBytes(_salt, "salt");
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    clean(u);
    return DK;
  }
  function pbkdf2(hash, password, salt, opts) {
    const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c2; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i2 = 0; i2 < Ti.length; i2++)
          Ti[i2] ^= u[i2];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  async function pbkdf2Async(hash, password, salt, opts) {
    const { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      await asyncLoop(c2 - 1, asyncTick, () => {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i2 = 0; i2 < Ti.length; i2++)
          Ti[i2] ^= u[i2];
      });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }

  // node_modules/@libp2p/crypto/dist/src/pbkdf2.js
  var hashName = {
    sha1,
    "sha2-256": sha2562,
    "sha2-512": sha5122
  };
  function pbkdf22(password, salt, iterations, keySize, hash) {
    if (hash !== "sha1" && hash !== "sha2-256" && hash !== "sha2-512") {
      const types2 = Object.keys(hashName).join(" / ");
      throw new InvalidParametersError(`Hash '${hash}' is unknown or not supported. Must be ${types2}`);
    }
    const hasher = hashName[hash];
    const dek = pbkdf2(hasher, password, salt, {
      c: iterations,
      dkLen: keySize
    });
    return base64.encode(dek).substring(1);
  }

  // node_modules/@sindresorhus/fnv1a/index.js
  var FNV_PRIMES = {
    32: 16777619n,
    64: 1099511628211n,
    128: 309485009821345068724781371n,
    256: 374144419156711147060143317175368453031918731002211n,
    512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
    1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
  };
  var FNV_OFFSETS = {
    32: 2166136261n,
    64: 14695981039346656037n,
    128: 144066263297769815596495629667062367629n,
    256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
    512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
    1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
  };
  var cachedEncoder = new globalThis.TextEncoder();
  function fnv1aUint8Array(uint8Array, size) {
    const fnvPrime = FNV_PRIMES[size];
    let hash = FNV_OFFSETS[size];
    for (let index = 0; index < uint8Array.length; index++) {
      hash ^= BigInt(uint8Array[index]);
      hash = BigInt.asUintN(size, hash * fnvPrime);
    }
    return hash;
  }
  function fnv1aEncodeInto(string2, size, utf8Buffer) {
    if (utf8Buffer.length === 0) {
      throw new Error("The `utf8Buffer` option must have a length greater than zero");
    }
    const fnvPrime = FNV_PRIMES[size];
    let hash = FNV_OFFSETS[size];
    let remaining = string2;
    while (remaining.length > 0) {
      const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
      remaining = remaining.slice(result.read);
      for (let index = 0; index < result.written; index++) {
        hash ^= BigInt(utf8Buffer[index]);
        hash = BigInt.asUintN(size, hash * fnvPrime);
      }
    }
    return hash;
  }
  function fnv1a(value2, { size = 32, utf8Buffer } = {}) {
    if (!FNV_PRIMES[size]) {
      throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
    }
    if (typeof value2 === "string") {
      if (utf8Buffer) {
        return fnv1aEncodeInto(value2, size, utf8Buffer);
      }
      value2 = cachedEncoder.encode(value2);
    }
    return fnv1aUint8Array(value2, size);
  }

  // node_modules/@libp2p/utils/dist/src/filters/hashes.js
  var fnv1a2 = {
    hash: (input) => {
      return Number(fnv1a(input, {
        size: 32
      }));
    },
    hashV: (input, seed) => {
      return numberToBuffer(fnv1a2.hash(input, seed));
    }
  };
  function numberToBuffer(num) {
    let hex = num.toString(16);
    if (hex.length % 2 === 1) {
      hex = `0${hex}`;
    }
    return fromString2(hex, "base16");
  }

  // node_modules/@libp2p/utils/dist/src/filters/fingerprint.js
  var MAX_FINGERPRINT_SIZE = 64;
  var Fingerprint = class {
    fp;
    h;
    seed;
    constructor(buf2, hash, seed, fingerprintSize = 2) {
      if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
        throw new TypeError("Invalid Fingerprint Size");
      }
      const fnv = hash.hashV(buf2, seed);
      const fp = alloc(fingerprintSize);
      for (let i2 = 0; i2 < fp.length; i2++) {
        fp[i2] = fnv[i2];
      }
      if (fp.length === 0) {
        fp[0] = 7;
      }
      this.fp = fp;
      this.h = hash;
      this.seed = seed;
    }
    hash() {
      return this.h.hash(this.fp, this.seed);
    }
    equals(other) {
      if (!(other?.fp instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.fp, other.fp);
    }
  };

  // node_modules/@libp2p/utils/dist/src/filters/utils.js
  function getRandomInt(min, max2) {
    return Math.floor(Math.random() * (max2 - min)) + min;
  }

  // node_modules/@libp2p/utils/dist/src/filters/bucket.js
  var Bucket = class {
    contents;
    constructor(size) {
      this.contents = new Array(size).fill(null);
    }
    has(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      return this.contents.some((fp) => {
        return fingerprint.equals(fp);
      });
    }
    add(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      for (let i2 = 0; i2 < this.contents.length; i2++) {
        if (this.contents[i2] == null) {
          this.contents[i2] = fingerprint;
          return true;
        }
      }
      return true;
    }
    swap(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      const i2 = getRandomInt(0, this.contents.length - 1);
      const current = this.contents[i2];
      this.contents[i2] = fingerprint;
      return current;
    }
    remove(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      const found = this.contents.findIndex((fp) => {
        return fingerprint.equals(fp);
      });
      if (found > -1) {
        this.contents[found] = null;
        return true;
      } else {
        return false;
      }
    }
  };

  // node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
  var maxCuckooCount = 500;
  var CuckooFilter = class {
    bucketSize;
    filterSize;
    fingerprintSize;
    buckets;
    count;
    hash;
    seed;
    constructor(init) {
      this.filterSize = init.filterSize;
      this.bucketSize = init.bucketSize ?? 4;
      this.fingerprintSize = init.fingerprintSize ?? 2;
      this.count = 0;
      this.buckets = [];
      this.hash = init.hash ?? fnv1a2;
      this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
    }
    add(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      if (this.buckets[j] == null) {
        this.buckets[j] = new Bucket(this.bucketSize);
      }
      if (this.buckets[k] == null) {
        this.buckets[k] = new Bucket(this.bucketSize);
      }
      if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
        this.count++;
        return true;
      }
      const rand = [j, k];
      let i2 = rand[getRandomInt(0, rand.length - 1)];
      if (this.buckets[i2] == null) {
        this.buckets[i2] = new Bucket(this.bucketSize);
      }
      for (let n2 = 0; n2 < maxCuckooCount; n2++) {
        const swapped = this.buckets[i2].swap(fingerprint);
        if (swapped == null) {
          continue;
        }
        i2 = (i2 ^ swapped.hash()) % this.filterSize;
        if (this.buckets[i2] == null) {
          this.buckets[i2] = new Bucket(this.bucketSize);
        }
        if (this.buckets[i2].add(swapped)) {
          this.count++;
          return true;
        } else {
          continue;
        }
      }
      return false;
    }
    has(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const inJ = this.buckets[j]?.has(fingerprint) ?? false;
      if (inJ) {
        return inJ;
      }
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      return this.buckets[k]?.has(fingerprint) ?? false;
    }
    remove(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const inJ = this.buckets[j]?.remove(fingerprint) ?? false;
      if (inJ) {
        this.count--;
        return inJ;
      }
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      const inK = this.buckets[k]?.remove(fingerprint) ?? false;
      if (inK) {
        this.count--;
      }
      return inK;
    }
    get reliable() {
      return Math.floor(100 * (this.count / this.filterSize)) <= 90;
    }
  };
  var MAX_LOAD = {
    1: 0.5,
    2: 0.84,
    4: 0.95,
    8: 0.98
  };
  function calculateBucketSize(errorRate = 1e-3) {
    if (errorRate > 2e-3) {
      return 2;
    }
    if (errorRate > 1e-5) {
      return 4;
    }
    return 8;
  }
  function optimize(maxItems, errorRate = 1e-3) {
    const bucketSize = calculateBucketSize(errorRate);
    const load2 = MAX_LOAD[bucketSize];
    const filterSize = Math.round(maxItems / load2);
    const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
    return {
      filterSize,
      bucketSize,
      fingerprintSize
    };
  }

  // node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js
  var ScalableCuckooFilter = class {
    filterSize;
    bucketSize;
    fingerprintSize;
    scale;
    filterSeries;
    hash;
    seed;
    constructor(init) {
      this.bucketSize = init.bucketSize ?? 4;
      this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;
      this.fingerprintSize = init.fingerprintSize ?? 2;
      this.scale = init.scale ?? 2;
      this.hash = init.hash ?? fnv1a2;
      this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
      this.filterSeries = [
        new CuckooFilter({
          filterSize: this.filterSize,
          bucketSize: this.bucketSize,
          fingerprintSize: this.fingerprintSize,
          hash: this.hash,
          seed: this.seed
        })
      ];
    }
    add(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      if (this.has(item)) {
        return true;
      }
      let current = this.filterSeries.find((cuckoo) => {
        return cuckoo.reliable;
      });
      if (current == null) {
        const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
        current = new CuckooFilter({
          filterSize: curSize,
          bucketSize: this.bucketSize,
          fingerprintSize: this.fingerprintSize,
          hash: this.hash,
          seed: this.seed
        });
        this.filterSeries.push(current);
      }
      return current.add(item);
    }
    has(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      for (let i2 = 0; i2 < this.filterSeries.length; i2++) {
        if (this.filterSeries[i2].has(item)) {
          return true;
        }
      }
      return false;
    }
    remove(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      for (let i2 = 0; i2 < this.filterSeries.length; i2++) {
        if (this.filterSeries[i2].remove(item)) {
          return true;
        }
      }
      return false;
    }
    get count() {
      return this.filterSeries.reduce((acc, curr) => {
        return acc + curr.count;
      }, 0);
    }
  };
  function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options2) {
    return new ScalableCuckooFilter({
      ...optimize(maxItems, errorRate),
      ...options2 ?? {}
    });
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/get-net-config.js
  function getNetConfig(ma) {
    const components = ma.getComponents();
    const config = {};
    let index = 0;
    if (components[index]?.name === "ip6zone") {
      config.zone = `${components[index].value}`;
      index++;
    }
    if (components[index].name === "ip4" || components[index].name === "ip6") {
      config.type = components[index].name;
      config.host = components[index].value;
      index++;
    } else if (components[index].name === "dns" || components[index].name === "dns4" || components[index].name === "dns6") {
      config.type = components[index].name;
      config.host = components[index].value;
      index++;
    } else if (components[index].name === "dnsaddr") {
      config.type = components[index].name;
      config.host = `_dnsaddr.${components[index].value}`;
      index++;
    }
    if (components[index]?.name === "tcp" || components[index]?.name === "udp") {
      config.protocol = components[index].name === "tcp" ? "tcp" : "udp";
      config.port = parseInt(`${components[index].value}`);
      index++;
    }
    if (components[index]?.name === "ipcidr") {
      if (config.type === "ip4") {
        config.cidr = parseInt(`${components[index].value}`);
      } else if (config.type === "ip6") {
        config.cidr = `${components[index].value}`;
      }
      index++;
    }
    if (config.type == null || config.host == null) {
      throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);
    }
    if (components[index]?.name === "tls" && components[index + 1]?.name === "sni") {
      config.sni = components[index + 1].value;
      index += 2;
    }
    return config;
  }

  // node_modules/@chainsafe/is-ip/lib/parser.js
  var Parser = class {
    index = 0;
    input = "";
    new(input) {
      this.index = 0;
      this.input = input;
      return this;
    }
    /** Run a parser, and restore the pre-parse state if it fails. */
    readAtomically(fn) {
      const index = this.index;
      const result = fn();
      if (result === void 0) {
        this.index = index;
      }
      return result;
    }
    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
    parseWith(fn) {
      const result = fn();
      if (this.index !== this.input.length) {
        return void 0;
      }
      return result;
    }
    /** Peek the next character from the input */
    peekChar() {
      if (this.index >= this.input.length) {
        return void 0;
      }
      return this.input[this.index];
    }
    /** Read the next character from the input */
    readChar() {
      if (this.index >= this.input.length) {
        return void 0;
      }
      return this.input[this.index++];
    }
    /** Read the next character from the input if it matches the target. */
    readGivenChar(target) {
      return this.readAtomically(() => {
        const char = this.readChar();
        if (char !== target) {
          return void 0;
        }
        return char;
      });
    }
    /**
     * Helper for reading separators in an indexed loop. Reads the separator
     * character iff index > 0, then runs the parser. When used in a loop,
     * the separator character will only be read on index > 0 (see
     * readIPv4Addr for an example)
     */
    readSeparator(sep, index, inner) {
      return this.readAtomically(() => {
        if (index > 0) {
          if (this.readGivenChar(sep) === void 0) {
            return void 0;
          }
        }
        return inner();
      });
    }
    /**
     * Read a number off the front of the input in the given radix, stopping
     * at the first non-digit character or eof. Fails if the number has more
     * digits than max_digits or if there is no number.
     */
    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
      return this.readAtomically(() => {
        let result = 0;
        let digitCount = 0;
        const leadingChar = this.peekChar();
        if (leadingChar === void 0) {
          return void 0;
        }
        const hasLeadingZero = leadingChar === "0";
        const maxValue2 = 2 ** (8 * maxBytes) - 1;
        while (true) {
          const digit = this.readAtomically(() => {
            const char = this.readChar();
            if (char === void 0) {
              return void 0;
            }
            const num = Number.parseInt(char, radix);
            if (Number.isNaN(num)) {
              return void 0;
            }
            return num;
          });
          if (digit === void 0) {
            break;
          }
          result *= radix;
          result += digit;
          if (result > maxValue2) {
            return void 0;
          }
          digitCount += 1;
          if (maxDigits !== void 0) {
            if (digitCount > maxDigits) {
              return void 0;
            }
          }
        }
        if (digitCount === 0) {
          return void 0;
        } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
          return void 0;
        } else {
          return result;
        }
      });
    }
    /** Read an IPv4 address. */
    readIPv4Addr() {
      return this.readAtomically(() => {
        const out = new Uint8Array(4);
        for (let i2 = 0; i2 < out.length; i2++) {
          const ix = this.readSeparator(".", i2, () => this.readNumber(10, 3, false, 1));
          if (ix === void 0) {
            return void 0;
          }
          out[i2] = ix;
        }
        return out;
      });
    }
    /** Read an IPv6 Address. */
    readIPv6Addr() {
      const readGroups = (groups) => {
        for (let i2 = 0; i2 < groups.length / 2; i2++) {
          const ix = i2 * 2;
          if (i2 < groups.length - 3) {
            const ipv4 = this.readSeparator(":", i2, () => this.readIPv4Addr());
            if (ipv4 !== void 0) {
              groups[ix] = ipv4[0];
              groups[ix + 1] = ipv4[1];
              groups[ix + 2] = ipv4[2];
              groups[ix + 3] = ipv4[3];
              return [ix + 4, true];
            }
          }
          const group = this.readSeparator(":", i2, () => this.readNumber(16, 4, true, 2));
          if (group === void 0) {
            return [ix, false];
          }
          groups[ix] = group >> 8;
          groups[ix + 1] = group & 255;
        }
        return [groups.length, false];
      };
      return this.readAtomically(() => {
        const head = new Uint8Array(16);
        const [headSize, headIp4] = readGroups(head);
        if (headSize === 16) {
          return head;
        }
        if (headIp4) {
          return void 0;
        }
        if (this.readGivenChar(":") === void 0) {
          return void 0;
        }
        if (this.readGivenChar(":") === void 0) {
          return void 0;
        }
        const tail = new Uint8Array(14);
        const limit = 16 - (headSize + 2);
        const [tailSize] = readGroups(tail.subarray(0, limit));
        head.set(tail.subarray(0, tailSize), 16 - tailSize);
        return head;
      });
    }
    /** Read an IP Address, either IPv4 or IPv6. */
    readIPAddr() {
      return this.readIPv4Addr() ?? this.readIPv6Addr();
    }
  };

  // node_modules/@chainsafe/is-ip/lib/parse.js
  var MAX_IPV6_LENGTH = 45;
  var MAX_IPV4_LENGTH = 15;
  var parser = new Parser();
  function parseIPv4(input) {
    if (input.length > MAX_IPV4_LENGTH) {
      return void 0;
    }
    return parser.new(input).parseWith(() => parser.readIPv4Addr());
  }
  function parseIPv6(input) {
    if (input.includes("%")) {
      input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
      return void 0;
    }
    return parser.new(input).parseWith(() => parser.readIPv6Addr());
  }
  function parseIP(input, mapIPv4ToIPv6 = false) {
    if (input.includes("%")) {
      input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
      return void 0;
    }
    const addr = parser.new(input).parseWith(() => parser.readIPAddr());
    if (!addr) {
      return void 0;
    }
    if (mapIPv4ToIPv6 && addr.length === 4) {
      return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, addr[0], addr[1], addr[2], addr[3]]);
    }
    return addr;
  }

  // node_modules/@chainsafe/netmask/dist/src/util.js
  function allFF(a2, from3, to) {
    let i2 = 0;
    for (const e2 of a2) {
      if (i2 < from3)
        continue;
      if (i2 > to)
        break;
      if (e2 !== 255)
        return false;
      i2++;
    }
    return true;
  }
  function deepEqual(a2, b, from3, to) {
    let i2 = 0;
    for (const e2 of a2) {
      if (i2 < from3)
        continue;
      if (i2 > to)
        break;
      if (e2 !== b[i2])
        return false;
      i2++;
    }
    return true;
  }
  function ipToString(ip) {
    switch (ip.length) {
      case IPv4Len: {
        return ip.join(".");
      }
      case IPv6Len: {
        const result = [];
        for (let i2 = 0; i2 < ip.length; i2++) {
          if (i2 % 2 === 0) {
            result.push(ip[i2].toString(16).padStart(2, "0") + ip[i2 + 1].toString(16).padStart(2, "0"));
          }
        }
        return result.join(":");
      }
      default: {
        throw new Error("Invalid ip length");
      }
    }
  }
  function simpleMaskLength(mask) {
    let ones = 0;
    for (let [index, byte] of mask.entries()) {
      if (byte === 255) {
        ones += 8;
        continue;
      }
      while ((byte & 128) != 0) {
        ones++;
        byte = byte << 1;
      }
      if ((byte & 128) != 0) {
        return -1;
      }
      for (let i2 = index + 1; i2 < mask.length; i2++) {
        if (mask[i2] != 0) {
          return -1;
        }
      }
      break;
    }
    return ones;
  }
  function maskToHex(mask) {
    let hex = "0x";
    for (const byte of mask) {
      hex += (byte >> 4).toString(16) + (byte & 15).toString(16);
    }
    return hex;
  }

  // node_modules/@chainsafe/netmask/dist/src/ip.js
  var IPv4Len = 4;
  var IPv6Len = 16;
  var maxIPv6Octet = parseInt("0xFFFF", 16);
  var ipv4Prefix = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    255,
    255
  ]);
  function maskIp(ip, mask) {
    if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {
      mask = mask.slice(12);
    }
    if (mask.length === IPv4Len && ip.length === IPv6Len && deepEqual(ip, ipv4Prefix, 0, 11)) {
      ip = ip.slice(12);
    }
    const n2 = ip.length;
    if (n2 != mask.length) {
      throw new Error("Failed to mask ip");
    }
    const out = new Uint8Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      out[i2] = ip[i2] & mask[i2];
    }
    return out;
  }
  function containsIp(net, ip) {
    if (typeof ip === "string") {
      ip = parseIP(ip);
    }
    if (ip == null)
      throw new Error("Invalid ip");
    if (ip.length !== net.network.length) {
      return false;
    }
    for (let i2 = 0; i2 < ip.length; i2++) {
      if ((net.network[i2] & net.mask[i2]) !== (ip[i2] & net.mask[i2])) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@chainsafe/netmask/dist/src/cidr.js
  function parseCidr(s2) {
    const [address, maskString] = s2.split("/");
    if (!address || !maskString)
      throw new Error("Failed to parse given CIDR: " + s2);
    let ipLength = IPv4Len;
    let ip = parseIPv4(address);
    if (ip == null) {
      ipLength = IPv6Len;
      ip = parseIPv6(address);
      if (ip == null)
        throw new Error("Failed to parse given CIDR: " + s2);
    }
    const m2 = parseInt(maskString, 10);
    if (Number.isNaN(m2) || String(m2).length !== maskString.length || m2 < 0 || m2 > ipLength * 8) {
      throw new Error("Failed to parse given CIDR: " + s2);
    }
    const mask = cidrMask(m2, 8 * ipLength);
    return {
      network: maskIp(ip, mask),
      mask
    };
  }
  function cidrMask(ones, bits2) {
    if (bits2 !== 8 * IPv4Len && bits2 !== 8 * IPv6Len)
      throw new Error("Invalid CIDR mask");
    if (ones < 0 || ones > bits2)
      throw new Error("Invalid CIDR mask");
    const l2 = bits2 / 8;
    const m2 = new Uint8Array(l2);
    for (let i2 = 0; i2 < l2; i2++) {
      if (ones >= 8) {
        m2[i2] = 255;
        ones -= 8;
        continue;
      }
      m2[i2] = 255 - (255 >> ones);
      ones = 0;
    }
    return m2;
  }

  // node_modules/@chainsafe/netmask/dist/src/ipnet.js
  var IpNet = class {
    /**
     *
     * @param ipOrCidr either network ip or full cidr address
     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
     */
    constructor(ipOrCidr, mask) {
      if (mask == null) {
        ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));
      } else {
        const ipResult = parseIP(ipOrCidr);
        if (ipResult == null) {
          throw new Error("Failed to parse network");
        }
        mask = String(mask);
        const m2 = parseInt(mask, 10);
        if (Number.isNaN(m2) || String(m2).length !== mask.length || m2 < 0 || m2 > ipResult.length * 8) {
          const maskResult = parseIP(mask);
          if (maskResult == null) {
            throw new Error("Failed to parse mask");
          }
          this.mask = maskResult;
        } else {
          this.mask = cidrMask(m2, 8 * ipResult.length);
        }
        this.network = maskIp(ipResult, this.mask);
      }
    }
    /**
     * Checks if netmask contains ip address
     * @param ip
     * @returns
     */
    contains(ip) {
      return containsIp({ network: this.network, mask: this.mask }, ip);
    }
    /**Serializes back to string format */
    toString() {
      const l2 = simpleMaskLength(this.mask);
      const mask = l2 !== -1 ? String(l2) : maskToHex(this.mask);
      return ipToString(this.network) + "/" + mask;
    }
  };

  // node_modules/@chainsafe/netmask/dist/src/index.js
  function cidrContains(cidr, ip) {
    const ipnet = new IpNet(cidr);
    return ipnet.contains(ip);
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-global-unicast.js
  function isGlobalUnicast(ma) {
    try {
      const config = getNetConfig(ma);
      switch (config.type) {
        case "ip6":
          return cidrContains("2000::/3", config.host);
        default:
          return false;
      }
    } catch {
      return false;
    }
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-link-local.js
  function isLinkLocal(ma) {
    try {
      const config = getNetConfig(ma);
      switch (config.type) {
        case "ip4":
          return config.host.startsWith("169.254.");
        case "ip6":
          return config.host.toLowerCase().startsWith("fe80");
        default:
          return false;
      }
    } catch (err2) {
      return false;
    }
  }

  // node_modules/is-loopback-addr/dist/src/index.js
  function isLoopbackAddr(ip) {
    return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
  function isLoopback(ma) {
    try {
      const config = getNetConfig(ma);
      switch (config.type) {
        case "ip4":
        case "ip6":
          return isLoopbackAddr(config.host);
        default:
          return false;
      }
    } catch {
      return false;
    }
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-network-address.js
  function isNetworkAddress(ma) {
    try {
      getNetConfig(ma);
      return true;
    } catch {
      return false;
    }
  }

  // node_modules/@chainsafe/is-ip/lib/is-ip.js
  function isIPv4(input) {
    return Boolean(parseIPv4(input));
  }
  function isIPv6(input) {
    return Boolean(parseIPv6(input));
  }

  // node_modules/@libp2p/utils/dist/src/private-ip.js
  var import_netmask2 = __toESM(require_netmask(), 1);
  var PRIVATE_IP_RANGES = [
    "0.0.0.0/8",
    "10.0.0.0/8",
    "100.64.0.0/10",
    "127.0.0.0/8",
    "169.254.0.0/16",
    "172.16.0.0/12",
    "192.0.0.0/24",
    "192.0.0.0/29",
    "192.0.0.8/32",
    "192.0.0.9/32",
    "192.0.0.10/32",
    "192.0.0.170/32",
    "192.0.0.171/32",
    "192.0.2.0/24",
    "192.31.196.0/24",
    "192.52.193.0/24",
    "192.88.99.0/24",
    "192.168.0.0/16",
    "192.175.48.0/24",
    "198.18.0.0/15",
    "198.51.100.0/24",
    "203.0.113.0/24",
    "240.0.0.0/4",
    "255.255.255.255/32"
  ];
  var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask2.Netmask(ipRange));
  function ipv4Check(ipAddr) {
    for (const r2 of NETMASK_RANGES) {
      if (r2.contains(ipAddr)) {
        return true;
      }
    }
    return false;
  }
  function isIpv4MappedIpv6(ipAddr) {
    return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
  }
  function ipv4MappedIpv6Check(ipAddr) {
    const parts = ipAddr.split(":");
    if (parts.length < 2) {
      return false;
    }
    const octet34 = parts[parts.length - 1].padStart(4, "0");
    const octet12 = parts[parts.length - 2].padStart(4, "0");
    const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
    return ipv4Check(ip4);
  }
  function isIpv4EmbeddedIpv6(ipAddr) {
    return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
  }
  function ipv4EmbeddedIpv6Check(ipAddr) {
    const parts = ipAddr.split(":");
    const ip4 = parts[parts.length - 1];
    return ipv4Check(ip4);
  }
  function ipv6Check(ipAddr) {
    return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
  }
  function isPrivateIp(ip) {
    if (isIPv4(ip)) {
      return ipv4Check(ip);
    }
    if (isIpv4MappedIpv6(ip)) {
      return ipv4MappedIpv6Check(ip);
    }
    if (isIpv4EmbeddedIpv6(ip)) {
      return ipv4EmbeddedIpv6Check(ip);
    }
    if (isIPv6(ip)) {
      return ipv6Check(ip);
    }
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
  function isPrivate(ma) {
    try {
      const config = getNetConfig(ma);
      switch (config.type) {
        case "ip4":
        case "ip6":
          return isPrivateIp(config.host) ?? false;
        default:
          return config.host === "localhost";
      }
    } catch {
      return false;
    }
  }

  // node_modules/p-defer/index.js
  function pDefer() {
    const deferred = {};
    deferred.promise = new Promise((resolve8, reject) => {
      deferred.resolve = resolve8;
      deferred.reject = reject;
    });
    return deferred;
  }

  // node_modules/it-pushable/dist/src/fifo.js
  var FixedFIFO = class {
    buffer;
    mask;
    top;
    btm;
    next;
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
        throw new Error("Max size for a FixedFIFO should be a power of two");
      }
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    push(data) {
      if (this.buffer[this.top] !== void 0) {
        return false;
      }
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last2 = this.buffer[this.btm];
      if (last2 === void 0) {
        return void 0;
      }
      this.buffer[this.btm] = void 0;
      this.btm = this.btm + 1 & this.mask;
      return last2;
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0;
    }
  };
  var FIFO = class {
    size;
    hwm;
    head;
    tail;
    constructor(options2 = {}) {
      this.hwm = options2.splitLimit ?? 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
      this.size = 0;
    }
    calculateSize(obj) {
      if (obj?.byteLength != null) {
        return obj.byteLength;
      }
      return 1;
    }
    push(val) {
      if (val?.value != null) {
        this.size += this.calculateSize(val.value);
      }
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      let val = this.tail.shift();
      if (val === void 0 && this.tail.next != null) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        val = this.tail.shift();
      }
      if (val?.value != null) {
        this.size -= this.calculateSize(val.value);
      }
      return val;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
  };

  // node_modules/it-pushable/dist/src/index.js
  var AbortError2 = class extends Error {
    type;
    code;
    constructor(message2, code8) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.code = code8 ?? "ABORT_ERR";
    }
  };
  function pushable(options2 = {}) {
    const getNext = (buffer2) => {
      const next = buffer2.shift();
      if (next == null) {
        return { done: true };
      }
      if (next.error != null) {
        throw next.error;
      }
      return {
        done: next.done === true,
        // @ts-expect-error if done is false, value will be present
        value: next.value
      };
    };
    return _pushable(getNext, options2);
  }
  function _pushable(getNext, options2) {
    options2 = options2 ?? {};
    let onEnd = options2.onEnd;
    let buffer2 = new FIFO();
    let pushable2;
    let onNext;
    let ended;
    let drain2 = pDefer();
    const waitNext = async () => {
      try {
        if (!buffer2.isEmpty()) {
          return getNext(buffer2);
        }
        if (ended) {
          return { done: true };
        }
        return await new Promise((resolve8, reject) => {
          onNext = (next) => {
            onNext = null;
            buffer2.push(next);
            try {
              resolve8(getNext(buffer2));
            } catch (err2) {
              reject(err2);
            }
            return pushable2;
          };
        });
      } finally {
        if (buffer2.isEmpty()) {
          queueMicrotask(() => {
            drain2.resolve();
            drain2 = pDefer();
          });
        }
      }
    };
    const bufferNext = (next) => {
      if (onNext != null) {
        return onNext(next);
      }
      buffer2.push(next);
      return pushable2;
    };
    const bufferError = (err2) => {
      buffer2 = new FIFO();
      if (onNext != null) {
        return onNext({ error: err2 });
      }
      buffer2.push({ error: err2 });
      return pushable2;
    };
    const push = (value2) => {
      if (ended) {
        return pushable2;
      }
      if (options2?.objectMode !== true && value2?.byteLength == null) {
        throw new Error("objectMode was not true but tried to push non-Uint8Array value");
      }
      return bufferNext({ done: false, value: value2 });
    };
    const end = (err2) => {
      if (ended)
        return pushable2;
      ended = true;
      return err2 != null ? bufferError(err2) : bufferNext({ done: true });
    };
    const _return = () => {
      buffer2 = new FIFO();
      end();
      return { done: true };
    };
    const _throw = (err2) => {
      end(err2);
      return { done: true };
    };
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: waitNext,
      return: _return,
      throw: _throw,
      push,
      end,
      get readableLength() {
        return buffer2.size;
      },
      onEmpty: async (options3) => {
        const signal = options3?.signal;
        signal?.throwIfAborted();
        if (buffer2.isEmpty()) {
          return;
        }
        let cancel;
        let listener;
        if (signal != null) {
          cancel = new Promise((resolve8, reject) => {
            listener = () => {
              reject(new AbortError2());
            };
            signal.addEventListener("abort", listener);
          });
        }
        try {
          await Promise.race([
            drain2.promise,
            cancel
          ]);
        } finally {
          if (listener != null && signal != null) {
            signal?.removeEventListener("abort", listener);
          }
        }
      }
    };
    if (onEnd == null) {
      return pushable2;
    }
    const _pushable2 = pushable2;
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next() {
        return _pushable2.next();
      },
      throw(err2) {
        _pushable2.throw(err2);
        if (onEnd != null) {
          onEnd(err2);
          onEnd = void 0;
        }
        return { done: true };
      },
      return() {
        _pushable2.return();
        if (onEnd != null) {
          onEnd();
          onEnd = void 0;
        }
        return { done: true };
      },
      push,
      end(err2) {
        _pushable2.end(err2);
        if (onEnd != null) {
          onEnd(err2);
          onEnd = void 0;
        }
        return pushable2;
      },
      get readableLength() {
        return _pushable2.readableLength;
      },
      onEmpty: (opts) => {
        return _pushable2.onEmpty(opts);
      }
    };
    return pushable2;
  }

  // node_modules/p-event/node_modules/p-timeout/index.js
  var TimeoutError2 = class extends Error {
    constructor(message2) {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var AbortError3 = class extends Error {
    constructor(message2) {
      super();
      this.name = "AbortError";
      this.message = message2;
    }
  };
  var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError3(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason = (signal) => {
    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
  };
  function pTimeout(promise, options2) {
    const {
      milliseconds,
      fallback,
      message: message2,
      customTimers = { setTimeout, clearTimeout }
    } = options2;
    let timer;
    let abortHandler;
    const wrappedPromise = new Promise((resolve8, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (options2.signal) {
        const { signal } = options2;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        abortHandler = () => {
          reject(getAbortedReason(signal));
        };
        signal.addEventListener("abort", abortHandler, { once: true });
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        promise.then(resolve8, reject);
        return;
      }
      const timeoutError = new TimeoutError2();
      timer = customTimers.setTimeout.call(void 0, () => {
        if (fallback) {
          try {
            resolve8(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        if (message2 === false) {
          resolve8();
        } else if (message2 instanceof Error) {
          reject(message2);
        } else {
          timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
          reject(timeoutError);
        }
      }, milliseconds);
      (async () => {
        try {
          resolve8(await promise);
        } catch (error) {
          reject(error);
        }
      })();
    });
    const cancelablePromise = wrappedPromise.finally(() => {
      cancelablePromise.clear();
      if (abortHandler && options2.signal) {
        options2.signal.removeEventListener("abort", abortHandler);
      }
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(void 0, timer);
      timer = void 0;
    };
    return cancelablePromise;
  }

  // node_modules/p-event/index.js
  var normalizeEmitter = (emitter) => {
    const addListener2 = emitter.addEventListener || emitter.on || emitter.addListener;
    const removeListener2 = emitter.removeEventListener || emitter.off || emitter.removeListener;
    if (!addListener2 || !removeListener2) {
      throw new TypeError("Emitter is not compatible");
    }
    return {
      addListener: addListener2.bind(emitter),
      removeListener: removeListener2.bind(emitter)
    };
  };
  function pEventMultiple(emitter, event, options2) {
    let cancel;
    const returnValue = new Promise((resolve8, reject) => {
      options2 = {
        rejectionEvents: ["error"],
        multiArgs: false,
        rejectionMultiArgs: false,
        resolveImmediately: false,
        ...options2
      };
      if (!(options2.count >= 0 && (options2.count === Number.POSITIVE_INFINITY || Number.isInteger(options2.count)))) {
        throw new TypeError("The `count` option should be at least 0 or more");
      }
      options2.signal?.throwIfAborted();
      const events = [event].flat();
      const items = [];
      const { addListener: addListener2, removeListener: removeListener2 } = normalizeEmitter(emitter);
      const onItem = async (...arguments_) => {
        const value2 = options2.multiArgs ? arguments_ : arguments_[0];
        if (options2.filter) {
          try {
            if (!await options2.filter(value2)) {
              return;
            }
          } catch (error) {
            cancel();
            reject(error);
            return;
          }
        }
        items.push(value2);
        if (options2.count === items.length) {
          cancel();
          resolve8(items);
        }
      };
      const rejectHandler = (...arguments_) => {
        cancel();
        reject(options2.rejectionMultiArgs ? arguments_ : arguments_[0]);
      };
      cancel = () => {
        for (const event2 of events) {
          removeListener2(event2, onItem);
        }
        for (const rejectionEvent of options2.rejectionEvents) {
          if (!events.includes(rejectionEvent)) {
            removeListener2(rejectionEvent, rejectHandler);
          }
        }
      };
      for (const event2 of events) {
        addListener2(event2, onItem);
      }
      for (const rejectionEvent of options2.rejectionEvents) {
        if (!events.includes(rejectionEvent)) {
          addListener2(rejectionEvent, rejectHandler);
        }
      }
      if (options2.signal) {
        options2.signal.addEventListener("abort", () => {
          rejectHandler(options2.signal.reason);
        }, { once: true });
      }
      if (options2.resolveImmediately) {
        resolve8(items);
      }
    });
    returnValue.cancel = cancel;
    if (typeof options2.timeout === "number") {
      const timeout = pTimeout(returnValue, { milliseconds: options2.timeout });
      timeout.cancel = () => {
        cancel();
        timeout.clear();
      };
      return timeout;
    }
    return returnValue;
  }
  function pEvent(emitter, event, options2) {
    if (typeof options2 === "function") {
      options2 = { filter: options2 };
    }
    options2 = {
      ...options2,
      count: 1,
      resolveImmediately: false
    };
    const arrayPromise = pEventMultiple(emitter, event, options2);
    const promise = arrayPromise.then((array) => array[0]);
    promise.cancel = arrayPromise.cancel;
    return promise;
  }

  // node_modules/@libp2p/utils/dist/src/debounce.js
  function debounce(func, wait) {
    let timeout;
    const output = function() {
      const later = function() {
        timeout = void 0;
        void func();
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
    output.start = () => {
    };
    output.stop = () => {
      clearTimeout(timeout);
    };
    return output;
  }

  // node_modules/@libp2p/utils/dist/src/errors.js
  var RateLimitError = class extends Error {
    remainingPoints;
    msBeforeNext;
    consumedPoints;
    isFirstInDuration;
    constructor(message2 = "Rate limit exceeded", props) {
      super(message2);
      this.name = "RateLimitError";
      this.remainingPoints = props.remainingPoints;
      this.msBeforeNext = props.msBeforeNext;
      this.consumedPoints = props.consumedPoints;
      this.isFirstInDuration = props.isFirstInDuration;
    }
  };
  var QueueFullError = class extends Error {
    static name = "QueueFullError";
    constructor(message2 = "The queue was full") {
      super(message2);
      this.name = "QueueFullError";
    }
  };
  var UnexpectedEOFError = class extends Error {
    static name = "UnexpectedEOFError";
    name = "UnexpectedEOFError";
  };
  var MaxEarlyStreamsError = class extends Error {
    static name = "MaxEarlyStreamsError";
    name = "MaxEarlyStreamsError";
  };
  var StreamClosedError = class extends Error {
    static name = "StreamClosedError";
    name = "StreamClosedError";
  };

  // node_modules/race-signal/dist/src/index.js
  function defaultTranslate(signal) {
    return signal.reason;
  }
  async function raceSignal(promise, signal, opts) {
    if (signal == null) {
      return promise;
    }
    const translateError = opts?.translateError ?? defaultTranslate;
    if (signal.aborted) {
      promise.catch(() => {
      });
      return Promise.reject(translateError(signal));
    }
    let listener;
    try {
      return await Promise.race([
        promise,
        new Promise((resolve8, reject) => {
          listener = () => {
            reject(translateError(signal));
          };
          signal.addEventListener("abort", listener);
        })
      ]);
    } finally {
      if (listener != null) {
        signal.removeEventListener("abort", listener);
      }
    }
  }

  // node_modules/@libp2p/utils/dist/src/queue/recipient.js
  var JobRecipient = class {
    deferred;
    signal;
    constructor(signal) {
      this.signal = signal;
      this.deferred = pDefer();
      this.onAbort = this.onAbort.bind(this);
      this.signal?.addEventListener("abort", this.onAbort);
    }
    onAbort() {
      this.deferred.reject(this.signal?.reason ?? new AbortError());
    }
    cleanup() {
      this.signal?.removeEventListener("abort", this.onAbort);
    }
  };

  // node_modules/@libp2p/utils/dist/src/queue/job.js
  function randomId() {
    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
  }
  var Job = class {
    id;
    fn;
    options;
    recipients;
    status;
    timeline;
    controller;
    constructor(fn, options2) {
      this.id = randomId();
      this.status = "queued";
      this.fn = fn;
      this.options = options2;
      this.recipients = [];
      this.timeline = {
        created: Date.now()
      };
      this.controller = new AbortController();
      setMaxListeners(Infinity, this.controller.signal);
      this.onAbort = this.onAbort.bind(this);
    }
    abort(err2) {
      this.controller.abort(err2);
    }
    onAbort() {
      const allAborted = this.recipients.reduce((acc, curr) => {
        return acc && curr.signal?.aborted === true;
      }, true);
      if (allAborted) {
        this.controller.abort(new AbortError());
        this.cleanup();
      }
    }
    async join(options2 = {}) {
      const recipient = new JobRecipient(options2.signal);
      this.recipients.push(recipient);
      options2.signal?.addEventListener("abort", this.onAbort);
      return recipient.deferred.promise;
    }
    async run() {
      this.status = "running";
      this.timeline.started = Date.now();
      try {
        this.controller.signal.throwIfAborted();
        const result = await raceSignal(this.fn({
          ...this.options ?? {},
          signal: this.controller.signal
        }), this.controller.signal);
        this.recipients.forEach((recipient) => {
          recipient.deferred.resolve(result);
        });
        this.status = "complete";
      } catch (err2) {
        this.recipients.forEach((recipient) => {
          recipient.deferred.reject(err2);
        });
        this.status = "errored";
      } finally {
        this.timeline.finished = Date.now();
        this.cleanup();
      }
    }
    cleanup() {
      this.recipients.forEach((recipient) => {
        recipient.cleanup();
        recipient.signal?.removeEventListener("abort", this.onAbort);
      });
    }
  };

  // node_modules/@libp2p/utils/dist/src/queue/index.js
  var Queue = class extends TypedEventEmitter {
    concurrency;
    maxSize;
    queue;
    pending;
    sort;
    paused;
    constructor(init = {}) {
      super();
      this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
      this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
      this.pending = 0;
      this.paused = false;
      if (init.metricName != null) {
        init.metrics?.registerMetricGroup(init.metricName, {
          calculate: () => {
            return {
              size: this.queue.length,
              running: this.pending,
              queued: this.queue.length - this.pending
            };
          }
        });
      }
      this.sort = init.sort;
      this.queue = [];
      this.emitEmpty = debounce(this.emitEmpty.bind(this), 1);
      this.emitIdle = debounce(this.emitIdle.bind(this), 1);
    }
    emitEmpty() {
      if (this.size !== 0) {
        return;
      }
      this.safeDispatchEvent("empty");
    }
    emitIdle() {
      if (this.running !== 0) {
        return;
      }
      this.safeDispatchEvent("idle");
    }
    pause() {
      this.paused = true;
    }
    resume() {
      if (!this.paused) {
        return;
      }
      this.paused = false;
      this.tryToStartAnother();
    }
    tryToStartAnother() {
      if (this.paused) {
        return false;
      }
      if (this.size === 0) {
        this.emitEmpty();
        if (this.running === 0) {
          this.emitIdle();
        }
        return false;
      }
      if (this.pending < this.concurrency) {
        let job;
        for (const j of this.queue) {
          if (j.status === "queued") {
            job = j;
            break;
          }
        }
        if (job == null) {
          return false;
        }
        this.safeDispatchEvent("active");
        this.pending++;
        void job.run().finally(() => {
          for (let i2 = 0; i2 < this.queue.length; i2++) {
            if (this.queue[i2] === job) {
              this.queue.splice(i2, 1);
              break;
            }
          }
          this.pending--;
          this.tryToStartAnother();
          this.safeDispatchEvent("next");
        });
        return true;
      }
      return false;
    }
    enqueue(job) {
      this.queue.push(job);
      if (this.sort != null) {
        this.queue.sort(this.sort);
      }
    }
    /**
     * Adds a sync or async task to the queue. Always returns a promise.
     */
    async add(fn, options2) {
      options2?.signal?.throwIfAborted();
      if (this.size === this.maxSize) {
        throw new QueueFullError();
      }
      const job = new Job(fn, options2);
      this.enqueue(job);
      this.safeDispatchEvent("add");
      this.tryToStartAnother();
      return job.join(options2).then((result) => {
        this.safeDispatchEvent("completed", { detail: result });
        this.safeDispatchEvent("success", { detail: { job, result } });
        return result;
      }).catch((err2) => {
        if (job.status === "queued") {
          for (let i2 = 0; i2 < this.queue.length; i2++) {
            if (this.queue[i2] === job) {
              this.queue.splice(i2, 1);
              break;
            }
          }
        }
        this.safeDispatchEvent("failure", { detail: { job, error: err2 } });
        throw err2;
      });
    }
    /**
     * Clear the queue
     */
    clear() {
      this.queue.splice(0, this.queue.length);
    }
    /**
     * Abort all jobs in the queue and clear it
     */
    abort() {
      this.queue.forEach((job) => {
        job.abort(new AbortError());
      });
      this.clear();
    }
    /**
     * Can be called multiple times. Useful if you for example add additional items at a later time.
     *
     * @returns A promise that settles when the queue becomes empty.
     */
    async onEmpty(options2) {
      if (this.size === 0) {
        return;
      }
      await pEvent(this, "empty", options2);
    }
    /**
     * @returns A promise that settles when the queue size is less than the given
     * limit: `queue.size < limit`.
     *
     * If you want to avoid having the queue grow beyond a certain size you can
     * `await queue.onSizeLessThan()` before adding a new item.
     *
     * Note that this only limits the number of items waiting to start. There
     * could still be up to `concurrency` jobs already running that this call does
     * not include in its calculation.
     */
    async onSizeLessThan(limit, options2) {
      if (this.size < limit) {
        return;
      }
      await pEvent(this, "next", {
        ...options2,
        filter: () => this.size < limit
      });
    }
    /**
     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
     * from the queue has finished. `.onEmpty` merely signals that the queue is
     * empty, but it could mean that some promises haven't completed yet.
     *
     * @returns A promise that settles when the queue becomes empty, and all
     * promises have completed; `queue.size === 0 && queue.pending === 0`.
     */
    async onIdle(options2) {
      if (this.pending === 0 && this.size === 0) {
        return;
      }
      await pEvent(this, "idle", options2);
    }
    /**
     * Size of the queue including running items
     */
    get size() {
      return this.queue.length;
    }
    /**
     * The number of queued items waiting to run.
     */
    get queued() {
      return this.queue.length - this.pending;
    }
    /**
     * The number of items currently running.
     */
    get running() {
      return this.pending;
    }
    /**
     * Returns an async generator that makes it easy to iterate over the results
     * of jobs added to the queue.
     *
     * The generator will end when the queue becomes idle, that is there are no
     * jobs running and no jobs that have yet to run.
     *
     * If you need to keep the queue open indefinitely, consider using it-pushable
     * instead.
     */
    async *toGenerator(options2) {
      options2?.signal?.throwIfAborted();
      const stream = pushable({
        objectMode: true
      });
      const cleanup = (err2) => {
        if (err2 != null) {
          this.abort();
        } else {
          this.clear();
        }
        stream.end(err2);
      };
      const onQueueJobComplete = (evt) => {
        if (evt.detail != null) {
          stream.push(evt.detail);
        }
      };
      const onQueueFailure = (evt) => {
        cleanup(evt.detail.error);
      };
      const onQueueIdle = () => {
        cleanup();
      };
      const onSignalAbort = () => {
        cleanup(new AbortError("Queue aborted"));
      };
      this.addEventListener("completed", onQueueJobComplete);
      this.addEventListener("failure", onQueueFailure);
      this.addEventListener("idle", onQueueIdle);
      options2?.signal?.addEventListener("abort", onSignalAbort);
      try {
        yield* stream;
      } finally {
        this.removeEventListener("completed", onQueueJobComplete);
        this.removeEventListener("failure", onQueueFailure);
        this.removeEventListener("idle", onQueueIdle);
        options2?.signal?.removeEventListener("abort", onSignalAbort);
        cleanup();
      }
    }
  };

  // node_modules/@libp2p/utils/dist/src/abstract-message-stream.js
  var DEFAULT_MAX_READ_BUFFER_LENGTH = Math.pow(2, 20) * 4;
  var AbstractMessageStream = class extends TypedEventEmitter {
    status;
    timeline;
    inactivityTimeout;
    maxReadBufferLength;
    maxWriteBufferLength;
    log;
    direction;
    maxMessageSize;
    readStatus;
    writeStatus;
    remoteReadStatus;
    remoteWriteStatus;
    writableNeedsDrain;
    /**
     * Any data stored here is emitted before any new incoming data.
     *
     * This is used when the stream is paused or if data is pushed onto the stream
     */
    readBuffer;
    writeBuffer;
    sendingData;
    onDrainPromise;
    constructor(init) {
      super();
      this.status = "open";
      this.log = init.log;
      this.direction = init.direction ?? "outbound";
      this.inactivityTimeout = init.inactivityTimeout ?? 12e4;
      this.maxReadBufferLength = init.maxReadBufferLength ?? DEFAULT_MAX_READ_BUFFER_LENGTH;
      this.maxWriteBufferLength = init.maxWriteBufferLength;
      this.maxMessageSize = init.maxMessageSize;
      this.readBuffer = new Uint8ArrayList();
      this.writeBuffer = new Uint8ArrayList();
      this.readStatus = "readable";
      this.remoteReadStatus = "readable";
      this.writeStatus = "writable";
      this.remoteWriteStatus = "writable";
      this.sendingData = false;
      this.writableNeedsDrain = false;
      this.timeline = {
        open: Date.now()
      };
      this.processSendQueue = this.processSendQueue.bind(this);
      const continueSendingOnDrain = () => {
        if (this.writableNeedsDrain) {
          this.log.trace("drain event received, continue sending data");
          this.writableNeedsDrain = false;
          this.processSendQueue();
        }
        this.onDrainPromise?.resolve();
      };
      this.addEventListener("drain", continueSendingOnDrain);
      const rejectOnDrainOnClose = (evt) => {
        this.onDrainPromise?.reject(evt.error ?? new StreamClosedError());
      };
      this.addEventListener("close", rejectOnDrainOnClose);
    }
    get readBufferLength() {
      return this.readBuffer.byteLength;
    }
    get writeBufferLength() {
      return this.writeBuffer.byteLength;
    }
    async onDrain(options2) {
      if (this.writableNeedsDrain !== true) {
        return Promise.resolve();
      }
      if (this.onDrainPromise == null) {
        this.onDrainPromise = Promise.withResolvers();
      }
      return raceSignal(this.onDrainPromise.promise, options2?.signal);
    }
    async *[Symbol.asyncIterator]() {
      if (this.readStatus !== "readable" && this.readStatus !== "paused") {
        return;
      }
      const output = pushable();
      const streamAsyncIterableOnMessageListener = (evt) => {
        output.push(evt.data);
      };
      this.addEventListener("message", streamAsyncIterableOnMessageListener);
      const streamAsyncIterableOnCloseListener = (evt) => {
        output.end(evt.error);
      };
      this.addEventListener("close", streamAsyncIterableOnCloseListener);
      const streamAsyncIterableOnRemoteCloseWriteListener = () => {
        output.end();
      };
      this.addEventListener("remoteCloseWrite", streamAsyncIterableOnRemoteCloseWriteListener);
      try {
        yield* output;
      } finally {
        this.removeEventListener("message", streamAsyncIterableOnMessageListener);
        this.removeEventListener("close", streamAsyncIterableOnCloseListener);
        this.removeEventListener("remoteCloseWrite", streamAsyncIterableOnRemoteCloseWriteListener);
      }
    }
    isReadable() {
      return this.status === "open";
    }
    send(data) {
      if (this.writeStatus === "closed" || this.writeStatus === "closing") {
        throw new StreamStateError(`Cannot write to a stream that is ${this.writeStatus}`);
      }
      this.log.trace("append %d bytes to write buffer", data.byteLength);
      this.writeBuffer.append(data);
      return this.processSendQueue();
    }
    /**
     * Close immediately for reading and writing and send a reset message (local
     * error)
     */
    abort(err2) {
      if (this.status === "aborted" || this.status === "reset" || this.status === "closed") {
        return;
      }
      this.log.error("abort with error - %e", err2);
      this.status = "aborted";
      if (this.readBuffer.byteLength > 0) {
        this.readBuffer.consume(this.readBuffer.byteLength);
      }
      if (this.writeBuffer.byteLength > 0) {
        this.writeBuffer.consume(this.writeBuffer.byteLength);
        this.safeDispatchEvent("idle");
      }
      this.writeStatus = "closed";
      this.remoteWriteStatus = "closed";
      this.readStatus = "closed";
      this.remoteReadStatus = "closed";
      this.timeline.close = Date.now();
      try {
        this.sendReset(err2);
      } catch (err3) {
        this.log("failed to send reset to remote - %e", err3);
      }
      this.dispatchEvent(new StreamAbortEvent(err2));
    }
    pause() {
      if (this.readStatus === "closed" || this.readStatus === "closing") {
        throw new StreamStateError("Cannot pause a stream that is closing/closed");
      }
      if (this.readStatus === "paused") {
        return;
      }
      this.readStatus = "paused";
      this.sendPause();
    }
    resume() {
      if (this.readStatus === "closed" || this.readStatus === "closing") {
        throw new StreamStateError("Cannot resume a stream that is closing/closed");
      }
      if (this.readStatus === "readable") {
        return;
      }
      this.readStatus = "readable";
      this.dispatchReadBuffer();
      this.sendResume();
    }
    push(data) {
      if (this.readStatus === "closed" || this.readStatus === "closing") {
        throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`);
      }
      if (data.byteLength === 0) {
        return;
      }
      this.readBuffer.append(data);
      if (this.readStatus === "paused" || this.listenerCount("message") === 0) {
        this.checkReadBufferLength();
        return;
      }
      setTimeout(() => {
        this.dispatchReadBuffer();
      }, 0);
    }
    unshift(data) {
      if (this.readStatus === "closed" || this.readStatus === "closing") {
        throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`);
      }
      if (data.byteLength === 0) {
        return;
      }
      this.readBuffer.prepend(data);
      if (this.readStatus === "paused" || this.listenerCount("message") === 0) {
        this.checkReadBufferLength();
        return;
      }
      setTimeout(() => {
        this.dispatchReadBuffer();
      }, 0);
    }
    /**
     * When an extending class reads data from it's implementation-specific source,
     * call this method to allow the stream consumer to read the data.
     */
    onData(data) {
      if (data.byteLength === 0) {
        return;
      }
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        this.log("ignoring data - read status %s", this.readStatus);
        return;
      }
      this.readBuffer.append(data);
      this.dispatchReadBuffer();
    }
    addEventListener(...args) {
      super.addEventListener.apply(this, args);
      if (args[0] === "message" && this.readBuffer.byteLength > 0) {
        queueMicrotask(() => {
          this.dispatchReadBuffer();
        });
      }
    }
    /**
     * Receive a reset message - close immediately for reading and writing (remote
     * error)
     */
    onRemoteReset() {
      this.log("remote reset");
      this.status = "reset";
      this.writeStatus = "closed";
      this.remoteWriteStatus = "closed";
      this.remoteReadStatus = "closed";
      this.timeline.close = Date.now();
      if (this.readBuffer.byteLength === 0) {
        this.readStatus = "closed";
      }
      const err2 = new StreamResetError();
      this.dispatchEvent(new StreamResetEvent(err2));
    }
    /**
     * The underlying resource or transport this stream uses has closed - it is
     * not possible to send any more messages though any data still in the read
     * buffer may still be read
     */
    onTransportClosed(err2) {
      this.log("transport closed");
      if (this.readStatus === "readable" && this.readBuffer.byteLength === 0) {
        this.log("close readable end after transport closed and read buffer is empty");
        this.readStatus = "closed";
      }
      if (this.remoteReadStatus !== "closed") {
        this.remoteReadStatus = "closed";
      }
      if (this.remoteWriteStatus !== "closed") {
        this.remoteWriteStatus = "closed";
      }
      if (this.writeStatus !== "closed") {
        this.writeStatus = "closed";
      }
      if (err2 != null) {
        this.abort(err2);
      } else {
        if (this.status === "open" || this.status === "closing") {
          this.timeline.close = Date.now();
          this.status = "closed";
          this.writeStatus = "closed";
          this.remoteWriteStatus = "closed";
          this.remoteReadStatus = "closed";
          this.dispatchEvent(new StreamCloseEvent());
        }
      }
    }
    /**
     * Called by extending classes when the remote closes its writable end
     */
    onRemoteCloseWrite() {
      if (this.remoteWriteStatus === "closed") {
        return;
      }
      this.log.trace("on remote close write");
      this.remoteWriteStatus = "closed";
      this.safeDispatchEvent("remoteCloseWrite");
      if (this.writeStatus === "closed") {
        this.onTransportClosed();
      }
    }
    /**
     * Called by extending classes when the remote closes its readable end
     */
    onRemoteCloseRead() {
      this.log.trace("on remote close read");
      this.remoteReadStatus = "closed";
      if (this.writeBuffer.byteLength > 0) {
        this.writeBuffer.consume(this.writeBuffer.byteLength);
        this.safeDispatchEvent("idle");
      }
    }
    processSendQueue() {
      if (this.writableNeedsDrain) {
        this.log.trace("not processing send queue as drain is required");
        this.checkWriteBufferLength();
        return false;
      }
      if (this.writeBuffer.byteLength === 0) {
        this.log.trace("not processing send queue as no bytes to send");
        return true;
      }
      if (this.sendingData) {
        this.log.trace("not processing send queue as already sending data");
        return true;
      }
      this.sendingData = true;
      this.log.trace("processing send queue with %d queued bytes", this.writeBuffer.byteLength);
      try {
        let canSendMore = true;
        const totalBytes = this.writeBuffer.byteLength;
        let sentBytes = 0;
        while (this.writeBuffer.byteLength > 0) {
          const end = Math.min(this.maxMessageSize ?? this.writeBuffer.byteLength, this.writeBuffer.byteLength);
          if (end === 0) {
            canSendMore = false;
            break;
          }
          const toSend = this.writeBuffer.sublist(0, end);
          const willSend = new Uint8ArrayList(toSend);
          this.writeBuffer.consume(toSend.byteLength);
          const sendResult = this.sendData(toSend);
          canSendMore = sendResult.canSendMore;
          sentBytes += sendResult.sentBytes;
          if (sendResult.sentBytes !== willSend.byteLength) {
            willSend.consume(sendResult.sentBytes);
            this.writeBuffer.prepend(willSend);
          }
          if (!canSendMore) {
            break;
          }
        }
        if (!canSendMore) {
          this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer", sentBytes, totalBytes, this.writeBuffer.byteLength);
          this.writableNeedsDrain = true;
          this.checkWriteBufferLength();
        }
        if (this.writeBuffer.byteLength === 0) {
          this.safeDispatchEvent("idle");
        }
        return canSendMore;
      } finally {
        this.sendingData = false;
      }
    }
    dispatchReadBuffer() {
      try {
        if (this.listenerCount("message") === 0) {
          this.log.trace("not dispatching pause buffer as there are no listeners for the message event");
          return;
        }
        if (this.readBuffer.byteLength === 0) {
          this.log.trace("not dispatching pause buffer as there is no data to dispatch");
          return;
        }
        if (this.readStatus === "paused") {
          this.log.trace("not dispatching pause buffer we are paused");
          return;
        }
        if (this.readStatus === "closing" || this.readStatus === "closed") {
          this.log("dropping %d bytes because the readable end is %s", this.readBuffer.byteLength, this.readStatus);
          this.readBuffer.consume(this.readBuffer.byteLength);
          return;
        }
        const buf2 = this.readBuffer.sublist();
        this.readBuffer.consume(buf2.byteLength);
        this.dispatchEvent(new StreamMessageEvent(buf2));
      } finally {
        if (this.readBuffer.byteLength === 0 && this.remoteWriteStatus === "closed") {
          this.log("close readable end after dispatching read buffer and remote writable end is closed");
          this.readStatus = "closed";
        }
        this.checkReadBufferLength();
      }
    }
    checkReadBufferLength() {
      if (this.readBuffer.byteLength > this.maxReadBufferLength) {
        this.abort(new StreamBufferError(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`));
      }
    }
    checkWriteBufferLength() {
      if (this.maxWriteBufferLength == null) {
        return;
      }
      if (this.writeBuffer.byteLength > this.maxWriteBufferLength) {
        this.abort(new StreamBufferError(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`));
      }
    }
    onMuxerNeedsDrain() {
      this.writableNeedsDrain = true;
    }
    onMuxerDrain() {
      this.safeDispatchEvent("drain");
    }
  };

  // node_modules/@libp2p/utils/dist/src/abstract-multiaddr-connection.js
  var AbstractMultiaddrConnection = class extends AbstractMessageStream {
    remoteAddr;
    metricPrefix;
    metrics;
    constructor(init) {
      super(init);
      this.metricPrefix = init.metricPrefix ?? "";
      this.metrics = init.metrics;
      this.remoteAddr = init.remoteAddr;
      this.addEventListener("close", (evt) => {
        this.metrics?.increment({ [`${this.metricPrefix}end`]: true });
        if (evt.error != null) {
          if (evt.local) {
            this.metrics?.increment({ [`${this.metricPrefix}abort`]: true });
          } else {
            this.metrics?.increment({ [`${this.metricPrefix}reset`]: true });
          }
        } else {
          if (evt.local) {
            this.metrics?.increment({ [`${this.metricPrefix}_local_close`]: true });
          } else {
            this.metrics?.increment({ [`${this.metricPrefix}_remote_close`]: true });
          }
        }
      });
    }
    async close(options2) {
      if (this.status !== "open") {
        return;
      }
      this.status = "closing";
      this.writeStatus = "closing";
      this.remoteWriteStatus = "closing";
      this.remoteReadStatus = "closing";
      if (this.sendingData || this.writeBuffer.byteLength > 0) {
        this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
        await pEvent(this, "idle", {
          ...options2,
          rejectionEvents: [
            "close"
          ]
        });
      }
      if (this.writableNeedsDrain) {
        this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
        await pEvent(this, "drain", {
          ...options2,
          rejectionEvents: [
            "close"
          ]
        });
      }
      await this.sendClose(options2);
      this.onTransportClosed();
    }
  };

  // node_modules/@libp2p/utils/dist/src/is-promise.js
  function isPromise2(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }

  // node_modules/@libp2p/utils/dist/src/abstract-stream-muxer.js
  var AbstractStreamMuxer = class extends TypedEventEmitter {
    streams;
    protocol;
    status;
    log;
    maConn;
    streamOptions;
    earlyStreams;
    maxEarlyStreams;
    metrics;
    constructor(maConn, init) {
      super();
      this.maConn = maConn;
      this.protocol = init.protocol;
      this.streams = [];
      this.earlyStreams = [];
      this.status = "open";
      this.log = maConn.log.newScope(init.name);
      this.streamOptions = init.streamOptions;
      this.maxEarlyStreams = init.maxEarlyStreams ?? 10;
      this.metrics = init.metrics;
      const muxerMaConnOnMessage = (evt) => {
        try {
          this.onData(evt.data);
        } catch (err2) {
          this.abort(err2);
          this.maConn.abort(err2);
        }
      };
      this.maConn.addEventListener("message", muxerMaConnOnMessage);
      const muxerMaConnOnDrain = () => {
        this.log("underlying stream drained, signal %d streams to continue writing", this.streams.length);
        this.streams.forEach((stream) => {
          stream.onMuxerDrain();
        });
      };
      this.maConn.addEventListener("drain", muxerMaConnOnDrain);
      const muxerOnMaConnClose = () => {
        this.log("underlying stream closed with status %s and %d streams", this.status, this.streams.length);
        this.onTransportClosed();
      };
      this.maConn.addEventListener("close", muxerOnMaConnClose);
    }
    send(data) {
      const result = this.maConn.send(data);
      if (result === false) {
        this.log("underlying stream saturated, signal %d streams to pause writing", this.streams.length);
        this.streams.forEach((stream) => {
          stream.onMuxerNeedsDrain();
        });
      }
      return result;
    }
    async close(options2) {
      if (this.status === "closed" || this.status === "closing") {
        return;
      }
      this.status = "closing";
      await raceSignal(Promise.all([...this.streams].map(async (s2) => {
        await s2.close(options2);
      })), options2?.signal);
      this.status = "closed";
    }
    abort(err2) {
      if (this.status === "closed") {
        return;
      }
      this.status = "closing";
      [...this.streams].forEach((s2) => {
        s2.abort(err2);
      });
      this.status = "closed";
    }
    onTransportClosed(err2) {
      this.status = "closing";
      try {
        [...this.streams].forEach((stream) => {
          stream.onTransportClosed(err2);
        });
      } catch (err3) {
        this.abort(err3);
      }
      this.status = "closed";
    }
    async createStream(options2) {
      if (this.status !== "open") {
        throw new MuxerClosedError();
      }
      let stream = this.onCreateStream({
        ...this.streamOptions,
        ...options2
      });
      if (isPromise2(stream)) {
        stream = await stream;
      }
      this.streams.push(stream);
      this.cleanUpStream(stream);
      return stream;
    }
    /**
     * Extending classes should invoke this method when a new stream was created
     * by the remote muxer
     */
    onRemoteStream(stream) {
      this.streams.push(stream);
      this.cleanUpStream(stream);
      if (this.listenerCount("stream") === 0) {
        this.earlyStreams.push(stream);
        if (this.earlyStreams.length > this.maxEarlyStreams) {
          this.abort(new MaxEarlyStreamsError(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));
        }
        return;
      }
      this.safeDispatchEvent("stream", {
        detail: stream
      });
    }
    cleanUpStream(stream) {
      const muxerOnStreamEnd = (evt) => {
        const index = this.streams.findIndex((s2) => s2 === stream);
        if (index !== -1) {
          this.streams.splice(index, 1);
        }
        if (evt.error != null) {
          if (evt.local) {
            this.metrics?.increment({ [`${stream.direction}_stream_reset`]: true });
          } else {
            this.metrics?.increment({ [`${stream.direction}_stream_abort`]: true });
          }
        } else {
          this.metrics?.increment({ [`${stream.direction}_stream_end`]: true });
        }
      };
      stream.addEventListener("close", muxerOnStreamEnd);
      this.metrics?.increment({ [`${stream.direction}_stream`]: true });
    }
    addEventListener(...args) {
      super.addEventListener.apply(this, args);
      if (args[0] === "stream" && this.earlyStreams.length > 0) {
        queueMicrotask(() => {
          this.earlyStreams.forEach((stream) => {
            this.safeDispatchEvent("stream", {
              detail: stream
            });
          });
          this.earlyStreams = [];
        });
      }
    }
  };

  // node_modules/@libp2p/utils/dist/src/abstract-stream.js
  var AbstractStream = class extends AbstractMessageStream {
    id;
    protocol;
    constructor(init) {
      super(init);
      this.id = init.id;
      this.protocol = init.protocol ?? "";
    }
    async close(options2) {
      if (this.writeStatus === "closing" || this.writeStatus === "closed") {
        return;
      }
      this.writeStatus = "closing";
      if (this.sendingData || this.writeBuffer.byteLength > 0) {
        this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
        await pEvent(this, "idle", {
          ...options2,
          rejectionEvents: [
            "close"
          ]
        });
      }
      if (this.writableNeedsDrain) {
        this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s", this.writeBuffer.byteLength, this.sendingData);
        await pEvent(this, "drain", {
          ...options2,
          rejectionEvents: [
            "close"
          ]
        });
        this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s", this.writeBuffer.byteLength, this.sendingData);
      }
      await this.sendCloseWrite(options2);
      this.writeStatus = "closed";
      this.log("closed writable end gracefully");
      if (this.remoteWriteStatus === "closed") {
        this.onTransportClosed();
      }
    }
    async closeRead(options2) {
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        return;
      }
      if (this.readBuffer.byteLength > 0) {
        this.readBuffer.consume(this.readBuffer.byteLength);
      }
      this.readStatus = "closing";
      await this.sendCloseRead(options2);
      this.readStatus = "closed";
      this.log("closed readable end gracefully");
    }
  };

  // node_modules/@libp2p/utils/dist/src/moving-average.js
  var MovingAverage = class {
    movingAverage;
    variance;
    deviation;
    forecast;
    timeSpan;
    previousTime;
    constructor(timeSpan2) {
      this.timeSpan = timeSpan2;
      this.movingAverage = 0;
      this.variance = 0;
      this.deviation = 0;
      this.forecast = 0;
    }
    alpha(t2, pt) {
      return 1 - Math.exp(-(t2 - pt) / this.timeSpan);
    }
    push(value2, time = Date.now()) {
      if (this.previousTime != null) {
        const a2 = this.alpha(time, this.previousTime);
        const diff = value2 - this.movingAverage;
        const incr = a2 * diff;
        this.movingAverage = a2 * value2 + (1 - a2) * this.movingAverage;
        this.variance = (1 - a2) * (this.variance + diff * incr);
        this.deviation = Math.sqrt(this.variance);
        this.forecast = this.movingAverage + a2 * diff;
      } else {
        this.movingAverage = value2;
      }
      this.previousTime = time;
    }
  };

  // node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
  var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
  var DEFAULT_FAILURE_MULTIPLIER = 2;
  var DEFAULT_MIN_TIMEOUT = 5e3;
  var DEFAULT_MAX_TIMEOUT = 6e4;
  var DEFAULT_INTERVAL = 5e3;
  var AdaptiveTimeout = class {
    success;
    failure;
    next;
    metric;
    timeoutMultiplier;
    failureMultiplier;
    minTimeout;
    maxTimeout;
    constructor(init = {}) {
      const interval = init.interval ?? DEFAULT_INTERVAL;
      this.success = new MovingAverage(interval);
      this.failure = new MovingAverage(interval);
      this.next = new MovingAverage(interval);
      this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
      this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
      this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
      this.maxTimeout = init.maxTimeout ?? DEFAULT_MAX_TIMEOUT;
      if (init.metricName != null) {
        this.metric = init.metrics?.registerMetricGroup(init.metricName);
      }
    }
    getTimeoutSignal(options2 = {}) {
      let timeout = Math.round(this.next.movingAverage * (options2.timeoutFactor ?? this.timeoutMultiplier));
      if (timeout < this.minTimeout) {
        timeout = this.minTimeout;
      }
      if (timeout > this.maxTimeout) {
        timeout = this.maxTimeout;
      }
      const sendTimeout = AbortSignal.timeout(timeout);
      const timeoutSignal = anySignal([options2.signal, sendTimeout]);
      setMaxListeners(Infinity, timeoutSignal, sendTimeout);
      timeoutSignal.start = Date.now();
      timeoutSignal.timeout = timeout;
      return timeoutSignal;
    }
    cleanUp(signal) {
      const time = Date.now() - signal.start;
      if (signal.aborted) {
        this.failure.push(time);
        this.next.push(time * this.failureMultiplier);
        this.metric?.update({
          failureMovingAverage: this.failure.movingAverage,
          failureDeviation: this.failure.deviation,
          failureForecast: this.failure.forecast,
          failureVariance: this.failure.variance,
          failure: time
        });
      } else {
        this.success.push(time);
        this.next.push(time);
        this.metric?.update({
          successMovingAverage: this.success.movingAverage,
          successDeviation: this.success.deviation,
          successForecast: this.success.forecast,
          successVariance: this.success.variance,
          success: time
        });
      }
    }
  };

  // node_modules/@multiformats/multiaddr/dist/src/errors.js
  var InvalidMultiaddrError2 = class extends Error {
    static name = "InvalidMultiaddrError";
    name = "InvalidMultiaddrError";
  };
  var ValidationError = class extends Error {
    static name = "ValidationError";
    name = "ValidationError";
  };
  var InvalidParametersError2 = class extends Error {
    static name = "InvalidParametersError";
    name = "InvalidParametersError";
  };
  var UnknownProtocolError = class extends Error {
    static name = "UnknownProtocolError";
    name = "UnknownProtocolError";
  };

  // node_modules/@multiformats/multiaddr/dist/src/constants.js
  var CODE_IP4 = 4;
  var CODE_TCP = 6;
  var CODE_UDP = 273;
  var CODE_DCCP = 33;
  var CODE_IP6 = 41;
  var CODE_IP6ZONE = 42;
  var CODE_IPCIDR = 43;
  var CODE_DNS = 53;
  var CODE_DNS4 = 54;
  var CODE_DNS6 = 55;
  var CODE_DNSADDR = 56;
  var CODE_SCTP = 132;
  var CODE_UDT = 301;
  var CODE_UTP = 302;
  var CODE_UNIX = 400;
  var CODE_P2P = 421;
  var CODE_ONION = 444;
  var CODE_ONION3 = 445;
  var CODE_GARLIC64 = 446;
  var CODE_GARLIC32 = 447;
  var CODE_TLS = 448;
  var CODE_SNI = 449;
  var CODE_NOISE = 454;
  var CODE_QUIC = 460;
  var CODE_QUIC_V1 = 461;
  var CODE_WEBTRANSPORT = 465;
  var CODE_CERTHASH = 466;
  var CODE_HTTP = 480;
  var CODE_HTTP_PATH = 481;
  var CODE_HTTPS = 443;
  var CODE_WS = 477;
  var CODE_WSS = 478;
  var CODE_P2P_WEBSOCKET_STAR = 479;
  var CODE_P2P_STARDUST = 277;
  var CODE_P2P_WEBRTC_STAR = 275;
  var CODE_P2P_WEBRTC_DIRECT = 276;
  var CODE_WEBRTC_DIRECT = 280;
  var CODE_WEBRTC = 281;
  var CODE_P2P_CIRCUIT = 290;
  var CODE_MEMORY = 777;

  // node_modules/@multiformats/multiaddr/dist/src/utils.js
  function bytesToString(base3) {
    return (buf2) => {
      return toString2(buf2, base3);
    };
  }
  function stringToBytes(base3) {
    return (buf2) => {
      return fromString2(buf2, base3);
    };
  }
  function bytes2port(buf2) {
    const view = new DataView(buf2.buffer);
    return view.getUint16(buf2.byteOffset).toString();
  }
  function port2bytes(port) {
    const buf2 = new ArrayBuffer(2);
    const view = new DataView(buf2);
    view.setUint16(0, typeof port === "string" ? parseInt(port) : port);
    return new Uint8Array(buf2);
  }
  function onion2bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    const buf2 = fromString2(addr[0], "base32");
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return concat([buf2, portBuf], buf2.length + portBuf.length);
  }
  function onion32bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    const buf2 = base32.decode(`b${addr[0]}`);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return concat([buf2, portBuf], buf2.length + portBuf.length);
  }
  function bytes2onion(buf2) {
    const addrBytes = buf2.subarray(0, buf2.length - 2);
    const portBytes = buf2.subarray(buf2.length - 2);
    const addr = toString2(addrBytes, "base32");
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
  }
  var ip4ToBytes = function(ip) {
    ip = ip.toString().trim();
    const bytes = new Uint8Array(4);
    ip.split(/\./g).forEach((byte, index) => {
      const value2 = parseInt(byte, 10);
      if (isNaN(value2) || value2 < 0 || value2 > 255) {
        throw new InvalidMultiaddrError2("Invalid byte value in IP address");
      }
      bytes[index] = value2;
    });
    return bytes;
  };
  var ip6ToBytes = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    const sections = ip.split(":", 8);
    let i2;
    for (i2 = 0; i2 < sections.length; i2++) {
      const isv4 = isIPv4(sections[i2]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = ip4ToBytes(sections[i2]);
        sections[i2] = toString2(v4Buffer.subarray(0, 2), "base16");
      }
      if (v4Buffer != null && ++i2 < 8) {
        sections.splice(i2, 0, toString2(v4Buffer.subarray(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8) {
        sections.unshift("0");
      }
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8) {
        sections.push("0");
      }
    } else if (sections.length < 8) {
      for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++) {
      }
      const argv = [i2, 1];
      for (i2 = 9 - sections.length; i2 > 0; i2--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes = new Uint8Array(offset + 16);
    for (i2 = 0; i2 < sections.length; i2++) {
      if (sections[i2] === "") {
        sections[i2] = "0";
      }
      const word2 = parseInt(sections[i2], 16);
      if (isNaN(word2) || word2 < 0 || word2 > 65535) {
        throw new InvalidMultiaddrError2("Invalid byte value in IP address");
      }
      bytes[offset++] = word2 >> 8 & 255;
      bytes[offset++] = word2 & 255;
    }
    return bytes;
  };
  var ip4ToString = function(buf2) {
    if (buf2.byteLength !== 4) {
      throw new InvalidMultiaddrError2("IPv4 address was incorrect length");
    }
    const result = [];
    for (let i2 = 0; i2 < buf2.byteLength; i2++) {
      result.push(buf2[i2]);
    }
    return result.join(".");
  };
  var ip6ToString = function(buf2) {
    if (buf2.byteLength !== 16) {
      throw new InvalidMultiaddrError2("IPv6 address was incorrect length");
    }
    const result = [];
    for (let i2 = 0; i2 < buf2.byteLength; i2 += 2) {
      const byte1 = buf2[i2];
      const byte2 = buf2[i2 + 1];
      const tuple = `${byte1.toString(16).padStart(2, "0")}${byte2.toString(16).padStart(2, "0")}`;
      result.push(tuple);
    }
    const ip = result.join(":");
    try {
      const url = new URL(`http://[${ip}]`);
      return url.hostname.substring(1, url.hostname.length - 1);
    } catch {
      throw new InvalidMultiaddrError2(`Invalid IPv6 address "${ip}"`);
    }
  };
  function ip6StringToValue(str) {
    try {
      const url = new URL(`http://[${str}]`);
      return url.hostname.substring(1, url.hostname.length - 1);
    } catch {
      throw new InvalidMultiaddrError2(`Invalid IPv6 address "${str}"`);
    }
  }
  var decoders2 = Object.values(bases).map((c2) => c2.decoder);
  var anybaseDecoder = (function() {
    let acc = decoders2[0].or(decoders2[1]);
    decoders2.slice(2).forEach((d2) => acc = acc.or(d2));
    return acc;
  })();
  function mb2bytes(mbstr) {
    return anybaseDecoder.decode(mbstr);
  }
  function bytes2mb(base3) {
    return (buf2) => {
      return base3.encoder.encode(buf2);
    };
  }

  // node_modules/@multiformats/multiaddr/dist/src/validation.js
  function integer(value2) {
    const int = parseInt(value2);
    if (int.toString() !== value2) {
      throw new ValidationError("Value must be an integer");
    }
  }
  function positive(value2) {
    if (value2 < 0) {
      throw new ValidationError("Value must be a positive integer, or zero");
    }
  }
  function maxValue(max2) {
    return (value2) => {
      if (value2 > max2) {
        throw new ValidationError(`Value must be smaller than or equal to ${max2}`);
      }
    };
  }
  function validate(...funcs) {
    return (value2) => {
      for (const fn of funcs) {
        fn(value2);
      }
    };
  }
  var validatePort = validate(integer, positive, maxValue(65535));

  // node_modules/@multiformats/multiaddr/dist/src/registry.js
  var V = -1;
  var Registry = class {
    protocolsByCode = /* @__PURE__ */ new Map();
    protocolsByName = /* @__PURE__ */ new Map();
    getProtocol(key) {
      let codec;
      if (typeof key === "string") {
        codec = this.protocolsByName.get(key);
      } else {
        codec = this.protocolsByCode.get(key);
      }
      if (codec == null) {
        throw new UnknownProtocolError(`Protocol ${key} was unknown`);
      }
      return codec;
    }
    addProtocol(codec) {
      this.protocolsByCode.set(codec.code, codec);
      this.protocolsByName.set(codec.name, codec);
      codec.aliases?.forEach((alias) => {
        this.protocolsByName.set(alias, codec);
      });
    }
    removeProtocol(code8) {
      const codec = this.protocolsByCode.get(code8);
      if (codec == null) {
        return;
      }
      this.protocolsByCode.delete(codec.code);
      this.protocolsByName.delete(codec.name);
      codec.aliases?.forEach((alias) => {
        this.protocolsByName.delete(alias);
      });
    }
  };
  var registry = new Registry();
  var codecs = [{
    code: CODE_IP4,
    name: "ip4",
    size: 32,
    valueToBytes: ip4ToBytes,
    bytesToValue: ip4ToString,
    validate: (value2) => {
      if (!isIPv4(value2)) {
        throw new ValidationError(`Invalid IPv4 address "${value2}"`);
      }
    }
  }, {
    code: CODE_TCP,
    name: "tcp",
    size: 16,
    valueToBytes: port2bytes,
    bytesToValue: bytes2port,
    validate: validatePort
  }, {
    code: CODE_UDP,
    name: "udp",
    size: 16,
    valueToBytes: port2bytes,
    bytesToValue: bytes2port,
    validate: validatePort
  }, {
    code: CODE_DCCP,
    name: "dccp",
    size: 16,
    valueToBytes: port2bytes,
    bytesToValue: bytes2port,
    validate: validatePort
  }, {
    code: CODE_IP6,
    name: "ip6",
    size: 128,
    valueToBytes: ip6ToBytes,
    bytesToValue: ip6ToString,
    stringToValue: ip6StringToValue,
    validate: (value2) => {
      if (!isIPv6(value2)) {
        throw new ValidationError(`Invalid IPv6 address "${value2}"`);
      }
    }
  }, {
    code: CODE_IP6ZONE,
    name: "ip6zone",
    size: V
  }, {
    code: CODE_IPCIDR,
    name: "ipcidr",
    size: 8,
    bytesToValue: bytesToString("base10"),
    valueToBytes: stringToBytes("base10")
  }, {
    code: CODE_DNS,
    name: "dns",
    size: V
  }, {
    code: CODE_DNS4,
    name: "dns4",
    size: V
  }, {
    code: CODE_DNS6,
    name: "dns6",
    size: V
  }, {
    code: CODE_DNSADDR,
    name: "dnsaddr",
    size: V
  }, {
    code: CODE_SCTP,
    name: "sctp",
    size: 16,
    valueToBytes: port2bytes,
    bytesToValue: bytes2port,
    validate: validatePort
  }, {
    code: CODE_UDT,
    name: "udt"
  }, {
    code: CODE_UTP,
    name: "utp"
  }, {
    code: CODE_UNIX,
    name: "unix",
    size: V,
    stringToValue: (str) => decodeURIComponent(str),
    valueToString: (val) => encodeURIComponent(val)
  }, {
    code: CODE_P2P,
    name: "p2p",
    aliases: ["ipfs"],
    size: V,
    bytesToValue: bytesToString("base58btc"),
    valueToBytes: (val) => {
      if (val.startsWith("Q") || val.startsWith("1")) {
        return stringToBytes("base58btc")(val);
      }
      return CID.parse(val).multihash.bytes;
    }
  }, {
    code: CODE_ONION,
    name: "onion",
    size: 96,
    bytesToValue: bytes2onion,
    valueToBytes: onion2bytes
  }, {
    code: CODE_ONION3,
    name: "onion3",
    size: 296,
    bytesToValue: bytes2onion,
    valueToBytes: onion32bytes
  }, {
    code: CODE_GARLIC64,
    name: "garlic64",
    size: V
  }, {
    code: CODE_GARLIC32,
    name: "garlic32",
    size: V
  }, {
    code: CODE_TLS,
    name: "tls"
  }, {
    code: CODE_SNI,
    name: "sni",
    size: V
  }, {
    code: CODE_NOISE,
    name: "noise"
  }, {
    code: CODE_QUIC,
    name: "quic"
  }, {
    code: CODE_QUIC_V1,
    name: "quic-v1"
  }, {
    code: CODE_WEBTRANSPORT,
    name: "webtransport"
  }, {
    code: CODE_CERTHASH,
    name: "certhash",
    size: V,
    bytesToValue: bytes2mb(base64url),
    valueToBytes: mb2bytes
  }, {
    code: CODE_HTTP,
    name: "http"
  }, {
    code: CODE_HTTP_PATH,
    name: "http-path",
    size: V,
    stringToValue: (str) => `/${decodeURIComponent(str)}`,
    valueToString: (val) => encodeURIComponent(val.substring(1))
  }, {
    code: CODE_HTTPS,
    name: "https"
  }, {
    code: CODE_WS,
    name: "ws"
  }, {
    code: CODE_WSS,
    name: "wss"
  }, {
    code: CODE_P2P_WEBSOCKET_STAR,
    name: "p2p-websocket-star"
  }, {
    code: CODE_P2P_STARDUST,
    name: "p2p-stardust"
  }, {
    code: CODE_P2P_WEBRTC_STAR,
    name: "p2p-webrtc-star"
  }, {
    code: CODE_P2P_WEBRTC_DIRECT,
    name: "p2p-webrtc-direct"
  }, {
    code: CODE_WEBRTC_DIRECT,
    name: "webrtc-direct"
  }, {
    code: CODE_WEBRTC,
    name: "webrtc"
  }, {
    code: CODE_P2P_CIRCUIT,
    name: "p2p-circuit"
  }, {
    code: CODE_MEMORY,
    name: "memory",
    size: V
  }];
  codecs.forEach((codec) => {
    registry.addProtocol(codec);
  });

  // node_modules/@multiformats/multiaddr/dist/src/components.js
  function bytesToComponents(bytes) {
    const components = [];
    let i2 = 0;
    while (i2 < bytes.length) {
      const code8 = decode8(bytes, i2);
      const codec = registry.getProtocol(code8);
      const codeLength = encodingLength2(code8);
      const size = sizeForAddr(codec, bytes, i2 + codeLength);
      let sizeLength = 0;
      if (size > 0 && codec.size === V) {
        sizeLength = encodingLength2(size);
      }
      const componentLength = codeLength + sizeLength + size;
      const component = {
        code: code8,
        name: codec.name,
        bytes: bytes.subarray(i2, i2 + componentLength)
      };
      if (size > 0) {
        const valueOffset = i2 + codeLength + sizeLength;
        const valueBytes = bytes.subarray(valueOffset, valueOffset + size);
        component.value = codec.bytesToValue?.(valueBytes) ?? toString2(valueBytes);
      }
      components.push(component);
      i2 += componentLength;
    }
    return components;
  }
  function componentsToBytes(components) {
    let length4 = 0;
    const bytes = [];
    for (const component of components) {
      if (component.bytes == null) {
        const codec = registry.getProtocol(component.code);
        const codecLength = encodingLength2(component.code);
        let valueBytes;
        let valueLength = 0;
        let valueLengthLength = 0;
        if (component.value != null) {
          valueBytes = codec.valueToBytes?.(component.value) ?? fromString2(component.value);
          valueLength = valueBytes.byteLength;
          if (codec.size === V) {
            valueLengthLength = encodingLength2(valueLength);
          }
        }
        const bytes2 = new Uint8Array(codecLength + valueLengthLength + valueLength);
        let offset = 0;
        encodeUint8Array(component.code, bytes2, offset);
        offset += codecLength;
        if (valueBytes != null) {
          if (codec.size === V) {
            encodeUint8Array(valueLength, bytes2, offset);
            offset += valueLengthLength;
          }
          bytes2.set(valueBytes, offset);
        }
        component.bytes = bytes2;
      }
      bytes.push(component.bytes);
      length4 += component.bytes.byteLength;
    }
    return concat(bytes, length4);
  }
  function stringToComponents(string2) {
    if (string2.charAt(0) !== "/") {
      throw new InvalidMultiaddrError2('String multiaddr must start with "/"');
    }
    const components = [];
    let collecting = "protocol";
    let value2 = "";
    let protocol = "";
    for (let i2 = 1; i2 < string2.length; i2++) {
      const char = string2.charAt(i2);
      if (char !== "/") {
        if (collecting === "protocol") {
          protocol += string2.charAt(i2);
        } else {
          value2 += string2.charAt(i2);
        }
      }
      const ended = i2 === string2.length - 1;
      if (char === "/" || ended) {
        const codec = registry.getProtocol(protocol);
        if (collecting === "protocol") {
          if (codec.size == null || codec.size === 0) {
            components.push({
              code: codec.code,
              name: codec.name
            });
            value2 = "";
            protocol = "";
            collecting = "protocol";
            continue;
          } else if (ended) {
            throw new InvalidMultiaddrError2(`Component ${protocol} was missing value`);
          }
          collecting = "value";
        } else if (collecting === "value") {
          const component = {
            code: codec.code,
            name: codec.name
          };
          if (codec.size != null && codec.size !== 0) {
            if (value2 === "") {
              throw new InvalidMultiaddrError2(`Component ${protocol} was missing value`);
            }
            component.value = codec.stringToValue?.(value2) ?? value2;
          }
          components.push(component);
          value2 = "";
          protocol = "";
          collecting = "protocol";
        }
      }
    }
    if (protocol !== "" && value2 !== "") {
      throw new InvalidMultiaddrError2("Incomplete multiaddr");
    }
    return components;
  }
  function componentsToString(components) {
    return `/${components.flatMap((component) => {
      if (component.value == null) {
        return component.name;
      }
      const codec = registry.getProtocol(component.code);
      if (codec == null) {
        throw new InvalidMultiaddrError2(`Unknown protocol code ${component.code}`);
      }
      return [
        component.name,
        codec.valueToString?.(component.value) ?? component.value
      ];
    }).join("/")}`;
  }
  function sizeForAddr(codec, bytes, offset) {
    if (codec.size == null || codec.size === 0) {
      return 0;
    }
    if (codec.size > 0) {
      return codec.size / 8;
    }
    return decode8(bytes, offset);
  }

  // node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
  var inspect = Symbol.for("nodejs.util.inspect.custom");
  var symbol2 = Symbol.for("@multiformats/multiaddr");
  function toComponents(addr) {
    if (addr == null) {
      addr = "/";
    }
    if (isMultiaddr(addr)) {
      return addr.getComponents();
    }
    if (addr instanceof Uint8Array) {
      return bytesToComponents(addr);
    }
    if (typeof addr === "string") {
      addr = addr.replace(/\/(\/)+/, "/").replace(/(\/)+$/, "");
      if (addr === "") {
        addr = "/";
      }
      return stringToComponents(addr);
    }
    if (Array.isArray(addr)) {
      return addr;
    }
    throw new InvalidMultiaddrError2("Must be a string, Uint8Array, Component[], or another Multiaddr");
  }
  var Multiaddr = class _Multiaddr {
    [symbol2] = true;
    #components;
    // cache string representation
    #string;
    // cache byte representation
    #bytes;
    constructor(addr = "/", options2 = {}) {
      this.#components = toComponents(addr);
      if (options2.validate !== false) {
        validate2(this);
      }
    }
    get bytes() {
      if (this.#bytes == null) {
        this.#bytes = componentsToBytes(this.#components);
      }
      return this.#bytes;
    }
    toString() {
      if (this.#string == null) {
        this.#string = componentsToString(this.#components);
      }
      return this.#string;
    }
    toJSON() {
      return this.toString();
    }
    getComponents() {
      return [
        ...this.#components.map((c2) => ({ ...c2 }))
      ];
    }
    encapsulate(addr) {
      const ma = new _Multiaddr(addr);
      return new _Multiaddr([
        ...this.#components,
        ...ma.getComponents()
      ], {
        validate: false
      });
    }
    decapsulate(addr) {
      const addrString = addr.toString();
      const s2 = this.toString();
      const i2 = s2.lastIndexOf(addrString);
      if (i2 < 0) {
        throw new InvalidParametersError2(`Address ${this.toString()} does not contain subaddress: ${addrString}`);
      }
      return new _Multiaddr(s2.slice(0, i2), {
        validate: false
      });
    }
    decapsulateCode(code8) {
      let index;
      for (let i2 = this.#components.length - 1; i2 > -1; i2--) {
        if (this.#components[i2].code === code8) {
          index = i2;
          break;
        }
      }
      return new _Multiaddr(this.#components.slice(0, index), {
        validate: false
      });
    }
    equals(addr) {
      return equals3(this.bytes, addr.bytes);
    }
    /**
     * Returns Multiaddr as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { multiaddr } from '@multiformats/multiaddr'
     *
     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
     * ```
     */
    [inspect]() {
      return `Multiaddr(${this.toString()})`;
    }
  };
  function validate2(addr) {
    addr.getComponents().forEach((component) => {
      const codec = registry.getProtocol(component.code);
      if (component.value == null) {
        return;
      }
      codec.validate?.(component.value);
    });
  }

  // node_modules/@multiformats/multiaddr/dist/src/index.js
  function isMultiaddr(value2) {
    return Boolean(value2?.[symbol2]);
  }
  function multiaddr(addr) {
    return new Multiaddr(addr);
  }

  // node_modules/it-queueless-pushable/node_modules/race-signal/dist/src/index.js
  var AbortError4 = class extends Error {
    type;
    code;
    constructor(message2, code8, name9) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.name = name9 ?? "AbortError";
      this.code = code8 ?? "ABORT_ERR";
    }
  };
  async function raceSignal2(promise, signal, opts) {
    if (signal == null) {
      return promise;
    }
    if (signal.aborted) {
      promise.catch(() => {
      });
      return Promise.reject(new AbortError4(opts?.errorMessage, opts?.errorCode, opts?.errorName));
    }
    let listener;
    const error = new AbortError4(opts?.errorMessage, opts?.errorCode, opts?.errorName);
    try {
      return await Promise.race([
        promise,
        new Promise((resolve8, reject) => {
          listener = () => {
            reject(error);
          };
          signal.addEventListener("abort", listener);
        })
      ]);
    } finally {
      if (listener != null) {
        signal.removeEventListener("abort", listener);
      }
    }
  }

  // node_modules/it-queueless-pushable/dist/src/index.js
  var QueuelessPushable = class {
    readNext;
    haveNext;
    ended;
    nextResult;
    error;
    constructor() {
      this.ended = false;
      this.readNext = pDefer();
      this.haveNext = pDefer();
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    async next() {
      if (this.nextResult == null) {
        await this.haveNext.promise;
      }
      if (this.nextResult == null) {
        throw new Error("HaveNext promise resolved but nextResult was undefined");
      }
      const nextResult = this.nextResult;
      this.nextResult = void 0;
      this.readNext.resolve();
      this.readNext = pDefer();
      return nextResult;
    }
    async throw(err2) {
      this.ended = true;
      this.error = err2;
      if (err2 != null) {
        this.haveNext.promise.catch(() => {
        });
        this.haveNext.reject(err2);
      }
      const result = {
        done: true,
        value: void 0
      };
      return result;
    }
    async return() {
      const result = {
        done: true,
        value: void 0
      };
      this.ended = true;
      this.nextResult = result;
      this.haveNext.resolve();
      return result;
    }
    async push(value2, options2) {
      await this._push(value2, options2);
    }
    async end(err2, options2) {
      if (err2 != null) {
        await this.throw(err2);
      } else {
        await this._push(void 0, options2);
      }
    }
    async _push(value2, options2) {
      if (value2 != null && this.ended) {
        throw this.error ?? new Error("Cannot push value onto an ended pushable");
      }
      while (this.nextResult != null) {
        await this.readNext.promise;
      }
      if (value2 != null) {
        this.nextResult = { done: false, value: value2 };
      } else {
        this.ended = true;
        this.nextResult = { done: true, value: void 0 };
      }
      this.haveNext.resolve();
      this.haveNext = pDefer();
      await raceSignal2(this.readNext.promise, options2?.signal, options2);
    }
  };
  function queuelessPushable() {
    return new QueuelessPushable();
  }

  // node_modules/it-merge/dist/src/index.js
  function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  async function addAllToPushable(sources, output, signal) {
    try {
      await Promise.all(sources.map(async (source) => {
        for await (const item of source) {
          await output.push(item, {
            signal
          });
          signal.throwIfAborted();
        }
      }));
      await output.end(void 0, {
        signal
      });
    } catch (err2) {
      await output.end(err2, {
        signal
      }).catch(() => {
      });
    }
  }
  async function* mergeSources(sources) {
    const controller = new AbortController();
    const output = queuelessPushable();
    addAllToPushable(sources, output, controller.signal).catch(() => {
    });
    try {
      yield* output;
    } finally {
      controller.abort();
    }
  }
  function* mergeSyncSources(syncSources) {
    for (const source of syncSources) {
      yield* source;
    }
  }
  function merge(...sources) {
    const syncSources = [];
    for (const source of sources) {
      if (!isAsyncIterable(source)) {
        syncSources.push(source);
      }
    }
    if (syncSources.length === sources.length) {
      return mergeSyncSources(syncSources);
    }
    return mergeSources(sources);
  }
  var src_default = merge;

  // node_modules/it-pipe/dist/src/index.js
  function pipe(first2, ...rest) {
    if (first2 == null) {
      throw new Error("Empty pipeline");
    }
    if (isDuplex(first2)) {
      const duplex = first2;
      first2 = () => duplex.source;
    } else if (isIterable(first2) || isAsyncIterable2(first2)) {
      const source = first2;
      first2 = () => source;
    }
    const fns = [first2, ...rest];
    if (fns.length > 1) {
      if (isDuplex(fns[fns.length - 1])) {
        fns[fns.length - 1] = fns[fns.length - 1].sink;
      }
    }
    if (fns.length > 2) {
      for (let i2 = 1; i2 < fns.length - 1; i2++) {
        if (isDuplex(fns[i2])) {
          fns[i2] = duplexPipelineFn(fns[i2]);
        }
      }
    }
    return rawPipe(...fns);
  }
  var rawPipe = (...fns) => {
    let res;
    while (fns.length > 0) {
      res = fns.shift()(res);
    }
    return res;
  };
  var isAsyncIterable2 = (obj) => {
    return obj?.[Symbol.asyncIterator] != null;
  };
  var isIterable = (obj) => {
    return obj?.[Symbol.iterator] != null;
  };
  var isDuplex = (obj) => {
    if (obj == null) {
      return false;
    }
    return obj.sink != null && obj.source != null;
  };
  var duplexPipelineFn = (duplex) => {
    return (source) => {
      const p2 = duplex.sink(source);
      if (p2?.then != null) {
        const stream = pushable({
          objectMode: true
        });
        p2.then(() => {
          stream.end();
        }, (err2) => {
          stream.end(err2);
        });
        let sourceWrap;
        const source2 = duplex.source;
        if (isAsyncIterable2(source2)) {
          sourceWrap = async function* () {
            yield* source2;
            stream.end();
          };
        } else if (isIterable(source2)) {
          sourceWrap = function* () {
            yield* source2;
            stream.end();
          };
        } else {
          throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
        }
        return src_default(stream, sourceWrap());
      }
      return duplex.source;
    };
  };

  // node_modules/@libp2p/utils/dist/src/stream-utils.js
  var DEFAULT_MAX_BUFFER_SIZE = 4194304;
  var UnwrappedError = class extends Error {
    static name = "UnwrappedError";
    name = "UnwrappedError";
  };
  var InvalidMessageLengthError = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };
  function isStream(obj) {
    return typeof obj?.closeRead === "function";
  }
  function isMultiaddrConnection(obj) {
    return typeof obj?.close === "function";
  }
  function isEOF(obj) {
    if (isStream(obj)) {
      return obj.remoteWriteStatus !== "writable" && obj.readBufferLength === 0;
    }
    if (isMultiaddrConnection(obj)) {
      return obj.status !== "open";
    }
    return false;
  }
  function isValid(obj) {
    return obj?.addEventListener != null && obj?.removeEventListener != null && obj?.send != null && obj?.push != null && obj?.log != null;
  }
  function byteStream(stream, opts) {
    const maxBufferSize2 = opts?.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE;
    const readBuffer = new Uint8ArrayList();
    let hasBytes;
    let unwrapped = false;
    if (!isValid(stream)) {
      throw new InvalidParametersError("Argument should be a Stream or a Multiaddr");
    }
    const byteStreamOnMessageListener = (evt) => {
      readBuffer.append(evt.data);
      if (readBuffer.byteLength > maxBufferSize2) {
        const readBufferSize = readBuffer.byteLength;
        readBuffer.consume(readBuffer.byteLength);
        hasBytes?.reject(new Error(`Read buffer overflow - ${readBufferSize} > ${maxBufferSize2}`));
      }
      hasBytes?.resolve();
    };
    stream.addEventListener("message", byteStreamOnMessageListener);
    const byteStreamOnCloseListener = (evt) => {
      if (evt.error != null) {
        hasBytes?.reject(evt.error);
      } else {
        hasBytes?.resolve();
      }
    };
    stream.addEventListener("close", byteStreamOnCloseListener);
    const byteStreamOnRemoteCloseWrite = () => {
      hasBytes?.resolve();
    };
    stream.addEventListener("remoteCloseWrite", byteStreamOnRemoteCloseWrite);
    const byteStream2 = {
      readBuffer,
      // @ts-expect-error options type prevents type inference
      async read(options2) {
        if (unwrapped === true) {
          throw new UnwrappedError("Stream was unwrapped");
        }
        if (isEOF(stream)) {
          if (options2?.bytes == null) {
            return null;
          }
          if (readBuffer.byteLength < options2.bytes) {
            stream.log.error("closed after reading %d/%d bytes", readBuffer.byteLength, options2.bytes);
            throw new UnexpectedEOFError(`Unexpected EOF - stream closed after reading ${readBuffer.byteLength}/${options2.bytes} bytes`);
          }
        }
        const bytesToRead = options2?.bytes ?? 1;
        hasBytes = Promise.withResolvers();
        while (true) {
          if (readBuffer.byteLength >= bytesToRead) {
            hasBytes.resolve();
            break;
          }
          await raceSignal(hasBytes.promise, options2?.signal);
          if (isEOF(stream)) {
            if (readBuffer.byteLength === 0 && options2?.bytes == null) {
              return null;
            }
            break;
          }
          hasBytes = Promise.withResolvers();
        }
        const toRead = options2?.bytes ?? readBuffer.byteLength;
        if (readBuffer.byteLength < toRead) {
          if (isEOF(stream)) {
            stream.log.error("closed while reading %d/%d bytes", readBuffer.byteLength, toRead);
            throw new UnexpectedEOFError(`Unexpected EOF - stream closed while reading ${readBuffer.byteLength}/${toRead} bytes`);
          }
          return byteStream2.read(options2);
        }
        const output = readBuffer.sublist(0, toRead);
        readBuffer.consume(toRead);
        return output;
      },
      async write(data, options2) {
        if (unwrapped === true) {
          throw new UnwrappedError("Stream was unwrapped");
        }
        if (!stream.send(data)) {
          await pEvent(stream, "drain", {
            signal: options2?.signal,
            rejectionEvents: ["close"]
          });
        }
      },
      unwrap() {
        if (unwrapped) {
          return stream;
        }
        unwrapped = true;
        stream.removeEventListener("message", byteStreamOnMessageListener);
        stream.removeEventListener("close", byteStreamOnCloseListener);
        stream.removeEventListener("remoteCloseWrite", byteStreamOnRemoteCloseWrite);
        if (readBuffer.byteLength > 0) {
          stream.log("stream unwrapped with %d unread bytes", readBuffer.byteLength);
          stream.push(readBuffer);
        }
        return stream;
      }
    };
    return byteStream2;
  }
  function lpStream(stream, opts = {}) {
    const bytes = byteStream(stream, opts);
    if (opts.maxDataLength != null && opts.maxLengthLength == null) {
      opts.maxLengthLength = encodingLength2(opts.maxDataLength);
    }
    const decodeLength = opts?.lengthDecoder ?? decode8;
    const encodeLength2 = opts?.lengthEncoder ?? encode7;
    const lpStream2 = {
      async read(options2) {
        let dataLength = -1;
        const lengthBuffer = new Uint8ArrayList();
        while (true) {
          const buf3 = await bytes.read({
            ...options2,
            bytes: 1
          });
          if (buf3 == null) {
            break;
          }
          lengthBuffer.append(buf3);
          try {
            dataLength = decodeLength(lengthBuffer);
          } catch (err2) {
            if (err2 instanceof RangeError) {
              continue;
            }
            throw err2;
          }
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
            throw new InvalidDataLengthLengthError(`Message length length too long - ${lengthBuffer.byteLength} > ${opts.maxLengthLength}`);
          }
          if (dataLength > -1) {
            break;
          }
        }
        if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
          throw new InvalidDataLengthError(`Message length too long - ${dataLength} > ${opts.maxDataLength}`);
        }
        const buf2 = await bytes.read({
          ...options2,
          bytes: dataLength
        });
        if (buf2 == null) {
          stream.log.error("tried to read %d bytes but the stream closed", dataLength);
          throw new UnexpectedEOFError(`Unexpected EOF - tried to read ${dataLength} bytes but the stream closed`);
        }
        if (buf2.byteLength !== dataLength) {
          stream.log.error("read %d/%d bytes before the stream closed", buf2.byteLength, dataLength);
          throw new UnexpectedEOFError(`Unexpected EOF - read ${buf2.byteLength}/${dataLength} bytes before the stream closed`);
        }
        return buf2;
      },
      async write(data, options2) {
        await bytes.write(new Uint8ArrayList(encodeLength2(data.byteLength), data), options2);
      },
      async writeV(data, options2) {
        const list = new Uint8ArrayList(...data.flatMap((buf2) => [encodeLength2(buf2.byteLength), buf2]));
        await bytes.write(list, options2);
      },
      unwrap() {
        return bytes.unwrap();
      }
    };
    return lpStream2;
  }
  function pbStream(stream, opts) {
    const lp = lpStream(stream, opts);
    const pbStream2 = {
      read: async (proto, options2) => {
        const value2 = await lp.read(options2);
        return proto.decode(value2);
      },
      write: async (message2, proto, options2) => {
        await lp.write(proto.encode(message2), options2);
      },
      writeV: async (messages2, proto, options2) => {
        await lp.writeV(messages2.map((message2) => proto.encode(message2)), options2);
      },
      pb: (proto) => {
        return {
          read: async (options2) => pbStream2.read(proto, options2),
          write: async (d2, options2) => pbStream2.write(d2, proto, options2),
          writeV: async (d2, options2) => pbStream2.writeV(d2, proto, options2),
          unwrap: () => pbStream2
        };
      },
      unwrap: () => {
        return lp.unwrap();
      }
    };
    return pbStream2;
  }

  // node_modules/@libp2p/utils/dist/src/length-prefixed-decoder.js
  var DEFAULT_MAX_BUFFER_SIZE2 = 1024 * 1024 * 4;
  var DEFAULT_MAX_DATA_LENGTH = 1024 * 1024 * 4;
  var LengthPrefixedDecoder = class {
    buffer;
    maxBufferSize;
    lengthDecoder;
    maxDataLength;
    encodingLength;
    constructor(init = {}) {
      this.buffer = new Uint8ArrayList();
      this.maxBufferSize = init.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE2;
      this.maxDataLength = init.maxDataLength ?? DEFAULT_MAX_DATA_LENGTH;
      this.lengthDecoder = init.lengthDecoder ?? decode8;
      this.encodingLength = init.encodingLength ?? encodingLength2;
    }
    /**
     * Decodes length-prefixed data
     */
    *decode(buf2) {
      this.buffer.append(buf2);
      if (this.buffer.byteLength > this.maxBufferSize) {
        throw new InvalidParametersError(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);
      }
      while (true) {
        let dataLength;
        try {
          dataLength = this.lengthDecoder(this.buffer);
        } catch (err2) {
          if (err2 instanceof RangeError) {
            break;
          }
          throw err2;
        }
        if (dataLength < 0 || dataLength > this.maxDataLength) {
          throw new InvalidMessageLengthError("Invalid message length");
        }
        const lengthLength = this.encodingLength(dataLength);
        const chunkLength = lengthLength + dataLength;
        if (this.buffer.byteLength >= chunkLength) {
          const buf3 = this.buffer.sublist(lengthLength, chunkLength);
          this.buffer.consume(chunkLength);
          if (buf3.byteLength > 0) {
            yield buf3;
          }
        } else {
          break;
        }
      }
    }
  };

  // node_modules/cborg/lib/is.js
  var typeofs = [
    "string",
    "number",
    "bigint",
    "symbol"
  ];
  var objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "HTMLElement",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function is(value2) {
    if (value2 === null) {
      return "null";
    }
    if (value2 === void 0) {
      return "undefined";
    }
    if (value2 === true || value2 === false) {
      return "boolean";
    }
    const typeOf = typeof value2;
    if (typeofs.includes(typeOf)) {
      return typeOf;
    }
    if (typeOf === "function") {
      return "Function";
    }
    if (Array.isArray(value2)) {
      return "Array";
    }
    if (isBuffer(value2)) {
      return "Buffer";
    }
    const objectType = getObjectType(value2);
    if (objectType) {
      return objectType;
    }
    return "Object";
  }
  function isBuffer(value2) {
    return value2 && value2.constructor && value2.constructor.isBuffer && value2.constructor.isBuffer.call(null, value2);
  }
  function getObjectType(value2) {
    const objectTypeName = Object.prototype.toString.call(value2).slice(8, -1);
    if (objectTypeNames.includes(objectTypeName)) {
      return objectTypeName;
    }
    return void 0;
  }

  // node_modules/cborg/lib/token.js
  var Type = class {
    /**
     * @param {number} major
     * @param {string} name
     * @param {boolean} terminal
     */
    constructor(major, name9, terminal) {
      this.major = major;
      this.majorEncoded = major << 5;
      this.name = name9;
      this.terminal = terminal;
    }
    /* c8 ignore next 3 */
    toString() {
      return `Type[${this.major}].${this.name}`;
    }
    /**
     * @param {Type} typ
     * @returns {number}
     */
    compare(typ) {
      return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
    }
  };
  Type.uint = new Type(0, "uint", true);
  Type.negint = new Type(1, "negint", true);
  Type.bytes = new Type(2, "bytes", true);
  Type.string = new Type(3, "string", true);
  Type.array = new Type(4, "array", false);
  Type.map = new Type(5, "map", false);
  Type.tag = new Type(6, "tag", false);
  Type.float = new Type(7, "float", true);
  Type.false = new Type(7, "false", true);
  Type.true = new Type(7, "true", true);
  Type.null = new Type(7, "null", true);
  Type.undefined = new Type(7, "undefined", true);
  Type.break = new Type(7, "break", true);
  var Token = class {
    /**
     * @param {Type} type
     * @param {any} [value]
     * @param {number} [encodedLength]
     */
    constructor(type, value2, encodedLength) {
      this.type = type;
      this.value = value2;
      this.encodedLength = encodedLength;
      this.encodedBytes = void 0;
      this.byteValue = void 0;
    }
    /* c8 ignore next 3 */
    toString() {
      return `Token[${this.type}].${this.value}`;
    }
  };

  // node_modules/cborg/lib/byte-utils.js
  var useBuffer = globalThis.process && // @ts-ignore
  !globalThis.process.browser && // @ts-ignore
  globalThis.Buffer && // @ts-ignore
  typeof globalThis.Buffer.isBuffer === "function";
  var textDecoder2 = new TextDecoder();
  var textEncoder2 = new TextEncoder();
  function isBuffer2(buf2) {
    return useBuffer && globalThis.Buffer.isBuffer(buf2);
  }
  function asU8A(buf2) {
    if (!(buf2 instanceof Uint8Array)) {
      return Uint8Array.from(buf2);
    }
    return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
  }
  var toString3 = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start2, end) => {
      return end - start2 > 64 ? (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(bytes.subarray(start2, end)).toString("utf8")
      ) : utf8Slice(bytes, start2, end);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start2, end) => {
      return end - start2 > 64 ? textDecoder2.decode(bytes.subarray(start2, end)) : utf8Slice(bytes, start2, end);
    }
  );
  var fromString3 = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {string} string
     */
    (string2) => {
      return string2.length > 64 ? (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(string2)
      ) : utf8ToBytes2(string2);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {string} string
     */
    (string2) => {
      return string2.length > 64 ? textEncoder2.encode(string2) : utf8ToBytes2(string2);
    }
  );
  var fromArray = (arr) => {
    return Uint8Array.from(arr);
  };
  var slice = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start2, end) => {
      if (isBuffer2(bytes)) {
        return new Uint8Array(bytes.subarray(start2, end));
      }
      return bytes.slice(start2, end);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array} bytes
     * @param {number} start
     * @param {number} end
     */
    (bytes, start2, end) => {
      return bytes.slice(start2, end);
    }
  );
  var concat2 = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array[]} chunks
     * @param {number} length
     * @returns {Uint8Array}
     */
    (chunks, length4) => {
      chunks = chunks.map((c2) => c2 instanceof Uint8Array ? c2 : (
        // eslint-disable-line operator-linebreak
        // @ts-ignore
        globalThis.Buffer.from(c2)
      ));
      return asU8A(globalThis.Buffer.concat(chunks, length4));
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {Uint8Array[]} chunks
     * @param {number} length
     * @returns {Uint8Array}
     */
    (chunks, length4) => {
      const out = new Uint8Array(length4);
      let off = 0;
      for (let b of chunks) {
        if (off + b.length > out.length) {
          b = b.subarray(0, out.length - off);
        }
        out.set(b, off);
        off += b.length;
      }
      return out;
    }
  );
  var alloc3 = useBuffer ? (
    // eslint-disable-line operator-linebreak
    /**
     * @param {number} size
     * @returns {Uint8Array}
     */
    (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    }
  ) : (
    // eslint-disable-line operator-linebreak
    /**
     * @param {number} size
     * @returns {Uint8Array}
     */
    (size) => {
      return new Uint8Array(size);
    }
  );
  function compare(b1, b2) {
    if (isBuffer2(b1) && isBuffer2(b2)) {
      return b1.compare(b2);
    }
    for (let i2 = 0; i2 < b1.length; i2++) {
      if (b1[i2] === b2[i2]) {
        continue;
      }
      return b1[i2] < b2[i2] ? -1 : 1;
    }
    return 0;
  }
  function utf8ToBytes2(str) {
    const out = [];
    let p2 = 0;
    for (let i2 = 0; i2 < str.length; i2++) {
      let c2 = str.charCodeAt(i2);
      if (c2 < 128) {
        out[p2++] = c2;
      } else if (c2 < 2048) {
        out[p2++] = c2 >> 6 | 192;
        out[p2++] = c2 & 63 | 128;
      } else if ((c2 & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
        c2 = 65536 + ((c2 & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
        out[p2++] = c2 >> 18 | 240;
        out[p2++] = c2 >> 12 & 63 | 128;
        out[p2++] = c2 >> 6 & 63 | 128;
        out[p2++] = c2 & 63 | 128;
      } else {
        out[p2++] = c2 >> 12 | 224;
        out[p2++] = c2 >> 6 & 63 | 128;
        out[p2++] = c2 & 63 | 128;
      }
    }
    return out;
  }
  function utf8Slice(buf2, offset, end) {
    const res = [];
    while (offset < end) {
      const firstByte = buf2[offset];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (offset + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[offset + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[offset + 1];
            thirdByte = buf2[offset + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[offset + 1];
            thirdByte = buf2[offset + 2];
            fourthByte = buf2[offset + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      offset += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }

  // node_modules/cborg/lib/bl.js
  var defaultChunkSize = 256;
  var Bl = class {
    /**
     * @param {number} [chunkSize]
     */
    constructor(chunkSize = defaultChunkSize) {
      this.chunkSize = chunkSize;
      this.cursor = 0;
      this.maxCursor = -1;
      this.chunks = [];
      this._initReuseChunk = null;
    }
    reset() {
      this.cursor = 0;
      this.maxCursor = -1;
      if (this.chunks.length) {
        this.chunks = [];
      }
      if (this._initReuseChunk !== null) {
        this.chunks.push(this._initReuseChunk);
        this.maxCursor = this._initReuseChunk.length - 1;
      }
    }
    /**
     * @param {Uint8Array|number[]} bytes
     */
    push(bytes) {
      let topChunk = this.chunks[this.chunks.length - 1];
      const newMax = this.cursor + bytes.length;
      if (newMax <= this.maxCursor + 1) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        topChunk.set(bytes, chunkPos);
      } else {
        if (topChunk) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          if (chunkPos < topChunk.length) {
            this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
            this.maxCursor = this.cursor - 1;
          }
        }
        if (bytes.length < 64 && bytes.length < this.chunkSize) {
          topChunk = alloc3(this.chunkSize);
          this.chunks.push(topChunk);
          this.maxCursor += topChunk.length;
          if (this._initReuseChunk === null) {
            this._initReuseChunk = topChunk;
          }
          topChunk.set(bytes, 0);
        } else {
          this.chunks.push(bytes);
          this.maxCursor += bytes.length;
        }
      }
      this.cursor += bytes.length;
    }
    /**
     * @param {boolean} [reset]
     * @returns {Uint8Array}
     */
    toBytes(reset = false) {
      let byts;
      if (this.chunks.length === 1) {
        const chunk = this.chunks[0];
        if (reset && this.cursor > chunk.length / 2) {
          byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
          this._initReuseChunk = null;
          this.chunks = [];
        } else {
          byts = slice(chunk, 0, this.cursor);
        }
      } else {
        byts = concat2(this.chunks, this.cursor);
      }
      if (reset) {
        this.reset();
      }
      return byts;
    }
  };

  // node_modules/cborg/lib/common.js
  var decodeErrPrefix = "CBOR decode error:";
  var encodeErrPrefix = "CBOR encode error:";
  var uintMinorPrefixBytes = [];
  uintMinorPrefixBytes[23] = 1;
  uintMinorPrefixBytes[24] = 2;
  uintMinorPrefixBytes[25] = 3;
  uintMinorPrefixBytes[26] = 5;
  uintMinorPrefixBytes[27] = 9;
  function assertEnoughData(data, pos, need) {
    if (data.length - pos < need) {
      throw new Error(`${decodeErrPrefix} not enough data for type`);
    }
  }

  // node_modules/cborg/lib/0uint.js
  var uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
  function readUint8(data, offset, options2) {
    assertEnoughData(data, offset, 1);
    const value2 = data[offset];
    if (options2.strict === true && value2 < uintBoundaries[0]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value2;
  }
  function readUint16(data, offset, options2) {
    assertEnoughData(data, offset, 2);
    const value2 = data[offset] << 8 | data[offset + 1];
    if (options2.strict === true && value2 < uintBoundaries[1]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value2;
  }
  function readUint32(data, offset, options2) {
    assertEnoughData(data, offset, 4);
    const value2 = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    if (options2.strict === true && value2 < uintBoundaries[2]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    return value2;
  }
  function readUint64(data, offset, options2) {
    assertEnoughData(data, offset, 8);
    const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
    const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
    const value2 = (BigInt(hi) << BigInt(32)) + BigInt(lo);
    if (options2.strict === true && value2 < uintBoundaries[3]) {
      throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
    }
    if (value2 <= Number.MAX_SAFE_INTEGER) {
      return Number(value2);
    }
    if (options2.allowBigInt === true) {
      return value2;
    }
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  function decodeUint8(data, pos, _minor, options2) {
    return new Token(Type.uint, readUint8(data, pos + 1, options2), 2);
  }
  function decodeUint16(data, pos, _minor, options2) {
    return new Token(Type.uint, readUint16(data, pos + 1, options2), 3);
  }
  function decodeUint32(data, pos, _minor, options2) {
    return new Token(Type.uint, readUint32(data, pos + 1, options2), 5);
  }
  function decodeUint64(data, pos, _minor, options2) {
    return new Token(Type.uint, readUint64(data, pos + 1, options2), 9);
  }
  function encodeUint(buf2, token) {
    return encodeUintValue(buf2, 0, token.value);
  }
  function encodeUintValue(buf2, major, uint) {
    if (uint < uintBoundaries[0]) {
      const nuint = Number(uint);
      buf2.push([major | nuint]);
    } else if (uint < uintBoundaries[1]) {
      const nuint = Number(uint);
      buf2.push([major | 24, nuint]);
    } else if (uint < uintBoundaries[2]) {
      const nuint = Number(uint);
      buf2.push([major | 25, nuint >>> 8, nuint & 255]);
    } else if (uint < uintBoundaries[3]) {
      const nuint = Number(uint);
      buf2.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
    } else {
      const buint = BigInt(uint);
      if (buint < uintBoundaries[4]) {
        const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
        let lo = Number(buint & BigInt(4294967295));
        let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
        set[8] = lo & 255;
        lo = lo >> 8;
        set[7] = lo & 255;
        lo = lo >> 8;
        set[6] = lo & 255;
        lo = lo >> 8;
        set[5] = lo & 255;
        set[4] = hi & 255;
        hi = hi >> 8;
        set[3] = hi & 255;
        hi = hi >> 8;
        set[2] = hi & 255;
        hi = hi >> 8;
        set[1] = hi & 255;
        buf2.push(set);
      } else {
        throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
      }
    }
  }
  encodeUint.encodedSize = function encodedSize(token) {
    return encodeUintValue.encodedSize(token.value);
  };
  encodeUintValue.encodedSize = function encodedSize2(uint) {
    if (uint < uintBoundaries[0]) {
      return 1;
    }
    if (uint < uintBoundaries[1]) {
      return 2;
    }
    if (uint < uintBoundaries[2]) {
      return 3;
    }
    if (uint < uintBoundaries[3]) {
      return 5;
    }
    return 9;
  };
  encodeUint.compareTokens = function compareTokens(tok1, tok2) {
    return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
      /* c8 ignore next */
      0
    );
  };

  // node_modules/cborg/lib/1negint.js
  function decodeNegint8(data, pos, _minor, options2) {
    return new Token(Type.negint, -1 - readUint8(data, pos + 1, options2), 2);
  }
  function decodeNegint16(data, pos, _minor, options2) {
    return new Token(Type.negint, -1 - readUint16(data, pos + 1, options2), 3);
  }
  function decodeNegint32(data, pos, _minor, options2) {
    return new Token(Type.negint, -1 - readUint32(data, pos + 1, options2), 5);
  }
  var neg1b = BigInt(-1);
  var pos1b = BigInt(1);
  function decodeNegint64(data, pos, _minor, options2) {
    const int = readUint64(data, pos + 1, options2);
    if (typeof int !== "bigint") {
      const value2 = -1 - int;
      if (value2 >= Number.MIN_SAFE_INTEGER) {
        return new Token(Type.negint, value2, 9);
      }
    }
    if (options2.allowBigInt !== true) {
      throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
    }
    return new Token(Type.negint, neg1b - BigInt(int), 9);
  }
  function encodeNegint(buf2, token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    encodeUintValue(buf2, token.type.majorEncoded, unsigned);
  }
  encodeNegint.encodedSize = function encodedSize3(token) {
    const negint = token.value;
    const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
    if (unsigned < uintBoundaries[0]) {
      return 1;
    }
    if (unsigned < uintBoundaries[1]) {
      return 2;
    }
    if (unsigned < uintBoundaries[2]) {
      return 3;
    }
    if (unsigned < uintBoundaries[3]) {
      return 5;
    }
    return 9;
  };
  encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
    return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
      /* c8 ignore next */
      0
    );
  };

  // node_modules/cborg/lib/2bytes.js
  function toToken(data, pos, prefix, length4) {
    assertEnoughData(data, pos, prefix + length4);
    const buf2 = slice(data, pos + prefix, pos + prefix + length4);
    return new Token(Type.bytes, buf2, prefix + length4);
  }
  function decodeBytesCompact(data, pos, minor, _options) {
    return toToken(data, pos, 1, minor);
  }
  function decodeBytes8(data, pos, _minor, options2) {
    return toToken(data, pos, 2, readUint8(data, pos + 1, options2));
  }
  function decodeBytes16(data, pos, _minor, options2) {
    return toToken(data, pos, 3, readUint16(data, pos + 1, options2));
  }
  function decodeBytes32(data, pos, _minor, options2) {
    return toToken(data, pos, 5, readUint32(data, pos + 1, options2));
  }
  function decodeBytes64(data, pos, _minor, options2) {
    const l2 = readUint64(data, pos + 1, options2);
    if (typeof l2 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
    }
    return toToken(data, pos, 9, l2);
  }
  function tokenBytes(token) {
    if (token.encodedBytes === void 0) {
      token.encodedBytes = token.type === Type.string ? fromString3(token.value) : token.value;
    }
    return token.encodedBytes;
  }
  function encodeBytes(buf2, token) {
    const bytes = tokenBytes(token);
    encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
    buf2.push(bytes);
  }
  encodeBytes.encodedSize = function encodedSize4(token) {
    const bytes = tokenBytes(token);
    return encodeUintValue.encodedSize(bytes.length) + bytes.length;
  };
  encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
    return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
  };
  function compareBytes(b1, b2) {
    return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
  }

  // node_modules/cborg/lib/3string.js
  function toToken2(data, pos, prefix, length4, options2) {
    const totLength = prefix + length4;
    assertEnoughData(data, pos, totLength);
    const tok = new Token(Type.string, toString3(data, pos + prefix, pos + totLength), totLength);
    if (options2.retainStringBytes === true) {
      tok.byteValue = slice(data, pos + prefix, pos + totLength);
    }
    return tok;
  }
  function decodeStringCompact(data, pos, minor, options2) {
    return toToken2(data, pos, 1, minor, options2);
  }
  function decodeString8(data, pos, _minor, options2) {
    return toToken2(data, pos, 2, readUint8(data, pos + 1, options2), options2);
  }
  function decodeString16(data, pos, _minor, options2) {
    return toToken2(data, pos, 3, readUint16(data, pos + 1, options2), options2);
  }
  function decodeString32(data, pos, _minor, options2) {
    return toToken2(data, pos, 5, readUint32(data, pos + 1, options2), options2);
  }
  function decodeString64(data, pos, _minor, options2) {
    const l2 = readUint64(data, pos + 1, options2);
    if (typeof l2 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
    }
    return toToken2(data, pos, 9, l2, options2);
  }
  var encodeString = encodeBytes;

  // node_modules/cborg/lib/4array.js
  function toToken3(_data, _pos, prefix, length4) {
    return new Token(Type.array, length4, prefix);
  }
  function decodeArrayCompact(data, pos, minor, _options) {
    return toToken3(data, pos, 1, minor);
  }
  function decodeArray8(data, pos, _minor, options2) {
    return toToken3(data, pos, 2, readUint8(data, pos + 1, options2));
  }
  function decodeArray16(data, pos, _minor, options2) {
    return toToken3(data, pos, 3, readUint16(data, pos + 1, options2));
  }
  function decodeArray32(data, pos, _minor, options2) {
    return toToken3(data, pos, 5, readUint32(data, pos + 1, options2));
  }
  function decodeArray64(data, pos, _minor, options2) {
    const l2 = readUint64(data, pos + 1, options2);
    if (typeof l2 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
    }
    return toToken3(data, pos, 9, l2);
  }
  function decodeArrayIndefinite(data, pos, _minor, options2) {
    if (options2.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken3(data, pos, 1, Infinity);
  }
  function encodeArray(buf2, token) {
    encodeUintValue(buf2, Type.array.majorEncoded, token.value);
  }
  encodeArray.compareTokens = encodeUint.compareTokens;
  encodeArray.encodedSize = function encodedSize5(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/lib/5map.js
  function toToken4(_data, _pos, prefix, length4) {
    return new Token(Type.map, length4, prefix);
  }
  function decodeMapCompact(data, pos, minor, _options) {
    return toToken4(data, pos, 1, minor);
  }
  function decodeMap8(data, pos, _minor, options2) {
    return toToken4(data, pos, 2, readUint8(data, pos + 1, options2));
  }
  function decodeMap16(data, pos, _minor, options2) {
    return toToken4(data, pos, 3, readUint16(data, pos + 1, options2));
  }
  function decodeMap32(data, pos, _minor, options2) {
    return toToken4(data, pos, 5, readUint32(data, pos + 1, options2));
  }
  function decodeMap64(data, pos, _minor, options2) {
    const l2 = readUint64(data, pos + 1, options2);
    if (typeof l2 === "bigint") {
      throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
    }
    return toToken4(data, pos, 9, l2);
  }
  function decodeMapIndefinite(data, pos, _minor, options2) {
    if (options2.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return toToken4(data, pos, 1, Infinity);
  }
  function encodeMap(buf2, token) {
    encodeUintValue(buf2, Type.map.majorEncoded, token.value);
  }
  encodeMap.compareTokens = encodeUint.compareTokens;
  encodeMap.encodedSize = function encodedSize6(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/lib/6tag.js
  function decodeTagCompact(_data, _pos, minor, _options) {
    return new Token(Type.tag, minor, 1);
  }
  function decodeTag8(data, pos, _minor, options2) {
    return new Token(Type.tag, readUint8(data, pos + 1, options2), 2);
  }
  function decodeTag16(data, pos, _minor, options2) {
    return new Token(Type.tag, readUint16(data, pos + 1, options2), 3);
  }
  function decodeTag32(data, pos, _minor, options2) {
    return new Token(Type.tag, readUint32(data, pos + 1, options2), 5);
  }
  function decodeTag64(data, pos, _minor, options2) {
    return new Token(Type.tag, readUint64(data, pos + 1, options2), 9);
  }
  function encodeTag(buf2, token) {
    encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
  }
  encodeTag.compareTokens = encodeUint.compareTokens;
  encodeTag.encodedSize = function encodedSize7(token) {
    return encodeUintValue.encodedSize(token.value);
  };

  // node_modules/cborg/lib/7float.js
  var MINOR_FALSE = 20;
  var MINOR_TRUE = 21;
  var MINOR_NULL = 22;
  var MINOR_UNDEFINED = 23;
  function decodeUndefined(_data, _pos, _minor, options2) {
    if (options2.allowUndefined === false) {
      throw new Error(`${decodeErrPrefix} undefined values are not supported`);
    } else if (options2.coerceUndefinedToNull === true) {
      return new Token(Type.null, null, 1);
    }
    return new Token(Type.undefined, void 0, 1);
  }
  function decodeBreak(_data, _pos, _minor, options2) {
    if (options2.allowIndefinite === false) {
      throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
    }
    return new Token(Type.break, void 0, 1);
  }
  function createToken(value2, bytes, options2) {
    if (options2) {
      if (options2.allowNaN === false && Number.isNaN(value2)) {
        throw new Error(`${decodeErrPrefix} NaN values are not supported`);
      }
      if (options2.allowInfinity === false && (value2 === Infinity || value2 === -Infinity)) {
        throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
      }
    }
    return new Token(Type.float, value2, bytes);
  }
  function decodeFloat16(data, pos, _minor, options2) {
    return createToken(readFloat16(data, pos + 1), 3, options2);
  }
  function decodeFloat32(data, pos, _minor, options2) {
    return createToken(readFloat32(data, pos + 1), 5, options2);
  }
  function decodeFloat64(data, pos, _minor, options2) {
    return createToken(readFloat64(data, pos + 1), 9, options2);
  }
  function encodeFloat(buf2, token, options2) {
    const float = token.value;
    if (float === false) {
      buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
    } else if (float === true) {
      buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
    } else if (float === null) {
      buf2.push([Type.float.majorEncoded | MINOR_NULL]);
    } else if (float === void 0) {
      buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
    } else {
      let decoded;
      let success = false;
      if (!options2 || options2.float64 !== true) {
        encodeFloat16(float);
        decoded = readFloat16(ui8a, 1);
        if (float === decoded || Number.isNaN(float)) {
          ui8a[0] = 249;
          buf2.push(ui8a.slice(0, 3));
          success = true;
        } else {
          encodeFloat32(float);
          decoded = readFloat32(ui8a, 1);
          if (float === decoded) {
            ui8a[0] = 250;
            buf2.push(ui8a.slice(0, 5));
            success = true;
          }
        }
      }
      if (!success) {
        encodeFloat64(float);
        decoded = readFloat64(ui8a, 1);
        ui8a[0] = 251;
        buf2.push(ui8a.slice(0, 9));
      }
    }
  }
  encodeFloat.encodedSize = function encodedSize8(token, options2) {
    const float = token.value;
    if (float === false || float === true || float === null || float === void 0) {
      return 1;
    }
    if (!options2 || options2.float64 !== true) {
      encodeFloat16(float);
      let decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        return 3;
      }
      encodeFloat32(float);
      decoded = readFloat32(ui8a, 1);
      if (float === decoded) {
        return 5;
      }
    }
    return 9;
  };
  var buffer = new ArrayBuffer(9);
  var dataView = new DataView(buffer, 1);
  var ui8a = new Uint8Array(buffer, 0);
  function encodeFloat16(inp) {
    if (inp === Infinity) {
      dataView.setUint16(0, 31744, false);
    } else if (inp === -Infinity) {
      dataView.setUint16(0, 64512, false);
    } else if (Number.isNaN(inp)) {
      dataView.setUint16(0, 32256, false);
    } else {
      dataView.setFloat32(0, inp);
      const valu32 = dataView.getUint32(0);
      const exponent = (valu32 & 2139095040) >> 23;
      const mantissa = valu32 & 8388607;
      if (exponent === 255) {
        dataView.setUint16(0, 31744, false);
      } else if (exponent === 0) {
        dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
      } else {
        const logicalExponent = exponent - 127;
        if (logicalExponent < -24) {
          dataView.setUint16(0, 0);
        } else if (logicalExponent < -14) {
          dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
          1 << 24 + logicalExponent, false);
        } else {
          dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
        }
      }
    }
  }
  function readFloat16(ui8a2, pos) {
    if (ui8a2.length - pos < 2) {
      throw new Error(`${decodeErrPrefix} not enough data for float16`);
    }
    const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
    if (half === 31744) {
      return Infinity;
    }
    if (half === 64512) {
      return -Infinity;
    }
    if (half === 32256) {
      return NaN;
    }
    const exp = half >> 10 & 31;
    const mant = half & 1023;
    let val;
    if (exp === 0) {
      val = mant * 2 ** -24;
    } else if (exp !== 31) {
      val = (mant + 1024) * 2 ** (exp - 25);
    } else {
      val = mant === 0 ? Infinity : NaN;
    }
    return half & 32768 ? -val : val;
  }
  function encodeFloat32(inp) {
    dataView.setFloat32(0, inp, false);
  }
  function readFloat32(ui8a2, pos) {
    if (ui8a2.length - pos < 4) {
      throw new Error(`${decodeErrPrefix} not enough data for float32`);
    }
    const offset = (ui8a2.byteOffset || 0) + pos;
    return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
  }
  function encodeFloat64(inp) {
    dataView.setFloat64(0, inp, false);
  }
  function readFloat64(ui8a2, pos) {
    if (ui8a2.length - pos < 8) {
      throw new Error(`${decodeErrPrefix} not enough data for float64`);
    }
    const offset = (ui8a2.byteOffset || 0) + pos;
    return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
  }
  encodeFloat.compareTokens = encodeUint.compareTokens;

  // node_modules/cborg/lib/jump.js
  function invalidMinor(data, pos, minor) {
    throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
  }
  function errorer(msg) {
    return () => {
      throw new Error(`${decodeErrPrefix} ${msg}`);
    };
  }
  var jump = [];
  for (let i2 = 0; i2 <= 23; i2++) {
    jump[i2] = invalidMinor;
  }
  jump[24] = decodeUint8;
  jump[25] = decodeUint16;
  jump[26] = decodeUint32;
  jump[27] = decodeUint64;
  jump[28] = invalidMinor;
  jump[29] = invalidMinor;
  jump[30] = invalidMinor;
  jump[31] = invalidMinor;
  for (let i2 = 32; i2 <= 55; i2++) {
    jump[i2] = invalidMinor;
  }
  jump[56] = decodeNegint8;
  jump[57] = decodeNegint16;
  jump[58] = decodeNegint32;
  jump[59] = decodeNegint64;
  jump[60] = invalidMinor;
  jump[61] = invalidMinor;
  jump[62] = invalidMinor;
  jump[63] = invalidMinor;
  for (let i2 = 64; i2 <= 87; i2++) {
    jump[i2] = decodeBytesCompact;
  }
  jump[88] = decodeBytes8;
  jump[89] = decodeBytes16;
  jump[90] = decodeBytes32;
  jump[91] = decodeBytes64;
  jump[92] = invalidMinor;
  jump[93] = invalidMinor;
  jump[94] = invalidMinor;
  jump[95] = errorer("indefinite length bytes/strings are not supported");
  for (let i2 = 96; i2 <= 119; i2++) {
    jump[i2] = decodeStringCompact;
  }
  jump[120] = decodeString8;
  jump[121] = decodeString16;
  jump[122] = decodeString32;
  jump[123] = decodeString64;
  jump[124] = invalidMinor;
  jump[125] = invalidMinor;
  jump[126] = invalidMinor;
  jump[127] = errorer("indefinite length bytes/strings are not supported");
  for (let i2 = 128; i2 <= 151; i2++) {
    jump[i2] = decodeArrayCompact;
  }
  jump[152] = decodeArray8;
  jump[153] = decodeArray16;
  jump[154] = decodeArray32;
  jump[155] = decodeArray64;
  jump[156] = invalidMinor;
  jump[157] = invalidMinor;
  jump[158] = invalidMinor;
  jump[159] = decodeArrayIndefinite;
  for (let i2 = 160; i2 <= 183; i2++) {
    jump[i2] = decodeMapCompact;
  }
  jump[184] = decodeMap8;
  jump[185] = decodeMap16;
  jump[186] = decodeMap32;
  jump[187] = decodeMap64;
  jump[188] = invalidMinor;
  jump[189] = invalidMinor;
  jump[190] = invalidMinor;
  jump[191] = decodeMapIndefinite;
  for (let i2 = 192; i2 <= 215; i2++) {
    jump[i2] = decodeTagCompact;
  }
  jump[216] = decodeTag8;
  jump[217] = decodeTag16;
  jump[218] = decodeTag32;
  jump[219] = decodeTag64;
  jump[220] = invalidMinor;
  jump[221] = invalidMinor;
  jump[222] = invalidMinor;
  jump[223] = invalidMinor;
  for (let i2 = 224; i2 <= 243; i2++) {
    jump[i2] = errorer("simple values are not supported");
  }
  jump[244] = invalidMinor;
  jump[245] = invalidMinor;
  jump[246] = invalidMinor;
  jump[247] = decodeUndefined;
  jump[248] = errorer("simple values are not supported");
  jump[249] = decodeFloat16;
  jump[250] = decodeFloat32;
  jump[251] = decodeFloat64;
  jump[252] = invalidMinor;
  jump[253] = invalidMinor;
  jump[254] = invalidMinor;
  jump[255] = decodeBreak;
  var quick = [];
  for (let i2 = 0; i2 < 24; i2++) {
    quick[i2] = new Token(Type.uint, i2, 1);
  }
  for (let i2 = -1; i2 >= -24; i2--) {
    quick[31 - i2] = new Token(Type.negint, i2, 1);
  }
  quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
  quick[96] = new Token(Type.string, "", 1);
  quick[128] = new Token(Type.array, 0, 1);
  quick[160] = new Token(Type.map, 0, 1);
  quick[244] = new Token(Type.false, false, 1);
  quick[245] = new Token(Type.true, true, 1);
  quick[246] = new Token(Type.null, null, 1);
  function quickEncodeToken(token) {
    switch (token.type) {
      case Type.false:
        return fromArray([244]);
      case Type.true:
        return fromArray([245]);
      case Type.null:
        return fromArray([246]);
      case Type.bytes:
        if (!token.value.length) {
          return fromArray([64]);
        }
        return;
      case Type.string:
        if (token.value === "") {
          return fromArray([96]);
        }
        return;
      case Type.array:
        if (token.value === 0) {
          return fromArray([128]);
        }
        return;
      case Type.map:
        if (token.value === 0) {
          return fromArray([160]);
        }
        return;
      case Type.uint:
        if (token.value < 24) {
          return fromArray([Number(token.value)]);
        }
        return;
      case Type.negint:
        if (token.value >= -24) {
          return fromArray([31 - Number(token.value)]);
        }
    }
  }

  // node_modules/cborg/lib/encode.js
  var defaultEncodeOptions = {
    float64: false,
    mapSorter,
    quickEncodeToken
  };
  function makeCborEncoders() {
    const encoders = [];
    encoders[Type.uint.major] = encodeUint;
    encoders[Type.negint.major] = encodeNegint;
    encoders[Type.bytes.major] = encodeBytes;
    encoders[Type.string.major] = encodeString;
    encoders[Type.array.major] = encodeArray;
    encoders[Type.map.major] = encodeMap;
    encoders[Type.tag.major] = encodeTag;
    encoders[Type.float.major] = encodeFloat;
    return encoders;
  }
  var cborEncoders = makeCborEncoders();
  var buf = new Bl();
  var Ref = class _Ref {
    /**
     * @param {object|any[]} obj
     * @param {Reference|undefined} parent
     */
    constructor(obj, parent) {
      this.obj = obj;
      this.parent = parent;
    }
    /**
     * @param {object|any[]} obj
     * @returns {boolean}
     */
    includes(obj) {
      let p2 = this;
      do {
        if (p2.obj === obj) {
          return true;
        }
      } while (p2 = p2.parent);
      return false;
    }
    /**
     * @param {Reference|undefined} stack
     * @param {object|any[]} obj
     * @returns {Reference}
     */
    static createCheck(stack, obj) {
      if (stack && stack.includes(obj)) {
        throw new Error(`${encodeErrPrefix} object contains circular references`);
      }
      return new _Ref(obj, stack);
    }
  };
  var simpleTokens = {
    null: new Token(Type.null, null),
    undefined: new Token(Type.undefined, void 0),
    true: new Token(Type.true, true),
    false: new Token(Type.false, false),
    emptyArray: new Token(Type.array, 0),
    emptyMap: new Token(Type.map, 0)
  };
  var typeEncoders = {
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    number(obj, _typ, _options, _refStack) {
      if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
        return new Token(Type.float, obj);
      } else if (obj >= 0) {
        return new Token(Type.uint, obj);
      } else {
        return new Token(Type.negint, obj);
      }
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    bigint(obj, _typ, _options, _refStack) {
      if (obj >= BigInt(0)) {
        return new Token(Type.uint, obj);
      } else {
        return new Token(Type.negint, obj);
      }
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    Uint8Array(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, obj);
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    string(obj, _typ, _options, _refStack) {
      return new Token(Type.string, obj);
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    boolean(obj, _typ, _options, _refStack) {
      return obj ? simpleTokens.true : simpleTokens.false;
    },
    /**
     * @param {any} _obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    null(_obj, _typ, _options, _refStack) {
      return simpleTokens.null;
    },
    /**
     * @param {any} _obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    undefined(_obj, _typ, _options, _refStack) {
      return simpleTokens.undefined;
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    ArrayBuffer(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, new Uint8Array(obj));
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} _options
     * @param {Reference} [_refStack]
     * @returns {TokenOrNestedTokens}
     */
    DataView(obj, _typ, _options, _refStack) {
      return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
    },
    /**
     * @param {any} obj
     * @param {string} _typ
     * @param {EncodeOptions} options
     * @param {Reference} [refStack]
     * @returns {TokenOrNestedTokens}
     */
    Array(obj, _typ, options2, refStack) {
      if (!obj.length) {
        if (options2.addBreakTokens === true) {
          return [simpleTokens.emptyArray, new Token(Type.break)];
        }
        return simpleTokens.emptyArray;
      }
      refStack = Ref.createCheck(refStack, obj);
      const entries = [];
      let i2 = 0;
      for (const e2 of obj) {
        entries[i2++] = objectToTokens(e2, options2, refStack);
      }
      if (options2.addBreakTokens) {
        return [new Token(Type.array, obj.length), entries, new Token(Type.break)];
      }
      return [new Token(Type.array, obj.length), entries];
    },
    /**
     * @param {any} obj
     * @param {string} typ
     * @param {EncodeOptions} options
     * @param {Reference} [refStack]
     * @returns {TokenOrNestedTokens}
     */
    Object(obj, typ, options2, refStack) {
      const isMap = typ !== "Object";
      const keys = isMap ? obj.keys() : Object.keys(obj);
      const length4 = isMap ? obj.size : keys.length;
      if (!length4) {
        if (options2.addBreakTokens === true) {
          return [simpleTokens.emptyMap, new Token(Type.break)];
        }
        return simpleTokens.emptyMap;
      }
      refStack = Ref.createCheck(refStack, obj);
      const entries = [];
      let i2 = 0;
      for (const key of keys) {
        entries[i2++] = [
          objectToTokens(key, options2, refStack),
          objectToTokens(isMap ? obj.get(key) : obj[key], options2, refStack)
        ];
      }
      sortMapEntries(entries, options2);
      if (options2.addBreakTokens) {
        return [new Token(Type.map, length4), entries, new Token(Type.break)];
      }
      return [new Token(Type.map, length4), entries];
    }
  };
  typeEncoders.Map = typeEncoders.Object;
  typeEncoders.Buffer = typeEncoders.Uint8Array;
  for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
    typeEncoders[`${typ}Array`] = typeEncoders.DataView;
  }
  function objectToTokens(obj, options2 = {}, refStack) {
    const typ = is(obj);
    const customTypeEncoder = options2 && options2.typeEncoders && /** @type {OptionalTypeEncoder} */
    options2.typeEncoders[typ] || typeEncoders[typ];
    if (typeof customTypeEncoder === "function") {
      const tokens = customTypeEncoder(obj, typ, options2, refStack);
      if (tokens != null) {
        return tokens;
      }
    }
    const typeEncoder = typeEncoders[typ];
    if (!typeEncoder) {
      throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
    }
    return typeEncoder(obj, typ, options2, refStack);
  }
  function sortMapEntries(entries, options2) {
    if (options2.mapSorter) {
      entries.sort(options2.mapSorter);
    }
  }
  function mapSorter(e1, e2) {
    const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
    const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
    if (keyToken1.type !== keyToken2.type) {
      return keyToken1.type.compare(keyToken2.type);
    }
    const major = keyToken1.type.major;
    const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
    if (tcmp === 0) {
      console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
    }
    return tcmp;
  }
  function tokensToEncoded(buf2, tokens, encoders, options2) {
    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        tokensToEncoded(buf2, token, encoders, options2);
      }
    } else {
      encoders[tokens.type.major](buf2, tokens, options2);
    }
  }
  function encodeCustom(data, encoders, options2) {
    const tokens = objectToTokens(data, options2);
    if (!Array.isArray(tokens) && options2.quickEncodeToken) {
      const quickBytes = options2.quickEncodeToken(tokens);
      if (quickBytes) {
        return quickBytes;
      }
      const encoder2 = encoders[tokens.type.major];
      if (encoder2.encodedSize) {
        const size = encoder2.encodedSize(tokens, options2);
        const buf2 = new Bl(size);
        encoder2(buf2, tokens, options2);
        if (buf2.chunks.length !== 1) {
          throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
        }
        return asU8A(buf2.chunks[0]);
      }
    }
    buf.reset();
    tokensToEncoded(buf, tokens, encoders, options2);
    return buf.toBytes(true);
  }
  function encode8(data, options2) {
    options2 = Object.assign({}, defaultEncodeOptions, options2);
    return encodeCustom(data, cborEncoders, options2);
  }

  // node_modules/cborg/lib/decode.js
  var defaultDecodeOptions = {
    strict: false,
    allowIndefinite: true,
    allowUndefined: true,
    allowBigInt: true
  };
  var Tokeniser = class {
    /**
     * @param {Uint8Array} data
     * @param {DecodeOptions} options
     */
    constructor(data, options2 = {}) {
      this._pos = 0;
      this.data = data;
      this.options = options2;
    }
    pos() {
      return this._pos;
    }
    done() {
      return this._pos >= this.data.length;
    }
    next() {
      const byt = this.data[this._pos];
      let token = quick[byt];
      if (token === void 0) {
        const decoder = jump[byt];
        if (!decoder) {
          throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
        }
        const minor = byt & 31;
        token = decoder(this.data, this._pos, minor, this.options);
      }
      this._pos += token.encodedLength;
      return token;
    }
  };
  var DONE = Symbol.for("DONE");
  var BREAK = Symbol.for("BREAK");
  function tokenToArray(token, tokeniser, options2) {
    const arr = [];
    for (let i2 = 0; i2 < token.value; i2++) {
      const value2 = tokensToObject(tokeniser, options2);
      if (value2 === BREAK) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
      }
      if (value2 === DONE) {
        throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
      }
      arr[i2] = value2;
    }
    return arr;
  }
  function tokenToMap(token, tokeniser, options2) {
    const useMaps = options2.useMaps === true;
    const obj = useMaps ? void 0 : {};
    const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
    for (let i2 = 0; i2 < token.value; i2++) {
      const key = tokensToObject(tokeniser, options2);
      if (key === BREAK) {
        if (token.value === Infinity) {
          break;
        }
        throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
      }
      if (key === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
      }
      if (useMaps !== true && typeof key !== "string") {
        throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
      }
      if (options2.rejectDuplicateMapKeys === true) {
        if (useMaps && m2.has(key) || !useMaps && key in obj) {
          throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
        }
      }
      const value2 = tokensToObject(tokeniser, options2);
      if (value2 === DONE) {
        throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
      }
      if (useMaps) {
        m2.set(key, value2);
      } else {
        obj[key] = value2;
      }
    }
    return useMaps ? m2 : obj;
  }
  function tokensToObject(tokeniser, options2) {
    if (tokeniser.done()) {
      return DONE;
    }
    const token = tokeniser.next();
    if (token.type === Type.break) {
      return BREAK;
    }
    if (token.type.terminal) {
      return token.value;
    }
    if (token.type === Type.array) {
      return tokenToArray(token, tokeniser, options2);
    }
    if (token.type === Type.map) {
      return tokenToMap(token, tokeniser, options2);
    }
    if (token.type === Type.tag) {
      if (options2.tags && typeof options2.tags[token.value] === "function") {
        const tagged = tokensToObject(tokeniser, options2);
        return options2.tags[token.value](tagged);
      }
      throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
    }
    throw new Error("unsupported");
  }
  function decodeFirst(data, options2) {
    if (!(data instanceof Uint8Array)) {
      throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
    }
    options2 = Object.assign({}, defaultDecodeOptions, options2);
    const tokeniser = options2.tokenizer || new Tokeniser(data, options2);
    const decoded = tokensToObject(tokeniser, options2);
    if (decoded === DONE) {
      throw new Error(`${decodeErrPrefix} did not find any content to decode`);
    }
    if (decoded === BREAK) {
      throw new Error(`${decodeErrPrefix} got unexpected break`);
    }
    return [decoded, data.subarray(tokeniser.pos())];
  }
  function decode9(data, options2) {
    const [decoded, remainder] = decodeFirst(data, options2);
    if (remainder.length > 0) {
      throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
    }
    return decoded;
  }

  // node_modules/it-length-prefixed/dist/src/constants.js
  var MAX_LENGTH_LENGTH = 8;
  var MAX_DATA_LENGTH = 1024 * 1024 * 4;

  // node_modules/it-length-prefixed/dist/src/errors.js
  var InvalidMessageLengthError2 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError2 = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError2 = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };
  var UnexpectedEOFError2 = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // node_modules/it-length-prefixed/dist/src/utils.js
  function isAsyncIterable3(thing) {
    return thing[Symbol.asyncIterator] != null;
  }

  // node_modules/it-length-prefixed/dist/src/encode.js
  function validateMaxDataLength(chunk, maxDataLength) {
    if (chunk.byteLength > maxDataLength) {
      throw new InvalidDataLengthError2("Message length too long");
    }
  }
  var defaultEncoder = (length4) => {
    const lengthLength = encodingLength2(length4);
    const lengthBuf = allocUnsafe(lengthLength);
    encode7(length4, lengthBuf);
    defaultEncoder.bytes = lengthLength;
    return lengthBuf;
  };
  defaultEncoder.bytes = 0;
  function encode9(source, options2) {
    options2 = options2 ?? {};
    const encodeLength2 = options2.lengthEncoder ?? defaultEncoder;
    const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH;
    function* maybeYield(chunk) {
      validateMaxDataLength(chunk, maxDataLength);
      const length4 = encodeLength2(chunk.byteLength);
      if (length4 instanceof Uint8Array) {
        yield length4;
      } else {
        yield* length4;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
    if (isAsyncIterable3(source)) {
      return (async function* () {
        for await (const chunk of source) {
          yield* maybeYield(chunk);
        }
      })();
    }
    return (function* () {
      for (const chunk of source) {
        yield* maybeYield(chunk);
      }
    })();
  }
  encode9.single = (chunk, options2) => {
    options2 = options2 ?? {};
    const encodeLength2 = options2.lengthEncoder ?? defaultEncoder;
    const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH;
    validateMaxDataLength(chunk, maxDataLength);
    return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
  };

  // node_modules/it-length-prefixed/dist/src/decode.js
  var ReadMode;
  (function(ReadMode2) {
    ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
    ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
  })(ReadMode || (ReadMode = {}));
  var defaultDecoder = (buf2) => {
    const length4 = decode8(buf2);
    defaultDecoder.bytes = encodingLength2(length4);
    return length4;
  };
  defaultDecoder.bytes = 0;
  function decode10(source, options2) {
    const buffer2 = new Uint8ArrayList();
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = options2?.lengthDecoder ?? defaultDecoder;
    const maxLengthLength = options2?.maxLengthLength ?? MAX_LENGTH_LENGTH;
    const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH;
    function* maybeYield() {
      while (buffer2.byteLength > 0) {
        if (mode === ReadMode.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer2);
            if (dataLength < 0) {
              throw new InvalidMessageLengthError2("Invalid message length");
            }
            if (dataLength > maxDataLength) {
              throw new InvalidDataLengthError2("Message length too long");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer2.consume(dataLengthLength);
            if (options2?.onLength != null) {
              options2.onLength(dataLength);
            }
            mode = ReadMode.DATA;
          } catch (err2) {
            if (err2 instanceof RangeError) {
              if (buffer2.byteLength > maxLengthLength) {
                throw new InvalidDataLengthLengthError2("Message length length too long");
              }
              break;
            }
            throw err2;
          }
        }
        if (mode === ReadMode.DATA) {
          if (buffer2.byteLength < dataLength) {
            break;
          }
          const data = buffer2.sublist(0, dataLength);
          buffer2.consume(dataLength);
          if (options2?.onData != null) {
            options2.onData(data);
          }
          yield data;
          mode = ReadMode.LENGTH;
        }
      }
    }
    if (isAsyncIterable3(source)) {
      return (async function* () {
        for await (const buf2 of source) {
          buffer2.append(buf2);
          yield* maybeYield();
        }
        if (buffer2.byteLength > 0) {
          throw new UnexpectedEOFError2("Unexpected end of input");
        }
      })();
    }
    return (function* () {
      for (const buf2 of source) {
        buffer2.append(buf2);
        yield* maybeYield();
      }
      if (buffer2.byteLength > 0) {
        throw new UnexpectedEOFError2("Unexpected end of input");
      }
    })();
  }
  decode10.fromReader = (reader2, options2) => {
    let byteLength = 1;
    const varByteSource = (async function* () {
      while (true) {
        try {
          const { done, value: value2 } = await reader2.next(byteLength);
          if (done === true) {
            return;
          }
          if (value2 != null) {
            yield value2;
          }
        } catch (err2) {
          if (err2.code === "ERR_UNDER_READ") {
            return { done: true, value: null };
          }
          throw err2;
        } finally {
          byteLength = 1;
        }
      }
    })();
    const onLength = (l2) => {
      byteLength = l2;
    };
    return decode10(varByteSource, {
      ...options2 ?? {},
      onLength
    });
  };

  // node_modules/weald/node_modules/ms/dist/index.js
  var e = 1e3;
  var t = e * 60;
  var n = t * 60;
  var r = n * 24;
  var i = r * 7;
  var a = r * 365.25;
  var o = a / 12;
  function s(e2, t2) {
    if (typeof e2 == `string`) return l(e2);
    if (typeof e2 == `number`) return p(e2, t2);
    throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(e2)}`);
  }
  var c = s;
  function l(s2) {
    if (typeof s2 != `string` || s2.length === 0 || s2.length > 100) throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(s2)}`);
    let c2 = /^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(s2);
    if (!c2?.groups) return NaN;
    let { value: l2, unit: u = `ms` } = c2.groups, d2 = parseFloat(l2), f2 = u.toLowerCase();
    switch (f2) {
      case `years`:
      case `year`:
      case `yrs`:
      case `yr`:
      case `y`:
        return d2 * a;
      case `months`:
      case `month`:
      case `mo`:
        return d2 * o;
      case `weeks`:
      case `week`:
      case `w`:
        return d2 * i;
      case `days`:
      case `day`:
      case `d`:
        return d2 * r;
      case `hours`:
      case `hour`:
      case `hrs`:
      case `hr`:
      case `h`:
        return d2 * n;
      case `minutes`:
      case `minute`:
      case `mins`:
      case `min`:
      case `m`:
        return d2 * t;
      case `seconds`:
      case `second`:
      case `secs`:
      case `sec`:
      case `s`:
        return d2 * e;
      case `milliseconds`:
      case `millisecond`:
      case `msecs`:
      case `msec`:
      case `ms`:
        return d2;
      default:
        throw Error(`Unknown unit "${f2}" provided to ms.parse(). value=${JSON.stringify(s2)}`);
    }
  }
  function d(s2) {
    let c2 = Math.abs(s2);
    return c2 >= a ? `${Math.round(s2 / a)}y` : c2 >= o ? `${Math.round(s2 / o)}mo` : c2 >= i ? `${Math.round(s2 / i)}w` : c2 >= r ? `${Math.round(s2 / r)}d` : c2 >= n ? `${Math.round(s2 / n)}h` : c2 >= t ? `${Math.round(s2 / t)}m` : c2 >= e ? `${Math.round(s2 / e)}s` : `${s2}ms`;
  }
  function f(s2) {
    let c2 = Math.abs(s2);
    return c2 >= a ? m(s2, c2, a, `year`) : c2 >= o ? m(s2, c2, o, `month`) : c2 >= i ? m(s2, c2, i, `week`) : c2 >= r ? m(s2, c2, r, `day`) : c2 >= n ? m(s2, c2, n, `hour`) : c2 >= t ? m(s2, c2, t, `minute`) : c2 >= e ? m(s2, c2, e, `second`) : `${s2} ms`;
  }
  function p(e2, t2) {
    if (typeof e2 != `number` || !Number.isFinite(e2)) throw Error(`Value provided to ms.format() must be of type number.`);
    return t2?.long ? f(e2) : d(e2);
  }
  function m(e2, t2, n2, r2) {
    let i2 = t2 >= n2 * 1.5;
    return `${Math.round(e2 / n2)} ${r2}${i2 ? `s` : ``}`;
  }

  // node_modules/weald/dist/src/common.js
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = c;
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash = 0;
      for (let i2 = 0; i2 < namespace2.length; i2++) {
        hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2, options2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format3];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        if (options2?.onLog != null) {
          options2.onLog(...args);
        }
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace2;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace2);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace2, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split2.length;
      for (i2 = 0; i2 < len; i2++) {
        if (!split2[i2]) {
          continue;
        }
        namespaces = split2[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name9) {
      if (name9[name9.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
        if (createDebug.skips[i2].test(name9)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
        if (createDebug.names[i2].test(name9)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack ?? val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.setupFormatters(createDebug.formatters);
    createDebug.enable(createDebug.load());
    return createDebug;
  }

  // node_modules/weald/dist/src/browser.js
  var storage = localstorage();
  var colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/) != null) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement?.style?.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    // @ts-expect-error window.console.firebug and window.console.exception are not in the types
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + c(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  }
  var log = console.debug ?? console.log ?? (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        storage?.setItem("debug", namespaces);
      } else {
        storage?.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r2;
    try {
      r2 = storage?.getItem("debug");
    } catch (error) {
    }
    if (!r2 && typeof globalThis.process !== "undefined" && "env" in globalThis.process) {
      r2 = globalThis.process.env.DEBUG;
    }
    return r2;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  function setupFormatters(formatters) {
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
  var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });

  // node_modules/weald/dist/src/index.js
  var src_default2 = browser_default;

  // node_modules/@libp2p/logger/dist/src/index.js
  src_default2.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc.baseEncode(v);
  };
  src_default2.formatters.t = (v) => {
    return v == null ? "undefined" : base32.baseEncode(v);
  };
  src_default2.formatters.m = (v) => {
    return v == null ? "undefined" : base64.baseEncode(v);
  };
  src_default2.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default2.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default2.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default2.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  function formatError(v) {
    const message2 = notEmpty(v.message);
    const stack = notEmpty(v.stack);
    if (message2 != null && stack != null) {
      if (stack.includes(message2)) {
        return stack;
      }
      return `${message2}
${stack}`;
    }
    if (stack != null) {
      return stack;
    }
    if (message2 != null) {
      return message2;
    }
    return v.toString();
  }
  function isAggregateError(err2) {
    return err2 instanceof AggregateError || err2?.name === "AggregateError" && Array.isArray(err2.errors);
  }
  src_default2.formatters.e = (v) => {
    if (v == null) {
      return "undefined";
    }
    if (isAggregateError(v)) {
      const indent = "      ";
      let output = formatError(v);
      if (v.errors.length > 0) {
        output += `
${indent}${v.errors.map((err2) => `  ${formatError(err2).split("\n").join(`
${indent}`)}`).join(`
${indent}`)}`;
      } else {
        output += `
${indent}[Error list was empty]`;
      }
      return output.trim();
    }
    return formatError(v);
  };
  function createDisabledLogger(namespace2) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace2;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  }
  function defaultLogger(options2) {
    return {
      forComponent(name9) {
        return logger(name9, options2);
      }
    };
  }
  function logger(name9, options2) {
    let trace = createDisabledLogger(`${name9}:trace`);
    if (src_default2.enabled(`${name9}:trace`) && src_default2.names.map((r2) => r2.toString()).find((n2) => n2.includes(":trace")) != null) {
      trace = src_default2(`${name9}:trace`, options2);
    }
    return Object.assign(src_default2(name9, options2), {
      error: src_default2(`${name9}:error`, options2),
      trace,
      newScope: (scope) => logger(`${name9}:${scope}`, options2)
    });
  }
  function notEmpty(str) {
    if (str == null) {
      return;
    }
    str = str.trim();
    if (str.length === 0) {
      return;
    }
    return str;
  }

  // node_modules/delay/index.js
  var createAbortError = () => {
    const error = new Error("Delay aborted");
    error.name = "AbortError";
    return error;
  };
  var clearMethods = /* @__PURE__ */ new WeakMap();
  function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
    return (milliseconds, { value: value2, signal } = {}) => {
      if (signal?.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle;
      let rejectFunction;
      const clear = defaultClear ?? clearTimeout;
      const signalListener = () => {
        clear(timeoutId);
        rejectFunction(createAbortError());
      };
      const cleanup = () => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      };
      const delayPromise = new Promise((resolve8, reject) => {
        settle = () => {
          cleanup();
          resolve8(value2);
        };
        rejectFunction = reject;
        timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      clearMethods.set(delayPromise, () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
      });
      return delayPromise;
    };
  }
  var delay = createDelay();
  var delay_default = delay;

  // node_modules/@libp2p/utils/dist/src/peer-queue.js
  var PeerQueue = class extends Queue {
    has(peerId) {
      return this.find(peerId) != null;
    }
    find(peerId) {
      return this.queue.find((job) => {
        return peerId.equals(job.options.peerId);
      });
    }
  };

  // node_modules/@libp2p/utils/dist/src/priority-queue.js
  var PriorityQueue = class extends Queue {
    constructor(init = {}) {
      super({
        ...init,
        sort: (a2, b) => {
          if (a2.options.priority > b.options.priority) {
            return -1;
          }
          if (a2.options.priority < b.options.priority) {
            return 1;
          }
          return 0;
        }
      });
    }
  };

  // node_modules/@libp2p/utils/dist/src/rate-limiter.js
  var RateLimiter = class {
    memoryStorage;
    points;
    duration;
    blockDuration;
    keyPrefix;
    constructor(opts = {}) {
      this.points = opts.points ?? 4;
      this.duration = opts.duration ?? 1;
      this.blockDuration = opts.blockDuration ?? 0;
      this.keyPrefix = opts.keyPrefix ?? "rlflx";
      this.memoryStorage = new MemoryStorage();
    }
    consume(key, pointsToConsume = 1, options2 = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options2);
      let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      if (res.consumedPoints > this.points) {
        if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
          res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
        }
        throw new RateLimitError("Rate limit exceeded", res);
      }
      return res;
    }
    penalty(key, points = 1, options2 = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options2);
      const res = this.memoryStorage.incrby(rlKey, points, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      return res;
    }
    reward(key, points = 1, options2 = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options2);
      const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      return res;
    }
    /**
     * Block any key for secDuration seconds
     *
     * @param key
     * @param secDuration
     */
    block(key, secDuration) {
      const msDuration = secDuration * 1e3;
      const initPoints = this.points + 1;
      this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
      return {
        remainingPoints: 0,
        msBeforeNext: msDuration === 0 ? -1 : msDuration,
        consumedPoints: initPoints,
        isFirstInDuration: false
      };
    }
    set(key, points, secDuration = 0) {
      const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
      this.memoryStorage.set(this.getKey(key), points, secDuration);
      return {
        remainingPoints: 0,
        msBeforeNext: msDuration === 0 ? -1 : msDuration,
        consumedPoints: points,
        isFirstInDuration: false
      };
    }
    get(key) {
      const res = this.memoryStorage.get(this.getKey(key));
      if (res != null) {
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      }
      return res;
    }
    delete(key) {
      this.memoryStorage.delete(this.getKey(key));
    }
    _getKeySecDuration(options2) {
      if (options2?.customDuration != null && options2.customDuration >= 0) {
        return options2.customDuration;
      }
      return this.duration;
    }
    getKey(key) {
      return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
    }
    parseKey(rlKey) {
      return rlKey.substring(this.keyPrefix.length);
    }
  };
  var MemoryStorage = class {
    storage;
    constructor() {
      this.storage = /* @__PURE__ */ new Map();
    }
    incrby(key, value2, durationSec) {
      const existing = this.storage.get(key);
      if (existing != null) {
        const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
        if (existing.expiresAt == null || msBeforeExpires > 0) {
          existing.value += value2;
          return {
            remainingPoints: 0,
            msBeforeNext: msBeforeExpires,
            consumedPoints: existing.value,
            isFirstInDuration: false
          };
        }
        return this.set(key, value2, durationSec);
      }
      return this.set(key, value2, durationSec);
    }
    set(key, value2, durationSec) {
      const durationMs = durationSec * 1e3;
      const existing = this.storage.get(key);
      if (existing != null) {
        clearTimeout(existing.timeoutId);
      }
      const record = {
        value: value2,
        expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
      };
      this.storage.set(key, record);
      if (durationMs > 0) {
        record.timeoutId = setTimeout(() => {
          this.storage.delete(key);
        }, durationMs);
        if (record.timeoutId.unref != null) {
          record.timeoutId.unref();
        }
      }
      return {
        remainingPoints: 0,
        msBeforeNext: durationMs === 0 ? -1 : durationMs,
        consumedPoints: record.value,
        isFirstInDuration: true
      };
    }
    get(key) {
      const existing = this.storage.get(key);
      if (existing != null) {
        const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
    }
    delete(key) {
      const record = this.storage.get(key);
      if (record != null) {
        if (record.timeoutId != null) {
          clearTimeout(record.timeoutId);
        }
        this.storage.delete(key);
        return true;
      }
      return false;
    }
  };

  // node_modules/@libp2p/utils/dist/src/repeating-task.js
  function repeatingTask(fn, interval, options2) {
    let timeout;
    let shutdownController;
    let running = false;
    function runTask() {
      const opts = {
        signal: shutdownController.signal
      };
      if (options2?.timeout != null) {
        const signal = anySignal([shutdownController.signal, AbortSignal.timeout(options2.timeout)]);
        setMaxListeners(Infinity, signal);
        opts.signal = signal;
      }
      running = true;
      Promise.resolve().then(async () => {
        await fn(opts);
      }).catch(() => {
      }).finally(() => {
        running = false;
        if (shutdownController.signal.aborted) {
          return;
        }
        timeout = setTimeout(runTask, interval);
      });
    }
    const runTaskDebounced = debounce(runTask, options2?.debounce ?? 100);
    let started = false;
    return {
      setInterval: (ms) => {
        if (interval === ms) {
          return;
        }
        interval = ms;
        if (timeout != null) {
          clearTimeout(timeout);
          timeout = setTimeout(runTask, interval);
        }
      },
      setTimeout: (ms) => {
        options2 ??= {};
        options2.timeout = ms;
      },
      run: () => {
        if (running) {
          return;
        }
        clearTimeout(timeout);
        runTaskDebounced();
      },
      start: () => {
        if (started) {
          return;
        }
        started = true;
        shutdownController = new AbortController();
        setMaxListeners(Infinity, shutdownController.signal);
        if (options2?.runImmediately === true) {
          queueMicrotask(() => {
            runTask();
          });
        } else {
          timeout = setTimeout(runTask, interval);
        }
      },
      stop: () => {
        clearTimeout(timeout);
        shutdownController?.abort();
        started = false;
      }
    };
  }

  // node_modules/@libp2p/utils/dist/src/tracked-map.js
  var TrackedMap = class extends Map {
    metric;
    constructor(init) {
      super();
      const { name: name9, metrics } = init;
      this.metric = metrics.registerMetric(name9);
      this.updateComponentMetric();
    }
    set(key, value2) {
      super.set(key, value2);
      this.updateComponentMetric();
      return this;
    }
    delete(key) {
      const deleted = super.delete(key);
      this.updateComponentMetric();
      return deleted;
    }
    clear() {
      super.clear();
      this.updateComponentMetric();
    }
    updateComponentMetric() {
      this.metric.update(this.size);
    }
  };
  function trackedMap(config) {
    const { name: name9, metrics } = config;
    let map2;
    if (metrics != null) {
      map2 = new TrackedMap({ name: name9, metrics });
    } else {
      map2 = /* @__PURE__ */ new Map();
    }
    return map2;
  }

  // node_modules/it-drain/dist/src/index.js
  function isAsyncIterable4(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function drain(source) {
    if (isAsyncIterable4(source)) {
      return (async () => {
        for await (const _ of source) {
        }
      })();
    } else {
      for (const _ of source) {
      }
    }
  }
  var src_default3 = drain;

  // node_modules/it-peekable/dist/src/index.js
  function peekable(iterable) {
    const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
    const queue = [];
    return {
      peek: () => {
        return iterator.next();
      },
      push: (value2) => {
        queue.push(value2);
      },
      next: () => {
        if (queue.length > 0) {
          return {
            done: false,
            value: queue.shift()
          };
        }
        return iterator.next();
      },
      [symbol3]() {
        return this;
      }
    };
  }
  var src_default4 = peekable;

  // node_modules/it-map/dist/src/index.js
  function isAsyncIterable5(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function map(source, func) {
    let index = 0;
    if (isAsyncIterable5(source)) {
      return (async function* () {
        for await (const val of source) {
          yield func(val, index++);
        }
      })();
    }
    const peekable2 = src_default4(source);
    const { value: value2, done } = peekable2.next();
    if (done === true) {
      return (function* () {
      })();
    }
    const res = func(value2, index++);
    if (typeof res.then === "function") {
      return (async function* () {
        yield await res;
        for (const val of peekable2) {
          yield func(val, index++);
        }
      })();
    }
    const fn = func;
    return (function* () {
      yield res;
      for (const val of peekable2) {
        yield fn(val, index++);
      }
    })();
  }
  var src_default5 = map;

  // node_modules/it-take/dist/src/index.js
  function isAsyncIterable6(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function take(source, limit) {
    if (isAsyncIterable6(source)) {
      return (async function* () {
        let items = 0;
        if (limit < 1) {
          return;
        }
        for await (const entry of source) {
          yield entry;
          items++;
          if (items === limit) {
            return;
          }
        }
      })();
    }
    return (function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    })();
  }
  var src_default6 = take;

  // node_modules/abort-error/dist/src/index.js
  var AbortError5 = class extends Error {
    static name = "AbortError";
    name = "AbortError";
    constructor(message2 = "The operation was aborted", ...rest) {
      super(message2, ...rest);
    }
  };

  // node_modules/race-event/dist/src/index.js
  async function raceEvent(emitter, eventName, signal, opts) {
    const error = new AbortError5(opts?.errorMessage);
    if (opts?.errorCode != null) {
      error.code = opts.errorCode;
    }
    const errorEvent = opts?.errorEvent ?? "error";
    if (signal?.aborted === true) {
      return Promise.reject(error);
    }
    return new Promise((resolve8, reject) => {
      function removeListeners() {
        removeListener(signal, "abort", abortListener);
        removeListener(emitter, eventName, eventListener);
        removeListener(emitter, errorEvent, errorEventListener);
      }
      const eventListener = (evt) => {
        try {
          if (opts?.filter?.(evt) === false) {
            return;
          }
        } catch (err2) {
          removeListeners();
          reject(err2);
          return;
        }
        removeListeners();
        resolve8(evt);
      };
      const errorEventListener = (evt) => {
        removeListeners();
        if (evt instanceof Error) {
          reject(evt);
          return;
        }
        reject(evt.detail ?? opts?.error ?? new Error(`The "${opts?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`));
      };
      const abortListener = () => {
        removeListeners();
        reject(error);
      };
      addListener(signal, "abort", abortListener);
      addListener(emitter, eventName, eventListener);
      addListener(emitter, errorEvent, errorEventListener);
    });
  }
  function addListener(emitter, event, listener) {
    if (emitter == null) {
      return;
    }
    if (isEventTarget(emitter)) {
      emitter.addEventListener(event, listener);
    } else {
      emitter.addListener(event, listener);
    }
  }
  function removeListener(emitter, event, listener) {
    if (emitter == null) {
      return;
    }
    if (isEventTarget(emitter)) {
      emitter.removeEventListener(event, listener);
    } else {
      emitter.removeListener(event, listener);
    }
  }
  function isEventTarget(emitter) {
    return typeof emitter.addEventListener === "function" && typeof emitter.removeEventListener === "function";
  }

  // node_modules/@helia/bitswap/dist/src/constants.js
  var BITSWAP_120 = "/ipfs/bitswap/1.2.0";
  var DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
  var DEFAULT_MAX_INBOUND_STREAMS = 1024;
  var DEFAULT_MAX_OUTBOUND_STREAMS = 1024;
  var DEFAULT_MESSAGE_RECEIVE_TIMEOUT = 5e3;
  var DEFAULT_MESSAGE_SEND_DELAY = 10;
  var DEFAULT_MESSAGE_SEND_CONCURRENCY = 50;
  var DEFAULT_RUN_ON_TRANSIENT_CONNECTIONS = false;
  var DEFAULT_MAX_PROVIDERS_PER_REQUEST = 3;
  var DEFAULT_MAX_OUTGOING_MESSAGE_SIZE = 1024 * 1024 * 4;
  var DEFAULT_MAX_INCOMING_MESSAGE_SIZE = DEFAULT_MAX_OUTGOING_MESSAGE_SIZE;

  // node_modules/@helia/bitswap/dist/src/pb/message.js
  var WantType;
  (function(WantType2) {
    WantType2["WantBlock"] = "WantBlock";
    WantType2["WantHave"] = "WantHave";
  })(WantType || (WantType = {}));
  var __WantTypeValues;
  (function(__WantTypeValues2) {
    __WantTypeValues2[__WantTypeValues2["WantBlock"] = 0] = "WantBlock";
    __WantTypeValues2[__WantTypeValues2["WantHave"] = 1] = "WantHave";
  })(__WantTypeValues || (__WantTypeValues = {}));
  (function(WantType2) {
    WantType2.codec = () => {
      return enumeration(__WantTypeValues);
    };
  })(WantType || (WantType = {}));
  var WantlistEntry;
  (function(WantlistEntry2) {
    let _codec;
    WantlistEntry2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.cid != null && obj.cid.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.cid);
          }
          if (obj.priority != null && obj.priority !== 0) {
            w.uint32(16);
            w.int32(obj.priority);
          }
          if (obj.cancel != null) {
            w.uint32(24);
            w.bool(obj.cancel);
          }
          if (obj.wantType != null) {
            w.uint32(32);
            WantType.codec().encode(obj.wantType, w);
          }
          if (obj.sendDontHave != null) {
            w.uint32(40);
            w.bool(obj.sendDontHave);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            cid: alloc(0),
            priority: 0
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.cid = reader2.bytes();
                break;
              }
              case 2: {
                obj.priority = reader2.int32();
                break;
              }
              case 3: {
                obj.cancel = reader2.bool();
                break;
              }
              case 4: {
                obj.wantType = WantType.codec().decode(reader2);
                break;
              }
              case 5: {
                obj.sendDontHave = reader2.bool();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    WantlistEntry2.encode = (obj) => {
      return encodeMessage(obj, WantlistEntry2.codec());
    };
    WantlistEntry2.decode = (buf2, opts) => {
      return decodeMessage(buf2, WantlistEntry2.codec(), opts);
    };
  })(WantlistEntry || (WantlistEntry = {}));
  var Wantlist;
  (function(Wantlist2) {
    let _codec;
    Wantlist2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.entries != null) {
            for (const value2 of obj.entries) {
              w.uint32(10);
              WantlistEntry.codec().encode(value2, w);
            }
          }
          if (obj.full != null) {
            w.uint32(16);
            w.bool(obj.full);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            entries: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.entries != null && obj.entries.length === opts.limits.entries) {
                  throw new MaxLengthError('Decode error - map field "entries" had too many elements');
                }
                obj.entries.push(WantlistEntry.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.entries$
                }));
                break;
              }
              case 2: {
                obj.full = reader2.bool();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Wantlist2.encode = (obj) => {
      return encodeMessage(obj, Wantlist2.codec());
    };
    Wantlist2.decode = (buf2, opts) => {
      return decodeMessage(buf2, Wantlist2.codec(), opts);
    };
  })(Wantlist || (Wantlist = {}));
  var Block;
  (function(Block3) {
    let _codec;
    Block3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.prefix != null && obj.prefix.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.prefix);
          }
          if (obj.data != null && obj.data.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            prefix: alloc(0),
            data: alloc(0)
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.prefix = reader2.bytes();
                break;
              }
              case 2: {
                obj.data = reader2.bytes();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Block3.encode = (obj) => {
      return encodeMessage(obj, Block3.codec());
    };
    Block3.decode = (buf2, opts) => {
      return decodeMessage(buf2, Block3.codec(), opts);
    };
  })(Block || (Block = {}));
  var BlockPresenceType;
  (function(BlockPresenceType2) {
    BlockPresenceType2["HaveBlock"] = "HaveBlock";
    BlockPresenceType2["DoNotHaveBlock"] = "DoNotHaveBlock";
  })(BlockPresenceType || (BlockPresenceType = {}));
  var __BlockPresenceTypeValues;
  (function(__BlockPresenceTypeValues2) {
    __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["HaveBlock"] = 0] = "HaveBlock";
    __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["DoNotHaveBlock"] = 1] = "DoNotHaveBlock";
  })(__BlockPresenceTypeValues || (__BlockPresenceTypeValues = {}));
  (function(BlockPresenceType2) {
    BlockPresenceType2.codec = () => {
      return enumeration(__BlockPresenceTypeValues);
    };
  })(BlockPresenceType || (BlockPresenceType = {}));
  var BlockPresence;
  (function(BlockPresence2) {
    let _codec;
    BlockPresence2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.cid != null && obj.cid.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.cid);
          }
          if (obj.type != null && __BlockPresenceTypeValues[obj.type] !== 0) {
            w.uint32(16);
            BlockPresenceType.codec().encode(obj.type, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            cid: alloc(0),
            type: BlockPresenceType.HaveBlock
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.cid = reader2.bytes();
                break;
              }
              case 2: {
                obj.type = BlockPresenceType.codec().decode(reader2);
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    BlockPresence2.encode = (obj) => {
      return encodeMessage(obj, BlockPresence2.codec());
    };
    BlockPresence2.decode = (buf2, opts) => {
      return decodeMessage(buf2, BlockPresence2.codec(), opts);
    };
  })(BlockPresence || (BlockPresence = {}));
  var BitswapMessage;
  (function(BitswapMessage2) {
    let _codec;
    BitswapMessage2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.wantlist != null) {
            w.uint32(10);
            Wantlist.codec().encode(obj.wantlist, w);
          }
          if (obj.blocks != null) {
            for (const value2 of obj.blocks) {
              w.uint32(26);
              Block.codec().encode(value2, w);
            }
          }
          if (obj.blockPresences != null) {
            for (const value2 of obj.blockPresences) {
              w.uint32(34);
              BlockPresence.codec().encode(value2, w);
            }
          }
          if (obj.pendingBytes != null && obj.pendingBytes !== 0) {
            w.uint32(40);
            w.int32(obj.pendingBytes);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            blocks: [],
            blockPresences: [],
            pendingBytes: 0
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.wantlist = Wantlist.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.wantlist
                });
                break;
              }
              case 3: {
                if (opts.limits?.blocks != null && obj.blocks.length === opts.limits.blocks) {
                  throw new MaxLengthError('Decode error - map field "blocks" had too many elements');
                }
                obj.blocks.push(Block.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.blocks$
                }));
                break;
              }
              case 4: {
                if (opts.limits?.blockPresences != null && obj.blockPresences.length === opts.limits.blockPresences) {
                  throw new MaxLengthError('Decode error - map field "blockPresences" had too many elements');
                }
                obj.blockPresences.push(BlockPresence.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.blockPresences$
                }));
                break;
              }
              case 5: {
                obj.pendingBytes = reader2.int32();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    BitswapMessage2.encode = (obj) => {
      return encodeMessage(obj, BitswapMessage2.codec());
    };
    BitswapMessage2.decode = (buf2, opts) => {
      return decodeMessage(buf2, BitswapMessage2.codec(), opts);
    };
  })(BitswapMessage || (BitswapMessage = {}));

  // node_modules/@helia/bitswap/dist/src/utils/merge-messages.js
  function mergeMessages(existingMessage, newMessage) {
    for (const [key, entry] of newMessage.wantlist.entries()) {
      const existingEntry = existingMessage.wantlist.get(key);
      if (existingEntry != null) {
        if (existingEntry.priority > entry.priority) {
          entry.priority = existingEntry.priority;
        }
        entry.cancel = entry.cancel ?? existingEntry.cancel;
        entry.wantType = entry.wantType ?? existingEntry.wantType;
        entry.sendDontHave = entry.sendDontHave ?? existingEntry.sendDontHave;
      }
      existingMessage.wantlist.set(key, entry);
    }
    for (const [key, blockPresence] of newMessage.blockPresences.entries()) {
      existingMessage.blockPresences.set(key, blockPresence);
    }
    for (const [key, block] of newMessage.blocks.entries()) {
      existingMessage.blocks.set(key, block);
    }
    if (newMessage.full && !existingMessage.full) {
      existingMessage.full = true;
    }
    return existingMessage;
  }

  // node_modules/@helia/bitswap/dist/src/errors.js
  var BlockTooLargeError = class extends Error {
    static name = "BlockTooLargeError";
    constructor(message2 = "Block too large") {
      super(message2);
      this.name = "BlockTooLargeError";
    }
  };

  // node_modules/@helia/bitswap/dist/src/utils/split-message.js
  var MAX_BLOCK_SIZE = 4193648;
  var MAX_ENCODED_BLOCK_SIZE = MAX_BLOCK_SIZE + 16;
  function* splitMessage(message2, maxSize) {
    const wantListEntries = [...message2.wantlist.values()];
    const blockPresences = [...message2.blockPresences.values()];
    const blocks = [...message2.blocks.values()];
    let wantListIndex = 0;
    let blockPresencesIndex = 0;
    let blocksIndex = 0;
    let doneSending = false;
    while (true) {
      const subMessage = {
        wantlist: {
          full: message2.full ?? false,
          entries: []
        },
        blockPresences: [],
        blocks: [],
        pendingBytes: 0
      };
      let size = BitswapMessage.encode(subMessage).byteLength;
      let { added, hasMore, newSize } = addToMessage(blocks, subMessage.blocks, blocksIndex, maxSize, size, calculateEncodedBlockSize);
      blocksIndex += added;
      size = newSize;
      const haveMoreBlocks = hasMore;
      ({ added, hasMore, newSize } = addToMessage(blockPresences, subMessage.blockPresences, blockPresencesIndex, maxSize, size, calculateEncodedBlockPresenceSize));
      blockPresencesIndex += added;
      size = newSize;
      const haveMorePresences = hasMore;
      ({ added, hasMore, newSize } = addToMessage(wantListEntries, subMessage.wantlist.entries, wantListIndex, maxSize, size, calculateEncodedWantlistEntrySize));
      wantListIndex += added;
      size = newSize;
      const haveMoreWantlistEntries = hasMore;
      doneSending = !haveMoreBlocks && !haveMorePresences && !haveMoreWantlistEntries;
      if (!doneSending) {
        subMessage.wantlist.full = false;
      }
      yield BitswapMessage.encode(subMessage);
      if (doneSending) {
        break;
      }
    }
  }
  function addToMessage(input, output, start2, maxSize, size, calculateSize4) {
    let added = 0;
    let hasMore = false;
    for (let i2 = start2; i2 < input.length; i2++) {
      const item = input[i2];
      const itemSize = calculateSize4(item);
      if (itemSize > MAX_ENCODED_BLOCK_SIZE) {
        throw new BlockTooLargeError("Cannot send block as after encoding it is over the max message size");
      }
      const newSize = size + itemSize;
      if (newSize > maxSize) {
        hasMore = true;
        break;
      }
      output.push(item);
      added++;
      size = newSize;
    }
    return { hasMore, added, newSize: size };
  }
  function calculateEncodedBlockSize(block) {
    return calculateLength(3, Block.encode(block));
  }
  function calculateEncodedBlockPresenceSize(blockPresence) {
    return calculateLength(4, BlockPresence.encode(blockPresence));
  }
  function calculateEncodedWantlistEntrySize(entry) {
    return calculateLength(1, WantlistEntry.encode(entry));
  }
  function calculateLength(fieldNumber, data) {
    const fieldNumberLength = encodingLength2(fieldNumber);
    const dataLengthLength = encodingLength2(data.byteLength);
    return fieldNumberLength + dataLengthLength + data.byteLength;
  }

  // node_modules/@helia/bitswap/dist/src/network.js
  var Network = class extends TypedEventEmitter {
    log;
    libp2p;
    routing;
    protocols;
    running;
    maxInboundStreams;
    maxOutboundStreams;
    messageReceiveTimeout;
    registrarIds;
    metrics;
    sendQueue;
    runOnLimitedConnections;
    maxOutgoingMessageSize;
    maxIncomingMessageSize;
    constructor(components, init = {}) {
      super();
      this.log = components.logger.forComponent("helia:bitswap:network");
      this.libp2p = components.libp2p;
      this.routing = components.routing;
      this.protocols = init.protocols ?? [BITSWAP_120];
      this.registrarIds = [];
      this.running = false;
      this._onStream = this._onStream.bind(this);
      this.maxInboundStreams = init.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;
      this.maxOutboundStreams = init.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
      this.messageReceiveTimeout = init.messageReceiveTimeout ?? DEFAULT_MESSAGE_RECEIVE_TIMEOUT;
      this.runOnLimitedConnections = init.runOnLimitedConnections ?? DEFAULT_RUN_ON_TRANSIENT_CONNECTIONS;
      this.maxIncomingMessageSize = init.maxIncomingMessageSize ?? DEFAULT_MAX_OUTGOING_MESSAGE_SIZE;
      this.maxOutgoingMessageSize = init.maxOutgoingMessageSize ?? init.maxIncomingMessageSize ?? DEFAULT_MAX_INCOMING_MESSAGE_SIZE;
      this.metrics = {
        blocksSent: components.metrics?.registerCounter("helia_bitswap_sent_blocks_total"),
        dataSent: components.metrics?.registerCounter("helia_bitswap_sent_data_bytes_total")
      };
      this.sendQueue = new PeerQueue({
        concurrency: init.messageSendConcurrency ?? DEFAULT_MESSAGE_SEND_CONCURRENCY,
        metrics: components.metrics,
        metricName: "helia_bitswap_message_send_queue"
      });
    }
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
      await this.libp2p.handle(this.protocols, this._onStream, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnLimitedConnection: this.runOnLimitedConnections
      });
      const topology = {
        onConnect: (peerId) => {
          this.safeDispatchEvent("peer:connected", {
            detail: peerId
          });
        },
        onDisconnect: (peerId) => {
          this.safeDispatchEvent("peer:disconnected", {
            detail: peerId
          });
        }
      };
      this.registrarIds = [];
      for (const protocol of this.protocols) {
        this.registrarIds.push(await this.libp2p.register(protocol, topology));
      }
      this.libp2p.getConnections().forEach((conn) => {
        this.safeDispatchEvent("peer:connected", {
          detail: conn.remotePeer
        });
      });
    }
    async stop() {
      this.running = false;
      await this.libp2p.unhandle(this.protocols);
      if (this.registrarIds != null) {
        for (const id of this.registrarIds) {
          this.libp2p.unregister(id);
        }
        this.registrarIds = [];
      }
    }
    /**
     * Handles incoming bitswap messages
     */
    _onStream(stream, connection) {
      if (!this.running) {
        return;
      }
      Promise.resolve().then(async () => {
        this.log("incoming new bitswap %s stream from %p", stream.protocol, connection.remotePeer);
        const abortListener = () => {
          if (stream.status === "open") {
            stream.abort(new TimeoutError(`Incoming Bitswap stream timed out after ${this.messageReceiveTimeout}ms`));
          } else {
            this.log("stream aborted with status %s", stream.status);
          }
        };
        let signal = AbortSignal.timeout(this.messageReceiveTimeout);
        setMaxListeners(Infinity, signal);
        signal.addEventListener("abort", abortListener);
        await stream.close({
          signal
        });
        const input = pushable();
        stream.addEventListener("message", (evt) => {
          input.push(evt.data);
        });
        stream.addEventListener("remoteCloseWrite", () => {
          input.end();
        });
        stream.addEventListener("close", (evt) => {
          if (evt.error != null) {
            input.end(evt.error);
          }
        });
        for await (const data of decode10(input, {
          maxDataLength: this.maxIncomingMessageSize
        })) {
          try {
            const message2 = BitswapMessage.decode(data);
            this.log("incoming new bitswap %s message from %p on stream", stream.protocol, connection.remotePeer, stream.id);
            this.safeDispatchEvent("bitswap:message", {
              detail: {
                peer: connection.remotePeer,
                message: message2
              }
            });
            signal.removeEventListener("abort", abortListener);
            signal = AbortSignal.timeout(this.messageReceiveTimeout);
            setMaxListeners(Infinity, signal);
            signal.addEventListener("abort", abortListener);
          } catch (err2) {
            this.log.error("error reading incoming bitswap message from %p on stream - %e", connection.remotePeer, stream.id, err2);
            stream.abort(err2);
            break;
          }
        }
      }).catch((err2) => {
        this.log.error("error handling incoming stream from %p - %e", connection.remotePeer, err2);
        stream.abort(err2);
      });
    }
    /**
     * Find bitswap providers for a given `cid`.
     */
    async *findProviders(cid, options2) {
      options2?.onProgress?.(new CustomProgressEvent("bitswap:find-providers", cid));
      for await (const provider of this.routing.findProviders(cid, options2)) {
        const dialable = await this.libp2p.isDialable(provider.multiaddrs, {
          runOnLimitedConnection: this.runOnLimitedConnections
        });
        if (!dialable) {
          this.log("skipping peer %p as they are not dialable - %a[]", provider.id, provider.multiaddrs);
          continue;
        }
        options2?.onProgress?.(new CustomProgressEvent("bitswap:found-provider", {
          type: "bitswap",
          cid,
          provider,
          routing: provider.routing
        }));
        yield provider;
      }
    }
    /**
     * Find the providers of a given `cid` and connect to them.
     */
    async findAndConnect(cid, options2) {
      if (options2?.providers != null) {
        await Promise.all(options2.providers.map(async (prov) => this.connectTo(prov).catch((err2) => {
          this.log.error("could not connect to supplied provider - %e", err2);
        })));
      }
      await src_default3(src_default5(src_default6(this.findProviders(cid, options2), options2?.maxProviders ?? DEFAULT_MAX_PROVIDERS_PER_REQUEST), async (provider) => this.connectTo(provider.id, options2))).catch((err2) => {
        this.log.error(err2);
      });
    }
    /**
     * Connect to the given peer
     * Send the given msg (instance of Message) to the given peer
     */
    async sendMessage(peerId, message2, options2) {
      if (!this.running) {
        throw new Error("network isn't running");
      }
      const existingJob = this.sendQueue.queue.find((job) => {
        return peerId.equals(job.options.peerId) && job.status === "queued";
      });
      if (existingJob != null) {
        existingJob.options.message = mergeMessages(existingJob.options.message, message2);
        await existingJob.join({
          signal: options2?.signal
        });
        return;
      }
      await this.sendQueue.add(async (options3) => {
        const message3 = options3?.message;
        if (message3 == null) {
          throw new InvalidParametersError("No message to send");
        }
        this.log("sendMessage to %p", peerId);
        options3?.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist", peerId));
        const stream = await this.libp2p.dialProtocol(peerId, BITSWAP_120, options3);
        await stream.closeRead();
        try {
          for (const buf2 of splitMessage(message3, this.maxOutgoingMessageSize)) {
            if (!stream.send(encode9.single(buf2))) {
              await stream.onDrain(options3);
            }
          }
          await stream.close(options3);
        } catch (err2) {
          options3?.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist:error", { peer: peerId, error: err2 }));
          this.log.error("error sending message to %p - %e", peerId, err2);
          stream.abort(err2);
        }
        this._updateSentStats(message3.blocks);
      }, {
        peerId,
        signal: options2?.signal,
        message: message2
      });
    }
    /**
     * Connects to another peer
     */
    async connectTo(peer, options2) {
      if (!this.running) {
        throw new NotStartedError("Network isn't running");
      }
      options2?.onProgress?.(new CustomProgressEvent("bitswap:network:dial", peer));
      const [connection] = await Promise.all([
        this.libp2p.dial(peer, options2),
        raceEvent(this.libp2p, "peer:identify", options2?.signal, {
          filter: (evt) => {
            if (!evt.detail.peerId.equals(peer)) {
              return false;
            }
            if (evt.detail.protocols.includes(BITSWAP_120)) {
              return true;
            }
            throw new UnsupportedProtocolError(`${peer} did not support ${BITSWAP_120}`);
          }
        })
      ]);
      return connection;
    }
    _updateSentStats(blocks) {
      let bytes = 0;
      for (const block of blocks.values()) {
        bytes += block.data.byteLength;
      }
      this.metrics.dataSent?.increment(bytes);
      this.metrics.blocksSent?.increment(blocks.size);
    }
  };

  // node_modules/@libp2p/peer-id/dist/src/peer-id.js
  var inspect2 = Symbol.for("nodejs.util.inspect.custom");
  var LIBP2P_KEY_CODE = 114;
  var PeerIdImpl = class {
    type;
    multihash;
    publicKey;
    string;
    constructor(init) {
      this.type = init.type;
      this.multihash = init.multihash;
      Object.defineProperty(this, "string", {
        enumerable: false,
        writable: true
      });
    }
    get [Symbol.toStringTag]() {
      return `PeerId(${this.toString()})`;
    }
    [peerIdSymbol] = true;
    toString() {
      if (this.string == null) {
        this.string = base58btc.encode(this.multihash.bytes).slice(1);
      }
      return this.string;
    }
    toMultihash() {
      return this.multihash;
    }
    // return self-describing String representation
    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
    toCID() {
      return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
    }
    toJSON() {
      return this.toString();
    }
    /**
     * Checks the equality of `this` peer against a given PeerId
     */
    equals(id) {
      if (id == null) {
        return false;
      }
      if (id instanceof Uint8Array) {
        return equals3(this.multihash.bytes, id);
      } else if (typeof id === "string") {
        return this.toString() === id;
      } else if (id?.toMultihash()?.bytes != null) {
        return equals3(this.multihash.bytes, id.toMultihash().bytes);
      } else {
        throw new Error("not valid Id");
      }
    }
    /**
     * Returns PeerId as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```TypeScript
     * import { peerIdFromString } from '@libp2p/peer-id'
     *
     * console.info(peerIdFromString('QmFoo'))
     * // 'PeerId(QmFoo)'
     * ```
     */
    [inspect2]() {
      return `PeerId(${this.toString()})`;
    }
  };
  var RSAPeerId = class extends PeerIdImpl {
    type = "RSA";
    publicKey;
    constructor(init) {
      super({ ...init, type: "RSA" });
      this.publicKey = init.publicKey;
    }
  };
  var Ed25519PeerId = class extends PeerIdImpl {
    type = "Ed25519";
    publicKey;
    constructor(init) {
      super({ ...init, type: "Ed25519" });
      this.publicKey = init.publicKey;
    }
  };
  var Secp256k1PeerId = class extends PeerIdImpl {
    type = "secp256k1";
    publicKey;
    constructor(init) {
      super({ ...init, type: "secp256k1" });
      this.publicKey = init.publicKey;
    }
  };
  var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
  var URLPeerId = class {
    type = "url";
    multihash;
    publicKey;
    url;
    constructor(url) {
      this.url = url.toString();
      this.multihash = identity.digest(fromString2(this.url));
    }
    [inspect2]() {
      return `PeerId(${this.url})`;
    }
    [peerIdSymbol] = true;
    toString() {
      return this.toCID().toString();
    }
    toMultihash() {
      return this.multihash;
    }
    toCID() {
      return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash());
    }
    toJSON() {
      return this.toString();
    }
    equals(other) {
      if (other == null) {
        return false;
      }
      if (other instanceof Uint8Array) {
        other = toString2(other);
      }
      return other.toString() === this.toString();
    }
  };

  // node_modules/@libp2p/peer-id/dist/src/index.js
  var LIBP2P_KEY_CODE2 = 114;
  var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
  function peerIdFromString(str, decoder) {
    let multihash;
    if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
      multihash = decode4(base58btc.decode(`z${str}`));
    } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
      return peerIdFromCID(CID.parse(str));
    } else {
      if (decoder == null) {
        throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
      }
      multihash = decode4(decoder.decode(str));
    }
    return peerIdFromMultihash(multihash);
  }
  function peerIdFromPublicKey(publicKey2) {
    if (publicKey2.type === "Ed25519") {
      return new Ed25519PeerId({
        multihash: publicKey2.toCID().multihash,
        publicKey: publicKey2
      });
    } else if (publicKey2.type === "secp256k1") {
      return new Secp256k1PeerId({
        multihash: publicKey2.toCID().multihash,
        publicKey: publicKey2
      });
    } else if (publicKey2.type === "RSA") {
      return new RSAPeerId({
        multihash: publicKey2.toCID().multihash,
        publicKey: publicKey2
      });
    }
    throw new UnsupportedKeyTypeError();
  }
  function peerIdFromPrivateKey(privateKey) {
    return peerIdFromPublicKey(privateKey.publicKey);
  }
  function peerIdFromMultihash(multihash) {
    if (isSha256Multihash(multihash)) {
      return new RSAPeerId({ multihash });
    } else if (isIdentityMultihash(multihash)) {
      try {
        const publicKey2 = publicKeyFromMultihash(multihash);
        if (publicKey2.type === "Ed25519") {
          return new Ed25519PeerId({ multihash, publicKey: publicKey2 });
        } else if (publicKey2.type === "secp256k1") {
          return new Secp256k1PeerId({ multihash, publicKey: publicKey2 });
        }
      } catch (err2) {
        const url = toString2(multihash.digest);
        return new URLPeerId(new URL(url));
      }
    }
    throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
  }
  function peerIdFromCID(cid) {
    if (cid?.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
      throw new InvalidCIDError("Supplied PeerID CID is invalid");
    }
    if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
      const url = toString2(cid.multihash.digest);
      return new URLPeerId(new URL(url));
    }
    return peerIdFromMultihash(cid.multihash);
  }
  function isIdentityMultihash(multihash) {
    return multihash.code === identity.code;
  }
  function isSha256Multihash(multihash) {
    return multihash.code === sha256.code;
  }

  // node_modules/@libp2p/peer-collections/dist/src/util.js
  function mapIterable(iter, map2) {
    const iterator = {
      [Symbol.iterator]: () => {
        return iterator;
      },
      next: () => {
        const next = iter.next();
        const val = next.value;
        if (next.done === true || val == null) {
          const result = {
            done: true,
            value: void 0
          };
          return result;
        }
        return {
          done: false,
          value: map2(val)
        };
      }
    };
    return iterator;
  }
  function peerIdFromString2(str) {
    const multihash = decode4(base58btc.decode(`z${str}`));
    return peerIdFromMultihash(multihash);
  }

  // node_modules/@libp2p/peer-collections/dist/src/map.js
  var PeerMap = class {
    map;
    constructor(map2) {
      this.map = /* @__PURE__ */ new Map();
      if (map2 != null) {
        for (const [key, value2] of map2.entries()) {
          this.map.set(key.toString(), { key, value: value2 });
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    clear() {
      this.map.clear();
    }
    delete(peer) {
      return this.map.delete(peer.toString());
    }
    entries() {
      return mapIterable(this.map.entries(), (val) => {
        return [val[1].key, val[1].value];
      });
    }
    forEach(fn) {
      this.map.forEach((value2, key) => {
        fn(value2.value, value2.key, this);
      });
    }
    get(peer) {
      return this.map.get(peer.toString())?.value;
    }
    has(peer) {
      return this.map.has(peer.toString());
    }
    set(peer, value2) {
      this.map.set(peer.toString(), { key: peer, value: value2 });
    }
    keys() {
      return mapIterable(this.map.values(), (val) => {
        return val.key;
      });
    }
    values() {
      return mapIterable(this.map.values(), (val) => val.value);
    }
    get size() {
      return this.map.size;
    }
  };

  // node_modules/@libp2p/peer-collections/dist/src/set.js
  var PeerSet = class _PeerSet {
    set;
    constructor(set) {
      this.set = /* @__PURE__ */ new Set();
      if (set != null) {
        for (const key of set) {
          this.set.add(key.toString());
        }
      }
    }
    get size() {
      return this.set.size;
    }
    [Symbol.iterator]() {
      return this.values();
    }
    add(peer) {
      this.set.add(peer.toString());
    }
    clear() {
      this.set.clear();
    }
    delete(peer) {
      this.set.delete(peer.toString());
    }
    entries() {
      return mapIterable(this.set.entries(), (val) => {
        const peerId = peerIdFromString2(val[0]);
        return [peerId, peerId];
      });
    }
    forEach(predicate) {
      this.set.forEach((str) => {
        const peerId = peerIdFromString2(str);
        predicate(peerId, peerId, this);
      });
    }
    has(peer) {
      return this.set.has(peer.toString());
    }
    values() {
      return mapIterable(this.set.values(), (val) => {
        return peerIdFromString2(val);
      });
    }
    intersection(other) {
      const output = new _PeerSet();
      for (const peerId of other) {
        if (this.has(peerId)) {
          output.add(peerId);
        }
      }
      return output;
    }
    difference(other) {
      const output = new _PeerSet();
      for (const peerId of this) {
        if (!other.has(peerId)) {
          output.add(peerId);
        }
      }
      return output;
    }
    union(other) {
      const output = new _PeerSet();
      for (const peerId of other) {
        output.add(peerId);
      }
      for (const peerId of this) {
        output.add(peerId);
      }
      return output;
    }
  };
  function peerSet() {
    return new PeerSet();
  }

  // node_modules/@libp2p/peer-collections/dist/src/filter.js
  var PeerFilter = class {
    filter;
    constructor(size, errorRate) {
      this.filter = createScalableCuckooFilter(size, errorRate);
    }
    has(peerId) {
      return this.filter.has(peerId.toMultihash().bytes);
    }
    add(peerId) {
      this.filter.add(peerId.toMultihash().bytes);
    }
    remove(peerId) {
      this.filter.remove?.(peerId.toMultihash().bytes);
    }
  };
  function peerFilter(size, errorRate = 1e-3) {
    return new PeerFilter(size, errorRate);
  }

  // node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
  var TrackedPeerMap = class extends PeerMap {
    metric;
    constructor(init) {
      super();
      const { name: name9, metrics } = init;
      this.metric = metrics.registerMetric(name9);
      this.updateComponentMetric();
    }
    set(key, value2) {
      super.set(key, value2);
      this.updateComponentMetric();
      return this;
    }
    delete(key) {
      const deleted = super.delete(key);
      this.updateComponentMetric();
      return deleted;
    }
    clear() {
      super.clear();
      this.updateComponentMetric();
    }
    updateComponentMetric() {
      this.metric.update(this.size);
    }
  };
  function trackedPeerMap(config) {
    const { name: name9, metrics } = config;
    let map2;
    if (metrics != null) {
      map2 = new TrackedPeerMap({ name: name9, metrics });
    } else {
      map2 = new PeerMap();
    }
    return map2;
  }

  // node_modules/it-to-buffer/dist/src/index.js
  function isAsyncIterable7(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function toBuffer(source) {
    if (isAsyncIterable7(source)) {
      return (async () => {
        let buffer2 = new Uint8Array(0);
        for await (const buf2 of source) {
          buffer2 = concat([buffer2, buf2], buffer2.length + buf2.length);
        }
        return buffer2;
      })();
    }
    const bufs = [];
    let length4 = 0;
    for (const buf2 of source) {
      bufs.push(buf2);
      length4 += buf2.byteLength;
    }
    return concat(bufs, length4);
  }
  var src_default7 = toBuffer;

  // node_modules/@helia/bitswap/dist/src/utils/bitswap-message.js
  var QueuedBitswapMessage = class {
    full;
    pendingBytes;
    wantlist;
    blocks;
    blockPresences;
    constructor(full = false, pendingBytes = 0) {
      this.full = full;
      this.wantlist = /* @__PURE__ */ new Map();
      this.blocks = /* @__PURE__ */ new Map();
      this.blockPresences = /* @__PURE__ */ new Map();
      this.pendingBytes = 0;
    }
    addWantlistEntry(cid, entry) {
      const key = base64.encode(cid.multihash.bytes);
      this.wantlist.set(key, entry);
    }
    addBlockPresence(cid, blockPresence) {
      const key = base64.encode(cid.multihash.bytes);
      this.blockPresences.set(key, blockPresence);
    }
    addBlock(cid, block) {
      const key = base64.encode(cid.multihash.bytes);
      this.blocks.set(key, block);
    }
  };

  // node_modules/@helia/bitswap/dist/src/utils/varint-encoder.js
  function varintEncoder(buf2) {
    let out = new Uint8Array(buf2.reduce((acc, curr) => {
      return acc + encodingLength2(curr);
    }, 0));
    let offset = 0;
    for (const num of buf2) {
      out = encode7(num, out, offset);
      offset += encodingLength2(num);
    }
    return out;
  }
  var varint_encoder_default = varintEncoder;

  // node_modules/@helia/bitswap/dist/src/utils/cid-prefix.js
  function cidToPrefix(cid) {
    return varint_encoder_default([
      cid.version,
      cid.code,
      cid.multihash.code,
      cid.multihash.digest.byteLength
    ]);
  }

  // node_modules/@helia/bitswap/dist/src/peer-want-lists/ledger.js
  var Ledger = class {
    peerId;
    blockstore;
    network;
    wants;
    exchangeCount;
    bytesSent;
    bytesReceived;
    lastExchange;
    maxSizeReplaceHasWithBlock;
    log;
    constructor(components, init) {
      this.peerId = components.peerId;
      this.blockstore = components.blockstore;
      this.network = components.network;
      this.wants = /* @__PURE__ */ new Map();
      this.log = components.logger.forComponent(`helia:bitswap:ledger:${components.peerId}`);
      this.exchangeCount = 0;
      this.bytesSent = 0;
      this.bytesReceived = 0;
      this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock ?? DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK;
    }
    sentBytes(n2) {
      this.exchangeCount++;
      this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
      this.bytesSent += n2;
    }
    receivedBytes(n2) {
      this.exchangeCount++;
      this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
      this.bytesReceived += n2;
    }
    debtRatio() {
      return this.bytesSent / (this.bytesReceived + 1);
    }
    async sendBlocksToPeer(options2) {
      const message2 = new QueuedBitswapMessage();
      const sentBlocks = /* @__PURE__ */ new Set();
      for (const [key, entry] of this.wants.entries()) {
        try {
          const block = await src_default7(this.blockstore.get(entry.cid, options2));
          if (entry.wantType === WantType.WantHave) {
            if (block.byteLength < this.maxSizeReplaceHasWithBlock) {
              this.log("sending have and block for %c", entry.cid);
              sentBlocks.add(key);
              message2.addBlock(entry.cid, {
                data: block,
                prefix: cidToPrefix(entry.cid)
              });
            } else {
              this.log("sending have for %c", entry.cid);
              message2.addBlockPresence(entry.cid, {
                cid: entry.cid.bytes,
                type: BlockPresenceType.HaveBlock
              });
            }
          } else {
            this.log("sending block for %c", entry.cid);
            sentBlocks.add(key);
            message2.addBlock(entry.cid, {
              data: block,
              prefix: cidToPrefix(entry.cid)
            });
          }
        } catch (err2) {
          if (err2.name !== "NotFoundError") {
            throw err2;
          }
          this.log("do not have block for %c", entry.cid);
          if (!entry.sendDontHave) {
            continue;
          }
          if (entry.sentDoNotHave === true) {
            continue;
          }
          entry.sentDoNotHave = true;
          message2.addBlockPresence(entry.cid, {
            cid: entry.cid.bytes,
            type: BlockPresenceType.DoNotHaveBlock
          });
        }
      }
      if (message2.blocks.size > 0 || message2.blockPresences.size > 0) {
        this.log("sending message");
        await this.network.sendMessage(this.peerId, message2, options2);
        this.log("sent message");
        this.sentBytes([...message2.blocks.values()].reduce((acc, curr) => acc + curr.data.byteLength, 0));
        for (const key of sentBlocks) {
          this.wants.delete(key);
        }
      }
    }
  };

  // node_modules/@helia/bitswap/dist/src/peer-want-lists/index.js
  var PeerWantLists = class {
    blockstore;
    network;
    ledgerMap;
    maxSizeReplaceHasWithBlock;
    log;
    logger;
    constructor(components, init = {}) {
      this.blockstore = components.blockstore;
      this.network = components.network;
      this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock;
      this.log = components.logger.forComponent("helia:bitswap:peer-want-lists");
      this.logger = components.logger;
      this.ledgerMap = trackedPeerMap({
        name: "helia_bitswap_ledger_map",
        metrics: components.metrics
      });
      this.network.addEventListener("bitswap:message", (evt) => {
        this.receiveMessage(evt.detail.peer, evt.detail.message).catch((err2) => {
          this.log.error("error receiving bitswap message from %p - %e", evt.detail.peer, err2);
        });
      });
      this.network.addEventListener("peer:disconnected", (evt) => {
        this.peerDisconnected(evt.detail);
      });
    }
    ledgerForPeer(peerId) {
      const ledger = this.ledgerMap.get(peerId);
      if (ledger == null) {
        return void 0;
      }
      return {
        peer: ledger.peerId,
        value: ledger.debtRatio(),
        sent: ledger.bytesSent,
        received: ledger.bytesReceived,
        exchanged: ledger.exchangeCount
      };
    }
    wantListForPeer(peerId) {
      const ledger = this.ledgerMap.get(peerId);
      if (ledger == null) {
        return void 0;
      }
      return [...ledger.wants.values()];
    }
    peers() {
      return Array.from(this.ledgerMap.values()).map((l2) => l2.peerId);
    }
    /**
     * Handle incoming messages
     */
    async receiveMessage(peerId, message2) {
      let ledger = this.ledgerMap.get(peerId);
      if (ledger == null) {
        ledger = new Ledger({
          peerId,
          blockstore: this.blockstore,
          network: this.network,
          logger: this.logger
        }, {
          maxSizeReplaceHasWithBlock: this.maxSizeReplaceHasWithBlock
        });
        this.ledgerMap.set(peerId, ledger);
      }
      ledger.receivedBytes(message2.blocks?.reduce((acc, curr) => acc + curr.data.byteLength, 0) ?? 0);
      if (message2.wantlist != null) {
        if (message2.wantlist.full === true) {
          ledger.wants.clear();
        }
        for (const entry of message2.wantlist.entries) {
          const cid = CID.decode(entry.cid);
          const cidStr = toString2(cid.multihash.bytes, "base64");
          if (entry.cancel === true) {
            this.log("peer %p cancelled want of block for %c", peerId, cid);
            ledger.wants.delete(cidStr);
          } else {
            if (entry.wantType === WantType.WantHave) {
              this.log("peer %p wanted block presence for %c", peerId, cid);
            } else {
              this.log("peer %p wanted block for %c", peerId, cid);
            }
            ledger.wants.set(cidStr, {
              cid,
              priority: entry.priority,
              wantType: entry.wantType ?? WantType.WantBlock,
              sendDontHave: entry.sendDontHave ?? false
            });
          }
        }
      }
      this.log("send blocks to peer");
      await ledger.sendBlocksToPeer();
    }
    async receivedBlock(cid, options2) {
      const cidStr = toString2(cid.multihash.bytes, "base64");
      const ledgers = [];
      for (const ledger of this.ledgerMap.values()) {
        if (ledger.wants.has(cidStr)) {
          ledgers.push(ledger);
        }
      }
      await Promise.all(ledgers.map(async (ledger) => ledger.sendBlocksToPeer(options2)));
    }
    peerDisconnected(peerId) {
      this.ledgerMap.delete(peerId);
    }
  };

  // node_modules/eventemitter3/index.mjs
  var import_index8 = __toESM(require_eventemitter3(), 1);

  // node_modules/p-timeout/index.js
  var TimeoutError3 = class _TimeoutError extends Error {
    name = "TimeoutError";
    constructor(message2, options2) {
      super(message2, options2);
      Error.captureStackTrace?.(this, _TimeoutError);
    }
  };
  var getAbortedReason2 = (signal) => signal.reason ?? new DOMException("This operation was aborted.", "AbortError");
  function pTimeout2(promise, options2) {
    const {
      milliseconds,
      fallback,
      message: message2,
      customTimers = { setTimeout, clearTimeout },
      signal
    } = options2;
    let timer;
    let abortHandler;
    const wrappedPromise = new Promise((resolve8, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (signal?.aborted) {
        reject(getAbortedReason2(signal));
        return;
      }
      if (signal) {
        abortHandler = () => {
          reject(getAbortedReason2(signal));
        };
        signal.addEventListener("abort", abortHandler, { once: true });
      }
      promise.then(resolve8, reject);
      if (milliseconds === Number.POSITIVE_INFINITY) {
        return;
      }
      const timeoutError = new TimeoutError3();
      timer = customTimers.setTimeout.call(void 0, () => {
        if (fallback) {
          try {
            resolve8(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        if (message2 === false) {
          resolve8();
        } else if (message2 instanceof Error) {
          reject(message2);
        } else {
          timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
          reject(timeoutError);
        }
      }, milliseconds);
    });
    const cancelablePromise = wrappedPromise.finally(() => {
      cancelablePromise.clear();
      if (abortHandler && signal) {
        signal.removeEventListener("abort", abortHandler);
      }
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(void 0, timer);
      timer = void 0;
    };
    return cancelablePromise;
  }

  // node_modules/p-queue/dist/lower-bound.js
  function lowerBound(array, value2, comparator) {
    let first2 = 0;
    let count = array.length;
    while (count > 0) {
      const step = Math.trunc(count / 2);
      let it = first2 + step;
      if (comparator(array[it], value2) <= 0) {
        first2 = ++it;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first2;
  }

  // node_modules/p-queue/dist/priority-queue.js
  var PriorityQueue2 = class {
    #queue = [];
    enqueue(run, options2) {
      const { priority = 0, id } = options2 ?? {};
      const element = {
        priority,
        id,
        run
      };
      if (this.size === 0 || this.#queue[this.size - 1].priority >= priority) {
        this.#queue.push(element);
        return;
      }
      const index = lowerBound(this.#queue, element, (a2, b) => b.priority - a2.priority);
      this.#queue.splice(index, 0, element);
    }
    setPriority(id, priority) {
      const index = this.#queue.findIndex((element) => element.id === id);
      if (index === -1) {
        throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
      }
      const [item] = this.#queue.splice(index, 1);
      this.enqueue(item.run, { priority, id });
    }
    dequeue() {
      const item = this.#queue.shift();
      return item?.run;
    }
    filter(options2) {
      return this.#queue.filter((element) => element.priority === options2.priority).map((element) => element.run);
    }
    get size() {
      return this.#queue.length;
    }
  };

  // node_modules/p-queue/dist/index.js
  var PQueue = class extends import_index8.default {
    #carryoverIntervalCount;
    #isIntervalIgnored;
    #intervalCount = 0;
    #intervalCap;
    #rateLimitedInInterval = false;
    #rateLimitFlushScheduled = false;
    #interval;
    #intervalEnd = 0;
    #lastExecutionTime = 0;
    #intervalId;
    #timeoutId;
    #queue;
    #queueClass;
    #pending = 0;
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    #concurrency;
    #isPaused;
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    #idAssigner = 1n;
    // Track currently running tasks for debugging
    #runningTasks = /* @__PURE__ */ new Map();
    /**
        Get or set the default timeout for all tasks. Can be changed at runtime.
    
        Operations will throw a `TimeoutError` if they don't complete within the specified time.
    
        The timeout begins when the operation is dequeued and starts execution, not while it's waiting in the queue.
    
        @example
        ```
        const queue = new PQueue({timeout: 5000});
    
        // Change timeout for all future tasks
        queue.timeout = 10000;
        ```
        */
    timeout;
    constructor(options2) {
      super();
      options2 = {
        carryoverIntervalCount: false,
        intervalCap: Number.POSITIVE_INFINITY,
        interval: 0,
        concurrency: Number.POSITIVE_INFINITY,
        autoStart: true,
        queueClass: PriorityQueue2,
        ...options2
      };
      if (!(typeof options2.intervalCap === "number" && options2.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options2.intervalCap?.toString() ?? ""}\` (${typeof options2.intervalCap})`);
      }
      if (options2.interval === void 0 || !(Number.isFinite(options2.interval) && options2.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options2.interval?.toString() ?? ""}\` (${typeof options2.interval})`);
      }
      this.#carryoverIntervalCount = options2.carryoverIntervalCount ?? options2.carryoverConcurrencyCount ?? false;
      this.#isIntervalIgnored = options2.intervalCap === Number.POSITIVE_INFINITY || options2.interval === 0;
      this.#intervalCap = options2.intervalCap;
      this.#interval = options2.interval;
      this.#queue = new options2.queueClass();
      this.#queueClass = options2.queueClass;
      this.concurrency = options2.concurrency;
      if (options2.timeout !== void 0 && !(Number.isFinite(options2.timeout) && options2.timeout > 0)) {
        throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${options2.timeout}\` (${typeof options2.timeout})`);
      }
      this.timeout = options2.timeout;
      this.#isPaused = options2.autoStart === false;
      this.#setupRateLimitTracking();
    }
    get #doesIntervalAllowAnother() {
      return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
    }
    get #doesConcurrentAllowAnother() {
      return this.#pending < this.#concurrency;
    }
    #next() {
      this.#pending--;
      if (this.#pending === 0) {
        this.emit("pendingZero");
      }
      this.#tryToStartAnother();
      this.emit("next");
    }
    #onResumeInterval() {
      this.#onInterval();
      this.#initializeIntervalIfNeeded();
      this.#timeoutId = void 0;
    }
    get #isIntervalPaused() {
      const now = Date.now();
      if (this.#intervalId === void 0) {
        const delay3 = this.#intervalEnd - now;
        if (delay3 < 0) {
          if (this.#lastExecutionTime > 0) {
            const timeSinceLastExecution = now - this.#lastExecutionTime;
            if (timeSinceLastExecution < this.#interval) {
              this.#createIntervalTimeout(this.#interval - timeSinceLastExecution);
              return true;
            }
          }
          this.#intervalCount = this.#carryoverIntervalCount ? this.#pending : 0;
        } else {
          this.#createIntervalTimeout(delay3);
          return true;
        }
      }
      return false;
    }
    #createIntervalTimeout(delay3) {
      if (this.#timeoutId !== void 0) {
        return;
      }
      this.#timeoutId = setTimeout(() => {
        this.#onResumeInterval();
      }, delay3);
    }
    #clearIntervalTimer() {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
        this.#intervalId = void 0;
      }
    }
    #clearTimeoutTimer() {
      if (this.#timeoutId) {
        clearTimeout(this.#timeoutId);
        this.#timeoutId = void 0;
      }
    }
    #tryToStartAnother() {
      if (this.#queue.size === 0) {
        this.#clearIntervalTimer();
        this.emit("empty");
        if (this.#pending === 0) {
          this.#clearTimeoutTimer();
          this.emit("idle");
        }
        return false;
      }
      let taskStarted = false;
      if (!this.#isPaused) {
        const canInitializeInterval = !this.#isIntervalPaused;
        if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
          const job = this.#queue.dequeue();
          if (!this.#isIntervalIgnored) {
            this.#intervalCount++;
            this.#scheduleRateLimitUpdate();
          }
          this.emit("active");
          this.#lastExecutionTime = Date.now();
          job();
          if (canInitializeInterval) {
            this.#initializeIntervalIfNeeded();
          }
          taskStarted = true;
        }
      }
      return taskStarted;
    }
    #initializeIntervalIfNeeded() {
      if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
        return;
      }
      this.#intervalId = setInterval(() => {
        this.#onInterval();
      }, this.#interval);
      this.#intervalEnd = Date.now() + this.#interval;
    }
    #onInterval() {
      if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
        this.#clearIntervalTimer();
      }
      this.#intervalCount = this.#carryoverIntervalCount ? this.#pending : 0;
      this.#processQueue();
      this.#scheduleRateLimitUpdate();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    #processQueue() {
      while (this.#tryToStartAnother()) {
      }
    }
    get concurrency() {
      return this.#concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this.#concurrency = newConcurrency;
      this.#processQueue();
    }
    async #throwOnAbort(signal) {
      return new Promise((_resolve, reject) => {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        }, { once: true });
      });
    }
    /**
        Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
    
        For example, this can be used to prioritize a promise function to run earlier.
    
        ```js
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 1});
    
        queue.add(async () => '', {priority: 1});
        queue.add(async () => '', {priority: 0, id: ''});
        queue.add(async () => '', {priority: 1});
        queue.add(async () => '', {priority: 1});
    
        queue.setPriority('', 2);
        ```
    
        In this case, the promise function with `id: ''` runs second.
    
        You can also deprioritize a promise function to delay its execution:
    
        ```js
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 1});
    
        queue.add(async () => '', {priority: 1});
        queue.add(async () => '', {priority: 1, id: ''});
        queue.add(async () => '');
        queue.add(async () => '', {priority: 0});
    
        queue.setPriority('', -1);
        ```
        Here, the promise function with `id: ''` executes last.
        */
    setPriority(id, priority) {
      if (typeof priority !== "number" || !Number.isFinite(priority)) {
        throw new TypeError(`Expected \`priority\` to be a finite number, got \`${priority}\` (${typeof priority})`);
      }
      this.#queue.setPriority(id, priority);
    }
    async add(function_, options2 = {}) {
      options2.id ??= (this.#idAssigner++).toString();
      options2 = {
        timeout: this.timeout,
        ...options2
      };
      return new Promise((resolve8, reject) => {
        const taskSymbol = Symbol(`task-${options2.id}`);
        this.#queue.enqueue(async () => {
          this.#pending++;
          this.#runningTasks.set(taskSymbol, {
            id: options2.id,
            priority: options2.priority ?? 0,
            // Match priority-queue default
            startTime: Date.now(),
            timeout: options2.timeout
          });
          try {
            try {
              options2.signal?.throwIfAborted();
            } catch (error) {
              if (!this.#isIntervalIgnored) {
                this.#intervalCount--;
              }
              this.#runningTasks.delete(taskSymbol);
              throw error;
            }
            let operation = function_({ signal: options2.signal });
            if (options2.timeout) {
              operation = pTimeout2(Promise.resolve(operation), {
                milliseconds: options2.timeout,
                message: `Task timed out after ${options2.timeout}ms (queue has ${this.#pending} running, ${this.#queue.size} waiting)`
              });
            }
            if (options2.signal) {
              operation = Promise.race([operation, this.#throwOnAbort(options2.signal)]);
            }
            const result = await operation;
            resolve8(result);
            this.emit("completed", result);
          } catch (error) {
            reject(error);
            this.emit("error", error);
          } finally {
            this.#runningTasks.delete(taskSymbol);
            queueMicrotask(() => {
              this.#next();
            });
          }
        }, options2);
        this.emit("add");
        this.#tryToStartAnother();
      });
    }
    async addAll(functions, options2) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options2)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      if (!this.#isPaused) {
        return this;
      }
      this.#isPaused = false;
      this.#processQueue();
      return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this.#isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
      this.#queue = new this.#queueClass();
      this.#updateRateLimitState();
    }
    /**
        Can be called multiple times. Useful if you for example add additional items at a later time.
    
        @returns A promise that settles when the queue becomes empty.
        */
    async onEmpty() {
      if (this.#queue.size === 0) {
        return;
      }
      await this.#onEvent("empty");
    }
    /**
        @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
    
        If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
    
        Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
        */
    async onSizeLessThan(limit) {
      if (this.#queue.size < limit) {
        return;
      }
      await this.#onEvent("next", () => this.#queue.size < limit);
    }
    /**
        The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
        @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
        */
    async onIdle() {
      if (this.#pending === 0 && this.#queue.size === 0) {
        return;
      }
      await this.#onEvent("idle");
    }
    /**
        The difference with `.onIdle` is that `.onPendingZero` only waits for currently running tasks to finish, ignoring queued tasks.
    
        @returns A promise that settles when all currently running tasks have completed; `queue.pending === 0`.
        */
    async onPendingZero() {
      if (this.#pending === 0) {
        return;
      }
      await this.#onEvent("pendingZero");
    }
    /**
    @returns A promise that settles when the queue becomes rate-limited due to intervalCap.
    */
    async onRateLimit() {
      if (this.isRateLimited) {
        return;
      }
      await this.#onEvent("rateLimit");
    }
    /**
    @returns A promise that settles when the queue is no longer rate-limited.
    */
    async onRateLimitCleared() {
      if (!this.isRateLimited) {
        return;
      }
      await this.#onEvent("rateLimitCleared");
    }
    /**
        @returns A promise that rejects when any task in the queue errors.
    
        Use with `Promise.race([queue.onError(), queue.onIdle()])` to fail fast on the first error while still resolving normally when the queue goes idle.
    
        Important: The promise returned by `add()` still rejects. You must handle each `add()` promise (for example, `.catch(() => {})`) to avoid unhandled rejections.
    
        @example
        ```
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 2});
    
        queue.add(() => fetchData(1)).catch(() => {});
        queue.add(() => fetchData(2)).catch(() => {});
        queue.add(() => fetchData(3)).catch(() => {});
    
        // Stop processing on first error
        try {
            await Promise.race([
                queue.onError(),
                queue.onIdle()
            ]);
        } catch (error) {
            queue.pause(); // Stop processing remaining tasks
            console.error('Queue failed:', error);
        }
        ```
        */
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    async onError() {
      return new Promise((_resolve, reject) => {
        const handleError = (error) => {
          this.off("error", handleError);
          reject(error);
        };
        this.on("error", handleError);
      });
    }
    async #onEvent(event, filter2) {
      return new Promise((resolve8) => {
        const listener = () => {
          if (filter2 && !filter2()) {
            return;
          }
          this.off(event, listener);
          resolve8();
        };
        this.on(event, listener);
      });
    }
    /**
    Size of the queue, the number of queued items waiting to run.
    */
    get size() {
      return this.#queue.size;
    }
    /**
        Size of the queue, filtered by the given options.
    
        For example, this can be used to find the number of items remaining in the queue with a specific priority level.
        */
    sizeBy(options2) {
      return this.#queue.filter(options2).length;
    }
    /**
    Number of running items (no longer in the queue).
    */
    get pending() {
      return this.#pending;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this.#isPaused;
    }
    #setupRateLimitTracking() {
      if (this.#isIntervalIgnored) {
        return;
      }
      this.on("add", () => {
        if (this.#queue.size > 0) {
          this.#scheduleRateLimitUpdate();
        }
      });
      this.on("next", () => {
        this.#scheduleRateLimitUpdate();
      });
    }
    #scheduleRateLimitUpdate() {
      if (this.#isIntervalIgnored || this.#rateLimitFlushScheduled) {
        return;
      }
      this.#rateLimitFlushScheduled = true;
      queueMicrotask(() => {
        this.#rateLimitFlushScheduled = false;
        this.#updateRateLimitState();
      });
    }
    #updateRateLimitState() {
      const previous = this.#rateLimitedInInterval;
      const shouldBeRateLimited = !this.#isIntervalIgnored && this.#intervalCount >= this.#intervalCap && this.#queue.size > 0;
      if (shouldBeRateLimited !== previous) {
        this.#rateLimitedInInterval = shouldBeRateLimited;
        this.emit(shouldBeRateLimited ? "rateLimit" : "rateLimitCleared");
      }
    }
    /**
    Whether the queue is currently rate-limited due to intervalCap.
    */
    get isRateLimited() {
      return this.#rateLimitedInInterval;
    }
    /**
        Whether the queue is saturated. Returns `true` when:
        - All concurrency slots are occupied and tasks are waiting, OR
        - The queue is rate-limited and tasks are waiting
    
        Useful for detecting backpressure and potential hanging tasks.
    
        ```js
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 2});
    
        // Backpressure handling
        if (queue.isSaturated) {
            console.log('Queue is saturated, waiting for capacity...');
            await queue.onSizeLessThan(queue.concurrency);
        }
    
        // Monitoring for stuck tasks
        setInterval(() => {
            if (queue.isSaturated) {
                console.warn(`Queue saturated: ${queue.pending} running, ${queue.size} waiting`);
            }
        }, 60000);
        ```
        */
    get isSaturated() {
      return this.#pending === this.#concurrency && this.#queue.size > 0 || this.isRateLimited && this.#queue.size > 0;
    }
    /**
        The tasks currently being executed. Each task includes its `id`, `priority`, `startTime`, and `timeout` (if set).
    
        Returns an array of task info objects.
    
        ```js
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 2});
    
        // Add tasks with IDs for better debugging
        queue.add(() => fetchUser(123), {id: 'user-123'});
        queue.add(() => fetchPosts(456), {id: 'posts-456', priority: 1});
    
        // Check what's running
        console.log(queue.runningTasks);
        // => [{
        //   id: 'user-123',
        //   priority: 0,
        //   startTime: 1759253001716,
        //   timeout: undefined
        // }, {
        //   id: 'posts-456',
        //   priority: 1,
        //   startTime: 1759253001916,
        //   timeout: undefined
        // }]
        ```
        */
    get runningTasks() {
      return [...this.#runningTasks.values()].map((task) => ({ ...task }));
    }
  };

  // node_modules/@multiformats/dns/dist/src/utils/get-types.js
  function getTypes(types2) {
    const DEFAULT_TYPES = [
      RecordType.A
    ];
    if (types2 == null) {
      return DEFAULT_TYPES;
    }
    if (Array.isArray(types2)) {
      if (types2.length === 0) {
        return DEFAULT_TYPES;
      }
      return types2;
    }
    return [
      types2
    ];
  }

  // node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
  var DEFAULT_TTL = 60;
  function toDNSResponse(obj) {
    return {
      Status: obj.Status ?? 0,
      TC: obj.TC ?? obj.flag_tc ?? false,
      RD: obj.RD ?? obj.flag_rd ?? false,
      RA: obj.RA ?? obj.flag_ra ?? false,
      AD: obj.AD ?? obj.flag_ad ?? false,
      CD: obj.CD ?? obj.flag_cd ?? false,
      Question: (obj.Question ?? obj.questions ?? []).map((question) => {
        return {
          name: question.name,
          type: RecordType[question.type]
        };
      }),
      Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
        return {
          name: answer.name,
          type: RecordType[answer.type],
          TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
          data: answer.data instanceof Uint8Array ? toString2(answer.data) : answer.data
        };
      })
    };
  }

  // node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
  var DEFAULT_QUERY_CONCURRENCY = 4;
  function dnsJsonOverHttps(url, init = {}) {
    const httpQueue = new PQueue({
      concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
    });
    return async (fqdn, options2 = {}) => {
      const searchParams = new URLSearchParams();
      searchParams.set("name", fqdn);
      getTypes(options2.types).forEach((type) => {
        searchParams.append("type", RecordType[type]);
      });
      options2.onProgress?.(new CustomProgressEvent("dns:query", fqdn));
      const response = await httpQueue.add(async () => {
        const res = await fetch(`${url}?${searchParams}`, {
          headers: {
            accept: "application/dns-json"
          },
          signal: options2?.signal
        });
        if (res.status !== 200) {
          throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
        }
        const response2 = toDNSResponse(await res.json());
        options2.onProgress?.(new CustomProgressEvent("dns:response", response2));
        return response2;
      }, {
        signal: options2.signal
      });
      if (response == null) {
        throw new Error("No DNS response received");
      }
      return response;
    };
  }

  // node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
  function defaultResolver() {
    return [
      dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
      dnsJsonOverHttps("https://dns.google/resolve")
    ];
  }

  // node_modules/@multiformats/dns/dist/src/utils/cache.js
  var import_hashlru = __toESM(require_hashlru(), 1);
  var CachedAnswers = class {
    lru;
    constructor(maxSize) {
      this.lru = (0, import_hashlru.default)(maxSize);
    }
    get(fqdn, types2) {
      let foundAllAnswers = true;
      const answers = [];
      for (const type of types2) {
        const cached = this.getAnswers(fqdn, type);
        if (cached.length === 0) {
          foundAllAnswers = false;
          break;
        }
        answers.push(...cached);
      }
      if (foundAllAnswers) {
        return toDNSResponse({ answers });
      }
    }
    getAnswers(domain, type) {
      const key = `${domain.toLowerCase()}-${type}`;
      const answers = this.lru.get(key);
      if (answers != null) {
        const cachedAnswers = answers.filter((entry) => {
          return entry.expires > Date.now();
        }).map(({ expires, value: value2 }) => ({
          ...value2,
          TTL: Math.round((expires - Date.now()) / 1e3),
          type: RecordType[value2.type]
        }));
        if (cachedAnswers.length === 0) {
          this.lru.remove(key);
        }
        return cachedAnswers;
      }
      return [];
    }
    add(domain, answer) {
      const key = `${domain.toLowerCase()}-${answer.type}`;
      const answers = this.lru.get(key) ?? [];
      answers.push({
        expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
        value: answer
      });
      this.lru.set(key, answers);
    }
    remove(domain, type) {
      const key = `${domain.toLowerCase()}-${type}`;
      this.lru.remove(key);
    }
    clear() {
      this.lru.clear();
    }
  };
  function cache2(size) {
    return new CachedAnswers(size);
  }

  // node_modules/@multiformats/dns/dist/src/dns.js
  var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
  var DNS = class {
    resolvers;
    cache;
    constructor(init) {
      this.resolvers = {};
      this.cache = cache2(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
      Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
        if (!Array.isArray(resolver)) {
          resolver = [resolver];
        }
        if (!tld.endsWith(".")) {
          tld = `${tld}.`;
        }
        this.resolvers[tld] = resolver;
      });
      if (this.resolvers["."] == null) {
        this.resolvers["."] = defaultResolver();
      }
    }
    /**
     * Queries DNS resolvers for the passed record types for the passed domain.
     *
     * If cached records exist for all desired types they will be returned
     * instead.
     *
     * Any new responses will be added to the cache for subsequent requests.
     */
    async query(domain, options2 = {}) {
      const types2 = getTypes(options2.types);
      const cached = options2.cached !== false ? this.cache.get(domain, types2) : void 0;
      if (cached != null) {
        options2.onProgress?.(new CustomProgressEvent("dns:cache", cached));
        return cached;
      }
      const tld = `${domain.split(".").pop()}.`;
      const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
        return Math.random() > 0.5 ? -1 : 1;
      });
      const errors = [];
      for (const resolver of resolvers2) {
        if (options2.signal?.aborted === true) {
          break;
        }
        try {
          const result = await resolver(domain, {
            ...options2,
            types: types2
          });
          for (const answer of result.Answer) {
            this.cache.add(domain, answer);
          }
          return result;
        } catch (err2) {
          errors.push(err2);
          options2.onProgress?.(new CustomProgressEvent("dns:error", err2));
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      }
      throw new AggregateError(errors, `DNS lookup of ${domain} ${types2} failed`);
    }
  };

  // node_modules/@multiformats/dns/dist/src/index.js
  var RecordType;
  (function(RecordType2) {
    RecordType2[RecordType2["A"] = 1] = "A";
    RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
    RecordType2[RecordType2["TXT"] = 16] = "TXT";
    RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
  })(RecordType || (RecordType = {}));
  var MAX_RECURSIVE_DEPTH = 32;
  function dns(init = {}) {
    return new DNS(init);
  }

  // node_modules/interface-datastore/dist/src/key.js
  var pathSepS = "/";
  var pathSepB = new TextEncoder().encode(pathSepS);
  var pathSep = pathSepB[0];
  var Key = class _Key {
    _buf;
    /**
     * @param {string | Uint8Array} s
     * @param {boolean} [clean]
     */
    constructor(s2, clean3) {
      if (typeof s2 === "string") {
        this._buf = fromString2(s2);
      } else if (s2 instanceof Uint8Array) {
        this._buf = s2;
      } else {
        throw new Error("Invalid key, should be String of Uint8Array");
      }
      if (clean3 == null) {
        clean3 = true;
      }
      if (clean3) {
        this.clean();
      }
      if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
        throw new Error("Invalid key");
      }
    }
    /**
     * Convert to the string representation
     *
     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding] - The encoding to use.
     * @returns {string}
     */
    toString(encoding = "utf8") {
      return toString2(this._buf, encoding);
    }
    /**
     * Return the Uint8Array representation of the key
     *
     * @returns {Uint8Array}
     */
    uint8Array() {
      return this._buf;
    }
    /**
     * Return string representation of the key
     *
     * @returns {string}
     */
    get [Symbol.toStringTag]() {
      return `Key(${this.toString()})`;
    }
    /**
     * Constructs a key out of a namespace array.
     *
     * @param {Array<string>} list - The array of namespaces
     * @returns {Key}
     *
     * @example
     * ```js
     * Key.withNamespaces(['one', 'two'])
     * // => Key('/one/two')
     * ```
     */
    static withNamespaces(list) {
      return new _Key(list.join(pathSepS));
    }
    /**
     * Returns a randomly (uuid) generated key.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * Key.random()
     * // => Key('/344502982398')
     * ```
     */
    static random() {
      return new _Key(Math.random().toString().substring(2));
    }
    /**
     * @param {*} other
     */
    static asKey(other) {
      if (other instanceof Uint8Array || typeof other === "string") {
        return new _Key(other);
      }
      if (typeof other.uint8Array === "function") {
        return new _Key(other.uint8Array());
      }
      return null;
    }
    /**
     * Cleanup the current key
     *
     * @returns {void}
     */
    clean() {
      if (this._buf == null || this._buf.byteLength === 0) {
        this._buf = pathSepB;
      }
      if (this._buf[0] !== pathSep) {
        const bytes = new Uint8Array(this._buf.byteLength + 1);
        bytes.fill(pathSep, 0, 1);
        bytes.set(this._buf, 1);
        this._buf = bytes;
      }
      while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
        this._buf = this._buf.subarray(0, -1);
      }
    }
    /**
     * Check if the given key is sorted lower than ourself.
     *
     * @param {Key} key - The other Key to check against
     * @returns {boolean}
     */
    less(key) {
      const list1 = this.list();
      const list2 = key.list();
      for (let i2 = 0; i2 < list1.length; i2++) {
        if (list2.length < i2 + 1) {
          return false;
        }
        const c1 = list1[i2];
        const c2 = list2[i2];
        if (c1 < c2) {
          return true;
        } else if (c1 > c2) {
          return false;
        }
      }
      return list1.length < list2.length;
    }
    /**
     * Returns the key with all parts in reversed order.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
     * ```
     */
    reverse() {
      return _Key.withNamespaces(this.list().slice().reverse());
    }
    /**
     * Returns the `namespaces` making up this Key.
     *
     * @returns {Array<string>}
     */
    namespaces() {
      return this.list();
    }
    /**
     * Returns the "base" namespace of this key.
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
     * // => 'Actor:JohnCleese'
     * ```
     */
    baseNamespace() {
      const ns = this.namespaces();
      return ns[ns.length - 1];
    }
    /**
     * Returns the `list` representation of this key.
     *
     * @returns {Array<string>}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
     * ```
     */
    list() {
      return this.toString().split(pathSepS).slice(1);
    }
    /**
     * Returns the "type" of this key (value of last namespace).
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
     * // => 'Actor'
     * ```
     */
    type() {
      return namespaceType(this.baseNamespace());
    }
    /**
     * Returns the "name" of this key (field of last namespace).
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
     * // => 'JohnCleese'
     * ```
     */
    name() {
      return namespaceValue(this.baseNamespace());
    }
    /**
     * Returns an "instance" of this type key (appends value to namespace).
     *
     * @param {string} s - The string to append.
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
     * ```
     */
    instance(s2) {
      return new _Key(this.toString() + ":" + s2);
    }
    /**
     * Returns the "path" of this key (parent + type).
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
     * // => Key('/Comedy/MontyPython/Actor')
     * ```
     */
    path() {
      let p2 = this.parent().toString();
      if (!p2.endsWith(pathSepS)) {
        p2 += pathSepS;
      }
      p2 += this.type();
      return new _Key(p2);
    }
    /**
     * Returns the `parent` Key of this Key.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
     * // => Key("/Comedy/MontyPython")
     * ```
     */
    parent() {
      const list = this.list();
      if (list.length === 1) {
        return new _Key(pathSepS);
      }
      return new _Key(list.slice(0, -1).join(pathSepS));
    }
    /**
     * Returns the `child` Key of this Key.
     *
     * @param {Key} key - The child Key to add
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
     * ```
     */
    child(key) {
      if (this.toString() === pathSepS) {
        return key;
      } else if (key.toString() === pathSepS) {
        return this;
      }
      return new _Key(this.toString() + key.toString(), false);
    }
    /**
     * Returns whether this key is a prefix of `other`
     *
     * @param {Key} other - The other key to test against
     * @returns {boolean}
     *
     * @example
     * ```js
     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
     * // => true
     * ```
     */
    isAncestorOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return other.toString().startsWith(this.toString());
    }
    /**
     * Returns whether this key is a contains another as prefix.
     *
     * @param {Key} other - The other Key to test against
     * @returns {boolean}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
     * // => true
     * ```
     */
    isDecendantOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return this.toString().startsWith(other.toString());
    }
    /**
     * Checks if this key has only one namespace.
     *
     * @returns {boolean}
     */
    isTopLevel() {
      return this.list().length === 1;
    }
    /**
     * Concats one or more Keys into one new Key.
     *
     * @param {Array<Key>} keys - The array of keys to concatenate
     * @returns {Key}
     */
    concat(...keys) {
      return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
    }
  };
  function namespaceType(ns) {
    const parts = ns.split(":");
    if (parts.length < 2) {
      return "";
    }
    return parts.slice(0, -1).join(":");
  }
  function namespaceValue(ns) {
    const parts = ns.split(":");
    return parts[parts.length - 1];
  }
  function flatten(arr) {
    return [].concat(...arr);
  }

  // node_modules/multiformats/dist/src/block.js
  function readonly({ enumerable = true, configurable = false } = {}) {
    return { enumerable, configurable, writable: false };
  }
  function* linksWithin(path, value2) {
    if (value2 != null && typeof value2 === "object") {
      if (Array.isArray(value2)) {
        for (const [index, element] of value2.entries()) {
          const elementPath = [...path, index];
          const cid = CID.asCID(element);
          if (cid != null) {
            yield [elementPath.join("/"), cid];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value2);
        if (cid != null) {
          yield [path.join("/"), cid];
        } else {
          yield* links(value2, path);
        }
      }
    }
  }
  function* links(source, base3) {
    if (source == null || source instanceof Uint8Array) {
      return;
    }
    const cid = CID.asCID(source);
    if (cid != null) {
      yield [base3.join("/"), cid];
    }
    for (const [key, value2] of Object.entries(source)) {
      const path = [...base3, key];
      yield* linksWithin(path, value2);
    }
  }
  function* treeWithin(path, value2) {
    if (Array.isArray(value2)) {
      for (const [index, element] of value2.entries()) {
        const elementPath = [...path, index];
        yield elementPath.join("/");
        if (typeof element === "object" && CID.asCID(element) == null) {
          yield* tree(element, elementPath);
        }
      }
    } else {
      yield* tree(value2, path);
    }
  }
  function* tree(source, base3) {
    if (source == null || typeof source !== "object") {
      return;
    }
    for (const [key, value2] of Object.entries(source)) {
      const path = [...base3, key];
      yield path.join("/");
      if (value2 != null && !(value2 instanceof Uint8Array) && typeof value2 === "object" && CID.asCID(value2) == null) {
        yield* treeWithin(path, value2);
      }
    }
  }
  function get(source, path) {
    let node = source;
    for (const [index, key] of path.entries()) {
      node = node[key];
      if (node == null) {
        throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
      }
      const cid = CID.asCID(node);
      if (cid != null) {
        return { value: cid, remaining: path.slice(index + 1).join("/") };
      }
    }
    return { value: node };
  }
  var Block2 = class {
    cid;
    bytes;
    value;
    asBlock;
    constructor({ cid, bytes, value: value2 }) {
      if (cid == null || bytes == null || typeof value2 === "undefined") {
        throw new Error("Missing required argument");
      }
      this.cid = cid;
      this.bytes = bytes;
      this.value = value2;
      this.asBlock = this;
      Object.defineProperties(this, {
        cid: readonly(),
        bytes: readonly(),
        value: readonly(),
        asBlock: readonly()
      });
    }
    links() {
      return links(this.value, []);
    }
    tree() {
      return tree(this.value, []);
    }
    get(path = "/") {
      return get(this.value, path.split("/").filter(Boolean));
    }
  };
  function createUnsafe({ bytes, cid, value: maybeValue, codec }) {
    const value2 = maybeValue !== void 0 ? maybeValue : codec?.decode(bytes);
    if (value2 === void 0) {
      throw new Error('Missing required argument, must either provide "value" or "codec"');
    }
    return new Block2({
      cid,
      bytes,
      value: value2
    });
  }

  // node_modules/@helia/utils/dist/src/errors.js
  var AlreadyPinnedError = class extends Error {
    static name = "AlreadyPinnedError";
    name = "AlreadyPinnedError";
  };
  var BlockPinnedError = class extends Error {
    static name = "BlockPinnedError";
    name = "BlockPinnedError";
  };
  var InvalidDatastoreVersionError = class extends Error {
    static name = "InvalidDatastoreVersionError";
    name = "InvalidDatastoreVersionError";
  };
  var InvalidConfigurationError = class extends Error {
    static name = "InvalidConfigurationError";
    name = "InvalidConfigurationError";
  };

  // node_modules/@helia/utils/dist/src/pins.js
  var DATASTORE_PIN_PREFIX = "/pin/";
  var DATASTORE_BLOCK_PREFIX = "/pinned-block/";
  var DATASTORE_ENCODING = base36;
  var DAG_WALK_QUEUE_CONCURRENCY = 1;
  function toDSKey(cid) {
    if (cid.version === 0) {
      cid = cid.toV1();
    }
    return new Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);
  }
  var PinsImpl = class {
    datastore;
    blockstore;
    getCodec;
    constructor(datastore, blockstore, getCodec2) {
      this.datastore = datastore;
      this.blockstore = blockstore;
      this.getCodec = getCodec2;
    }
    async *add(cid, options2 = {}) {
      const pinKey = toDSKey(cid);
      if (await this.datastore.has(pinKey)) {
        throw new AlreadyPinnedError("Already pinned");
      }
      const depth = Math.round(options2.depth ?? Infinity);
      if (depth < 0) {
        throw new InvalidParametersError("Depth must be greater than or equal to 0");
      }
      const queue = new Queue({
        concurrency: DAG_WALK_QUEUE_CONCURRENCY
      });
      for await (const childCid of this.#walkDag(cid, queue, {
        ...options2,
        depth
      })) {
        await this.#updatePinnedBlock(childCid, (pinnedBlock) => {
          if (pinnedBlock.pinnedBy.find((c2) => equals3(c2, cid.bytes)) != null) {
            return false;
          }
          pinnedBlock.pinCount++;
          pinnedBlock.pinnedBy.push(cid.bytes);
          return true;
        }, options2);
        yield childCid;
      }
      const pin = {
        depth,
        metadata: options2.metadata ?? {}
      };
      await this.datastore.put(pinKey, encode8(pin), options2);
    }
    /**
     * Walk a DAG in an iterable fashion
     */
    async *#walkDag(cid, queue, options2) {
      if (options2.depth === -1) {
        return;
      }
      const codec = await this.getCodec(cid.code);
      const bytes = await src_default7(this.blockstore.get(cid, options2));
      const block = createUnsafe({ bytes, cid, codec });
      yield cid;
      for (const [, cid2] of block.links()) {
        yield* await queue.add(async () => {
          return this.#walkDag(cid2, queue, {
            ...options2,
            depth: options2.depth - 1
          });
        });
      }
    }
    /**
     * Update the pin count for the CID
     */
    async #updatePinnedBlock(cid, withPinnedBlock, options2) {
      const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
      let pinnedBlock = {
        pinCount: 0,
        pinnedBy: []
      };
      try {
        pinnedBlock = decode9(await this.datastore.get(blockKey, options2));
      } catch (err2) {
        if (err2.name !== "NotFoundError") {
          throw err2;
        }
      }
      const shouldContinue = withPinnedBlock(pinnedBlock);
      if (!shouldContinue) {
        return;
      }
      if (pinnedBlock.pinCount === 0) {
        if (await this.datastore.has(blockKey)) {
          await this.datastore.delete(blockKey);
          return;
        }
      }
      await this.datastore.put(blockKey, encode8(pinnedBlock), options2);
      options2.onProgress?.(new CustomProgressEvent("helia:pin:add", cid));
    }
    async *rm(cid, options2 = {}) {
      const pinKey = toDSKey(cid);
      const buf2 = await this.datastore.get(pinKey, options2);
      const pin = decode9(buf2);
      await this.datastore.delete(pinKey, options2);
      const queue = new Queue({
        concurrency: DAG_WALK_QUEUE_CONCURRENCY
      });
      for await (const childCid of this.#walkDag(cid, queue, {
        ...options2,
        depth: pin.depth
      })) {
        await this.#updatePinnedBlock(childCid, (pinnedBlock) => {
          pinnedBlock.pinCount--;
          pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter((c2) => equals3(c2, cid.bytes));
          return true;
        }, {
          ...options2,
          depth: pin.depth
        });
        yield childCid;
      }
    }
    async *ls(options2 = {}) {
      for await (const { key, value: value2 } of this.datastore.query({
        prefix: DATASTORE_PIN_PREFIX + (options2.cid != null ? `${options2.cid.toString(base36)}` : "")
      }, options2)) {
        const cid = CID.parse(key.toString().substring(5), base36);
        const pin = decode9(value2);
        yield {
          cid,
          ...pin
        };
      }
    }
    async isPinned(cid, options2 = {}) {
      const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
      return this.datastore.has(blockKey, options2);
    }
    async get(cid, options2) {
      const pinKey = toDSKey(cid);
      const buf2 = await this.datastore.get(pinKey, options2);
      return decode9(buf2);
    }
    async setMetadata(cid, metadata, options2) {
      const pinKey = toDSKey(cid);
      const buf2 = await this.datastore.get(pinKey, options2);
      const pin = decode9(buf2);
      pin.metadata = metadata ?? {};
      await this.datastore.put(pinKey, encode8(pin), options2);
    }
  };

  // node_modules/@helia/interface/dist/src/blocks.js
  var DEFAULT_SESSION_MIN_PROVIDERS = 1;
  var DEFAULT_SESSION_MAX_PROVIDERS = 5;

  // node_modules/@helia/interface/dist/src/errors.js
  var InsufficientProvidersError = class extends Error {
    static name = "InsufficientProvidersError";
    constructor(message2 = "Insufficient providers found") {
      super(message2);
      this.name = "InsufficientProvidersError";
    }
  };
  var NoRoutersAvailableError = class extends Error {
    static name = "NoRoutersAvailableError";
    constructor(message2 = "No routers available") {
      super(message2);
      this.name = "NoRoutersAvailableError";
    }
  };
  var UnknownHashAlgorithmError = class extends Error {
    static name = "UnknownHashAlgorithmError";
    constructor(message2 = "Unknown hash algorithm") {
      super(message2);
      this.name = "UnknownHashAlgorithmError";
    }
  };
  var UnknownCodecError = class extends Error {
    static name = "UnknownCodecError";
    constructor(message2 = "Unknown codec") {
      super(message2);
      this.name = "UnknownCodecError";
    }
  };

  // node_modules/@helia/utils/dist/src/routing.js
  var DEFAULT_PROVIDER_LOOKUP_CONCURRENCY = 5;
  var Routing = class {
    log;
    routers;
    providerLookupConcurrency;
    constructor(components, init) {
      this.log = components.logger.forComponent("helia:routing");
      this.routers = init.routers ?? [];
      this.providerLookupConcurrency = init.providerLookupConcurrency ?? DEFAULT_PROVIDER_LOOKUP_CONCURRENCY;
      this.findProviders = components.metrics?.traceFunction("helia.routing.findProviders", this.findProviders.bind(this), {
        optionsIndex: 1
      }) ?? this.findProviders;
      this.provide = components.metrics?.traceFunction("helia.routing.provide", this.provide.bind(this), {
        optionsIndex: 1
      }) ?? this.provide;
      this.cancelReprovide = components.metrics?.traceFunction("helia.routing.cancelReprovide", this.cancelReprovide.bind(this), {
        optionsIndex: 1
      }) ?? this.cancelReprovide;
      this.put = components.metrics?.traceFunction("helia.routing.put", this.put.bind(this), {
        optionsIndex: 2
      }) ?? this.put;
      this.get = components.metrics?.traceFunction("helia.routing.get", this.get.bind(this), {
        optionsIndex: 1
      }) ?? this.get;
      this.findPeer = components.metrics?.traceFunction("helia.routing.findPeer", this.findPeer.bind(this), {
        optionsIndex: 1
      }) ?? this.findPeer;
      this.getClosestPeers = components.metrics?.traceFunction("helia.routing.getClosestPeers", this.getClosestPeers.bind(this), {
        optionsIndex: 1
      }) ?? this.getClosestPeers;
    }
    async start() {
      await start(...this.routers);
    }
    async stop() {
      await stop(...this.routers);
    }
    /**
     * Iterates over all content routers in parallel to find providers of the
     * given key
     */
    async *findProviders(key, options2 = {}) {
      if (this.routers.length === 0) {
        throw new NoRoutersAvailableError("No content routers available");
      }
      const queue = new PeerQueue({
        concurrency: this.providerLookupConcurrency
      });
      for await (const peer of src_default(queue.toGenerator(), ...supports(this.routers, "findProviders").map((router) => router.findProviders(key, options2)))) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length === 0) {
          if (queue.find(peer.id) != null) {
            continue;
          }
          queue.add(async () => {
            try {
              const provider = await this.findPeer(peer.id, options2);
              if (provider.multiaddrs.length === 0) {
                return null;
              }
              return {
                ...provider,
                protocols: peer.protocols,
                routing: peer.routing
              };
            } catch (err2) {
              this.log.error("could not load multiaddrs for peer %p - %e", peer.id, err2);
              return null;
            }
          }, {
            peerId: peer.id,
            signal: options2.signal
          }).catch((err2) => {
            this.log.error("could not load multiaddrs for peer %p - %e", peer.id, err2);
          });
          continue;
        }
        yield peer;
      }
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */
    async provide(key, options2 = {}) {
      if (this.routers.length === 0) {
        throw new NoRoutersAvailableError("No content routers available");
      }
      await Promise.all(supports(this.routers, "provide").map(async (router) => {
        await router.provide(key, options2);
      }));
    }
    async cancelReprovide(key, options2 = {}) {
      await Promise.all(supports(this.routers, "cancelReprovide").map(async (router) => {
        await router.cancelReprovide(key, options2);
      }));
    }
    /**
     * Store the given key/value pair in the available content routings
     */
    async put(key, value2, options2) {
      await Promise.all(supports(this.routers, "put").map(async (router) => {
        await router.put(key, value2, options2);
      }));
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */
    async get(key, options2) {
      return Promise.any(supports(this.routers, "get").map(async (router) => {
        return router.get(key, options2);
      }));
    }
    /**
     * Iterates over all peer routers in parallel to find the given peer
     */
    async findPeer(id, options2) {
      if (this.routers.length === 0) {
        throw new NoRoutersAvailableError("No peer routers available");
      }
      const self2 = this;
      const source = src_default(...supports(this.routers, "findPeer").map((router) => (async function* () {
        try {
          yield await router.findPeer(id, options2);
        } catch (err2) {
          self2.log.error(err2);
        }
      })()));
      for await (const peer of source) {
        if (peer == null) {
          continue;
        }
        return peer;
      }
      throw new NotFoundError("Could not find peer in routing");
    }
    /**
     * Attempt to find the closest peers on the network to the given key
     */
    async *getClosestPeers(key, options2 = {}) {
      if (this.routers.length === 0) {
        throw new NoRoutersAvailableError("No peer routers available");
      }
      for await (const peer of src_default(...supports(this.routers, "getClosestPeers").map((router) => router.getClosestPeers(key, options2)))) {
        if (peer == null) {
          continue;
        }
        yield peer;
      }
    }
  };
  function supports(routers, key) {
    return routers.filter((router) => router[key] != null);
  }

  // node_modules/it-queue/dist/src/errors.js
  var QueueFullError2 = class extends Error {
    static name = "QueueFullError";
    constructor(message2 = "The queue was full") {
      super(message2);
      this.name = "QueueFullError";
    }
  };

  // node_modules/it-queue/node_modules/race-signal/dist/src/index.js
  var AbortError6 = class extends Error {
    type;
    code;
    constructor(message2, code8, name9) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.name = name9 ?? "AbortError";
      this.code = code8 ?? "ABORT_ERR";
    }
  };
  async function raceSignal3(promise, signal, opts) {
    if (signal == null) {
      return promise;
    }
    if (signal.aborted) {
      promise.catch(() => {
      });
      return Promise.reject(new AbortError6(opts?.errorMessage, opts?.errorCode, opts?.errorName));
    }
    let listener;
    const error = new AbortError6(opts?.errorMessage, opts?.errorCode, opts?.errorName);
    try {
      return await Promise.race([
        promise,
        new Promise((resolve8, reject) => {
          listener = () => {
            reject(error);
          };
          signal.addEventListener("abort", listener);
        })
      ]);
    } finally {
      if (listener != null) {
        signal.removeEventListener("abort", listener);
      }
    }
  }

  // node_modules/it-queue/dist/src/recipient.js
  var JobRecipient2 = class {
    deferred;
    signal;
    constructor(signal) {
      this.signal = signal;
      this.deferred = Promise.withResolvers();
      this.onAbort = this.onAbort.bind(this);
      this.signal?.addEventListener("abort", this.onAbort);
    }
    onAbort() {
      this.deferred.reject(this.signal?.reason ?? new AbortError5());
    }
    cleanup() {
      this.signal?.removeEventListener("abort", this.onAbort);
    }
  };

  // node_modules/it-queue/dist/src/job.js
  function randomId2() {
    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
  }
  var Job2 = class {
    id;
    fn;
    options;
    recipients;
    status;
    timeline;
    controller;
    constructor(fn, options2) {
      this.id = randomId2();
      this.status = "queued";
      this.fn = fn;
      this.options = options2;
      this.recipients = [];
      this.timeline = {
        created: Date.now()
      };
      this.controller = new AbortController();
      setMaxListeners(Infinity, this.controller.signal);
      this.onAbort = this.onAbort.bind(this);
    }
    abort(err2) {
      this.controller.abort(err2);
    }
    onAbort() {
      const allAborted = this.recipients.reduce((acc, curr) => {
        return acc && curr.signal?.aborted === true;
      }, true);
      if (allAborted) {
        this.controller.abort(new AbortError5());
        this.cleanup();
      }
    }
    async join(options2 = {}) {
      const recipient = new JobRecipient2(options2.signal);
      this.recipients.push(recipient);
      options2.signal?.addEventListener("abort", this.onAbort);
      return recipient.deferred.promise;
    }
    async run() {
      this.status = "running";
      this.timeline.started = Date.now();
      try {
        this.controller.signal.throwIfAborted();
        const result = await raceSignal3(this.fn({
          ...this.options ?? {},
          signal: this.controller.signal
        }), this.controller.signal);
        this.recipients.forEach((recipient) => {
          recipient.deferred.resolve(result);
        });
        this.status = "complete";
      } catch (err2) {
        this.recipients.forEach((recipient) => {
          recipient.deferred.reject(err2);
        });
        this.status = "errored";
      } finally {
        this.timeline.finished = Date.now();
        this.cleanup();
      }
    }
    cleanup() {
      this.recipients.forEach((recipient) => {
        recipient.cleanup();
        recipient.signal?.removeEventListener("abort", this.onAbort);
      });
    }
  };

  // node_modules/it-queue/dist/src/utils.js
  function debounce2(func, wait) {
    let timeout;
    const output = function() {
      const later = function() {
        timeout = void 0;
        void func();
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
    output.start = () => {
    };
    output.stop = () => {
      clearTimeout(timeout);
    };
    return output;
  }

  // node_modules/it-queue/dist/src/index.js
  var Queue2 = class extends TypedEventEmitter {
    concurrency;
    maxSize;
    queue;
    pending;
    sort;
    autoStart;
    constructor(init = {}) {
      super();
      this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
      this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
      this.pending = 0;
      this.autoStart = init.autoStart ?? true;
      this.sort = init.sort;
      this.queue = [];
      this.emitEmpty = debounce2(this.emitEmpty.bind(this), 1);
      this.emitIdle = debounce2(this.emitIdle.bind(this), 1);
    }
    [Symbol.asyncIterator]() {
      return this.toGenerator();
    }
    emitEmpty() {
      if (this.size !== 0) {
        return;
      }
      this.safeDispatchEvent("empty");
    }
    emitIdle() {
      if (this.running !== 0) {
        return;
      }
      this.safeDispatchEvent("idle");
    }
    tryToStartAnother() {
      if (this.size === 0) {
        this.emitEmpty();
        if (this.running === 0) {
          this.emitIdle();
        }
        return false;
      }
      if (this.pending < this.concurrency) {
        let job;
        for (const j of this.queue) {
          if (j.status === "queued") {
            job = j;
            break;
          }
        }
        if (job == null) {
          return false;
        }
        this.safeDispatchEvent("active");
        this.pending++;
        void job.run().finally(() => {
          for (let i2 = 0; i2 < this.queue.length; i2++) {
            if (this.queue[i2] === job) {
              this.queue.splice(i2, 1);
              break;
            }
          }
          this.pending--;
          this.safeDispatchEvent("next");
          if (this.autoStart) {
            this.tryToStartAnother();
          }
        });
        return true;
      }
      return false;
    }
    enqueue(job) {
      this.queue.push(job);
      if (this.sort != null) {
        this.queue.sort(this.sort);
      }
    }
    /**
     * Start the queue. If the `autoStart` parameter passed to the constructor was
     * not `false` this is a no-op
     */
    start() {
      if (this.autoStart !== false) {
        return;
      }
      this.autoStart = true;
      this.tryToStartAnother();
    }
    /**
     * Prevent further jobs from running - call `.start` to start the queue again
     */
    pause() {
      this.autoStart = false;
    }
    /**
     * Adds a sync or async task to the queue. Always returns a promise.
     */
    async add(fn, options2) {
      options2?.signal?.throwIfAborted();
      if (this.size === this.maxSize) {
        throw new QueueFullError2();
      }
      const job = new Job2(fn, options2);
      this.enqueue(job);
      this.safeDispatchEvent("add");
      if (this.autoStart) {
        this.tryToStartAnother();
      }
      return job.join(options2).then((result) => {
        this.safeDispatchEvent("success", { detail: { job, result } });
        return result;
      }).catch((err2) => {
        if (job.status === "queued") {
          for (let i2 = 0; i2 < this.queue.length; i2++) {
            if (this.queue[i2] === job) {
              this.queue.splice(i2, 1);
              break;
            }
          }
        }
        this.safeDispatchEvent("failure", { detail: { job, error: err2 } });
        throw err2;
      });
    }
    /**
     * Clear the queue
     */
    clear() {
      this.queue.splice(0, this.queue.length);
    }
    /**
     * Abort all jobs in the queue and clear it
     */
    abort() {
      this.queue.forEach((job) => {
        job.abort(new AbortError5());
      });
      this.clear();
    }
    /**
     * Can be called multiple times. Useful if you for example add additional items at a later time.
     *
     * @returns A promise that settles when the queue becomes empty.
     */
    async onEmpty(options2) {
      if (this.size === 0) {
        return;
      }
      await raceEvent(this, "empty", options2?.signal);
    }
    /**
     * @returns A promise that settles when the queue size is less than the given
     * limit: `queue.size < limit`.
     *
     * If you want to avoid having the queue grow beyond a certain size you can
     * `await queue.onSizeLessThan()` before adding a new item.
     *
     * Note that this only limits the number of items waiting to start. There
     * could still be up to `concurrency` jobs already running that this call does
     * not include in its calculation.
     */
    async onSizeLessThan(limit, options2) {
      if (this.size < limit) {
        return;
      }
      await raceEvent(this, "next", options2?.signal, {
        filter: () => this.size < limit
      });
    }
    /**
     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
     * from the queue has finished. `.onEmpty` merely signals that the queue is
     * empty, but it could mean that some promises haven't completed yet.
     *
     * @returns A promise that settles when the queue becomes empty, and all
     * promises have completed; `queue.size === 0 && queue.pending === 0`.
     */
    async onIdle(options2) {
      if (this.pending === 0 && this.size === 0) {
        return;
      }
      await raceEvent(this, "idle", options2?.signal);
    }
    /**
     * Size of the queue including running items
     */
    get size() {
      return this.queue.length;
    }
    /**
     * The number of queued items waiting to run.
     */
    get queued() {
      return this.queue.length - this.pending;
    }
    /**
     * The number of items currently running.
     */
    get running() {
      return this.pending;
    }
    /**
     * Returns an async generator that makes it easy to iterate over the results
     * of jobs added to the queue.
     *
     * The generator will end when the queue becomes idle, that is there are no
     * jobs running and no jobs that have yet to run.
     *
     * If you need to keep the queue open indefinitely, consider using it-pushable
     * instead.
     */
    async *toGenerator(options2) {
      options2?.signal?.throwIfAborted();
      const stream = pushable({
        objectMode: true
      });
      const cleanup = (err2) => {
        if (err2 != null) {
          this.abort();
        } else {
          this.clear();
        }
        stream.end(err2);
      };
      const onQueueJobComplete = (evt) => {
        if (evt.detail != null) {
          stream.push(evt.detail.result);
        }
      };
      const onQueueError = (evt) => {
        cleanup(evt.detail.error);
      };
      const onQueueIdle = () => {
        cleanup();
      };
      const onSignalAbort = () => {
        cleanup(new AbortError5("Queue aborted"));
      };
      this.addEventListener("success", onQueueJobComplete);
      this.addEventListener("failure", onQueueError);
      this.addEventListener("idle", onQueueIdle);
      options2?.signal?.addEventListener("abort", onSignalAbort);
      try {
        yield* stream;
      } finally {
        this.removeEventListener("success", onQueueJobComplete);
        this.removeEventListener("failure", onQueueError);
        this.removeEventListener("idle", onQueueIdle);
        options2?.signal?.removeEventListener("abort", onSignalAbort);
        cleanup();
      }
    }
  };

  // node_modules/mortice/dist/src/constants.js
  var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
  var WORKER_ABORT_READ_LOCK_REQUEST = "lock:worker:abort-read-request";
  var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
  var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
  var MASTER_READ_LOCK_ERROR = "lock:master:error-read";
  var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
  var WORKER_ABORT_WRITE_LOCK_REQUEST = "lock:worker:abort-write-request";
  var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
  var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
  var MASTER_WRITE_LOCK_ERROR = "lock:master:error-write";
  var WORKER_FINALIZE = "lock:worker:finalize";
  var BROADCAST_CHANNEL_NAME = "mortice";
  var defaultOptions = {
    singleProcess: false
  };

  // node_modules/mortice/dist/src/main/channel.js
  var handleChannelWorkerLockRequest = (emitter, channel, masterEvent, abortMasterEvent, requestType, abortType, errorType, releaseType, grantType) => {
    return (event) => {
      if (event.data == null) {
        return;
      }
      const requestEvent = {
        type: event.data.type,
        name: event.data.name,
        identifier: event.data.identifier
      };
      if (requestEvent.type === requestType) {
        emitter.safeDispatchEvent(masterEvent, {
          detail: {
            name: requestEvent.name,
            identifier: requestEvent.identifier,
            handler: async () => {
              channel.postMessage({
                type: grantType,
                name: requestEvent.name,
                identifier: requestEvent.identifier
              });
              await new Promise((resolve8) => {
                const releaseEventListener = (event2) => {
                  if (event2?.data == null) {
                    return;
                  }
                  const releaseEvent = {
                    type: event2.data.type,
                    name: event2.data.name,
                    identifier: event2.data.identifier
                  };
                  if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                    channel.removeEventListener("message", releaseEventListener);
                    resolve8();
                  }
                };
                channel.addEventListener("message", releaseEventListener);
              });
            },
            onError: (err2) => {
              channel.postMessage({
                type: errorType,
                name: requestEvent.name,
                identifier: requestEvent.identifier,
                error: {
                  message: err2.message,
                  name: err2.name,
                  stack: err2.stack
                }
              });
            }
          }
        });
      }
      if (requestEvent.type === abortType) {
        emitter.safeDispatchEvent(abortMasterEvent, {
          detail: {
            name: requestEvent.name,
            identifier: requestEvent.identifier
          }
        });
      }
      if (requestEvent.type === WORKER_FINALIZE) {
        emitter.safeDispatchEvent("finalizeRequest", {
          detail: {
            name: requestEvent.name
          }
        });
      }
    };
  };

  // node_modules/mortice/dist/src/utils.js
  var nanoid = (size = 10) => {
    return Math.random().toString().substring(2, size + 2);
  };

  // node_modules/mortice/dist/src/workers/channel.js
  var MorticeChannelWorker = class {
    name;
    channel;
    constructor(name9) {
      this.name = name9;
      this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    }
    readLock(options2) {
      return this.sendRequest(WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, options2);
    }
    writeLock(options2) {
      return this.sendRequest(WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, options2);
    }
    finalize() {
      this.channel.postMessage({
        type: WORKER_FINALIZE,
        name: this.name
      });
      this.channel.close();
    }
    async sendRequest(requestType, abortType, grantType, errorType, releaseType, options2) {
      options2?.signal?.throwIfAborted();
      const id = nanoid();
      this.channel.postMessage({
        type: requestType,
        identifier: id,
        name: this.name
      });
      return new Promise((resolve8, reject) => {
        const abortListener = () => {
          this.channel.postMessage({
            type: abortType,
            identifier: id,
            name: this.name
          });
        };
        options2?.signal?.addEventListener("abort", abortListener, {
          once: true
        });
        const listener = (event) => {
          if (event.data?.identifier !== id) {
            return;
          }
          if (event.data?.type === grantType) {
            this.channel.removeEventListener("message", listener);
            options2?.signal?.removeEventListener("abort", abortListener);
            resolve8(() => {
              this.channel.postMessage({
                type: releaseType,
                identifier: id,
                name: this.name
              });
            });
          }
          if (event.data.type === errorType) {
            this.channel.removeEventListener("message", listener);
            options2?.signal?.removeEventListener("abort", abortListener);
            const err2 = new Error();
            if (event.data.error != null) {
              err2.message = event.data.error.message;
              err2.name = event.data.error.name;
              err2.stack = event.data.error.stack;
            }
            reject(err2);
          }
        };
        this.channel.addEventListener("message", listener);
      });
    }
  };

  // node_modules/mortice/dist/src/browser.js
  var browser_default2 = (options2) => {
    options2 = Object.assign({}, defaultOptions, options2);
    const isPrimary = Boolean(globalThis.document) || options2.singleProcess;
    if (isPrimary) {
      const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
      const emitter = new TypedEventEmitter();
      channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestReadLock", "abortReadLockRequest", WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
      channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestWriteLock", "abortWriteLockRequest", WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
      return emitter;
    }
    return new MorticeChannelWorker(options2.name);
  };

  // node_modules/mortice/dist/src/mortice.js
  var mutexes = /* @__PURE__ */ new Map();
  var implementation;
  function isMortice(obj) {
    return typeof obj?.readLock === "function" && typeof obj?.writeLock === "function";
  }
  function getImplementation(opts) {
    if (implementation == null) {
      implementation = browser_default2(opts);
      if (!isMortice(implementation)) {
        const emitter = implementation;
        emitter.addEventListener("requestReadLock", (event) => {
          const mutexName = event.detail.name;
          const identifier = event.detail.identifier;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          const abortController = new AbortController();
          const abortListener = (event2) => {
            if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
              return;
            }
            abortController.abort();
          };
          emitter.addEventListener("abortReadLockRequest", abortListener);
          void mutex.readLock({
            signal: abortController.signal
          }).then(async (release) => {
            await event.detail.handler().finally(() => {
              release();
            });
          }).catch((err2) => {
            event.detail.onError(err2);
          }).finally(() => {
            emitter.removeEventListener("abortReadLockRequest", abortListener);
          });
        });
        emitter.addEventListener("requestWriteLock", (event) => {
          const mutexName = event.detail.name;
          const identifier = event.detail.identifier;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          const abortController = new AbortController();
          const abortListener = (event2) => {
            if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
              return;
            }
            abortController.abort();
          };
          emitter.addEventListener("abortWriteLockRequest", abortListener);
          void mutex.writeLock({
            signal: abortController.signal
          }).then(async (release) => {
            await event.detail.handler().finally(() => {
              release();
            });
          }).catch((err2) => {
            event.detail.onError(err2);
          }).finally(() => {
            emitter.removeEventListener("abortWriteLockRequest", abortListener);
          });
        });
        emitter.addEventListener("finalizeRequest", (event) => {
          const mutexName = event.detail.name;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          mutex.finalize();
        });
      }
    }
    return implementation;
  }
  async function createReleasable(queue, options2) {
    let res;
    let rej;
    const p2 = new Promise((resolve8, reject) => {
      res = resolve8;
      rej = reject;
    });
    const listener = () => {
      rej(new AbortError5());
    };
    options2?.signal?.addEventListener("abort", listener, {
      once: true
    });
    queue.add(async () => {
      await new Promise((resolve8) => {
        res(() => {
          options2?.signal?.removeEventListener("abort", listener);
          resolve8();
        });
      });
    }, {
      signal: options2?.signal
    }).catch((err2) => {
      rej(err2);
    });
    return p2;
  }
  var createMutex = (name9, options2) => {
    let mutex = mutexes.get(name9);
    if (mutex != null) {
      return mutex;
    }
    const implementation2 = getImplementation(options2);
    if (isMortice(implementation2)) {
      mutex = implementation2;
      mutexes.set(name9, mutex);
      return mutex;
    }
    const masterQueue = new Queue2({
      concurrency: 1
    });
    let readQueue;
    mutex = {
      async readLock(opts) {
        if (readQueue != null) {
          return createReleasable(readQueue, opts);
        }
        readQueue = new Queue2({
          concurrency: options2.concurrency,
          autoStart: false
        });
        const localReadQueue = readQueue;
        const readPromise = createReleasable(readQueue, opts);
        void masterQueue.add(async () => {
          localReadQueue.start();
          await localReadQueue.onIdle().then(() => {
            if (readQueue === localReadQueue) {
              readQueue = null;
            }
          });
        });
        return readPromise;
      },
      async writeLock(opts) {
        readQueue = null;
        return createReleasable(masterQueue, opts);
      },
      finalize: () => {
        mutexes.delete(name9);
      },
      queue: masterQueue
    };
    mutexes.set(name9, mutex);
    if (options2.autoFinalize === true) {
      masterQueue.addEventListener("idle", () => {
        mutex.finalize();
      }, {
        once: true
      });
    }
    return mutex;
  };

  // node_modules/mortice/dist/src/index.js
  var defaultOptions2 = {
    name: "lock",
    concurrency: Infinity,
    singleProcess: false,
    autoFinalize: false
  };
  function createMortice(options2) {
    const opts = Object.assign({}, defaultOptions2, options2);
    return createMutex(opts.name, opts);
  }

  // node_modules/@helia/utils/dist/src/storage.js
  var BlockStorage = class {
    lock;
    child;
    pins;
    started;
    /**
     * Create a new BlockStorage
     */
    constructor(blockstore, pins, options2 = {}) {
      this.child = blockstore;
      this.pins = pins;
      this.lock = createMortice({
        singleProcess: options2.holdGcLock
      });
      this.started = false;
    }
    isStarted() {
      return this.started;
    }
    async start() {
      await start(this.child);
      this.started = true;
    }
    async stop() {
      await stop(this.child);
      this.started = false;
    }
    unwrap() {
      return this.child;
    }
    /**
     * Put a block to the underlying datastore
     */
    async put(cid, block, options2 = {}) {
      options2?.signal?.throwIfAborted();
      const releaseLock = await this.lock.readLock();
      try {
        return await this.child.put(cid, block, options2);
      } finally {
        releaseLock();
      }
    }
    /**
     * Put a multiple blocks to the underlying datastore
     */
    async *putMany(blocks, options2 = {}) {
      options2?.signal?.throwIfAborted();
      const releaseLock = await this.lock.readLock();
      try {
        yield* this.child.putMany(blocks, options2);
      } finally {
        releaseLock();
      }
    }
    /**
     * Get a block by cid
     */
    async *get(cid, options2 = {}) {
      options2?.signal?.throwIfAborted();
      const releaseLock = await this.lock.readLock();
      try {
        yield* this.child.get(cid, options2);
      } finally {
        releaseLock();
      }
    }
    /**
     * Get multiple blocks back from an (async) iterable of cids
     */
    async *getMany(cids, options2 = {}) {
      options2?.signal?.throwIfAborted();
      const releaseLock = await this.lock.readLock();
      try {
        yield* this.child.getMany(cids, options2);
      } finally {
        releaseLock();
      }
    }
    /**
     * Delete a block from the blockstore
     */
    async delete(cid, options2 = {}) {
      options2?.signal?.throwIfAborted();
      const releaseLock = await this.lock.writeLock();
      try {
        if (await this.pins.isPinned(cid)) {
          throw new BlockPinnedError("Block was pinned - please unpin and try again");
        }
        await this.child.delete(cid, options2);
      } finally {
        releaseLock();
      }
    }
    /**
     * Delete multiple blocks from the blockstore
     */
    async *deleteMany(cids, options2 = {}) {
      options2?.signal?.throwIfAborted();
      const releaseLock = await this.lock.writeLock();
      try {
        const storage2 = this;
        yield* this.child.deleteMany((async function* () {
          for await (const cid of cids) {
            if (await storage2.pins.isPinned(cid)) {
              throw new BlockPinnedError("Block was pinned - please unpin and try again");
            }
            yield cid;
          }
        })(), options2);
      } finally {
        releaseLock();
      }
    }
    async has(cid, options2 = {}) {
      options2?.signal?.throwIfAborted();
      const releaseLock = await this.lock.readLock();
      try {
        return await this.child.has(cid, options2);
      } finally {
        releaseLock();
      }
    }
    async *getAll(options2 = {}) {
      options2?.signal?.throwIfAborted();
      const releaseLock = await this.lock.readLock();
      try {
        yield* this.child.getAll(options2);
      } finally {
        releaseLock();
      }
    }
    createSession(root, options2) {
      options2?.signal?.throwIfAborted();
      return this.child.createSession(root, options2);
    }
  };

  // node_modules/@helia/utils/dist/src/utils/datastore-version.js
  var DS_VERSION_KEY = new Key("/version");
  var CURRENT_VERSION = 1;
  async function assertDatastoreVersionIsCurrent(datastore) {
    if (!await datastore.has(DS_VERSION_KEY)) {
      await datastore.put(DS_VERSION_KEY, fromString2(`${CURRENT_VERSION}`));
      return;
    }
    const buf2 = await datastore.get(DS_VERSION_KEY);
    const str = toString2(buf2);
    const version3 = parseInt(str, 10);
    if (version3 !== CURRENT_VERSION) {
      throw new InvalidDatastoreVersionError("Invalid datastore version, a datastore migration may be required");
    }
  }

  // node_modules/@ipld/dag-cbor/src/index.js
  var src_exports3 = {};
  __export(src_exports3, {
    code: () => code4,
    decode: () => decode11,
    decodeOptions: () => decodeOptions,
    encode: () => encode10,
    encodeOptions: () => encodeOptions,
    name: () => name4,
    toByteView: () => toByteView
  });
  var CID_CBOR_TAG = 42;
  function toByteView(buf2) {
    if (buf2 instanceof ArrayBuffer) {
      return new Uint8Array(buf2, 0, buf2.byteLength);
    }
    return buf2;
  }
  function cidEncoder(obj) {
    if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
      return null;
    }
    const cid = CID.asCID(obj);
    if (!cid) {
      return null;
    }
    const bytes = new Uint8Array(cid.bytes.byteLength + 1);
    bytes.set(cid.bytes, 1);
    return [
      new Token(Type.tag, CID_CBOR_TAG),
      new Token(Type.bytes, bytes)
    ];
  }
  function undefinedEncoder() {
    throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
  }
  function numberEncoder(num) {
    if (Number.isNaN(num)) {
      throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
    }
    if (num === Infinity || num === -Infinity) {
      throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
    }
    return null;
  }
  function mapEncoder(map2) {
    for (const key of map2.keys()) {
      if (typeof key !== "string" || key.length === 0) {
        throw new Error("Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded");
      }
    }
    return null;
  }
  var _encodeOptions = {
    float64: true,
    typeEncoders: {
      Map: mapEncoder,
      Object: cidEncoder,
      undefined: undefinedEncoder,
      number: numberEncoder
    }
  };
  var encodeOptions = {
    ..._encodeOptions,
    typeEncoders: {
      ..._encodeOptions.typeEncoders
    }
  };
  function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
      throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
    }
    return CID.decode(bytes.subarray(1));
  }
  var _decodeOptions = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // this will lead to BigInt for ints outside of
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */
    tags: []
  };
  _decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
  var decodeOptions = {
    ..._decodeOptions,
    tags: _decodeOptions.tags.slice()
  };
  var name4 = "dag-cbor";
  var code4 = 113;
  var encode10 = (node) => encode8(node, _encodeOptions);
  var decode11 = (data) => decode9(toByteView(data), _decodeOptions);

  // node_modules/@ipld/dag-json/src/index.js
  var src_exports4 = {};
  __export(src_exports4, {
    code: () => code5,
    decode: () => decode13,
    encode: () => encode12,
    format: () => format2,
    name: () => name5,
    parse: () => parse,
    stringify: () => format2
  });

  // node_modules/cborg/lib/json/encode.js
  var JSONEncoder = class extends Array {
    constructor() {
      super();
      this.inRecursive = [];
    }
    /**
     * @param {Bl} buf
     */
    prefix(buf2) {
      const recurs = this.inRecursive[this.inRecursive.length - 1];
      if (recurs) {
        if (recurs.type === Type.array) {
          recurs.elements++;
          if (recurs.elements !== 1) {
            buf2.push([44]);
          }
        }
        if (recurs.type === Type.map) {
          recurs.elements++;
          if (recurs.elements !== 1) {
            if (recurs.elements % 2 === 1) {
              buf2.push([44]);
            } else {
              buf2.push([58]);
            }
          }
        }
      }
    }
    /**
     * @param {Bl} buf
     * @param {Token} token
     */
    [Type.uint.major](buf2, token) {
      this.prefix(buf2);
      const is2 = String(token.value);
      const isa = [];
      for (let i2 = 0; i2 < is2.length; i2++) {
        isa[i2] = is2.charCodeAt(i2);
      }
      buf2.push(isa);
    }
    /**
     * @param {Bl} buf
     * @param {Token} token
     */
    [Type.negint.major](buf2, token) {
      this[Type.uint.major](buf2, token);
    }
    /**
     * @param {Bl} _buf
     * @param {Token} _token
     */
    [Type.bytes.major](_buf, _token) {
      throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
    }
    /**
     * @param {Bl} buf
     * @param {Token} token
     */
    [Type.string.major](buf2, token) {
      this.prefix(buf2);
      const byts = fromString3(JSON.stringify(token.value));
      buf2.push(byts.length > 32 ? asU8A(byts) : byts);
    }
    /**
     * @param {Bl} buf
     * @param {Token} _token
     */
    [Type.array.major](buf2, _token) {
      this.prefix(buf2);
      this.inRecursive.push({ type: Type.array, elements: 0 });
      buf2.push([91]);
    }
    /**
     * @param {Bl} buf
     * @param {Token} _token
     */
    [Type.map.major](buf2, _token) {
      this.prefix(buf2);
      this.inRecursive.push({ type: Type.map, elements: 0 });
      buf2.push([123]);
    }
    /**
     * @param {Bl} _buf
     * @param {Token} _token
     */
    [Type.tag.major](_buf, _token) {
    }
    /**
     * @param {Bl} buf
     * @param {Token} token
     */
    [Type.float.major](buf2, token) {
      if (token.type.name === "break") {
        const recurs = this.inRecursive.pop();
        if (recurs) {
          if (recurs.type === Type.array) {
            buf2.push([93]);
          } else if (recurs.type === Type.map) {
            buf2.push([125]);
          } else {
            throw new Error("Unexpected recursive type; this should not happen!");
          }
          return;
        }
        throw new Error("Unexpected break; this should not happen!");
      }
      if (token.value === void 0) {
        throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
      }
      this.prefix(buf2);
      if (token.type.name === "true") {
        buf2.push([116, 114, 117, 101]);
        return;
      } else if (token.type.name === "false") {
        buf2.push([102, 97, 108, 115, 101]);
        return;
      } else if (token.type.name === "null") {
        buf2.push([110, 117, 108, 108]);
        return;
      }
      const is2 = String(token.value);
      const isa = [];
      let dp = false;
      for (let i2 = 0; i2 < is2.length; i2++) {
        isa[i2] = is2.charCodeAt(i2);
        if (!dp && (isa[i2] === 46 || isa[i2] === 101 || isa[i2] === 69)) {
          dp = true;
        }
      }
      if (!dp) {
        isa.push(46);
        isa.push(48);
      }
      buf2.push(isa);
    }
  };
  function mapSorter2(e1, e2) {
    if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
      throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
    }
    const keyToken1 = e1[0];
    const keyToken2 = e2[0];
    if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
      throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
    }
    if (keyToken1 < keyToken2) {
      return -1;
    }
    if (keyToken1 > keyToken2) {
      return 1;
    }
    throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
  }
  var defaultEncodeOptions2 = { addBreakTokens: true, mapSorter: mapSorter2 };
  function encode11(data, options2) {
    options2 = Object.assign({}, defaultEncodeOptions2, options2);
    return encodeCustom(data, new JSONEncoder(), options2);
  }

  // node_modules/cborg/lib/json/decode.js
  var Tokenizer = class {
    /**
     * @param {Uint8Array} data
     * @param {DecodeOptions} options
     */
    constructor(data, options2 = {}) {
      this._pos = 0;
      this.data = data;
      this.options = options2;
      this.modeStack = ["value"];
      this.lastToken = "";
    }
    pos() {
      return this._pos;
    }
    /**
     * @returns {boolean}
     */
    done() {
      return this._pos >= this.data.length;
    }
    /**
     * @returns {number}
     */
    ch() {
      return this.data[this._pos];
    }
    /**
     * @returns {string}
     */
    currentMode() {
      return this.modeStack[this.modeStack.length - 1];
    }
    skipWhitespace() {
      let c2 = this.ch();
      while (c2 === 32 || c2 === 9 || c2 === 13 || c2 === 10) {
        c2 = this.data[++this._pos];
      }
    }
    /**
     * @param {number[]} str
     */
    expect(str) {
      if (this.data.length - this._pos < str.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`);
      }
      for (let i2 = 0; i2 < str.length; i2++) {
        if (this.data[this._pos++] !== str[i2]) {
          throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
        }
      }
    }
    parseNumber() {
      const startPos = this._pos;
      let negative = false;
      let float = false;
      const swallow = (chars) => {
        while (!this.done()) {
          const ch = this.ch();
          if (chars.includes(ch)) {
            this._pos++;
          } else {
            break;
          }
        }
      };
      if (this.ch() === 45) {
        negative = true;
        this._pos++;
      }
      if (this.ch() === 48) {
        this._pos++;
        if (this.ch() === 46) {
          this._pos++;
          float = true;
        } else {
          return new Token(Type.uint, 0, this._pos - startPos);
        }
      }
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
      if (negative && this._pos === startPos + 1) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
      }
      if (!this.done() && this.ch() === 46) {
        if (float) {
          throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
        }
        float = true;
        this._pos++;
        swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
      }
      if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
        float = true;
        this._pos++;
        if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
          this._pos++;
        }
        swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
      }
      const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
      const num = parseFloat(numStr);
      if (float) {
        return new Token(Type.float, num, this._pos - startPos);
      }
      if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
        return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos);
      }
      return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos);
    }
    /**
     * @returns {Token}
     */
    parseString() {
      if (this.ch() !== 34) {
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`);
      }
      this._pos++;
      for (let i2 = this._pos, l2 = 0; i2 < this.data.length && l2 < 65536; i2++, l2++) {
        const ch = this.data[i2];
        if (ch === 92 || ch < 32 || ch >= 128) {
          break;
        }
        if (ch === 34) {
          const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i2));
          this._pos = i2 + 1;
          return new Token(Type.string, str, l2);
        }
      }
      const startPos = this._pos;
      const chars = [];
      const readu4 = () => {
        if (this._pos + 4 >= this.data.length) {
          throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`);
        }
        let u4 = 0;
        for (let i2 = 0; i2 < 4; i2++) {
          let ch = this.ch();
          if (ch >= 48 && ch <= 57) {
            ch -= 48;
          } else if (ch >= 97 && ch <= 102) {
            ch = ch - 97 + 10;
          } else if (ch >= 65 && ch <= 70) {
            ch = ch - 65 + 10;
          } else {
            throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`);
          }
          u4 = u4 * 16 + ch;
          this._pos++;
        }
        return u4;
      };
      const readUtf8Char = () => {
        const firstByte = this.ch();
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (this._pos + bytesPerSequence > this.data.length) {
          throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`);
        }
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          /* c8 ignore next 6 */
          // this case is dealt with by the caller function
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = this.data[this._pos + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = this.data[this._pos + 1];
            thirdByte = this.data[this._pos + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = this.data[this._pos + 1];
            thirdByte = this.data[this._pos + 2];
            fourthByte = this.data[this._pos + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          chars.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        chars.push(codePoint);
        this._pos += bytesPerSequence;
      };
      while (!this.done()) {
        const ch = this.ch();
        let ch1;
        switch (ch) {
          case 92:
            this._pos++;
            if (this.done()) {
              throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`);
            }
            ch1 = this.ch();
            this._pos++;
            switch (ch1) {
              case 34:
              // '"'
              case 39:
              // '\''
              case 92:
              // '\'
              case 47:
                chars.push(ch1);
                break;
              case 98:
                chars.push(8);
                break;
              case 116:
                chars.push(9);
                break;
              case 110:
                chars.push(10);
                break;
              case 102:
                chars.push(12);
                break;
              case 114:
                chars.push(13);
                break;
              case 117:
                chars.push(readu4());
                break;
              default:
                throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`);
            }
            break;
          case 34:
            this._pos++;
            return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos);
          default:
            if (ch < 32) {
              throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`);
            } else if (ch < 128) {
              chars.push(ch);
              this._pos++;
            } else {
              readUtf8Char();
            }
        }
      }
      throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`);
    }
    /**
     * @returns {Token}
     */
    parseValue() {
      switch (this.ch()) {
        case 123:
          this.modeStack.push("obj-start");
          this._pos++;
          return new Token(Type.map, Infinity, 1);
        case 91:
          this.modeStack.push("array-start");
          this._pos++;
          return new Token(Type.array, Infinity, 1);
        case 34: {
          return this.parseString();
        }
        case 110:
          this.expect([110, 117, 108, 108]);
          return new Token(Type.null, null, 4);
        case 102:
          this.expect([102, 97, 108, 115, 101]);
          return new Token(Type.false, false, 5);
        case 116:
          this.expect([116, 114, 117, 101]);
          return new Token(Type.true, true, 4);
        case 45:
        // '-'
        case 48:
        // '0'
        case 49:
        // '1'
        case 50:
        // '2'
        case 51:
        // '3'
        case 52:
        // '4'
        case 53:
        // '5'
        case 54:
        // '6'
        case 55:
        // '7'
        case 56:
        // '8'
        case 57:
          return this.parseNumber();
        default:
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`);
      }
    }
    /**
     * @returns {Token}
     */
    next() {
      this.skipWhitespace();
      switch (this.currentMode()) {
        case "value":
          this.modeStack.pop();
          return this.parseValue();
        case "array-value": {
          this.modeStack.pop();
          if (this.ch() === 93) {
            this._pos++;
            this.skipWhitespace();
            return new Token(Type.break, void 0, 1);
          }
          if (this.ch() !== 44) {
            throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
          }
          this._pos++;
          this.modeStack.push("array-value");
          this.skipWhitespace();
          return this.parseValue();
        }
        case "array-start": {
          this.modeStack.pop();
          if (this.ch() === 93) {
            this._pos++;
            this.skipWhitespace();
            return new Token(Type.break, void 0, 1);
          }
          this.modeStack.push("array-value");
          this.skipWhitespace();
          return this.parseValue();
        }
        // @ts-ignore
        case "obj-key":
          if (this.ch() === 125) {
            this.modeStack.pop();
            this._pos++;
            this.skipWhitespace();
            return new Token(Type.break, void 0, 1);
          }
          if (this.ch() !== 44) {
            throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
          }
          this._pos++;
          this.skipWhitespace();
        case "obj-start": {
          this.modeStack.pop();
          if (this.ch() === 125) {
            this._pos++;
            this.skipWhitespace();
            return new Token(Type.break, void 0, 1);
          }
          const token = this.parseString();
          this.skipWhitespace();
          if (this.ch() !== 58) {
            throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
          }
          this._pos++;
          this.modeStack.push("obj-value");
          return token;
        }
        case "obj-value": {
          this.modeStack.pop();
          this.modeStack.push("obj-key");
          this.skipWhitespace();
          return this.parseValue();
        }
        /* c8 ignore next 2 */
        default:
          throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`);
      }
    }
  };
  function decode12(data, options2) {
    options2 = Object.assign({ tokenizer: new Tokenizer(data, options2) }, options2);
    return decode9(data, options2);
  }

  // node_modules/@ipld/dag-json/src/index.js
  function toByteView2(buf2) {
    if (buf2 instanceof ArrayBuffer) {
      return new Uint8Array(buf2, 0, buf2.byteLength);
    }
    return buf2;
  }
  function cidEncoder2(obj) {
    if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
      return null;
    }
    const cid = CID.asCID(obj);
    if (!cid) {
      return null;
    }
    const cidString = cid.toString();
    return [
      new Token(Type.map, Infinity, 1),
      new Token(Type.string, "/", 1),
      // key
      new Token(Type.string, cidString, cidString.length),
      // value
      new Token(Type.break, void 0, 1)
    ];
  }
  function bytesEncoder(bytes) {
    const bytesString = base64.encode(bytes).slice(1);
    return [
      new Token(Type.map, Infinity, 1),
      new Token(Type.string, "/", 1),
      // key
      new Token(Type.map, Infinity, 1),
      // value
      new Token(Type.string, "bytes", 5),
      // inner key
      new Token(Type.string, bytesString, bytesString.length),
      // inner value
      new Token(Type.break, void 0, 1),
      new Token(Type.break, void 0, 1)
    ];
  }
  function taBytesEncoder(obj) {
    return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  }
  function abBytesEncoder(ab) {
    return bytesEncoder(new Uint8Array(ab));
  }
  function undefinedEncoder2() {
    throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
  }
  function numberEncoder2(num) {
    if (Number.isNaN(num)) {
      throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
    }
    if (num === Infinity || num === -Infinity) {
      throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
    }
    return null;
  }
  var encodeOptions2 = {
    typeEncoders: {
      Object: cidEncoder2,
      Buffer: bytesEncoder,
      Uint8Array: bytesEncoder,
      Int8Array: taBytesEncoder,
      Uint16Array: taBytesEncoder,
      Int16Array: taBytesEncoder,
      Uint32Array: taBytesEncoder,
      Int32Array: taBytesEncoder,
      Float32Array: taBytesEncoder,
      Float64Array: taBytesEncoder,
      Uint8ClampedArray: taBytesEncoder,
      BigInt64Array: taBytesEncoder,
      BigUint64Array: taBytesEncoder,
      DataView: taBytesEncoder,
      ArrayBuffer: abBytesEncoder,
      undefined: undefinedEncoder2,
      number: numberEncoder2
    }
  };
  var DagJsonTokenizer = class extends Tokenizer {
    /**
     * @param {Uint8Array} data
     * @param {object} [options]
     */
    constructor(data, options2) {
      super(data, options2);
      this.tokenBuffer = [];
    }
    /**
     * @returns {boolean}
     */
    done() {
      return this.tokenBuffer.length === 0 && super.done();
    }
    /**
     * @returns {Token}
     */
    _next() {
      if (this.tokenBuffer.length > 0) {
        return this.tokenBuffer.pop();
      }
      return super.next();
    }
    /**
     * Implements rules outlined in https://github.com/ipld/specs/pull/356
     *
     * @returns {Token}
     */
    next() {
      const token = this._next();
      if (token.type === Type.map) {
        const keyToken = this._next();
        if (keyToken.type === Type.string && keyToken.value === "/") {
          const valueToken = this._next();
          if (valueToken.type === Type.string) {
            const breakToken = this._next();
            if (breakToken.type !== Type.break) {
              throw new Error("Invalid encoded CID form");
            }
            this.tokenBuffer.push(valueToken);
            return new Token(Type.tag, 42, 0);
          }
          if (valueToken.type === Type.map) {
            const innerKeyToken = this._next();
            if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
              const innerValueToken = this._next();
              if (innerValueToken.type === Type.string) {
                for (let i2 = 0; i2 < 2; i2++) {
                  const breakToken = this._next();
                  if (breakToken.type !== Type.break) {
                    throw new Error("Invalid encoded Bytes form");
                  }
                }
                const bytes = base64.decode(`m${innerValueToken.value}`);
                return new Token(Type.bytes, bytes, innerValueToken.value.length);
              }
              this.tokenBuffer.push(innerValueToken);
            }
            this.tokenBuffer.push(innerKeyToken);
          }
          this.tokenBuffer.push(valueToken);
        }
        this.tokenBuffer.push(keyToken);
      }
      return token;
    }
  };
  var decodeOptions2 = {
    allowIndefinite: false,
    allowUndefined: false,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // this will lead to BigInt for ints outside of
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */
    tags: []
  };
  decodeOptions2.tags[42] = CID.parse;
  var name5 = "dag-json";
  var code5 = 297;
  var encode12 = (node) => encode11(node, encodeOptions2);
  var decode13 = (data) => {
    const buf2 = toByteView2(data);
    const options2 = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(buf2, decodeOptions2) });
    return decode12(buf2, options2);
  };
  var format2 = (node) => utf8Decoder.decode(encode12(node));
  var utf8Decoder = new TextDecoder();
  var parse = (data) => decode13(utf8Encoder.encode(data));
  var utf8Encoder = new TextEncoder();

  // node_modules/@ipld/dag-pb/src/index.js
  var src_exports5 = {};
  __export(src_exports5, {
    code: () => code6,
    createLink: () => createLink,
    createNode: () => createNode,
    decode: () => decode14,
    encode: () => encode13,
    name: () => name6,
    prepare: () => prepare,
    validate: () => validate3
  });

  // node_modules/@ipld/dag-pb/src/pb-decode.js
  var textDecoder3 = new TextDecoder();
  function decodeVarint(bytes, offset) {
    let v = 0;
    for (let shift = 0; ; shift += 7) {
      if (shift >= 64) {
        throw new Error("protobuf: varint overflow");
      }
      if (offset >= bytes.length) {
        throw new Error("protobuf: unexpected end of data");
      }
      const b = bytes[offset++];
      v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
      if (b < 128) {
        break;
      }
    }
    return [v, offset];
  }
  function decodeBytes(bytes, offset) {
    let byteLen;
    [byteLen, offset] = decodeVarint(bytes, offset);
    const postOffset = offset + byteLen;
    if (byteLen < 0 || postOffset < 0) {
      throw new Error("protobuf: invalid length");
    }
    if (postOffset > bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    return [bytes.subarray(offset, postOffset), postOffset];
  }
  function decodeKey(bytes, index) {
    let wire;
    [wire, index] = decodeVarint(bytes, index);
    return [wire & 7, wire >> 3, index];
  }
  function decodeLink(bytes) {
    const link = {};
    const l2 = bytes.length;
    let index = 0;
    while (index < l2) {
      let wireType, fieldNum;
      [wireType, fieldNum, index] = decodeKey(bytes, index);
      if (fieldNum === 1) {
        if (link.Hash) {
          throw new Error("protobuf: (PBLink) duplicate Hash section");
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
        }
        if (link.Name !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
        }
        if (link.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
        }
        [link.Hash, index] = decodeBytes(bytes, index);
      } else if (fieldNum === 2) {
        if (link.Name !== void 0) {
          throw new Error("protobuf: (PBLink) duplicate Name section");
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
        }
        if (link.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
        }
        let byts;
        [byts, index] = decodeBytes(bytes, index);
        link.Name = textDecoder3.decode(byts);
      } else if (fieldNum === 3) {
        if (link.Tsize !== void 0) {
          throw new Error("protobuf: (PBLink) duplicate Tsize section");
        }
        if (wireType !== 0) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
        }
        [link.Tsize, index] = decodeVarint(bytes, index);
      } else {
        throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
      }
    }
    if (index > l2) {
      throw new Error("protobuf: (PBLink) unexpected end of data");
    }
    return link;
  }
  function decodeNode(bytes) {
    const l2 = bytes.length;
    let index = 0;
    let links2 = void 0;
    let linksBeforeData = false;
    let data = void 0;
    while (index < l2) {
      let wireType, fieldNum;
      [wireType, fieldNum, index] = decodeKey(bytes, index);
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
      }
      if (fieldNum === 1) {
        if (data) {
          throw new Error("protobuf: (PBNode) duplicate Data section");
        }
        [data, index] = decodeBytes(bytes, index);
        if (links2) {
          linksBeforeData = true;
        }
      } else if (fieldNum === 2) {
        if (linksBeforeData) {
          throw new Error("protobuf: (PBNode) duplicate Links section");
        } else if (!links2) {
          links2 = [];
        }
        let byts;
        [byts, index] = decodeBytes(bytes, index);
        links2.push(decodeLink(byts));
      } else {
        throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
      }
    }
    if (index > l2) {
      throw new Error("protobuf: (PBNode) unexpected end of data");
    }
    const node = {};
    if (data) {
      node.Data = data;
    }
    node.Links = links2 || [];
    return node;
  }

  // node_modules/@ipld/dag-pb/src/pb-encode.js
  var textEncoder3 = new TextEncoder();
  var maxInt32 = 2 ** 32;
  var maxUInt32 = 2 ** 31;
  function encodeLink(link, bytes) {
    let i2 = bytes.length;
    if (typeof link.Tsize === "number") {
      if (link.Tsize < 0) {
        throw new Error("Tsize cannot be negative");
      }
      if (!Number.isSafeInteger(link.Tsize)) {
        throw new Error("Tsize too large for encoding");
      }
      i2 = encodeVarint(bytes, i2, link.Tsize) - 1;
      bytes[i2] = 24;
    }
    if (typeof link.Name === "string") {
      const nameBytes = textEncoder3.encode(link.Name);
      i2 -= nameBytes.length;
      bytes.set(nameBytes, i2);
      i2 = encodeVarint(bytes, i2, nameBytes.length) - 1;
      bytes[i2] = 18;
    }
    if (link.Hash) {
      i2 -= link.Hash.length;
      bytes.set(link.Hash, i2);
      i2 = encodeVarint(bytes, i2, link.Hash.length) - 1;
      bytes[i2] = 10;
    }
    return bytes.length - i2;
  }
  function encodeNode(node) {
    const size = sizeNode(node);
    const bytes = new Uint8Array(size);
    let i2 = size;
    if (node.Data) {
      i2 -= node.Data.length;
      bytes.set(node.Data, i2);
      i2 = encodeVarint(bytes, i2, node.Data.length) - 1;
      bytes[i2] = 10;
    }
    if (node.Links) {
      for (let index = node.Links.length - 1; index >= 0; index--) {
        const size2 = encodeLink(node.Links[index], bytes.subarray(0, i2));
        i2 -= size2;
        i2 = encodeVarint(bytes, i2, size2) - 1;
        bytes[i2] = 18;
      }
    }
    return bytes;
  }
  function sizeLink(link) {
    let n2 = 0;
    if (link.Hash) {
      const l2 = link.Hash.length;
      n2 += 1 + l2 + sov(l2);
    }
    if (typeof link.Name === "string") {
      const l2 = textEncoder3.encode(link.Name).length;
      n2 += 1 + l2 + sov(l2);
    }
    if (typeof link.Tsize === "number") {
      n2 += 1 + sov(link.Tsize);
    }
    return n2;
  }
  function sizeNode(node) {
    let n2 = 0;
    if (node.Data) {
      const l2 = node.Data.length;
      n2 += 1 + l2 + sov(l2);
    }
    if (node.Links) {
      for (const link of node.Links) {
        const l2 = sizeLink(link);
        n2 += 1 + l2 + sov(l2);
      }
    }
    return n2;
  }
  function encodeVarint(bytes, offset, v) {
    offset -= sov(v);
    const base3 = offset;
    while (v >= maxUInt32) {
      bytes[offset++] = v & 127 | 128;
      v /= 128;
    }
    while (v >= 128) {
      bytes[offset++] = v & 127 | 128;
      v >>>= 7;
    }
    bytes[offset] = v;
    return base3;
  }
  function sov(x) {
    if (x % 2 === 0) {
      x++;
    }
    return Math.floor((len64(x) + 6) / 7);
  }
  function len64(x) {
    let n2 = 0;
    if (x >= maxInt32) {
      x = Math.floor(x / maxInt32);
      n2 = 32;
    }
    if (x >= 1 << 16) {
      x >>>= 16;
      n2 += 16;
    }
    if (x >= 1 << 8) {
      x >>>= 8;
      n2 += 8;
    }
    return n2 + len8tab[x];
  }
  var len8tab = [
    0,
    1,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8
  ];

  // node_modules/@ipld/dag-pb/src/util.js
  var pbNodeProperties = ["Data", "Links"];
  var pbLinkProperties = ["Hash", "Name", "Tsize"];
  var textEncoder4 = new TextEncoder();
  function linkComparator(a2, b) {
    if (a2 === b) {
      return 0;
    }
    const abuf = a2.Name ? textEncoder4.encode(a2.Name) : [];
    const bbuf = b.Name ? textEncoder4.encode(b.Name) : [];
    let x = abuf.length;
    let y = bbuf.length;
    for (let i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
      if (abuf[i2] !== bbuf[i2]) {
        x = abuf[i2];
        y = bbuf[i2];
        break;
      }
    }
    return x < y ? -1 : y < x ? 1 : 0;
  }
  function hasOnlyProperties(node, properties) {
    return !Object.keys(node).some((p2) => !properties.includes(p2));
  }
  function asLink(link) {
    if (typeof link.asCID === "object") {
      const Hash = CID.asCID(link);
      if (!Hash) {
        throw new TypeError("Invalid DAG-PB form");
      }
      return { Hash };
    }
    if (typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form");
    }
    const pbl = {};
    if (link.Hash) {
      let cid = CID.asCID(link.Hash);
      try {
        if (!cid) {
          if (typeof link.Hash === "string") {
            cid = CID.parse(link.Hash);
          } else if (link.Hash instanceof Uint8Array) {
            cid = CID.decode(link.Hash);
          }
        }
      } catch (e2) {
        throw new TypeError(`Invalid DAG-PB form: ${e2.message}`);
      }
      if (cid) {
        pbl.Hash = cid;
      }
    }
    if (!pbl.Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    if (typeof link.Name === "string") {
      pbl.Name = link.Name;
    }
    if (typeof link.Tsize === "number") {
      pbl.Tsize = link.Tsize;
    }
    return pbl;
  }
  function prepare(node) {
    if (node instanceof Uint8Array || typeof node === "string") {
      node = { Data: node };
    }
    if (typeof node !== "object" || Array.isArray(node)) {
      throw new TypeError("Invalid DAG-PB form");
    }
    const pbn = {};
    if (node.Data !== void 0) {
      if (typeof node.Data === "string") {
        pbn.Data = textEncoder4.encode(node.Data);
      } else if (node.Data instanceof Uint8Array) {
        pbn.Data = node.Data;
      } else {
        throw new TypeError("Invalid DAG-PB form");
      }
    }
    if (node.Links !== void 0) {
      if (Array.isArray(node.Links)) {
        pbn.Links = node.Links.map(asLink);
        pbn.Links.sort(linkComparator);
      } else {
        throw new TypeError("Invalid DAG-PB form");
      }
    } else {
      pbn.Links = [];
    }
    return pbn;
  }
  function validate3(node) {
    if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
      throw new TypeError("Invalid DAG-PB form");
    }
    if (!hasOnlyProperties(node, pbNodeProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties)");
    }
    if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
      throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
    }
    if (!Array.isArray(node.Links)) {
      throw new TypeError("Invalid DAG-PB form (Links must be a list)");
    }
    for (let i2 = 0; i2 < node.Links.length; i2++) {
      const link = node.Links[i2];
      if (!link || typeof link !== "object" || Array.isArray(link) || link instanceof Uint8Array || link["/"] && link["/"] === link.bytes) {
        throw new TypeError("Invalid DAG-PB form (bad link)");
      }
      if (!hasOnlyProperties(link, pbLinkProperties)) {
        throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
      }
      if (link.Hash === void 0) {
        throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
      }
      if (link.Hash == null || !link.Hash["/"] || link.Hash["/"] !== link.Hash.bytes) {
        throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
      }
      if (link.Name !== void 0 && typeof link.Name !== "string") {
        throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
      }
      if (link.Tsize !== void 0) {
        if (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0) {
          throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
        }
        if (link.Tsize < 0) {
          throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
        }
      }
      if (i2 > 0 && linkComparator(link, node.Links[i2 - 1]) === -1) {
        throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
      }
    }
  }
  function createNode(data, links2 = []) {
    return prepare({ Data: data, Links: links2 });
  }
  function createLink(name9, size, cid) {
    return asLink({ Hash: cid, Name: name9, Tsize: size });
  }
  function toByteView3(buf2) {
    if (buf2 instanceof ArrayBuffer) {
      return new Uint8Array(buf2, 0, buf2.byteLength);
    }
    return buf2;
  }

  // node_modules/@ipld/dag-pb/src/index.js
  var name6 = "dag-pb";
  var code6 = 112;
  function encode13(node) {
    validate3(node);
    const pbn = {};
    if (node.Links) {
      pbn.Links = node.Links.map((l2) => {
        const link = {};
        if (l2.Hash) {
          link.Hash = l2.Hash.bytes;
        }
        if (l2.Name !== void 0) {
          link.Name = l2.Name;
        }
        if (l2.Tsize !== void 0) {
          link.Tsize = l2.Tsize;
        }
        return link;
      });
    }
    if (node.Data) {
      pbn.Data = node.Data;
    }
    return encodeNode(pbn);
  }
  function decode14(bytes) {
    const buf2 = toByteView3(bytes);
    const pbn = decodeNode(buf2);
    const node = {};
    if (pbn.Data) {
      node.Data = pbn.Data;
    }
    if (pbn.Links) {
      node.Links = pbn.Links.map((l2) => {
        const link = {};
        try {
          link.Hash = CID.decode(l2.Hash);
        } catch {
        }
        if (!link.Hash) {
          throw new Error("Invalid Hash field found in link, expected CID");
        }
        if (l2.Name !== void 0) {
          link.Name = l2.Name;
        }
        if (l2.Tsize !== void 0) {
          link.Tsize = l2.Tsize;
        }
        return link;
      });
    }
    return node;
  }

  // node_modules/@helia/utils/dist/src/utils/is-promise.js
  function isPromise3(p2) {
    return p2?.then != null;
  }

  // node_modules/@helia/utils/dist/src/utils/get-codec.js
  function getCodec(initialCodecs = [], loadCodec) {
    const codecs2 = {
      [code6]: src_exports5,
      [code3]: raw_exports,
      [code4]: src_exports3,
      [code5]: src_exports4,
      [code2]: json_exports
    };
    initialCodecs.forEach((codec) => {
      codecs2[codec.code] = codec;
    });
    return async (code8) => {
      let codec = codecs2[code8];
      if (codec == null && loadCodec != null) {
        const res = loadCodec(code8);
        if (isPromise3(res)) {
          codec = await res;
        } else {
          codec = res;
        }
        codecs2[codec.code] = codec;
      }
      if (codec != null) {
        return codec;
      }
      throw new UnknownCodecError(`Could not load codec for ${code8}`);
    };
  }

  // node_modules/@helia/utils/dist/src/utils/get-hasher.js
  function getHasher(initialHashers = [], loadHasher) {
    const hashers = {
      [sha256.code]: sha256,
      [sha512.code]: sha512,
      [identity.code]: identity
    };
    initialHashers.forEach((hasher) => {
      hashers[hasher.code] = hasher;
    });
    return async (code8) => {
      let hasher = hashers[code8];
      if (hasher == null && loadHasher != null) {
        const res = loadHasher(code8);
        if (isPromise3(res)) {
          hasher = await res;
        } else {
          hasher = res;
        }
        hashers[hasher.code] = hasher;
      }
      if (hasher != null) {
        return hasher;
      }
      throw new UnknownHashAlgorithmError(`No hasher configured for multihash code 0x${code8.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);
    };
  }

  // node_modules/interface-store/dist/src/errors.js
  var NotFoundError2 = class _NotFoundError extends Error {
    static name = "NotFoundError";
    static code = "ERR_NOT_FOUND";
    name = _NotFoundError.name;
    code = _NotFoundError.code;
    constructor(message2 = "Not Found") {
      super(message2);
    }
  };

  // node_modules/blockstore-core/dist/src/base.js
  var BaseBlockstore = class {
    has(key, options2) {
      return Promise.reject(new Error(".has is not implemented"));
    }
    put(key, val, options2) {
      return Promise.reject(new Error(".put is not implemented"));
    }
    async *putMany(source, options2) {
      for await (const { cid, bytes } of source) {
        await this.put(cid, bytes, options2);
        yield cid;
      }
    }
    get(key, options2) {
      throw new Error(".get is not implemented");
    }
    async *getMany(source, options2) {
      for await (const key of source) {
        yield {
          cid: key,
          bytes: this.get(key, options2)
        };
      }
    }
    delete(key, options2) {
      return Promise.reject(new Error(".delete is not implemented"));
    }
    async *deleteMany(source, options2) {
      for await (const key of source) {
        await this.delete(key, options2);
        yield key;
      }
    }
    /**
     * Extending classes should override `query` or implement this method
     */
    async *getAll(options2) {
      throw new Error(".getAll is not implemented");
    }
  };

  // node_modules/blockstore-core/dist/src/identity.js
  var IDENTITY_CODEC = 0;
  var IdentityHashDigestTooLongError = class extends Error {
    static name = "IdentityHashDigestTooLongError";
    name = "IdentityHashDigestTooLongError";
  };
  var IdentityBlockstore = class extends BaseBlockstore {
    child;
    maxDigestLength;
    constructor(child, init) {
      super();
      this.child = child;
      this.maxDigestLength = init?.maxDigestLength;
    }
    put(key, block, options2) {
      if (key.multihash.code === IDENTITY_CODEC) {
        if (this.maxDigestLength != null && key.multihash.digest.byteLength > this.maxDigestLength) {
          throw new IdentityHashDigestTooLongError(`Identity digest too long - ${key.multihash.digest.byteLength} > this.maxDigestLength`);
        }
        options2?.signal?.throwIfAborted();
        return key;
      }
      if (this.child == null) {
        options2?.signal?.throwIfAborted();
        return key;
      }
      return this.child.put(key, block, options2);
    }
    *get(key, options2) {
      if (key.multihash.code === IDENTITY_CODEC) {
        if (this.maxDigestLength != null && key.multihash.digest.byteLength > this.maxDigestLength) {
          throw new IdentityHashDigestTooLongError(`Identity digest too long - ${key.multihash.digest.byteLength} > this.maxDigestLength`);
        }
        options2?.signal?.throwIfAborted();
        yield key.multihash.digest;
        return;
      }
      if (this.child == null) {
        options2?.signal?.throwIfAborted();
        throw new NotFoundError2();
      }
      yield* this.child.get(key, options2);
    }
    has(key, options2) {
      if (key.multihash.code === IDENTITY_CODEC) {
        if (this.maxDigestLength != null && key.multihash.digest.byteLength > this.maxDigestLength) {
          throw new IdentityHashDigestTooLongError(`Identity digest too long - ${key.multihash.digest.byteLength} > this.maxDigestLength`);
        }
        options2?.signal?.throwIfAborted();
        return true;
      }
      if (this.child == null) {
        options2?.signal?.throwIfAborted();
        return false;
      }
      return this.child.has(key, options2);
    }
    delete(key, options2) {
      if (key.code === IDENTITY_CODEC) {
        if (this.maxDigestLength != null && key.multihash.digest.byteLength > this.maxDigestLength) {
          throw new IdentityHashDigestTooLongError(`Identity digest too long - ${key.multihash.digest.byteLength} > this.maxDigestLength`);
        }
        options2?.signal?.throwIfAborted();
        return;
      }
      if (this.child != null) {
        return this.child.delete(key, options2);
      }
    }
    *getAll(options2) {
      if (this.child != null) {
        yield* this.child.getAll(options2);
      }
      options2?.signal?.throwIfAborted();
    }
  };

  // node_modules/it-filter/dist/src/index.js
  function isAsyncIterable8(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function filter(source, fn) {
    let index = 0;
    if (isAsyncIterable8(source)) {
      return (async function* () {
        for await (const entry of source) {
          if (await fn(entry, index++)) {
            yield entry;
          }
        }
      })();
    }
    const peekable2 = src_default4(source);
    const { value: value2, done } = peekable2.next();
    if (done === true) {
      return (function* () {
      })();
    }
    const res = fn(value2, index++);
    if (typeof res.then === "function") {
      return (async function* () {
        if (await res) {
          yield value2;
        }
        for (const entry of peekable2) {
          if (await fn(entry, index++)) {
            yield entry;
          }
        }
      })();
    }
    const func = fn;
    return (function* () {
      if (res === true) {
        yield value2;
      }
      for (const entry of peekable2) {
        if (func(entry, index++)) {
          yield entry;
        }
      }
    })();
  }
  var src_default8 = filter;

  // node_modules/it-foreach/dist/src/index.js
  function isAsyncIterable9(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function isPromise4(thing) {
    return thing?.then != null;
  }
  function forEach(source, fn) {
    let index = 0;
    if (isAsyncIterable9(source)) {
      return (async function* () {
        for await (const val of source) {
          const res2 = fn(val, index++);
          if (isPromise4(res2)) {
            await res2;
          }
          yield val;
        }
      })();
    }
    const peekable2 = src_default4(source);
    const { value: value2, done } = peekable2.next();
    if (done === true) {
      return (function* () {
      })();
    }
    const res = fn(value2, index++);
    if (typeof res?.then === "function") {
      return (async function* () {
        yield value2;
        for (const val of peekable2) {
          const res2 = fn(val, index++);
          if (isPromise4(res2)) {
            await res2;
          }
          yield val;
        }
      })();
    }
    const func = fn;
    return (function* () {
      yield value2;
      for (const val of peekable2) {
        func(val, index++);
        yield val;
      }
    })();
  }
  var src_default9 = forEach;

  // node_modules/@helia/utils/dist/src/utils/networked-storage.js
  var DEFAULT_MAX_IDENTITY_HASH_DIGEST_LENGTH = 128;
  var Storage = class {
    child;
    getHasher;
    log;
    logger;
    components;
    /**
     * Create a new BlockStorage
     */
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("helia:networked-storage");
      this.logger = components.logger;
      this.components = components;
      this.child = new IdentityBlockstore(components.blockstore, {
        maxDigestLength: init.maxIdentityHashDigestLength ?? DEFAULT_MAX_IDENTITY_HASH_DIGEST_LENGTH
      });
      this.getHasher = components.getHasher;
    }
    /**
     * Put a block to the underlying datastore
     */
    async put(cid, block, options2 = {}) {
      if (await this.child.has(cid, options2)) {
        options2.onProgress?.(new CustomProgressEvent("blocks:put:duplicate", cid));
        return cid;
      }
      options2.onProgress?.(new CustomProgressEvent("blocks:put:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, options2)));
      options2.onProgress?.(new CustomProgressEvent("blocks:put:blockstore:put", cid));
      return this.child.put(cid, block, options2);
    }
    /**
     * Put a multiple blocks to the underlying datastore
     */
    async *putMany(blocks, options2 = {}) {
      const missingBlocks = src_default8(blocks, async ({ cid }) => {
        const has = await this.child.has(cid, options2);
        if (has) {
          options2.onProgress?.(new CustomProgressEvent("blocks:put-many:duplicate", cid));
        }
        return !has;
      });
      const notifyEach = src_default9(missingBlocks, async ({ cid }) => {
        options2.onProgress?.(new CustomProgressEvent("blocks:put-many:providers:notify", cid));
        await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, options2)));
      });
      options2.onProgress?.(new CustomProgressEvent("blocks:put-many:blockstore:put-many"));
      yield* this.child.putMany(notifyEach, options2);
    }
    /**
     * Get a block by cid
     */
    async *get(cid, options2 = {}) {
      if (options2.offline !== true && !await this.child.has(cid, options2)) {
        const hasher = await this.getHasher(cid.multihash.code);
        options2.onProgress?.(new CustomProgressEvent("blocks:get:providers:get", cid));
        const block = await raceBlockRetrievers(cid, this.components.blockBrokers, hasher, {
          ...options2,
          log: this.log
        });
        options2.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:put", cid));
        await this.child.put(cid, block, options2);
        options2.onProgress?.(new CustomProgressEvent("blocks:get:providers:notify", cid));
        await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, options2)));
        yield block;
        return;
      }
      options2.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:get", cid));
      yield* this.child.get(cid, options2);
    }
    /**
     * Get multiple blocks back from an (async) iterable of cids
     */
    async *getMany(cids, options2 = {}) {
      options2.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:get-many"));
      yield* this.child.getMany(src_default9(cids, async (cid) => {
        if (options2.offline !== true && !await this.child.has(cid, options2)) {
          const hasher = await this.getHasher(cid.multihash.code);
          options2.onProgress?.(new CustomProgressEvent("blocks:get-many:providers:get", cid));
          const block = await raceBlockRetrievers(cid, this.components.blockBrokers, hasher, {
            ...options2,
            log: this.log
          });
          options2.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:put", cid));
          await this.child.put(cid, block, options2);
          options2.onProgress?.(new CustomProgressEvent("blocks:get-many:providers:notify", cid));
          await Promise.all(this.components.blockBrokers.map(async (broker) => broker.announce?.(cid, options2)));
        }
      }));
    }
    /**
     * Delete a block from the blockstore
     */
    async delete(cid, options2 = {}) {
      options2.onProgress?.(new CustomProgressEvent("blocks:delete:blockstore:delete", cid));
      await this.child.delete(cid, options2);
    }
    /**
     * Delete multiple blocks from the blockstore
     */
    async *deleteMany(cids, options2 = {}) {
      options2.onProgress?.(new CustomProgressEvent("blocks:delete-many:blockstore:delete-many"));
      yield* this.child.deleteMany((async function* () {
        for await (const cid of cids) {
          yield cid;
        }
      })(), options2);
    }
    async has(cid, options2 = {}) {
      return this.child.has(cid, options2);
    }
    async *getAll(options2 = {}) {
      options2.onProgress?.(new CustomProgressEvent("blocks:get-all:blockstore:get-many"));
      yield* this.child.getAll(options2);
    }
  };
  var NetworkedStorage = class extends Storage {
    started;
    /**
     * Create a new BlockStorage
     */
    constructor(components, init = {}) {
      super(components, init);
      this.started = false;
    }
    isStarted() {
      return this.started;
    }
    async start() {
      await start(this.child, ...this.components.blockBrokers);
      this.started = true;
    }
    async stop() {
      await stop(this.child, ...this.components.blockBrokers);
      this.started = false;
    }
    unwrap() {
      return this.child;
    }
    createSession(root, options2) {
      const blockBrokers = this.components.blockBrokers.map((broker) => {
        if (broker.createSession == null) {
          return broker;
        }
        return broker.createSession(options2);
      });
      return new SessionStorage({
        blockstore: this.child,
        blockBrokers,
        getHasher: this.getHasher,
        logger: this.logger
      }, {
        root
      });
    }
  };
  var SessionStorage = class extends Storage {
    closeController;
    constructor(components, init) {
      super(components);
      this.closeController = new AbortController();
      setMaxListeners(Infinity, this.closeController.signal);
      this.log = components.logger.forComponent(`helia:session-storage:${init.root}`);
    }
    close() {
      this.closeController.abort();
    }
    /**
     * Put a block to the underlying datastore
     */
    async put(cid, block, options2 = {}) {
      const signal = anySignal([this.closeController.signal, options2.signal]);
      setMaxListeners(Infinity, signal);
      try {
        return await super.put(cid, block, {
          ...options2,
          signal
        });
      } finally {
        signal.clear();
      }
    }
    /**
     * Put a multiple blocks to the underlying datastore
     */
    async *putMany(blocks, options2 = {}) {
      const signal = anySignal([this.closeController.signal, options2.signal]);
      setMaxListeners(Infinity, signal);
      try {
        yield* super.putMany(blocks, {
          ...options2,
          signal
        });
      } finally {
        signal.clear();
      }
    }
    /**
     * Get a block by cid
     */
    async *get(cid, options2 = {}) {
      const signal = anySignal([this.closeController.signal, options2.signal]);
      setMaxListeners(Infinity, signal);
      try {
        yield* super.get(cid, {
          ...options2,
          signal
        });
      } finally {
        signal.clear();
      }
    }
    /**
     * Get multiple blocks back from an (async) iterable of cids
     */
    async *getMany(cids, options2 = {}) {
      const signal = anySignal([this.closeController.signal, options2.signal]);
      setMaxListeners(Infinity, signal);
      try {
        yield* super.getMany(cids, {
          ...options2,
          signal
        });
      } finally {
        signal.clear();
      }
    }
    /**
     * Delete a block from the blockstore
     */
    async delete(cid, options2 = {}) {
      const signal = anySignal([this.closeController.signal, options2.signal]);
      setMaxListeners(Infinity, signal);
      try {
        await super.delete(cid, {
          ...options2,
          signal
        });
      } finally {
        signal.clear();
      }
    }
    /**
     * Delete multiple blocks from the blockstore
     */
    async *deleteMany(cids, options2 = {}) {
      const signal = anySignal([this.closeController.signal, options2.signal]);
      setMaxListeners(Infinity, signal);
      try {
        yield* super.deleteMany(cids, {
          ...options2,
          signal
        });
      } finally {
        signal.clear();
      }
    }
    async has(cid, options2 = {}) {
      const signal = anySignal([this.closeController.signal, options2.signal]);
      setMaxListeners(Infinity, signal);
      try {
        return await super.has(cid, {
          ...options2,
          signal
        });
      } finally {
        signal.clear();
      }
    }
    async *getAll(options2 = {}) {
      const signal = anySignal([this.closeController.signal, options2.signal]);
      setMaxListeners(Infinity, signal);
      try {
        yield* super.getAll({
          ...options2,
          signal
        });
      } finally {
        signal.clear();
      }
    }
  };
  function isRetrievingBlockBroker(broker) {
    return typeof broker.retrieve === "function";
  }
  var getCidBlockVerifierFunction = (cid, hasher) => {
    if (hasher == null) {
      throw new InvalidParametersError(`No hasher configured for multihash code 0x${cid.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);
    }
    return async (block) => {
      let hash;
      const res = hasher.digest(block);
      if (isPromise3(res)) {
        hash = await res;
      } else {
        hash = res;
      }
      if (!equals3(hash.digest, cid.multihash.digest)) {
        throw new InvalidMultihashError("Hash of downloaded block did not match multihash from passed CID");
      }
    };
  };
  async function raceBlockRetrievers(cid, blockBrokers, hasher, options2) {
    const validateFn = getCidBlockVerifierFunction(cid, hasher);
    const controller = new AbortController();
    const signal = anySignal([controller.signal, options2.signal]);
    setMaxListeners(Infinity, controller.signal, signal);
    const retrievers = [];
    for (const broker of blockBrokers) {
      if (isRetrievingBlockBroker(broker)) {
        retrievers.push(broker);
      }
    }
    if (retrievers.length === 0) {
      throw new InvalidConfigurationError(`No block brokers capable of retrieving blocks are configured, the CID ${cid} cannot be fetched from the network`);
    }
    try {
      return await Promise.any(retrievers.map(async (retriever) => {
        try {
          let blocksWereValidated = false;
          const block = await retriever.retrieve(cid, {
            ...options2,
            signal,
            validateFn: async (block2) => {
              await validateFn(block2);
              options2.signal?.throwIfAborted();
              blocksWereValidated = true;
            }
          });
          if (!blocksWereValidated) {
            await validateFn(block);
            options2.signal?.throwIfAborted();
          }
          return block;
        } catch (err2) {
          options2.log.error("could not retrieve verified block for %c - %e", cid, err2);
          throw err2;
        }
      }));
    } finally {
      controller.abort();
      signal.clear();
    }
  }

  // node_modules/@helia/utils/dist/src/abstract-session.js
  var AbstractSession = class extends TypedEventEmitter {
    initialPeerSearchComplete;
    requests;
    name;
    log;
    logger;
    minProviders;
    maxProviders;
    providers;
    evictionFilter;
    initialProviders;
    constructor(components, init) {
      super();
      setMaxListeners(Infinity, this);
      this.name = init.name;
      this.logger = components.logger;
      this.log = components.logger.forComponent(this.name);
      this.requests = /* @__PURE__ */ new Map();
      this.minProviders = init.minProviders ?? DEFAULT_SESSION_MIN_PROVIDERS;
      this.maxProviders = init.maxProviders ?? DEFAULT_SESSION_MAX_PROVIDERS;
      this.providers = [];
      this.evictionFilter = createScalableCuckooFilter(this.maxProviders);
      this.initialProviders = init.providers ?? [];
    }
    async retrieve(cid, options2 = {}) {
      const cidStr = base64.encode(cid.multihash.bytes);
      const existingJob = this.requests.get(cidStr);
      if (existingJob != null) {
        this.log("join existing request for %c", cid);
        return existingJob;
      }
      const deferred = pDefer();
      this.requests.set(cidStr, deferred.promise);
      if (this.providers.length === 0) {
        let first2 = false;
        if (this.initialPeerSearchComplete == null) {
          first2 = true;
          this.log = this.logger.forComponent(`${this.name}:${cid}`);
          this.initialPeerSearchComplete = this.findProviders(cid, this.minProviders, options2);
        }
        try {
          await raceSignal(this.initialPeerSearchComplete, options2.signal);
          if (first2) {
            this.log("found initial session peers for %c", cid);
          }
        } catch (err2) {
          if (first2) {
            this.log("failed to find initial session peers for %c - %e", cid, err2);
          }
          this.requests.delete(cidStr);
          deferred.reject(err2);
          throw err2;
        }
      }
      let foundBlock = false;
      const queue = new Queue({
        concurrency: this.maxProviders
      });
      queue.addEventListener("failure", (evt) => {
        this.log.error("error querying provider %o, evicting from session", evt.detail.job.options.provider, evt.detail.error);
        this.evict(evt.detail.job.options.provider);
      });
      queue.addEventListener("success", (evt) => {
        foundBlock = true;
        deferred.resolve(evt.detail.result);
      });
      queue.addEventListener("idle", () => {
        if (foundBlock) {
          this.log.trace("session idle, found block");
          return;
        }
        if (options2.signal?.aborted === true) {
          this.log.trace("session idle, signal aborted");
          return;
        }
        Promise.resolve().then(async () => {
          this.log("no session peers had block for for %c, finding new providers", cid);
          for (let i2 = 0; i2 < this.minProviders; i2++) {
            if (this.providers.length === 0) {
              break;
            }
            const provider = this.providers[Math.floor(Math.random() * this.providers.length)];
            this.evict(provider);
          }
          await this.findProviders(cid, this.minProviders, options2);
          this.log("found new providers re-retrieving %c", cid);
          this.requests.delete(cidStr);
          deferred.resolve(await this.retrieve(cid, options2));
        }).catch((err2) => {
          this.log.error("could not find new providers for %c - %e", cid, err2);
          deferred.reject(err2);
        });
      });
      const peerAddedToSessionListener = (event) => {
        queue.add(async () => {
          return this.queryProvider(cid, event.detail, options2);
        }, {
          provider: event.detail
        }).catch((err2) => {
          if (options2.signal?.aborted === true) {
            return;
          }
          this.log.error("error retrieving session block for %c - %e", cid, err2);
        });
      };
      this.addEventListener("provider", peerAddedToSessionListener);
      Promise.all([...this.providers].map(async (provider) => {
        return queue.add(async () => {
          return this.queryProvider(cid, provider, options2);
        }, {
          provider
        });
      })).catch((err2) => {
        if (options2.signal?.aborted === true) {
          return;
        }
        this.log.error("error retrieving session block for %c - %e", cid, err2);
      });
      const signalAbortedListener = () => {
        deferred.reject(new AbortError(options2.signal?.reason ?? "Session aborted"));
        queue.abort();
      };
      options2.signal?.addEventListener("abort", signalAbortedListener);
      try {
        return await raceSignal(deferred.promise, options2.signal);
      } finally {
        this.removeEventListener("provider", peerAddedToSessionListener);
        options2.signal?.removeEventListener("abort", signalAbortedListener);
        queue.clear();
        this.requests.delete(cidStr);
      }
    }
    evict(provider) {
      this.evictionFilter.add(this.toEvictionKey(provider));
      const index = this.providers.findIndex((prov) => this.equals(prov, provider));
      if (index === -1) {
        return;
      }
      this.providers.splice(index, 1);
    }
    isEvicted(provider) {
      return this.evictionFilter.has(this.toEvictionKey(provider));
    }
    hasProvider(provider) {
      if (this.providers.find((prov) => this.equals(prov, provider)) != null) {
        return true;
      }
      if (this.isEvicted(provider)) {
        return true;
      }
      return false;
    }
    async findProviders(cid, count, options2) {
      const deferred = pDefer();
      let found = 0;
      void Promise.resolve().then(async () => {
        this.log("finding %d-%d new provider(s) for %c", count, this.maxProviders, cid);
        if (this.initialProviders.length > 0) {
          while (found < count && this.initialProviders.length > 0) {
            const prov = this.initialProviders.pop();
            if (prov == null) {
              break;
            }
            const provider = await this.convertToProvider(prov, options2);
            if (options2.signal?.aborted === true) {
              break;
            }
            if (provider == null) {
              continue;
            }
            if (this.hasProvider(provider)) {
              continue;
            }
            this.log("found %d/%d new providers", found, this.maxProviders);
            this.providers.push(provider);
            this.safeDispatchEvent("provider", {
              detail: provider
            });
            found++;
            if (found === count) {
              this.log("session is ready");
              deferred.resolve();
            }
            if (this.providers.length === this.maxProviders) {
              this.log("found max session peers", found);
              break;
            }
          }
        }
        if (found < this.maxProviders) {
          for await (const provider of this.findNewProviders(cid, options2)) {
            if (found === this.maxProviders || options2.signal?.aborted === true) {
              break;
            }
            if (this.hasProvider(provider)) {
              continue;
            }
            this.log("found %d/%d new providers", found, this.maxProviders);
            this.providers.push(provider);
            this.safeDispatchEvent("provider", {
              detail: provider
            });
            found++;
            if (found === count) {
              this.log("session is ready");
              deferred.resolve();
            }
            if (this.providers.length === this.maxProviders) {
              this.log("found max session peers", found);
              break;
            }
          }
        }
        this.log("found %d/%d new session peers", found, this.maxProviders);
        if (found < count) {
          throw new InsufficientProvidersError(`Found ${found} of ${count} ${this.name} providers for ${cid}`);
        }
      }).catch((err2) => {
        this.log.error("error searching routing for potential session peers for %c - %e", cid, err2);
        deferred.reject(err2);
      });
      return deferred.promise;
    }
  };

  // node_modules/@helia/utils/dist/src/graph-walker.js
  function depthFirstWalker(components, init = {}) {
    return new DepthFirstGraphWalker(components, init);
  }
  function breadthFirstWalker(components, init = {}) {
    return new BreadthFirstGraphWalker(components, init);
  }
  var AbstractGraphWalker = class {
    components;
    constructor(components, init) {
      this.components = components;
    }
    async *walk(cid, options2) {
      const queue = this.getQueue();
      const gen = src_default8(queue.toGenerator(options2), (node) => node != null);
      let finished = false;
      const job = async (opts) => {
        const cid2 = opts.cid;
        const bytes = await src_default7(this.components.blockstore.get(cid2, opts));
        const block = createUnsafe({
          cid: cid2,
          bytes,
          codec: await this.components.getCodec(cid2.code)
        });
        for (const [, linkedCid] of block.links()) {
          if (options2?.includeChild?.(linkedCid, block) === false) {
            continue;
          }
          queue.add(job, {
            ...opts,
            cid: linkedCid,
            depth: opts.depth + 1,
            path: [...opts.path, linkedCid]
          }).catch((err2) => {
            if (!finished) {
              gen.throw(err2);
            }
          });
        }
        return {
          block,
          depth: opts.depth,
          path: opts.path
        };
      };
      queue.add(job, {
        ...options2,
        cid,
        depth: 0,
        path: [cid]
      }).catch((err2) => {
        if (!finished) {
          gen.throw(err2);
        }
      });
      try {
        yield* gen;
      } finally {
        finished = true;
        queue.abort();
      }
    }
  };
  var DepthFirstGraphWalker = class extends AbstractGraphWalker {
    getQueue() {
      return new Queue({
        concurrency: 1,
        sort: (a2, b) => {
          if (a2.options.depth === b.options.depth) {
            return 0;
          }
          if (a2.options.depth < b.options.depth) {
            return 1;
          }
          return -1;
        }
      });
    }
  };
  var BreadthFirstGraphWalker = class extends AbstractGraphWalker {
    getQueue() {
      return new Queue({
        concurrency: 1,
        sort: (a2, b) => {
          if (a2.options.depth === b.options.depth) {
            return 0;
          }
          if (a2.options.depth < b.options.depth) {
            return -1;
          }
          return 1;
        }
      });
    }
  };

  // node_modules/@helia/utils/dist/src/index.js
  var Helia = class {
    libp2p;
    blockstore;
    datastore;
    events;
    pins;
    logger;
    routing;
    getCodec;
    getHasher;
    dns;
    metrics;
    log;
    constructor(init) {
      this.logger = init.logger ?? defaultLogger();
      this.log = this.logger.forComponent("helia");
      this.getHasher = getHasher(init.hashers, init.loadHasher);
      this.getCodec = getCodec(init.codecs, init.loadCodec);
      this.dns = init.dns ?? dns();
      this.metrics = init.metrics;
      this.libp2p = init.libp2p;
      this.events = new TypedEventEmitter();
      const components = {
        blockstore: init.blockstore,
        datastore: init.datastore,
        logger: this.logger,
        libp2p: this.libp2p,
        blockBrokers: [],
        getHasher: this.getHasher,
        getCodec: this.getCodec,
        dns: this.dns,
        metrics: this.metrics,
        ...init.components ?? {}
      };
      this.routing = components.routing = new Routing(components, {
        routers: (init.routers ?? []).flatMap((router) => {
          const routers = [
            router
          ];
          if (router[contentRoutingSymbol] != null) {
            routers.push(router[contentRoutingSymbol]);
          }
          if (router[peerRoutingSymbol] != null) {
            routers.push(router[peerRoutingSymbol]);
          }
          return routers;
        }),
        providerLookupConcurrency: init.providerLookupConcurrency
      });
      const networkedStorage = new NetworkedStorage(components, init);
      this.pins = new PinsImpl(init.datastore, networkedStorage, this.getCodec);
      this.blockstore = new BlockStorage(networkedStorage, this.pins, {
        holdGcLock: init.holdGcLock ?? true
      });
      this.datastore = init.datastore;
      components.blockBrokers = init.blockBrokers.map((fn) => {
        return fn(components);
      });
    }
    async start() {
      await assertDatastoreVersionIsCurrent(this.datastore);
      await start(this.blockstore, this.datastore, this.routing, this.libp2p);
      this.events.dispatchEvent(new CustomEvent("start", { detail: this }));
    }
    async stop() {
      await stop(this.blockstore, this.datastore, this.routing, this.libp2p);
      this.events.dispatchEvent(new CustomEvent("stop", { detail: this }));
    }
    async gc(options2 = {}) {
      const releaseLock = await this.blockstore.lock.writeLock();
      try {
        const helia2 = this;
        const blockstore = this.blockstore.unwrap();
        this.log("gc start");
        await src_default3(blockstore.deleteMany((async function* () {
          for await (const { cid } of blockstore.getAll()) {
            try {
              if (await helia2.pins.isPinned(cid, options2)) {
                continue;
              }
              yield cid;
              options2.onProgress?.(new CustomProgressEvent("helia:gc:deleted", cid));
            } catch (err2) {
              helia2.log.error("error during gc - %e", err2);
              options2.onProgress?.(new CustomProgressEvent("helia:gc:error", err2));
            }
          }
        })()));
      } finally {
        releaseLock();
      }
      this.log("gc finished");
    }
  };

  // node_modules/@helia/bitswap/dist/src/session.js
  var BitswapSession = class extends AbstractSession {
    wantList;
    network;
    libp2p;
    constructor(components, init) {
      super(components, {
        ...init,
        name: "helia:bitswap:session"
      });
      this.wantList = components.wantList;
      this.network = components.network;
      this.libp2p = components.libp2p;
    }
    async queryProvider(cid, provider, options2) {
      this.log("sending WANT-BLOCK for %c to %p", cid, provider);
      const result = await this.wantList.wantSessionBlock(cid, provider, options2);
      this.log("%p %s %c", provider, result.has ? "has" : "does not have", cid);
      if (result.has && result.block != null) {
        return result.block;
      }
      throw new Error("Provider did not have block");
    }
    async *findNewProviders(cid, options2 = {}) {
      for await (const provider of this.network.findProviders(cid, options2)) {
        yield provider.id;
      }
    }
    toEvictionKey(provider) {
      return provider.toMultihash().bytes;
    }
    equals(providerA, providerB) {
      return providerA.equals(providerB);
    }
    async convertToProvider(provider, options2) {
      if (isPeerId(provider)) {
        return provider;
      }
      const connection = await this.libp2p.dial(provider, options2);
      return connection.remotePeer;
    }
  };
  function createBitswapSession(components, init) {
    return new BitswapSession(components, init);
  }

  // node_modules/@helia/bitswap/dist/src/stats.js
  var Stats = class {
    blocksReceived;
    duplicateBlocksReceived;
    dataReceived;
    duplicateDataReceived;
    constructor(components) {
      this.blocksReceived = components.metrics?.registerMetricGroup("helia_bitswap_received_blocks");
      this.duplicateBlocksReceived = components.metrics?.registerMetricGroup("helia_bitswap_duplicate_received_blocks");
      this.dataReceived = components.metrics?.registerMetricGroup("helia_bitswap_data_received_bytes");
      this.duplicateDataReceived = components.metrics?.registerMetricGroup("helia_bitswap_duplicate_data_received_bytes");
    }
    updateBlocksReceived(count = 1, peerId) {
      const stats = {
        global: count
      };
      if (peerId != null) {
        stats[peerId.toString()] = count;
      }
      this.blocksReceived?.increment(stats);
    }
    updateDuplicateBlocksReceived(count = 1, peerId) {
      const stats = {
        global: count
      };
      if (peerId != null) {
        stats[peerId.toString()] = count;
      }
      this.duplicateBlocksReceived?.increment(stats);
    }
    updateDataReceived(bytes, peerId) {
      const stats = {
        global: bytes
      };
      if (peerId != null) {
        stats[peerId.toString()] = bytes;
      }
      this.dataReceived?.increment(stats);
    }
    updateDuplicateDataReceived(bytes, peerId) {
      const stats = {
        global: bytes
      };
      if (peerId != null) {
        stats[peerId.toString()] = bytes;
      }
      this.duplicateDataReceived?.increment(stats);
    }
  };

  // node_modules/@helia/bitswap/dist/src/utils/varint-decoder.js
  function varintDecoder(buf2) {
    if (!(buf2 instanceof Uint8Array)) {
      throw new Error("arg needs to be a Uint8Array");
    }
    const result = [];
    while (buf2.length > 0) {
      const num = decode8(buf2);
      result.push(num);
      buf2 = buf2.slice(encodingLength2(num));
    }
    return result;
  }
  var varint_decoder_default = varintDecoder;

  // node_modules/@helia/bitswap/dist/src/want-list.js
  var WantList = class extends TypedEventEmitter {
    /**
     * Tracks what CIDs we've previously sent to which peers
     */
    peers;
    wants;
    network;
    log;
    sendMessagesDelay;
    sendMessagesTimeout;
    hashLoader;
    sendingMessages;
    constructor(components, init = {}) {
      super();
      setMaxListeners(Infinity, this);
      this.peers = trackedPeerMap({
        name: "helia_bitswap_peers",
        metrics: components.metrics
      });
      this.wants = trackedMap({
        name: "helia_bitswap_wantlist",
        metrics: components.metrics
      });
      this.network = components.network;
      this.sendMessagesDelay = init.sendMessagesDelay ?? DEFAULT_MESSAGE_SEND_DELAY;
      this.log = components.logger.forComponent("helia:bitswap:wantlist");
      this.hashLoader = init.hashLoader;
      this.network.addEventListener("bitswap:message", (evt) => {
        this.receiveMessage(evt.detail.peer, evt.detail.message).catch((err2) => {
          this.log.error("error receiving bitswap message from %p - %e", evt.detail.peer, err2);
        });
      });
      this.network.addEventListener("peer:connected", (evt) => {
        this.peerConnected(evt.detail).catch((err2) => {
          this.log.error("error processing newly connected bitswap peer %p - %e", evt.detail, err2);
        });
      });
      this.network.addEventListener("peer:disconnected", (evt) => {
        this.peerDisconnected(evt.detail);
      });
    }
    async addEntry(cid, options2) {
      const cidStr = toString2(cid.multihash.bytes, "base64");
      let entry = this.wants.get(cidStr);
      if (entry == null) {
        entry = {
          cid,
          priority: options2.priority ?? 1,
          wantType: options2.wantType ?? WantType.WantBlock,
          cancel: false,
          sendDontHave: true
        };
        this.wants.set(cidStr, entry);
      }
      if (entry.wantType === WantType.WantHave && options2.wantType === WantType.WantBlock) {
        entry.wantType = WantType.WantBlock;
      }
      await this.sendMessagesDebounced();
      try {
        if (options2.wantType === WantType.WantBlock) {
          const event2 = await raceEvent(this, "block", options2?.signal, {
            filter: (event3) => {
              return equals3(cid.multihash.digest, event3.detail.cid.multihash.digest);
            },
            errorMessage: "Want was aborted"
          });
          return event2.detail;
        }
        const event = await raceEvent(this, "presence", options2?.signal, {
          filter: (event2) => {
            return equals3(cid.multihash.digest, event2.detail.cid.multihash.digest);
          },
          errorMessage: "Want was aborted"
        });
        return event.detail;
      } finally {
        if (options2.signal?.aborted === true) {
          this.log("want for %c was aborted, cancelling want", cid);
          entry.cancel = true;
          await this.sendMessagesDebounced();
        }
      }
    }
    async sendMessagesDebounced() {
      await this.sendingMessages?.promise;
      clearTimeout(this.sendMessagesTimeout);
      this.sendMessagesTimeout = setTimeout(() => {
        void this.sendMessages().catch((err2) => {
          this.log("error sending messages to peers - %e", err2);
        });
      }, this.sendMessagesDelay);
    }
    async sendMessages() {
      this.sendingMessages = pDefer();
      await Promise.all([...this.peers.entries()].map(async ([peerId, sentWants]) => {
        const sent = /* @__PURE__ */ new Set();
        const message2 = new QueuedBitswapMessage();
        for (const [key, entry] of this.wants.entries()) {
          const sentPreviously = sentWants.has(key);
          if (sentPreviously || entry.cancel) {
            continue;
          }
          sent.add(key);
          message2.addWantlistEntry(entry.cid, {
            cid: entry.cid.bytes,
            priority: entry.priority,
            wantType: entry.wantType,
            cancel: entry.cancel,
            sendDontHave: entry.sendDontHave
          });
        }
        if (message2.wantlist.size === 0) {
          return;
        }
        try {
          await this.network.sendMessage(peerId, message2);
          for (const key of sent) {
            sentWants.add(key);
          }
        } catch (err2) {
          this.log.error("error sending full wantlist to new peer - %e", err2);
        }
      })).catch((err2) => {
        this.log.error("error sending messages - %e", err2);
      });
      for (const [key, entry] of this.wants) {
        if (entry.cancel) {
          this.wants.delete(key);
          for (const sentWants of this.peers.values()) {
            sentWants.delete(key);
          }
        }
      }
      this.sendingMessages.resolve();
    }
    has(cid) {
      const cidStr = toString2(cid.multihash.bytes, "base64");
      return this.wants.has(cidStr);
    }
    /**
     * Add a CID to the wantlist
     */
    async wantSessionPresence(cid, peerId, options2 = {}) {
      const message2 = new QueuedBitswapMessage();
      message2.addWantlistEntry(cid, {
        cid: cid.bytes,
        sendDontHave: true,
        wantType: WantType.WantHave,
        priority: 1
      });
      await this.network.sendMessage(peerId, message2);
      const event = await raceEvent(this, "presence", options2.signal, {
        filter: (event2) => {
          return peerId.equals(event2.detail.sender) && equals3(cid.multihash.digest, event2.detail.cid.multihash.digest);
        }
      });
      return event.detail;
    }
    /**
     * Add a CID to the wantlist
     */
    async wantBlock(cid, options2 = {}) {
      return this.addEntry(cid, {
        ...options2,
        wantType: WantType.WantBlock
      });
    }
    /**
     * Add a CID to the wantlist
     */
    async wantSessionBlock(cid, peerId, options2 = {}) {
      const message2 = new QueuedBitswapMessage();
      message2.addWantlistEntry(cid, {
        cid: cid.bytes,
        sendDontHave: true,
        wantType: WantType.WantBlock,
        priority: 1
      });
      await this.network.sendMessage(peerId, message2);
      const event = await raceEvent(this, "presence", options2.signal, {
        filter: (event2) => {
          return peerId.equals(event2.detail.sender) && equals3(cid.multihash.digest, event2.detail.cid.multihash.digest);
        }
      });
      return event.detail;
    }
    /**
     * Invoked when a block has been received from an external source
     */
    async receivedBlock(cid, options2) {
      const cidStr = toString2(cid.multihash.bytes, "base64");
      const entry = this.wants.get(cidStr);
      if (entry == null) {
        return;
      }
      entry.cancel = true;
      await this.sendMessagesDebounced();
    }
    /**
     * Invoked when a message is received from a bitswap peer
     */
    async receiveMessage(sender, message2) {
      this.log("received message from %p with %d blocks", sender, message2.blocks.length);
      let blocksCancelled = false;
      for (const block of message2.blocks) {
        if (block.prefix == null || block.data == null) {
          continue;
        }
        const values = varint_decoder_default(block.prefix);
        const cidVersion = values[0];
        const multicodec2 = values[1];
        const hashAlg = values[2];
        const hasher = hashAlg === sha256.code ? sha256 : await this.hashLoader?.getHasher(hashAlg);
        if (hasher == null) {
          this.log.error("unknown hash algorithm", hashAlg);
          continue;
        }
        let hash = hasher.digest(block.data);
        if (hash.then != null) {
          hash = await hash;
        }
        const cid = CID.create(cidVersion === 0 ? 0 : 1, multicodec2, hash);
        this.log("received block from %p for %c", sender, cid);
        this.safeDispatchEvent("block", {
          detail: {
            sender,
            cid,
            block: block.data
          }
        });
        this.safeDispatchEvent("presence", {
          detail: {
            sender,
            cid,
            has: true,
            block: block.data
          }
        });
        const cidStr = toString2(cid.multihash.bytes, "base64");
        const entry = this.wants.get(cidStr);
        if (entry == null) {
          continue;
        }
        entry.cancel = true;
        blocksCancelled = true;
      }
      for (const { cid: cidBytes, type } of message2.blockPresences) {
        const cid = CID.decode(cidBytes);
        this.log("received %s from %p for %c", type, sender, cid);
        this.safeDispatchEvent("presence", {
          detail: {
            sender,
            cid,
            has: type === BlockPresenceType.HaveBlock
          }
        });
      }
      if (blocksCancelled) {
        await this.sendMessagesDebounced();
      }
    }
    /**
     * Invoked when the network topology notices a new peer that supports Bitswap
     */
    async peerConnected(peerId) {
      const sentWants = /* @__PURE__ */ new Set();
      const message2 = new QueuedBitswapMessage(true);
      for (const [key, entry] of this.wants.entries()) {
        if (entry.cancel) {
          continue;
        }
        sentWants.add(key);
        message2.addWantlistEntry(entry.cid, {
          cid: entry.cid.bytes,
          priority: 1,
          wantType: WantType.WantBlock,
          cancel: false,
          sendDontHave: false
        });
      }
      if (message2.wantlist.size === 0) {
        this.peers.set(peerId, sentWants);
        return;
      }
      try {
        await this.network.sendMessage(peerId, message2);
        this.peers.set(peerId, sentWants);
      } catch (err2) {
        this.log.error("error sending full wantlist to new peer %p - %e", peerId, err2);
      }
    }
    /**
     * Invoked when the network topology notices peer that supports Bitswap has
     * disconnected
     */
    peerDisconnected(peerId) {
      this.peers.delete(peerId);
    }
    start() {
    }
    stop() {
      this.peers.clear();
      clearTimeout(this.sendMessagesTimeout);
    }
  };

  // node_modules/@helia/bitswap/dist/src/bitswap.js
  var Bitswap = class {
    log;
    logger;
    stats;
    network;
    blockstore;
    peerWantLists;
    wantList;
    libp2p;
    constructor(components, init = {}) {
      this.logger = components.logger;
      this.log = components.logger.forComponent("helia:bitswap");
      this.blockstore = components.blockstore;
      this.libp2p = components.libp2p;
      this.stats = new Stats(components);
      this.network = new Network(components, init);
      this.peerWantLists = new PeerWantLists({
        ...components,
        network: this.network
      }, init);
      this.wantList = new WantList({
        ...components,
        network: this.network
      }, init);
    }
    createSession(options2 = {}) {
      return createBitswapSession({
        wantList: this.wantList,
        network: this.network,
        logger: this.logger,
        libp2p: this.libp2p
      }, options2);
    }
    async want(cid, options2 = {}) {
      const controller = new AbortController();
      const signal = anySignal([controller.signal, options2.signal]);
      setMaxListeners(Infinity, controller.signal, signal);
      this.network.findAndConnect(cid, {
        ...options2,
        signal
      }).catch((err2) => {
        if (!controller.signal.aborted) {
          this.log.error("error during finding and connect for cid %c - %e", cid, err2);
        }
      });
      try {
        const result = await this.wantList.wantBlock(cid, {
          ...options2,
          signal
        });
        options2.onProgress?.(new CustomProgressEvent("bitswap:block", { cid, sender: result.sender }));
        return result.block;
      } finally {
        controller.abort();
        signal.clear();
      }
    }
    /**
     * Sends notifications about the arrival of a block
     */
    async notify(cid, options2 = {}) {
      await Promise.all([
        this.peerWantLists.receivedBlock(cid, options2),
        this.wantList.receivedBlock(cid, options2)
      ]);
    }
    getWantlist() {
      return [...this.wantList.wants.values()].filter((entry) => !entry.cancel).map((entry) => ({
        cid: entry.cid,
        priority: entry.priority,
        wantType: entry.wantType
      }));
    }
    getPeerWantlist(peer) {
      return this.peerWantLists.wantListForPeer(peer);
    }
    /**
     * Start the bitswap node
     */
    async start() {
      this.wantList.start();
      await this.network.start();
    }
    /**
     * Stop the bitswap node
     */
    async stop() {
      this.wantList.stop();
      await this.network.stop();
    }
  };

  // node_modules/@helia/bitswap/dist/src/index.js
  var createBitswap = (components, options2 = {}) => {
    return new Bitswap(components, options2);
  };

  // node_modules/@helia/block-brokers/dist/src/bitswap.js
  var BitswapBlockBroker = class {
    bitswap;
    started;
    constructor(components, init = {}) {
      const { getHasher: getHasher2 } = components;
      this.bitswap = createBitswap(components, {
        hashLoader: {
          getHasher: async (codecOrName) => {
            return getHasher2(codecOrName);
          }
        },
        ...init
      });
      this.started = false;
    }
    isStarted() {
      return this.started;
    }
    async start() {
      await this.bitswap.start();
      this.started = true;
    }
    async stop() {
      await this.bitswap.stop();
      this.started = false;
    }
    async announce(cid, options2) {
      await this.bitswap.notify(cid, options2);
    }
    async retrieve(cid, options2 = {}) {
      return this.bitswap.want(cid, options2);
    }
    createSession(options2) {
      const session = this.bitswap.createSession(options2);
      return {
        announce: async (cid, options3) => {
          await this.bitswap.notify(cid, options3);
        },
        retrieve: async (cid, options3) => {
          return session.retrieve(cid, options3);
        }
      };
    }
  };
  function bitswap(init = {}) {
    return (components) => new BitswapBlockBroker(components, init);
  }

  // node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
  var ASSUME_HTTP_CODES = [
    CODE_TCP,
    CODE_DNS,
    CODE_DNSADDR,
    CODE_DNS4,
    CODE_DNS6
  ];
  function extractSNI(ma) {
    return extractTuple("sni", ma)?.value;
  }
  function extractPort(ma) {
    const port = extractTuple("tcp", ma)?.value;
    if (port == null) {
      return "";
    }
    return `:${port}`;
  }
  function extractTuple(name9, ma) {
    return ma.find((component) => component.name === name9);
  }
  function hasTLS(ma) {
    return ma.some(({ code: code8 }) => code8 === CODE_TLS);
  }
  function interpretNext(head, rest) {
    const interpreter = interpreters[head.name];
    if (interpreter == null) {
      throw new Error(`Can't interpret protocol ${head.name}`);
    }
    const restVal = interpreter(head, rest);
    if (head.code === CODE_IP6) {
      return `[${restVal}]`;
    }
    return restVal;
  }
  var interpreters = {
    ip4: (head, rest) => head.value,
    ip6: (head, rest) => {
      if (rest.length === 0) {
        return head.value;
      }
      return `[${head.value}]`;
    },
    tcp: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `tcp://${interpretNext(tail, rest)}:${head.value}`;
    },
    udp: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `udp://${interpretNext(tail, rest)}:${head.value}`;
    },
    dnsaddr: (head, rest) => head.value,
    dns4: (head, rest) => head.value,
    dns6: (head, rest) => head.value,
    dns: (head, rest) => head.value,
    ipfs: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `${interpretNext(tail, rest)}`;
    },
    p2p: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `${interpretNext(tail, rest)}`;
    },
    http: (head, rest) => {
      const maHasTLS = hasTLS(rest);
      const sni = extractSNI(rest);
      const port = extractPort(rest);
      if (maHasTLS && sni != null) {
        return `https://${sni}${port}`;
      }
      const protocol = maHasTLS ? "https://" : "http://";
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tail, rest);
      baseVal = baseVal?.replace("tcp://", "");
      return `${protocol}${baseVal}`;
    },
    "http-path": (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      const baseVal = interpretNext(tail, rest);
      const decodedValue = decodeURIComponent(head.value ?? "");
      return `${baseVal}${decodedValue}`;
    },
    tls: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return interpretNext(tail, rest);
    },
    sni: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return interpretNext(tail, rest);
    },
    https: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tail, rest);
      baseVal = baseVal?.replace("tcp://", "");
      return `https://${baseVal}`;
    },
    ws: (head, rest) => {
      const maHasTLS = hasTLS(rest);
      const sni = extractSNI(rest);
      const port = extractPort(rest);
      if (maHasTLS && sni != null) {
        return `wss://${sni}${port}`;
      }
      const protocol = maHasTLS ? "wss://" : "ws://";
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tail, rest);
      baseVal = baseVal?.replace("tcp://", "");
      return `${protocol}${baseVal}`;
    },
    wss: (head, rest) => {
      const tail = rest.pop();
      if (tail == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tail, rest);
      baseVal = baseVal?.replace("tcp://", "");
      return `wss://${baseVal}`;
    }
  };
  function multiaddrToUri(input, opts) {
    const ma = multiaddr(input);
    const components = ma.getComponents();
    const head = components.pop();
    if (head == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const interpreter = interpreters[head.name];
    if (interpreter == null) {
      throw new Error(`No interpreter found for ${head.name}`);
    }
    let uri = interpreter(head, components) ?? "";
    if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head.code)) {
      uri = uri.replace(/^.*:\/\//, "");
      if (head.value === "443") {
        uri = `https://${uri}`;
      } else {
        uri = `http://${uri}`;
      }
    }
    if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
      uri = new URL(uri).toString();
      if (uri.endsWith("/")) {
        uri = uri.substring(0, uri.length - 1);
      }
    }
    return uri;
  }

  // node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
  var code7 = (code8) => {
    return {
      match: (vals) => {
        const component = vals[0];
        if (component == null) {
          return false;
        }
        if (component.code !== code8) {
          return false;
        }
        if (component.value != null) {
          return false;
        }
        return vals.slice(1);
      }
    };
  };
  var value = (code8, value2) => {
    return {
      match: (vals) => {
        const component = vals[0];
        if (component?.code !== code8) {
          return false;
        }
        if (component.value == null) {
          return false;
        }
        if (value2 != null && component.value !== value2) {
          return false;
        }
        return vals.slice(1);
      }
    };
  };
  var not = (matcher) => {
    return {
      match: (vals) => {
        const result = matcher.match(vals);
        if (result === false) {
          return vals;
        }
        return false;
      }
    };
  };
  var optional = (matcher) => {
    return {
      match: (vals) => {
        const result = matcher.match(vals);
        if (result === false) {
          return vals;
        }
        return result;
      }
    };
  };
  var or2 = (...matchers) => {
    return {
      match: (vals) => {
        let matches;
        for (const matcher of matchers) {
          const result = matcher.match(vals);
          if (result === false) {
            continue;
          }
          if (matches == null || result.length < matches.length) {
            matches = result;
          }
        }
        if (matches == null) {
          return false;
        }
        return matches;
      }
    };
  };
  var and = (...matchers) => {
    return {
      match: (vals) => {
        for (const matcher of matchers) {
          const result = matcher.match(vals);
          if (result === false) {
            return false;
          }
          vals = result;
        }
        return vals;
      }
    };
  };
  function fmt(...matchers) {
    function match(ma) {
      if (ma == null) {
        return false;
      }
      let parts = ma.getComponents();
      for (const matcher of matchers) {
        const result = matcher.match(parts);
        if (result === false) {
          return false;
        }
        parts = result;
      }
      return parts;
    }
    function matches(ma) {
      const result = match(ma);
      return result !== false;
    }
    function exactMatch(ma) {
      const result = match(ma);
      if (result === false) {
        return false;
      }
      return result.length === 0;
    }
    return {
      matchers,
      matches,
      exactMatch
    };
  }

  // node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
  var _PEER_ID = value(CODE_P2P);
  var PEER_ID = fmt(_PEER_ID);
  var _DNS4 = value(CODE_DNS4);
  var _DNS6 = value(CODE_DNS6);
  var _DNSADDR = value(CODE_DNSADDR);
  var _DNS = value(CODE_DNS);
  var DNS4 = fmt(_DNS4, optional(value(CODE_P2P)));
  var DNS6 = fmt(_DNS6, optional(value(CODE_P2P)));
  var DNSADDR = fmt(_DNSADDR, optional(value(CODE_P2P)));
  var DNS2 = fmt(or2(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P)));
  var _IP4 = and(value(CODE_IP4), optional(value(CODE_IPCIDR)));
  var _IP6 = and(optional(value(CODE_IP6ZONE)), value(CODE_IP6), optional(value(CODE_IPCIDR)));
  var _IP = or2(_IP4, _IP6);
  var _IP_OR_DOMAIN = or2(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
  var IP_OR_DOMAIN = fmt(or2(_IP, and(or2(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P)))));
  var IP4 = fmt(_IP4);
  var IP6 = fmt(_IP6);
  var IP = fmt(_IP);
  var _TCP = and(_IP_OR_DOMAIN, value(CODE_TCP));
  var _UDP = and(_IP_OR_DOMAIN, value(CODE_UDP));
  var TCP = fmt(and(_TCP, optional(value(CODE_P2P))));
  var UDP = fmt(_UDP);
  var _QUIC = and(_UDP, code7(CODE_QUIC), optional(value(CODE_P2P)));
  var _QUIC_V1 = and(_UDP, code7(CODE_QUIC_V1), optional(value(CODE_P2P)));
  var QUIC_V0_OR_V1 = or2(_QUIC, _QUIC_V1);
  var QUIC = fmt(_QUIC);
  var QUIC_V1 = fmt(_QUIC_V1);
  var _WEB = or2(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUIC_V1);
  var _WebSockets = or2(and(_WEB, code7(CODE_WS), optional(value(CODE_P2P))));
  var WebSockets = fmt(_WebSockets);
  var _WebSocketsSecure = or2(and(_WEB, code7(CODE_WSS), optional(value(CODE_P2P))), and(_WEB, code7(CODE_TLS), optional(value(CODE_SNI)), code7(CODE_WS), optional(value(CODE_P2P))));
  var WebSocketsSecure = fmt(_WebSocketsSecure);
  var _WebRTCDirect = and(_UDP, code7(CODE_WEBRTC_DIRECT), optional(value(CODE_CERTHASH)), optional(value(CODE_CERTHASH)), optional(value(CODE_P2P)));
  var WebRTCDirect = fmt(_WebRTCDirect);
  var _WebTransport = and(_QUIC_V1, code7(CODE_WEBTRANSPORT), optional(value(CODE_CERTHASH)), optional(value(CODE_CERTHASH)), optional(value(CODE_P2P)));
  var WebTransport = fmt(_WebTransport);
  var _P2P = or2(_WebSockets, _WebSocketsSecure, and(_TCP, optional(value(CODE_P2P))), and(QUIC_V0_OR_V1, optional(value(CODE_P2P))), and(_IP_OR_DOMAIN, optional(value(CODE_P2P))), _WebRTCDirect, _WebTransport, value(CODE_P2P));
  var P2P = fmt(_P2P);
  var _Circuit = and(optional(_P2P), code7(CODE_P2P_CIRCUIT), not(code7(CODE_WEBRTC)), optional(value(CODE_P2P)));
  var Circuit = fmt(_Circuit);
  var _WebRTC = or2(and(_P2P, code7(CODE_P2P_CIRCUIT), code7(CODE_WEBRTC), optional(value(CODE_P2P))), and(_P2P, code7(CODE_WEBRTC), optional(value(CODE_P2P))), and(code7(CODE_WEBRTC), optional(value(CODE_P2P))));
  var WebRTC = fmt(_WebRTC);
  var _HTTP = or2(and(_IP_OR_DOMAIN, value(CODE_TCP), code7(CODE_HTTP), optional(value(CODE_P2P))), and(_IP_OR_DOMAIN, code7(CODE_HTTP), optional(value(CODE_P2P))));
  var HTTP = fmt(_HTTP);
  var _HTTPS = and(_IP_OR_DOMAIN, or2(and(value(CODE_TCP, "443"), code7(CODE_HTTP)), and(value(CODE_TCP), code7(CODE_HTTPS)), and(value(CODE_TCP), code7(CODE_TLS), code7(CODE_HTTP)), and(code7(CODE_TLS), code7(CODE_HTTP)), code7(CODE_TLS), code7(CODE_HTTPS)), optional(value(CODE_P2P)));
  var HTTPS = fmt(_HTTPS);
  var _Memory = or2(and(value(CODE_MEMORY), optional(value(CODE_P2P))));
  var Memory = fmt(_Memory);
  var _Unix = or2(and(value(CODE_UNIX), optional(value(CODE_P2P))));
  var Unix = fmt(_Unix);

  // node_modules/@helia/block-brokers/dist/src/trustless-gateway/utils.js
  function filterNonHTTPMultiaddrs(multiaddrs, allowInsecure, allowLocal) {
    return multiaddrs.filter((ma) => {
      if (HTTPS.matches(ma) || allowInsecure && HTTP.matches(ma)) {
        if (allowLocal) {
          return true;
        }
        if (DNS2.matches(ma)) {
          return true;
        }
        return isPrivate(ma) === false;
      }
      if (!allowInsecure && allowLocal) {
        const { host } = getNetConfig(ma);
        if (host === "127.0.0.1" || host === "localhost" || host.endsWith(".localhost")) {
          return true;
        }
      }
      return false;
    });
  }
  async function* findHttpGatewayProviders(cid, routing, logger2, allowInsecure, allowLocal, options2 = {}) {
    for await (const provider of routing.findProviders(cid, options2)) {
      const httpAddresses = filterNonHTTPMultiaddrs(provider.multiaddrs, allowInsecure, allowLocal);
      if (httpAddresses.length === 0) {
        continue;
      }
      const uri = multiaddrToUri(httpAddresses[0]);
      const prov = {
        type: "trustless-gateway",
        cid,
        url: uri.toString(),
        routing: provider.routing
      };
      options2?.onProgress?.(new CustomProgressEvent("trustless-gateway:found-provider", prov));
      yield new TrustlessGateway(uri, { logger: logger2, transformRequestInit: options2.transformRequestInit });
    }
  }
  async function limitedResponse(response, byteLimit, options2) {
    const { signal, log: log18 } = options2 ?? {};
    const contentLength = response.headers.get("content-length");
    if (contentLength != null) {
      const contentLengthNumber = parseInt(contentLength, 10);
      if (contentLengthNumber > byteLimit) {
        log18?.error("content-length header (%d) is greater than the limit (%d)", contentLengthNumber, byteLimit);
        if (response.body != null) {
          await response.body.cancel().catch((err2) => {
            log18?.error("error cancelling response body after content-length check - %e", err2);
          });
        }
        throw new Error(`Content-Length header (${contentLengthNumber}) is greater than the limit (${byteLimit}).`);
      }
    }
    const reader2 = response.body?.getReader();
    if (reader2 == null) {
      throw new Error("Response body is not readable");
    }
    const chunkList = new Uint8ArrayList();
    try {
      while (true) {
        if (signal?.aborted === true) {
          throw new Error("Response body read was aborted.");
        }
        const { done, value: value2 } = await reader2.read();
        if (done) {
          break;
        }
        chunkList.append(value2);
        if (chunkList.byteLength > byteLimit) {
          throw new Error(`Response body is greater than the limit (${byteLimit}), received ${chunkList.byteLength} bytes.`);
        }
      }
    } finally {
      reader2.cancel().catch((err2) => {
        log18?.error("error cancelling reader - %e", err2);
      }).finally(() => {
        reader2.releaseLock();
      });
    }
    return chunkList.subarray();
  }

  // node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js
  var TrustlessGateway = class {
    url;
    /**
     * The number of times this gateway has been attempted to be used to fetch a
     * block. This includes successful, errored, and aborted attempts. By counting
     * even aborted attempts, slow gateways that are out-raced by others will be
     * considered less reliable.
     */
    #attempts = 0;
    /**
     * The number of times this gateway has errored while attempting to fetch a
     * block. This includes `response.ok === false` and any other errors that
     * throw while attempting to fetch a block. This does not include aborted
     * attempts.
     */
    #errors = 0;
    /**
     * The number of times this gateway has returned an invalid block. A gateway
     * that returns the wrong blocks for a CID should be considered for removal
     * from the list of gateways to fetch blocks from.
     */
    #invalidBlocks = 0;
    /**
     * The number of times this gateway has successfully fetched a block.
     */
    #successes = 0;
    /**
     * A map of pending responses for this gateway. This is used to ensure that
     * only one request per CID is made to a given gateway at a time, and that we
     * don't make multiple in-flight requests for the same CID to the same gateway.
     */
    #pendingResponses = /* @__PURE__ */ new Map();
    log;
    transformRequestInit;
    constructor(url, { logger: logger2, transformRequestInit }) {
      this.url = url instanceof URL ? url : new URL(url);
      this.transformRequestInit = transformRequestInit;
      this.log = logger2.forComponent(`helia:trustless-gateway-block-broker:${this.url.hostname}`);
    }
    /**
     * This function returns a unique string for the multihash.bytes of the CID.
     *
     * Some useful resources for why this is needed can be found using the links below:
     *
     * - https://github.com/ipfs/helia/pull/503#discussion_r1572451331
     * - https://github.com/ipfs/kubo/issues/6815
     * - https://www.notion.so/pl-strflt/Handling-ambiguity-around-CIDs-9d5e14f6516f438980b01ef188efe15d#d9d45cd1ed8b4d349b96285de4aed5ab
     */
    #uniqueBlockId(cid) {
      const multihashBytes = cid.multihash.bytes;
      return base64.encode(multihashBytes);
    }
    /**
     * Fetch a raw block from `this.url` following the specification defined at
     * https://specs.ipfs.tech/http-gateways/trustless-gateway/
     */
    async getRawBlock(cid, { signal, maxSize = DEFAULT_MAX_SIZE } = {}) {
      const gwUrl = new URL(this.url.toString());
      gwUrl.pathname = `/ipfs/${cid.toString()}`;
      gwUrl.search = "?format=raw";
      if (signal?.aborted === true) {
        throw new Error(`Signal to fetch raw block for CID ${cid} from gateway ${this.url} was aborted prior to fetch`);
      }
      const blockId = this.#uniqueBlockId(cid);
      const innerController = new AbortController();
      const abortInnerSignal = () => {
        innerController.abort();
      };
      signal?.addEventListener("abort", abortInnerSignal);
      try {
        let pendingResponse = this.#pendingResponses.get(blockId);
        if (pendingResponse == null) {
          this.#attempts++;
          const defaultReqInit = {
            signal: innerController.signal,
            headers: {
              Accept: "application/vnd.ipld.raw"
            },
            cache: "force-cache"
          };
          const reqInit = this.transformRequestInit != null ? await this.transformRequestInit(defaultReqInit) : defaultReqInit;
          pendingResponse = fetch(gwUrl.toString(), reqInit).then(async (res) => {
            this.log("GET %s %d", gwUrl, res.status);
            if (!res.ok) {
              this.#errors++;
              throw new Error(`unable to fetch raw block for CID ${cid} from gateway ${this.url}`);
            }
            const body = await limitedResponse(res, maxSize, { signal: innerController.signal, log: this.log });
            this.#successes++;
            return body;
          });
          this.#pendingResponses.set(blockId, pendingResponse);
        }
        return await pendingResponse;
      } catch (cause) {
        if (signal?.aborted === true) {
          throw new Error(`fetching raw block for CID ${cid} from gateway ${this.url} was aborted`);
        }
        this.#errors++;
        throw new Error(`unable to fetch raw block for CID ${cid}`);
      } finally {
        signal?.removeEventListener("abort", abortInnerSignal);
        this.#pendingResponses.delete(blockId);
      }
    }
    /**
     * Encapsulate the logic for determining whether a gateway is considered
     * reliable, for prioritization. This is based on the number of successful attempts made
     * and the number of errors encountered.
     *
     * Unused gateways have 100% reliability; They will be prioritized over
     * gateways with a 100% success rate to ensure that we attempt all gateways.
     */
    reliability() {
      if (this.#attempts === 0) {
        return 1;
      }
      if (this.#invalidBlocks > 0) {
        return -Infinity;
      }
      return this.#successes / (this.#attempts + this.#errors * 3);
    }
    /**
     * Increment the number of invalid blocks returned by this gateway.
     */
    incrementInvalidBlocks() {
      this.#invalidBlocks++;
    }
    getStats() {
      return {
        attempts: this.#attempts,
        errors: this.#errors,
        invalidBlocks: this.#invalidBlocks,
        successes: this.#successes,
        pendingResponses: this.#pendingResponses.size
      };
    }
  };

  // node_modules/@helia/block-brokers/dist/src/trustless-gateway/session.js
  var TrustlessGatewaySession = class extends AbstractSession {
    routing;
    allowInsecure;
    allowLocal;
    transformRequestInit;
    constructor(components, init) {
      super(components, {
        ...init,
        name: "helia:trustless-gateway:session"
      });
      this.routing = components.routing;
      this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
      this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
      this.transformRequestInit = init.transformRequestInit;
    }
    async queryProvider(cid, provider, options2) {
      this.log("fetching BLOCK for %c from %s", cid, provider.url);
      const block = await provider.getRawBlock(cid, options2);
      this.log.trace("got block for %c from %s", cid, provider.url);
      await options2.validateFn?.(block);
      return block;
    }
    async *findNewProviders(cid, options2 = {}) {
      yield* findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, { ...options2, transformRequestInit: this.transformRequestInit });
    }
    toEvictionKey(provider) {
      return provider.url.toString();
    }
    equals(providerA, providerB) {
      return providerA.url.toString() === providerB.url.toString();
    }
    async convertToProvider(provider, options2) {
      if (isPeerId(provider)) {
        return;
      }
      const httpAddresses = filterNonHTTPMultiaddrs(Array.isArray(provider) ? provider : [provider], this.allowInsecure, this.allowLocal);
      if (httpAddresses.length === 0) {
        return;
      }
      const uri = multiaddrToUri(httpAddresses[0]);
      return new TrustlessGateway(uri, {
        logger: this.logger,
        transformRequestInit: this.transformRequestInit
      });
    }
  };
  function createTrustlessGatewaySession(components, init) {
    return new TrustlessGatewaySession(components, init);
  }

  // node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js
  var TrustlessGatewayBlockBroker = class {
    allowInsecure;
    allowLocal;
    transformRequestInit;
    routing;
    log;
    logger;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("helia:trustless-gateway-block-broker");
      this.logger = components.logger;
      this.routing = components.routing;
      this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
      this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
      this.transformRequestInit = init.transformRequestInit;
    }
    async retrieve(cid, options2 = {}) {
      const aggregateErrors = [];
      for await (const gateway of findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, { ...options2, transformRequestInit: this.transformRequestInit })) {
        this.log("getting block for %c from %s", cid, gateway.url);
        try {
          const block = await gateway.getRawBlock(cid, options2);
          this.log.trace("got block for %c from %s", cid, gateway.url);
          try {
            await options2.validateFn?.(block);
          } catch (err2) {
            this.log.error("failed to validate block for %c from %s - %e", cid, gateway.url, err2);
            continue;
          }
          return block;
        } catch (err2) {
          this.log.error("failed to get block for %c from %s - %e", cid, gateway.url, err2);
          if (err2 instanceof Error) {
            aggregateErrors.push(err2);
          } else {
            aggregateErrors.push(new Error(`Unable to fetch raw block for CID ${cid} from gateway ${gateway.url}`));
          }
          if (options2.signal?.aborted === true) {
            this.log.trace("request aborted while fetching raw block for CID %c from gateway %s", cid, gateway.url);
            break;
          }
        }
      }
      if (aggregateErrors.length > 0) {
        throw new AggregateError(aggregateErrors, `Unable to fetch raw block for CID ${cid} from any gateway`);
      } else {
        throw new Error(`Unable to fetch raw block for CID ${cid} from any gateway`);
      }
    }
    createSession(options2 = {}) {
      return createTrustlessGatewaySession({
        logger: this.logger,
        routing: this.routing
      }, {
        ...options2,
        allowLocal: this.allowLocal,
        allowInsecure: this.allowInsecure,
        transformRequestInit: this.transformRequestInit
      });
    }
  };

  // node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js
  var DEFAULT_ALLOW_INSECURE = false;
  var DEFAULT_ALLOW_LOCAL = false;
  var DEFAULT_MAX_SIZE = 2097152;
  function trustlessGateway(init = {}) {
    return (components) => new TrustlessGatewayBlockBroker(components, init);
  }

  // node_modules/browser-readablestream-to-it/dist/src/index.js
  async function* browserReadableStreamToIt(stream, options2 = {}) {
    const reader2 = stream.getReader();
    try {
      while (true) {
        const result = await reader2.read();
        if (result.done) {
          return;
        }
        yield result.value;
      }
    } finally {
      if (options2.preventCancel !== true) {
        await reader2.cancel();
      }
      reader2.releaseLock();
    }
  }

  // node_modules/ipns/dist/src/index.js
  var import_timestamp_nano = __toESM(require_timestamp_min(), 1);

  // node_modules/ipns/dist/src/errors.js
  var SignatureVerificationError = class extends Error {
    static name = "SignatureVerificationError";
    constructor(message2 = "Record signature verification failed") {
      super(message2);
      this.name = "SignatureVerificationError";
    }
  };
  var RecordExpiredError = class extends Error {
    static name = "RecordExpiredError";
    constructor(message2 = "Record has expired") {
      super(message2);
      this.name = "RecordExpiredError";
    }
  };
  var UnsupportedValidityError = class extends Error {
    static name = "UnsupportedValidityError";
    constructor(message2 = "The validity type is unsupported") {
      super(message2);
      this.name = "UnsupportedValidityError";
    }
  };
  var RecordTooLargeError = class extends Error {
    static name = "RecordTooLargeError";
    constructor(message2 = "The record is too large") {
      super(message2);
      this.name = "RecordTooLargeError";
    }
  };
  var InvalidValueError = class extends Error {
    static name = "InvalidValueError";
    constructor(message2 = "Value must be a valid content path starting with /") {
      super(message2);
      this.name = "InvalidValueError";
    }
  };
  var InvalidRecordDataError = class extends Error {
    static name = "InvalidRecordDataError";
    constructor(message2 = "Invalid record data") {
      super(message2);
      this.name = "InvalidRecordDataError";
    }
  };
  var InvalidEmbeddedPublicKeyError = class extends Error {
    static name = "InvalidEmbeddedPublicKeyError";
    constructor(message2 = "Invalid embedded public key") {
      super(message2);
      this.name = "InvalidEmbeddedPublicKeyError";
    }
  };

  // node_modules/ipns/dist/src/pb/ipns.js
  var IpnsEntry;
  (function(IpnsEntry2) {
    let ValidityType;
    (function(ValidityType2) {
      ValidityType2["EOL"] = "EOL";
    })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
    let __ValidityTypeValues;
    (function(__ValidityTypeValues2) {
      __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
    })(__ValidityTypeValues || (__ValidityTypeValues = {}));
    (function(ValidityType2) {
      ValidityType2.codec = () => {
        return enumeration(__ValidityTypeValues);
      };
    })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
    let _codec;
    IpnsEntry2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.value != null) {
            w.uint32(10);
            w.bytes(obj.value);
          }
          if (obj.signatureV1 != null) {
            w.uint32(18);
            w.bytes(obj.signatureV1);
          }
          if (obj.validityType != null) {
            w.uint32(24);
            IpnsEntry2.ValidityType.codec().encode(obj.validityType, w);
          }
          if (obj.validity != null) {
            w.uint32(34);
            w.bytes(obj.validity);
          }
          if (obj.sequence != null) {
            w.uint32(40);
            w.uint64(obj.sequence);
          }
          if (obj.ttl != null) {
            w.uint32(48);
            w.uint64(obj.ttl);
          }
          if (obj.pubKey != null) {
            w.uint32(58);
            w.bytes(obj.pubKey);
          }
          if (obj.signatureV2 != null) {
            w.uint32(66);
            w.bytes(obj.signatureV2);
          }
          if (obj.data != null) {
            w.uint32(74);
            w.bytes(obj.data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.value = reader2.bytes();
                break;
              }
              case 2: {
                obj.signatureV1 = reader2.bytes();
                break;
              }
              case 3: {
                obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader2);
                break;
              }
              case 4: {
                obj.validity = reader2.bytes();
                break;
              }
              case 5: {
                obj.sequence = reader2.uint64();
                break;
              }
              case 6: {
                obj.ttl = reader2.uint64();
                break;
              }
              case 7: {
                obj.pubKey = reader2.bytes();
                break;
              }
              case 8: {
                obj.signatureV2 = reader2.bytes();
                break;
              }
              case 9: {
                obj.data = reader2.bytes();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    IpnsEntry2.encode = (obj) => {
      return encodeMessage(obj, IpnsEntry2.codec());
    };
    IpnsEntry2.decode = (buf2, opts) => {
      return decodeMessage(buf2, IpnsEntry2.codec(), opts);
    };
  })(IpnsEntry || (IpnsEntry = {}));

  // node_modules/ipns/dist/src/utils.js
  var log2 = logger("ipns:utils");
  var IPNS_PREFIX = fromString2("/ipns/");
  var IDENTITY_CODEC2 = 0;
  var SHA2_256_CODEC = 18;
  function extractPublicKeyFromIPNSRecord(record) {
    let pubKey;
    if (record.pubKey != null) {
      try {
        pubKey = publicKeyFromProtobuf(record.pubKey);
      } catch (err2) {
        log2.error(err2);
        throw err2;
      }
    }
    if (pubKey != null) {
      return pubKey;
    }
  }
  function ipnsRecordDataForV2Sig(data) {
    const entryData = fromString2("ipns-signature:");
    return concat([entryData, data]);
  }
  function marshalIPNSRecord(obj) {
    if ("signatureV1" in obj) {
      return IpnsEntry.encode({
        value: fromString2(obj.value),
        signatureV1: obj.signatureV1,
        validityType: obj.validityType,
        validity: fromString2(obj.validity),
        sequence: obj.sequence,
        ttl: obj.ttl,
        pubKey: obj.pubKey,
        signatureV2: obj.signatureV2,
        data: obj.data
      });
    } else {
      return IpnsEntry.encode({
        pubKey: obj.pubKey,
        signatureV2: obj.signatureV2,
        data: obj.data
      });
    }
  }
  function unmarshalIPNSRecord(buf2) {
    const message2 = IpnsEntry.decode(buf2);
    if (message2.sequence != null) {
      message2.sequence = BigInt(message2.sequence);
    }
    if (message2.ttl != null) {
      message2.ttl = BigInt(message2.ttl);
    }
    if (message2.signatureV2 == null || message2.data == null) {
      throw new SignatureVerificationError("Missing data or signatureV2");
    }
    const data = parseCborData(message2.data);
    const value2 = normalizeByteValue(data.Value);
    const validity = toString2(data.Validity);
    if (message2.value != null && message2.signatureV1 != null) {
      validateCborDataMatchesPbData(message2);
      return {
        value: value2,
        validityType: IpnsEntry.ValidityType.EOL,
        validity,
        sequence: data.Sequence,
        ttl: data.TTL,
        pubKey: message2.pubKey,
        signatureV1: message2.signatureV1,
        signatureV2: message2.signatureV2,
        data: message2.data
      };
    } else if (message2.signatureV2 != null) {
      return {
        value: value2,
        validityType: IpnsEntry.ValidityType.EOL,
        validity,
        sequence: data.Sequence,
        ttl: data.TTL,
        pubKey: message2.pubKey,
        signatureV2: message2.signatureV2,
        data: message2.data
      };
    } else {
      throw new Error("invalid record: does not include signatureV1 or signatureV2");
    }
  }
  function multihashToIPNSRoutingKey(digest2) {
    return concat([
      IPNS_PREFIX,
      digest2.bytes
    ]);
  }
  function multihashFromIPNSRoutingKey(key) {
    const digest2 = decode4(key.slice(IPNS_PREFIX.length));
    if (!isCodec(digest2, IDENTITY_CODEC2) && !isCodec(digest2, SHA2_256_CODEC)) {
      throw new InvalidMultihashError("Multihash in IPNS key was not identity or sha2-256");
    }
    return digest2;
  }
  function parseCborData(buf2) {
    const data = decode9(buf2);
    if (data.ValidityType === 0) {
      data.ValidityType = IpnsEntry.ValidityType.EOL;
    } else {
      throw new UnsupportedValidityError("The validity type is unsupported");
    }
    if (Number.isInteger(data.Sequence)) {
      data.Sequence = BigInt(data.Sequence);
    }
    if (Number.isInteger(data.TTL)) {
      data.TTL = BigInt(data.TTL);
    }
    return data;
  }
  function normalizeByteValue(value2) {
    const string2 = toString2(value2).trim();
    if (string2.startsWith("/")) {
      return string2;
    }
    try {
      return `/ipfs/${CID.decode(value2).toV1().toString()}`;
    } catch {
    }
    try {
      return `/ipfs/${CID.parse(string2).toV1().toString()}`;
    } catch {
    }
    throw new InvalidValueError("Value must be a valid content path starting with /");
  }
  function validateCborDataMatchesPbData(entry) {
    if (entry.data == null) {
      throw new InvalidRecordDataError("Record data is missing");
    }
    const data = parseCborData(entry.data);
    if (!equals3(data.Value, entry.value ?? new Uint8Array(0))) {
      throw new SignatureVerificationError('Field "value" did not match between protobuf and CBOR');
    }
    if (!equals3(data.Validity, entry.validity ?? new Uint8Array(0))) {
      throw new SignatureVerificationError('Field "validity" did not match between protobuf and CBOR');
    }
    if (data.ValidityType !== entry.validityType) {
      throw new SignatureVerificationError('Field "validityType" did not match between protobuf and CBOR');
    }
    if (data.Sequence !== entry.sequence) {
      throw new SignatureVerificationError('Field "sequence" did not match between protobuf and CBOR');
    }
    if (data.TTL !== entry.ttl) {
      throw new SignatureVerificationError('Field "ttl" did not match between protobuf and CBOR');
    }
  }
  function isCodec(digest2, codec) {
    return digest2.code === codec;
  }

  // node_modules/ipns/dist/src/index.js
  var log3 = logger("ipns");
  var DEFAULT_TTL_NS = 5 * 60 * 1e9;
  var namespace = "/ipns/";
  var namespaceLength = namespace.length;

  // node_modules/ipns/dist/src/validator.js
  var import_timestamp_nano2 = __toESM(require_timestamp_min(), 1);
  var log4 = logger("ipns:validator");
  var MAX_RECORD_SIZE = 1024 * 10;
  async function validate4(publicKey2, marshalledRecord) {
    const record = unmarshalIPNSRecord(marshalledRecord);
    let isValid2;
    try {
      const dataForSignature = ipnsRecordDataForV2Sig(record.data);
      isValid2 = await publicKey2.verify(dataForSignature, record.signatureV2);
    } catch (err2) {
      isValid2 = false;
    }
    if (!isValid2) {
      log4.error("record signature verification failed");
      throw new SignatureVerificationError("Record signature verification failed");
    }
    if (record.validityType === IpnsEntry.ValidityType.EOL) {
      if (import_timestamp_nano2.default.fromString(record.validity).toDate().getTime() < Date.now()) {
        log4.error("record has expired");
        throw new RecordExpiredError("record has expired");
      }
    } else if (record.validityType != null) {
      log4.error("the validity type is unsupported");
      throw new UnsupportedValidityError("The validity type is unsupported");
    }
    log4("ipns record for %s is valid", record.value);
  }
  async function ipnsValidator(routingKey, marshalledRecord) {
    if (marshalledRecord.byteLength > MAX_RECORD_SIZE) {
      throw new RecordTooLargeError("The record is too large");
    }
    const routingMultihash = multihashFromIPNSRoutingKey(routingKey);
    let routingPubKey;
    if (isCodec(routingMultihash, 0)) {
      routingPubKey = publicKeyFromMultihash(routingMultihash);
    }
    const receivedRecord = unmarshalIPNSRecord(marshalledRecord);
    const recordPubKey = extractPublicKeyFromIPNSRecord(receivedRecord) ?? routingPubKey;
    if (recordPubKey == null) {
      throw new InvalidEmbeddedPublicKeyError("Could not extract public key from IPNS record or routing key");
    }
    const expectedRoutingKey = multihashToIPNSRoutingKey(recordPubKey.toMultihash());
    if (!equals3(expectedRoutingKey, routingKey)) {
      throw new InvalidEmbeddedPublicKeyError("Embedded public key did not match routing key");
    }
    await validate4(recordPubKey, marshalledRecord);
  }

  // node_modules/it-ndjson/dist/src/errors.js
  var InvalidMessageLengthError3 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MESSAGE_LENGTH";
  };

  // node_modules/it-ndjson/dist/src/parse.js
  async function* parse2(source, opts = {}) {
    const matcher = /\r?\n/;
    const decoder = new TextDecoder("utf8");
    let buffer2 = "";
    for await (let chunk of source) {
      if (typeof chunk === "string") {
        chunk = new TextEncoder().encode(chunk);
      }
      if (isUint8ArrayList(chunk)) {
        chunk = chunk.subarray();
      }
      buffer2 += decoder.decode(chunk, { stream: true });
      if (buffer2.length > (opts?.maxMessageLength ?? buffer2.length)) {
        throw new InvalidMessageLengthError3("Incoming message too long");
      }
      const parts = buffer2.split(matcher);
      buffer2 = parts.pop() ?? "";
      for (let i2 = 0; i2 < parts.length; i2++) {
        yield JSON.parse(parts[i2]);
      }
    }
    buffer2 += decoder.decode();
    if (buffer2 !== "") {
      yield JSON.parse(buffer2);
    }
  }

  // node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/errors.js
  var InvalidRequestError = class extends Error {
    static name = "InvalidRequestError";
    constructor(message2 = "Invalid request") {
      super(message2);
      this.name = "InvalidRequestError";
    }
  };
  var BadResponseError = class extends Error {
    static name = "BadResponseError";
    constructor(message2 = "Bad response") {
      super(message2);
      this.name = "BadResponseError";
    }
  };

  // node_modules/it-first/dist/src/index.js
  function isAsyncIterable10(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function first(source) {
    if (isAsyncIterable10(source)) {
      return (async () => {
        for await (const entry of source) {
          return entry;
        }
        return void 0;
      })();
    }
    for (const entry of source) {
      return entry;
    }
    return void 0;
  }
  var src_default10 = first;

  // node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/routings.js
  var IPNS_PREFIX2 = fromString2("/ipns/");
  function isIPNSKey(key) {
    return equals3(key.subarray(0, IPNS_PREFIX2.byteLength), IPNS_PREFIX2);
  }
  var DelegatedRoutingV1HttpApiClientContentRouting = class {
    client;
    constructor(client) {
      this.client = client;
    }
    async *findProviders(cid, options2 = {}) {
      try {
        yield* src_default5(this.client.getProviders(cid, options2), (record) => {
          return {
            id: record.ID,
            multiaddrs: record.Addrs ?? [],
            routing: "delegated-http-routing-v1"
          };
        });
      } catch (err2) {
        if (err2 instanceof NotFoundError) {
          return;
        }
        throw err2;
      }
    }
    async provide() {
    }
    async cancelReprovide() {
    }
    async put(key, value2, options2) {
      if (!isIPNSKey(key)) {
        return;
      }
      const digest2 = multihashFromIPNSRoutingKey(key);
      const cid = CID.createV1(114, digest2);
      const record = unmarshalIPNSRecord(value2);
      await this.client.putIPNS(cid, record, options2);
    }
    async get(key, options2) {
      if (!isIPNSKey(key)) {
        throw new NotFoundError("Not found");
      }
      const digest2 = multihashFromIPNSRoutingKey(key);
      const cid = CID.createV1(114, digest2);
      try {
        const record = await this.client.getIPNS(cid, options2);
        return marshalIPNSRecord(record);
      } catch (err2) {
        if (err2.name === "BadResponseError") {
          throw new NotFoundError("Not found");
        }
        throw err2;
      }
    }
  };
  var DelegatedRoutingV1HttpApiClientPeerRouting = class {
    client;
    constructor(client) {
      this.client = client;
    }
    async findPeer(peerId, options2 = {}) {
      const peer = await src_default10(this.client.getPeers(peerId, options2));
      if (peer != null) {
        return {
          id: peer.ID,
          multiaddrs: peer.Addrs ?? []
        };
      }
      throw new NotFoundError("Not found");
    }
    async *getClosestPeers(key, options2 = {}) {
    }
  };

  // node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/client.js
  var log5 = logger("delegated-routing-v1-http-api-client");
  var defaultValues = {
    concurrentRequests: 4,
    timeout: 3e4,
    cacheTTL: 5 * 60 * 1e3,
    // 5 minutes default as per https://specs.ipfs.tech/routing/http-routing-v1/#response-headers
    cacheName: "delegated-routing-v1-cache"
  };
  var DefaultDelegatedRoutingV1HttpApiClient = class {
    started;
    httpQueue;
    shutDownController;
    clientUrl;
    timeout;
    contentRouting;
    peerRouting;
    filterAddrs;
    filterProtocols;
    inFlightRequests;
    cacheName;
    cache;
    cacheTTL;
    /**
     * Create a new DelegatedContentRouting instance
     */
    constructor(url, init = {}) {
      this.started = false;
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
      this.httpQueue = new PQueue({
        concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests
      });
      this.inFlightRequests = /* @__PURE__ */ new Map();
      this.clientUrl = url instanceof URL ? url : new URL(url);
      this.timeout = init.timeout ?? defaultValues.timeout;
      this.filterAddrs = init.filterAddrs;
      this.filterProtocols = init.filterProtocols;
      this.contentRouting = new DelegatedRoutingV1HttpApiClientContentRouting(this);
      this.peerRouting = new DelegatedRoutingV1HttpApiClientPeerRouting(this);
      this.cacheName = init.cacheName ?? defaultValues.cacheName;
      this.cacheTTL = init.cacheTTL ?? defaultValues.cacheTTL;
    }
    get [contentRoutingSymbol]() {
      return this.contentRouting;
    }
    get [peerRoutingSymbol]() {
      return this.peerRouting;
    }
    isStarted() {
      return this.started;
    }
    async start() {
      if (this.started) {
        return;
      }
      this.started = true;
      if (this.cacheTTL > 0) {
        this.cache = await globalThis.caches?.open(this.cacheName);
        if (this.cache != null) {
          log5("cache enabled with ttl %d", this.cacheTTL);
        }
      }
    }
    async stop() {
      this.httpQueue.clear();
      this.shutDownController.abort();
      await globalThis.caches?.delete(this.cacheName);
      this.started = false;
    }
    async *getProviders(cid, options2 = {}) {
      log5("getProviders starts: %c", cid);
      const timeoutSignal = AbortSignal.timeout(this.timeout);
      const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
      setMaxListeners(Infinity, timeoutSignal, signal);
      const onStart = pDefer();
      const onFinish = pDefer();
      void this.httpQueue.add(async () => {
        onStart.resolve();
        return onFinish.promise;
      });
      try {
        await onStart.promise;
        const url = new URL(`${this.clientUrl}routing/v1/providers/${cid}`);
        this.#addFilterParams(url, options2.filterAddrs, options2.filterProtocols);
        const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
        const res = await this.#makeRequest(url.toString(), getOptions);
        if (!res.ok) {
          if (res.status === 404) {
            return;
          }
          if (res.status === 422) {
            throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
          }
          throw new BadResponseError(`Unexpected status code: ${res.status}`);
        }
        if (res.body == null) {
          throw new BadResponseError("Routing response had no body");
        }
        const contentType = res.headers.get("Content-Type");
        if (contentType == null) {
          throw new BadResponseError("No Content-Type header received");
        }
        if (contentType.startsWith("application/json")) {
          const body = await res.json();
          const providers = body.Providers ?? [];
          for (const provider of providers) {
            const record = this.#conformToPeerSchema(provider);
            if (record != null) {
              yield record;
            }
          }
        } else if (contentType.includes("application/x-ndjson")) {
          for await (const provider of parse2(browserReadableStreamToIt(res.body))) {
            const record = this.#conformToPeerSchema(provider);
            if (record != null) {
              yield record;
            }
          }
        } else {
          throw new BadResponseError(`Unsupported Content-Type: ${contentType}`);
        }
      } finally {
        signal.clear();
        onFinish.resolve();
        log5("getProviders finished: %c", cid);
      }
    }
    async *getPeers(peerId, options2 = {}) {
      log5("getPeers starts: %c", peerId);
      const timeoutSignal = AbortSignal.timeout(this.timeout);
      const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
      setMaxListeners(Infinity, timeoutSignal, signal);
      const onStart = pDefer();
      const onFinish = pDefer();
      void this.httpQueue.add(async () => {
        onStart.resolve();
        return onFinish.promise;
      });
      try {
        await onStart.promise;
        const url = new URL(`${this.clientUrl}routing/v1/peers/${peerId.toCID().toString()}`);
        this.#addFilterParams(url, options2.filterAddrs, options2.filterProtocols);
        const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
        const res = await this.#makeRequest(url.toString(), getOptions);
        if (res.status === 404) {
          return;
        }
        if (res.status === 422) {
          throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
        }
        if (res.body == null) {
          throw new BadResponseError("Routing response had no body");
        }
        const contentType = res.headers.get("Content-Type");
        if (contentType?.startsWith("application/json")) {
          const body = await res.json();
          const peers = body.Peers ?? [];
          for (const peer of peers) {
            const record = this.#conformToPeerSchema(peer);
            if (record != null) {
              yield record;
            }
          }
        } else {
          for await (const peer of parse2(browserReadableStreamToIt(res.body))) {
            const record = this.#conformToPeerSchema(peer);
            if (record != null) {
              yield record;
            }
          }
        }
      } catch (err2) {
        log5.error("getPeers errored:", err2);
      } finally {
        signal.clear();
        onFinish.resolve();
        log5("getPeers finished: %c", peerId);
      }
    }
    async getIPNS(libp2pKey, options2 = {}) {
      log5("getIPNS starts: %s", libp2pKey);
      const timeoutSignal = AbortSignal.timeout(this.timeout);
      const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
      setMaxListeners(Infinity, timeoutSignal, signal);
      const onStart = pDefer();
      const onFinish = pDefer();
      void this.httpQueue.add(async () => {
        onStart.resolve();
        return onFinish.promise;
      });
      const resource = `${this.clientUrl}routing/v1/ipns/${libp2pKey}`;
      try {
        await onStart.promise;
        const getOptions = { headers: { Accept: "application/vnd.ipfs.ipns-record" }, signal };
        const res = await this.#makeRequest(resource, getOptions);
        log5("getIPNS GET %s %d", resource, res.status);
        if (res.status === 404) {
          throw new NotFoundError("No matching records found");
        }
        if (res.status === 422) {
          throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
        }
        if (!res.ok) {
          throw new BadResponseError(`Unexpected status code: ${res.status}`);
        }
        const contentType = res.headers.get("Content-Type");
        if (contentType == null || !contentType.includes("application/vnd.ipfs.ipns-record")) {
          throw new NotFoundError("No matching records found");
        }
        if (res.body == null) {
          throw new BadResponseError("GET ipns response had no body");
        }
        const buf2 = await res.arrayBuffer();
        const body = new Uint8Array(buf2, 0, buf2.byteLength);
        if (options2.validate !== false) {
          await ipnsValidator(multihashToIPNSRoutingKey(libp2pKey.multihash), body);
        }
        return unmarshalIPNSRecord(body);
      } catch (err2) {
        log5.error("getIPNS GET %s error:", resource, err2);
        throw err2;
      } finally {
        signal.clear();
        onFinish.resolve();
        log5("getIPNS finished: %s", libp2pKey);
      }
    }
    async putIPNS(libp2pKey, record, options2 = {}) {
      log5("putIPNS starts: %c", libp2pKey);
      const timeoutSignal = AbortSignal.timeout(this.timeout);
      const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
      setMaxListeners(Infinity, timeoutSignal, signal);
      const onStart = pDefer();
      const onFinish = pDefer();
      void this.httpQueue.add(async () => {
        onStart.resolve();
        return onFinish.promise;
      });
      const resource = `${this.clientUrl}routing/v1/ipns/${libp2pKey}`;
      try {
        await onStart.promise;
        const body = marshalIPNSRecord(record);
        const getOptions = { method: "PUT", headers: { "Content-Type": "application/vnd.ipfs.ipns-record" }, body, signal };
        const res = await this.#makeRequest(resource, getOptions);
        log5("putIPNS PUT %s %d", resource, res.status);
        if (res.status !== 200) {
          throw new BadResponseError("PUT ipns response had status other than 200");
        }
      } catch (err2) {
        log5.error("putIPNS PUT %s error:", resource, err2.stack);
        throw err2;
      } finally {
        signal.clear();
        onFinish.resolve();
        log5("putIPNS finished: %c", libp2pKey);
      }
    }
    #conformToPeerSchema(record) {
      try {
        const protocols = [];
        const multiaddrs = record.Addrs?.map(multiaddr) ?? [];
        if (record.Protocols != null) {
          protocols.push(...record.Protocols);
        }
        if (record.Protocol != null) {
          protocols.push(record.Protocol);
          delete record.Protocol;
        }
        return {
          ...record,
          Schema: "peer",
          ID: peerIdFromString(record.ID),
          Addrs: multiaddrs,
          Protocols: protocols
        };
      } catch (err2) {
        log5.error("could not conform record to peer schema", err2);
      }
    }
    #addFilterParams(url, filterAddrs, filterProtocols) {
      if (filterAddrs != null || this.filterAddrs != null) {
        const adressFilter = filterAddrs?.join(",") ?? this.filterAddrs?.join(",") ?? "";
        if (adressFilter !== "") {
          url.searchParams.set("filter-addrs", adressFilter);
        }
      }
      if (filterProtocols != null || this.filterProtocols != null) {
        const protocolFilter = filterProtocols?.join(",") ?? this.filterProtocols?.join(",") ?? "";
        if (protocolFilter !== "") {
          url.searchParams.set("filter-protocols", protocolFilter);
        }
      }
    }
    /**
     * makeRequest has two features:
     * - Ensures only one concurrent request is made for the same URL
     * - Caches GET requests if the Cache API is available
     */
    async #makeRequest(url, options2) {
      const requestMethod = options2.method ?? "GET";
      const key = `${requestMethod}-${url}`;
      if (requestMethod === "GET") {
        const cachedResponse = await this.cache?.match(url);
        if (cachedResponse != null) {
          const expires = parseInt(cachedResponse.headers.get("x-cache-expires") ?? "0", 10);
          if (expires > Date.now()) {
            log5("returning cached response for %s", key);
            return cachedResponse;
          } else {
            await this.cache?.delete(url);
          }
        }
      }
      const existingRequest = this.inFlightRequests.get(key);
      if (existingRequest != null) {
        const response2 = await existingRequest;
        log5("deduplicating outgoing request for %s", key);
        return response2.clone();
      }
      const requestPromise = fetch(url, options2).then(async (response2) => {
        if (this.cache != null && response2.ok && requestMethod === "GET") {
          const expires = Date.now() + this.cacheTTL;
          const headers = new Headers(response2.headers);
          headers.set("x-cache-expires", expires.toString());
          const cachedResponse = new Response(response2.clone().body, {
            status: response2.status,
            statusText: response2.statusText,
            headers
          });
          await this.cache.put(url, cachedResponse);
        }
        return response2;
      }).finally(() => {
        this.inFlightRequests.delete(key);
      });
      this.inFlightRequests.set(key, requestPromise);
      const response = await requestPromise;
      return response;
    }
  };

  // node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/index.js
  function createDelegatedRoutingV1HttpApiClient(url, init = {}) {
    return new DefaultDelegatedRoutingV1HttpApiClient(new URL(url), init);
  }

  // node_modules/@helia/routers/dist/src/utils/delegated-http-routing-defaults.browser.js
  function delegatedHTTPRoutingDefaults() {
    return {
      filterProtocols: ["unknown", "transport-bitswap", "transport-ipfs-gateway-http"],
      filterAddrs: ["https", "webtransport", "webrtc", "webrtc-direct", "wss", "tls"]
    };
  }

  // node_modules/ip-regex/index.js
  var word = "[a-fA-F\\d:]";
  var boundry = (options2) => options2 && options2.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6segment = "[a-fA-F\\d]{1,4}";
  var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
  var v4exact = new RegExp(`^${v4}$`);
  var v6exact = new RegExp(`^${v6}$`);
  var ipRegex = (options2) => options2 && options2.exact ? v46Exact : new RegExp(`(?:${boundry(options2)}${v4}${boundry(options2)})|(?:${boundry(options2)}${v6}${boundry(options2)})`, "g");
  ipRegex.v4 = (options2) => options2 && options2.exact ? v4exact : new RegExp(`${boundry(options2)}${v4}${boundry(options2)}`, "g");
  ipRegex.v6 = (options2) => options2 && options2.exact ? v6exact : new RegExp(`${boundry(options2)}${v6}${boundry(options2)}`, "g");
  var ip_regex_default = ipRegex;

  // node_modules/function-timeout/browser.js
  function functionTimeout(function_) {
    const wrappedFunction = (...arguments_) => function_(...arguments_);
    Object.defineProperty(wrappedFunction, "name", {
      value: `functionTimeout(${function_.name || "<anonymous>"})`,
      configurable: true
    });
    return wrappedFunction;
  }
  function isTimeoutError() {
    return false;
  }

  // node_modules/is-regexp/index.js
  var { toString: toString4 } = Object.prototype;
  function isRegexp(value2) {
    return toString4.call(value2) === "[object RegExp]";
  }

  // node_modules/clone-regexp/index.js
  var flagMap = {
    global: "g",
    ignoreCase: "i",
    multiline: "m",
    dotAll: "s",
    sticky: "y",
    unicode: "u"
  };
  function clonedRegexp(regexp, options2 = {}) {
    if (!isRegexp(regexp)) {
      throw new TypeError("Expected a RegExp instance");
    }
    const flags = Object.keys(flagMap).map((flag) => (typeof options2[flag] === "boolean" ? options2[flag] : regexp[flag]) ? flagMap[flag] : "").join("");
    const clonedRegexp2 = new RegExp(options2.source || regexp.source, flags);
    clonedRegexp2.lastIndex = typeof options2.lastIndex === "number" ? options2.lastIndex : regexp.lastIndex;
    return clonedRegexp2;
  }

  // node_modules/super-regex/index.js
  function isMatch(regex, string2, { timeout } = {}) {
    try {
      return functionTimeout(() => clonedRegexp(regex).test(string2), { timeout })();
    } catch (error) {
      if (isTimeoutError(error)) {
        return false;
      }
      throw error;
    }
  }

  // node_modules/is-ip/index.js
  var maxIPv4Length = 15;
  var maxIPv6Length = 45;
  var options = {
    timeout: 400
  };
  function isIPv62(string2) {
    if (string2.length > maxIPv6Length) {
      return false;
    }
    return isMatch(ip_regex_default.v6({ exact: true }), string2, options);
  }
  function isIPv42(string2) {
    if (string2.length > maxIPv4Length) {
      return false;
    }
    return isMatch(ip_regex_default.v4({ exact: true }), string2, options);
  }

  // node_modules/@multiformats/uri-to-multiaddr/dist/src/index.js
  var portFor = {
    http: "80",
    https: "443",
    ws: "80",
    wss: "443"
  };
  var BROWSER_SCHEMES = ["http", "https", "ws", "wss"];
  function uriToMultiaddr(uriStr, opts) {
    opts = opts ?? {};
    const defaultDnsType = opts.defaultDnsType ?? "dns";
    const { scheme, hostname, port, path } = parseUri(uriStr);
    const parts = [
      tupleForHostname(hostname, defaultDnsType),
      tupleForPort(port, scheme),
      tupleForScheme(scheme)
    ];
    if (path != null) {
      parts.push(tupleForPath(path));
    }
    const multiaddrStr = "/" + parts.filter((x) => Boolean(x)).reduce((a2, b) => a2.concat(b), []).join("/");
    return multiaddr(multiaddrStr);
  }
  function parseUri(uriStr) {
    const [scheme] = uriStr.split(":");
    if (!BROWSER_SCHEMES.includes(scheme)) {
      uriStr = "http" + uriStr.substring(scheme.length);
    }
    let { protocol, hostname, port, pathname, search } = new URL(uriStr);
    if (port == null || port === "") {
      const protocolPort = portForProtocol(scheme);
      if (protocolPort != null) {
        port = protocolPort;
      }
      if (protocolPort == null && protocol === "http:") {
        port = "80";
      }
    }
    let path;
    if (pathname != null && pathname !== "" && pathname !== "/") {
      if (pathname.startsWith("/")) {
        pathname = pathname.substring(1);
      }
      path = pathname;
    }
    if (search != null && search !== "") {
      path = path ?? "";
      path += search;
    }
    return { scheme, hostname, port, path };
  }
  function tupleForHostname(hostname, defaultDnsType) {
    if (hostname == null || hostname === "") {
      return void 0;
    }
    if (isIPv42(hostname)) {
      return ["ip4", hostname];
    }
    if (isIPv62(hostname)) {
      return ["ip6", hostname];
    }
    if (hostname[0] === "[") {
      const trimmed = hostname.substring(1, hostname.length - 1);
      if (isIPv62(trimmed)) {
        return ["ip6", trimmed];
      }
    }
    return [defaultDnsType, hostname];
  }
  function tupleForPort(port, scheme) {
    if (port == null || port === "") {
      return void 0;
    }
    if (scheme === "udp") {
      return ["udp", port];
    }
    return ["tcp", port];
  }
  function tupleForScheme(scheme) {
    if (scheme.match(/^tcp$|^udp$/) != null) {
      return void 0;
    }
    if (scheme === "https") {
      return ["/tls/http"];
    }
    if (scheme === "wss") {
      return ["/tls/ws"];
    }
    return [scheme];
  }
  function tupleForPath(path) {
    if (path == null || path === "") {
      return void 0;
    }
    return ["http-path", encodeURIComponent(path)];
  }
  function portForProtocol(protocol) {
    if (protocol == null || protocol === "" || portFor[protocol] == null) {
      return void 0;
    }
    return portFor[protocol];
  }

  // node_modules/@helia/routers/dist/src/http-gateway-routing.js
  var DEFAULT_TRUSTLESS_GATEWAYS = [
    // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs.github.io/public-gateway-checker/
    "https://trustless-gateway.link",
    // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs.github.io/public-gateway-checker/
    "https://4everland.io"
  ];
  var TRANSPORT_IPFS_GATEWAY_HTTP_CODE3 = 2336;
  function toPeerInfo(url) {
    url = url.toString();
    return {
      id: peerIdFromCID(CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE3, identity.digest(fromString2(url)))),
      multiaddrs: [
        uriToMultiaddr(url)
      ]
    };
  }
  var HTTPGatewayRouter = class {
    gateways;
    shuffle;
    constructor(init = {}) {
      this.gateways = (init.gateways ?? DEFAULT_TRUSTLESS_GATEWAYS).map((url) => toPeerInfo(url));
      this.shuffle = init.shuffle ?? true;
    }
    async *findProviders(cid, options2) {
      yield* (this.shuffle ? this.gateways.toSorted(() => Math.random() > 0.5 ? 1 : -1) : this.gateways).map((info) => {
        const provider = {
          ...info,
          protocols: ["transport-ipfs-gateway-http"],
          routing: "http-gateway-routing"
        };
        return provider;
      });
    }
  };
  function httpGatewayRouting(init = {}) {
    return new HTTPGatewayRouter(init);
  }

  // node_modules/@helia/routers/dist/src/libp2p-routing.js
  var Libp2pRouter = class {
    libp2p;
    constructor(libp2p) {
      this.libp2p = libp2p;
    }
    async provide(cid, options2) {
      await this.libp2p.contentRouting.provide(cid, options2);
    }
    async cancelReprovide(key, options2) {
      await this.libp2p.contentRouting.cancelReprovide(key, options2);
    }
    async *findProviders(cid, options2) {
      yield* this.libp2p.contentRouting.findProviders(cid, options2);
    }
    async put(key, value2, options2) {
      await this.libp2p.contentRouting.put(key, value2, options2);
    }
    async get(key, options2) {
      return this.libp2p.contentRouting.get(key, options2);
    }
    async findPeer(peerId, options2) {
      return this.libp2p.peerRouting.findPeer(peerId, options2);
    }
    async *getClosestPeers(key, options2) {
      yield* this.libp2p.peerRouting.getClosestPeers(key, options2);
    }
  };
  function libp2pRouting(libp2p) {
    return new Libp2pRouter(libp2p);
  }

  // node_modules/it-all/dist/src/index.js
  function isAsyncIterable11(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function all(source) {
    if (isAsyncIterable11(source)) {
      return (async () => {
        const arr2 = [];
        for await (const entry of source) {
          arr2.push(entry);
        }
        return arr2;
      })();
    }
    const arr = [];
    for (const entry of source) {
      arr.push(entry);
    }
    return arr;
  }
  var src_default11 = all;

  // node_modules/blockstore-core/dist/src/memory.js
  function isPromise5(p2) {
    return typeof p2?.then === "function";
  }
  var MemoryBlockstore = class extends BaseBlockstore {
    data;
    constructor() {
      super();
      this.data = /* @__PURE__ */ new Map();
    }
    put(key, val, options2) {
      options2?.signal?.throwIfAborted();
      let buf2;
      if (val instanceof Uint8Array) {
        buf2 = [val];
      } else {
        const result = src_default11(val);
        if (isPromise5(result)) {
          return result.then((val2) => {
            return this._put(key, val2, options2);
          });
        } else {
          buf2 = result;
        }
      }
      return this._put(key, buf2, options2);
    }
    _put(key, val, options2) {
      options2?.signal?.throwIfAborted();
      this.data.set(base32.encode(key.multihash.bytes), val);
      return key;
    }
    *get(key, options2) {
      options2?.signal?.throwIfAborted();
      const buf2 = this.data.get(base32.encode(key.multihash.bytes));
      if (buf2 == null) {
        throw new NotFoundError2();
      }
      yield* buf2;
    }
    has(key, options2) {
      options2?.signal?.throwIfAborted();
      return this.data.has(base32.encode(key.multihash.bytes));
    }
    async delete(key, options2) {
      options2?.signal?.throwIfAborted();
      this.data.delete(base32.encode(key.multihash.bytes));
    }
    *getAll(options2) {
      options2?.signal?.throwIfAborted();
      for (const [key, value2] of this.data.entries()) {
        yield {
          cid: CID.createV1(code3, decode4(base32.decode(key))),
          bytes: (async function* () {
            yield* value2;
          })()
        };
        options2?.signal?.throwIfAborted();
      }
    }
  };

  // node_modules/blockstore-core/dist/src/tiered.js
  var log6 = logger("blockstore:core:tiered");

  // node_modules/datastore-core/dist/src/shard.js
  var SHARDING_FN = "SHARDING";

  // node_modules/it-sort/dist/src/index.js
  function isAsyncIterable12(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function sort(source, sorter) {
    if (isAsyncIterable12(source)) {
      return (async function* () {
        const arr = await src_default11(source);
        yield* arr.sort(sorter);
      })();
    }
    return (function* () {
      const arr = src_default11(source);
      yield* arr.sort(sorter);
    })();
  }
  var src_default12 = sort;

  // node_modules/datastore-core/dist/src/base.js
  var BaseDatastore = class {
    put(key, val, options2) {
      return Promise.reject(new Error(".put is not implemented"));
    }
    get(key, options2) {
      return Promise.reject(new Error(".get is not implemented"));
    }
    has(key, options2) {
      return Promise.reject(new Error(".has is not implemented"));
    }
    delete(key, options2) {
      return Promise.reject(new Error(".delete is not implemented"));
    }
    async *putMany(source, options2 = {}) {
      for await (const { key, value: value2 } of source) {
        await this.put(key, value2, options2);
        yield key;
      }
    }
    async *getMany(source, options2 = {}) {
      for await (const key of source) {
        yield {
          key,
          value: await this.get(key, options2)
        };
      }
    }
    async *deleteMany(source, options2 = {}) {
      for await (const key of source) {
        await this.delete(key, options2);
        yield key;
      }
    }
    batch() {
      let puts = [];
      let dels = [];
      return {
        put(key, value2) {
          puts.push({ key, value: value2 });
        },
        delete(key) {
          dels.push(key);
        },
        commit: async (options2) => {
          await src_default3(this.putMany(puts, options2));
          puts = [];
          await src_default3(this.deleteMany(dels, options2));
          dels = [];
        }
      };
    }
    /**
     * Extending classes should override `query` or implement this method
     */
    // eslint-disable-next-line require-yield
    async *_all(q, options2) {
      throw new Error("._all is not implemented");
    }
    /**
     * Extending classes should override `queryKeys` or implement this method
     */
    // eslint-disable-next-line require-yield
    async *_allKeys(q, options2) {
      throw new Error("._allKeys is not implemented");
    }
    query(q, options2) {
      let it = this._all(q, options2);
      if (q.prefix != null) {
        const prefix = q.prefix;
        it = src_default8(it, (e2) => e2.key.toString().startsWith(prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f2) => src_default8(it2, f2), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f2) => src_default12(it2, f2), it);
      }
      if (q.offset != null) {
        let i2 = 0;
        const offset = q.offset;
        it = src_default8(it, () => i2++ >= offset);
      }
      if (q.limit != null) {
        it = src_default6(it, q.limit);
      }
      return it;
    }
    queryKeys(q, options2) {
      let it = this._allKeys(q, options2);
      if (q.prefix != null) {
        const prefix = q.prefix;
        it = src_default8(it, (key) => key.toString().startsWith(prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f2) => src_default8(it2, f2), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f2) => src_default12(it2, f2), it);
      }
      if (q.offset != null) {
        const offset = q.offset;
        let i2 = 0;
        it = src_default8(it, () => i2++ >= offset);
      }
      if (q.limit != null) {
        it = src_default6(it, q.limit);
      }
      return it;
    }
  };

  // node_modules/datastore-core/dist/src/memory.js
  var MemoryDatastore = class extends BaseDatastore {
    data;
    constructor() {
      super();
      this.data = /* @__PURE__ */ new Map();
    }
    put(key, val, options2) {
      options2?.signal?.throwIfAborted();
      this.data.set(key.toString(), val);
      return key;
    }
    get(key, options2) {
      options2?.signal?.throwIfAborted();
      const result = this.data.get(key.toString());
      if (result == null) {
        throw new NotFoundError2();
      }
      return result;
    }
    has(key, options2) {
      options2?.signal?.throwIfAborted();
      return this.data.has(key.toString());
    }
    delete(key, options2) {
      options2?.signal?.throwIfAborted();
      this.data.delete(key.toString());
    }
    *_all(q, options2) {
      options2?.signal?.throwIfAborted();
      for (const [key, value2] of this.data.entries()) {
        yield { key: new Key(key), value: value2 };
        options2?.signal?.throwIfAborted();
      }
    }
    *_allKeys(q, options2) {
      options2?.signal?.throwIfAborted();
      for (const key of this.data.keys()) {
        yield new Key(key);
        options2?.signal?.throwIfAborted();
      }
    }
  };

  // node_modules/datastore-core/dist/src/sharding.js
  var shardKey = new Key(SHARDING_FN);

  // node_modules/datastore-core/dist/src/tiered.js
  var log7 = logger("datastore:core:tiered");

  // node_modules/libp2p/dist/src/config.js
  async function validateConfig(opts) {
    if (opts.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
      throw new InvalidParametersError("Private network is enforced, but no protector was provided");
    }
    return opts;
  }

  // node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
  var Envelope;
  (function(Envelope3) {
    let _codec;
    Envelope3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.publicKey);
          }
          if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.payloadType);
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w.uint32(26);
            w.bytes(obj.payload);
          }
          if (obj.signature != null && obj.signature.byteLength > 0) {
            w.uint32(42);
            w.bytes(obj.signature);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            publicKey: alloc(0),
            payloadType: alloc(0),
            payload: alloc(0),
            signature: alloc(0)
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.publicKey = reader2.bytes();
                break;
              }
              case 2: {
                obj.payloadType = reader2.bytes();
                break;
              }
              case 3: {
                obj.payload = reader2.bytes();
                break;
              }
              case 5: {
                obj.signature = reader2.bytes();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Envelope3.encode = (obj) => {
      return encodeMessage(obj, Envelope3.codec());
    };
    Envelope3.decode = (buf2, opts) => {
      return decodeMessage(buf2, Envelope3.codec(), opts);
    };
  })(Envelope || (Envelope = {}));

  // node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
  var InvalidSignatureError = class extends Error {
    constructor(message2 = "Invalid signature") {
      super(message2);
      this.name = "InvalidSignatureError";
    }
  };

  // node_modules/@libp2p/peer-record/dist/src/envelope/index.js
  var RecordEnvelope = class _RecordEnvelope {
    /**
     * Unmarshal a serialized Envelope protobuf message
     */
    static createFromProtobuf = (data) => {
      const envelopeData = Envelope.decode(data);
      const publicKey2 = publicKeyFromProtobuf(envelopeData.publicKey);
      return new _RecordEnvelope({
        publicKey: publicKey2,
        payloadType: envelopeData.payloadType,
        payload: envelopeData.payload,
        signature: envelopeData.signature
      });
    };
    /**
     * Seal marshals the given Record, places the marshaled bytes inside an Envelope
     * and signs it with the given peerId's private key
     */
    static seal = async (record, privateKey, options2) => {
      if (privateKey == null) {
        throw new Error("Missing private key");
      }
      const domain = record.domain;
      const payloadType = record.codec;
      const payload = record.marshal();
      const signData = formatSignaturePayload(domain, payloadType, payload);
      const signature = await privateKey.sign(signData.subarray(), options2);
      return new _RecordEnvelope({
        publicKey: privateKey.publicKey,
        payloadType,
        payload,
        signature
      });
    };
    /**
     * Open and certify a given marshaled envelope.
     * Data is unmarshaled and the signature validated for the given domain.
     */
    static openAndCertify = async (data, domain, options2) => {
      const envelope = _RecordEnvelope.createFromProtobuf(data);
      const valid = await envelope.validate(domain, options2);
      if (!valid) {
        throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
      }
      return envelope;
    };
    publicKey;
    payloadType;
    payload;
    signature;
    marshaled;
    /**
     * The Envelope is responsible for keeping an arbitrary signed record
     * by a libp2p peer.
     */
    constructor(init) {
      const { publicKey: publicKey2, payloadType, payload, signature } = init;
      this.publicKey = publicKey2;
      this.payloadType = payloadType;
      this.payload = payload;
      this.signature = signature;
    }
    /**
     * Marshal the envelope content
     */
    marshal() {
      if (this.marshaled == null) {
        this.marshaled = Envelope.encode({
          publicKey: publicKeyToProtobuf(this.publicKey),
          payloadType: this.payloadType,
          payload: this.payload.subarray(),
          signature: this.signature
        });
      }
      return this.marshaled;
    }
    /**
     * Verifies if the other Envelope is identical to this one
     */
    equals(other) {
      if (other == null) {
        return false;
      }
      return equals3(this.marshal(), other.marshal());
    }
    /**
     * Validate envelope data signature for the given domain
     */
    async validate(domain, options2) {
      const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
      return this.publicKey.verify(signData.subarray(), this.signature, options2);
    }
  };
  var formatSignaturePayload = (domain, payloadType, payload) => {
    const domainUint8Array = fromString2(domain);
    const domainLength = encode7(domainUint8Array.byteLength);
    const payloadTypeLength = encode7(payloadType.length);
    const payloadLength = encode7(payload.length);
    return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
  };

  // node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
  var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
  var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

  // node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
  var PeerRecord;
  (function(PeerRecord3) {
    let AddressInfo;
    (function(AddressInfo2) {
      let _codec2;
      AddressInfo2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
              w.uint32(10);
              w.bytes(obj.multiaddr);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length4, opts = {}) => {
            const obj = {
              multiaddr: alloc(0)
            };
            const end = length4 == null ? reader2.len : reader2.pos + length4;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.multiaddr = reader2.bytes();
                  break;
                }
                default: {
                  reader2.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      AddressInfo2.encode = (obj) => {
        return encodeMessage(obj, AddressInfo2.codec());
      };
      AddressInfo2.decode = (buf2, opts) => {
        return decodeMessage(buf2, AddressInfo2.codec(), opts);
      };
    })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
    let _codec;
    PeerRecord3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.peerId != null && obj.peerId.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.peerId);
          }
          if (obj.seq != null && obj.seq !== 0n) {
            w.uint32(16);
            w.uint64(obj.seq);
          }
          if (obj.addresses != null) {
            for (const value2 of obj.addresses) {
              w.uint32(26);
              PeerRecord3.AddressInfo.codec().encode(value2, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            peerId: alloc(0),
            seq: 0n,
            addresses: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.peerId = reader2.bytes();
                break;
              }
              case 2: {
                obj.seq = reader2.uint64();
                break;
              }
              case 3: {
                if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                  throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
                }
                obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.addresses$
                }));
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerRecord3.encode = (obj) => {
      return encodeMessage(obj, PeerRecord3.codec());
    };
    PeerRecord3.decode = (buf2, opts) => {
      return decodeMessage(buf2, PeerRecord3.codec(), opts);
    };
  })(PeerRecord || (PeerRecord = {}));

  // node_modules/@libp2p/peer-record/dist/src/peer-record/utils.js
  function arrayEquals(a2, b) {
    const sort2 = (a3, b2) => a3.toString().localeCompare(b2.toString());
    if (a2.length !== b.length) {
      return false;
    }
    b.sort(sort2);
    return a2.sort(sort2).every((item, index) => b[index].equals(item));
  }

  // node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
  var PeerRecord2 = class _PeerRecord {
    /**
     * Unmarshal Peer Record Protobuf
     */
    static createFromProtobuf = (buf2) => {
      const peerRecord = PeerRecord.decode(buf2);
      const peerId = peerIdFromMultihash(decode4(peerRecord.peerId));
      const multiaddrs = (peerRecord.addresses ?? []).map((a2) => multiaddr(a2.multiaddr));
      const seqNumber = peerRecord.seq;
      return new _PeerRecord({ peerId, multiaddrs, seqNumber });
    };
    static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
    static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
    peerId;
    multiaddrs;
    seqNumber;
    domain = _PeerRecord.DOMAIN;
    codec = _PeerRecord.CODEC;
    marshaled;
    constructor(init) {
      const { peerId, multiaddrs, seqNumber } = init;
      this.peerId = peerId;
      this.multiaddrs = multiaddrs ?? [];
      this.seqNumber = seqNumber ?? BigInt(Date.now());
    }
    /**
     * Marshal a record to be used in an envelope
     */
    marshal() {
      if (this.marshaled == null) {
        this.marshaled = PeerRecord.encode({
          peerId: this.peerId.toMultihash().bytes,
          seq: BigInt(this.seqNumber),
          addresses: this.multiaddrs.map((m2) => ({
            multiaddr: m2.bytes
          }))
        });
      }
      return this.marshaled;
    }
    /**
     * Returns true if `this` record equals the `other`
     */
    equals(other) {
      if (!(other instanceof _PeerRecord)) {
        return false;
      }
      if (!this.peerId.equals(other.peerId)) {
        return false;
      }
      if (this.seqNumber !== other.seqNumber) {
        return false;
      }
      if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
        return false;
      }
      return true;
    }
  };

  // node_modules/@libp2p/peer-store/dist/src/constants.js
  var MAX_ADDRESS_AGE = 36e5;
  var MAX_PEER_AGE = 216e5;

  // node_modules/@libp2p/peer-store/dist/src/pb/peer.js
  var Peer;
  (function(Peer3) {
    let Peer$metadataEntry;
    (function(Peer$metadataEntry2) {
      let _codec2;
      Peer$metadataEntry2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.key != null && obj.key !== "") {
              w.uint32(10);
              w.string(obj.key);
            }
            if (obj.value != null && obj.value.byteLength > 0) {
              w.uint32(18);
              w.bytes(obj.value);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length4, opts = {}) => {
            const obj = {
              key: "",
              value: alloc(0)
            };
            const end = length4 == null ? reader2.len : reader2.pos + length4;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.key = reader2.string();
                  break;
                }
                case 2: {
                  obj.value = reader2.bytes();
                  break;
                }
                default: {
                  reader2.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Peer$metadataEntry2.encode = (obj) => {
        return encodeMessage(obj, Peer$metadataEntry2.codec());
      };
      Peer$metadataEntry2.decode = (buf2, opts) => {
        return decodeMessage(buf2, Peer$metadataEntry2.codec(), opts);
      };
    })(Peer$metadataEntry = Peer3.Peer$metadataEntry || (Peer3.Peer$metadataEntry = {}));
    let Peer$tagsEntry;
    (function(Peer$tagsEntry2) {
      let _codec2;
      Peer$tagsEntry2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.key != null && obj.key !== "") {
              w.uint32(10);
              w.string(obj.key);
            }
            if (obj.value != null) {
              w.uint32(18);
              Tag.codec().encode(obj.value, w);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length4, opts = {}) => {
            const obj = {
              key: ""
            };
            const end = length4 == null ? reader2.len : reader2.pos + length4;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.key = reader2.string();
                  break;
                }
                case 2: {
                  obj.value = Tag.codec().decode(reader2, reader2.uint32(), {
                    limits: opts.limits?.value
                  });
                  break;
                }
                default: {
                  reader2.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Peer$tagsEntry2.encode = (obj) => {
        return encodeMessage(obj, Peer$tagsEntry2.codec());
      };
      Peer$tagsEntry2.decode = (buf2, opts) => {
        return decodeMessage(buf2, Peer$tagsEntry2.codec(), opts);
      };
    })(Peer$tagsEntry = Peer3.Peer$tagsEntry || (Peer3.Peer$tagsEntry = {}));
    let _codec;
    Peer3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.addresses != null) {
            for (const value2 of obj.addresses) {
              w.uint32(10);
              Address.codec().encode(value2, w);
            }
          }
          if (obj.protocols != null) {
            for (const value2 of obj.protocols) {
              w.uint32(18);
              w.string(value2);
            }
          }
          if (obj.publicKey != null) {
            w.uint32(34);
            w.bytes(obj.publicKey);
          }
          if (obj.peerRecordEnvelope != null) {
            w.uint32(42);
            w.bytes(obj.peerRecordEnvelope);
          }
          if (obj.metadata != null && obj.metadata.size !== 0) {
            for (const [key, value2] of obj.metadata.entries()) {
              w.uint32(50);
              Peer3.Peer$metadataEntry.codec().encode({ key, value: value2 }, w);
            }
          }
          if (obj.tags != null && obj.tags.size !== 0) {
            for (const [key, value2] of obj.tags.entries()) {
              w.uint32(58);
              Peer3.Peer$tagsEntry.codec().encode({ key, value: value2 }, w);
            }
          }
          if (obj.updated != null) {
            w.uint32(64);
            w.uint64Number(obj.updated);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            addresses: [],
            protocols: [],
            metadata: /* @__PURE__ */ new Map(),
            tags: /* @__PURE__ */ new Map()
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                  throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
                }
                obj.addresses.push(Address.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.addresses$
                }));
                break;
              }
              case 2: {
                if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                  throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
                }
                obj.protocols.push(reader2.string());
                break;
              }
              case 4: {
                obj.publicKey = reader2.bytes();
                break;
              }
              case 5: {
                obj.peerRecordEnvelope = reader2.bytes();
                break;
              }
              case 6: {
                if (opts.limits?.metadata != null && obj.metadata.size === opts.limits.metadata) {
                  throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
                }
                const entry = Peer3.Peer$metadataEntry.codec().decode(reader2, reader2.uint32());
                obj.metadata.set(entry.key, entry.value);
                break;
              }
              case 7: {
                if (opts.limits?.tags != null && obj.tags.size === opts.limits.tags) {
                  throw new MaxSizeError('Decode error - map field "tags" had too many elements');
                }
                const entry = Peer3.Peer$tagsEntry.codec().decode(reader2, reader2.uint32(), {
                  limits: {
                    value: opts.limits?.tags$value
                  }
                });
                obj.tags.set(entry.key, entry.value);
                break;
              }
              case 8: {
                obj.updated = reader2.uint64Number();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Peer3.encode = (obj) => {
      return encodeMessage(obj, Peer3.codec());
    };
    Peer3.decode = (buf2, opts) => {
      return decodeMessage(buf2, Peer3.codec(), opts);
    };
  })(Peer || (Peer = {}));
  var Address;
  (function(Address2) {
    let _codec;
    Address2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (obj.isCertified != null) {
            w.uint32(16);
            w.bool(obj.isCertified);
          }
          if (obj.observed != null) {
            w.uint32(24);
            w.uint64Number(obj.observed);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            multiaddr: alloc(0)
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader2.bytes();
                break;
              }
              case 2: {
                obj.isCertified = reader2.bool();
                break;
              }
              case 3: {
                obj.observed = reader2.uint64Number();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Address2.encode = (obj) => {
      return encodeMessage(obj, Address2.codec());
    };
    Address2.decode = (buf2, opts) => {
      return decodeMessage(buf2, Address2.codec(), opts);
    };
  })(Address || (Address = {}));
  var Tag;
  (function(Tag2) {
    let _codec;
    Tag2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.value != null && obj.value !== 0) {
            w.uint32(8);
            w.uint32(obj.value);
          }
          if (obj.expiry != null) {
            w.uint32(16);
            w.uint64(obj.expiry);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            value: 0
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.value = reader2.uint32();
                break;
              }
              case 2: {
                obj.expiry = reader2.uint64();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Tag2.encode = (obj) => {
      return encodeMessage(obj, Tag2.codec());
    };
    Tag2.decode = (buf2, opts) => {
      return decodeMessage(buf2, Tag2.codec(), opts);
    };
  })(Tag || (Tag = {}));

  // node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
  function populatePublicKey(peerId, protobuf) {
    if (peerId.publicKey != null || protobuf.publicKey == null) {
      return peerId;
    }
    let digest2;
    if (peerId.type === "RSA") {
      digest2 = peerId.toMultihash();
    }
    const publicKey2 = publicKeyFromProtobuf(protobuf.publicKey, digest2);
    return peerIdFromPublicKey(publicKey2);
  }
  function bytesToPeer(peerId, buf2, maxAddressAge) {
    const peer = Peer.decode(buf2);
    return pbToPeer(peerId, peer, maxAddressAge);
  }
  function pbToPeer(peerId, peer, maxAddressAge) {
    const tags = /* @__PURE__ */ new Map();
    const now = BigInt(Date.now());
    for (const [key, tag] of peer.tags.entries()) {
      if (tag.expiry != null && tag.expiry < now) {
        continue;
      }
      tags.set(key, tag);
    }
    return {
      ...peer,
      id: populatePublicKey(peerId, peer),
      addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata: peer.metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
      tags
    };
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/peer-equals.js
  function peerEquals(peerA, peerB) {
    return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
  }
  function addressesEqual(addressesA, addressesB) {
    return compareArrays(addressesA, addressesB, (a2, b) => {
      if (a2.isCertified !== b.isCertified) {
        return false;
      }
      if (!equals3(a2.multiaddr, b.multiaddr)) {
        return false;
      }
      return true;
    });
  }
  function protocolsEqual(protocolsA, protocolsB) {
    return compareArrays(protocolsA, protocolsB, (a2, b) => a2 === b);
  }
  function publicKeyEqual(publicKeyA, publicKeyB) {
    return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
  }
  function peerRecordEnvelope(envelopeA, envelopeB) {
    return compareOptionalUint8Arrays(envelopeA, envelopeB);
  }
  function metadataEqual(metadataA, metadataB) {
    return compareMaps(metadataA, metadataB, (a2, b) => equals3(a2, b));
  }
  function tagsEqual(metadataA, metadataB) {
    return compareMaps(metadataA, metadataB, (a2, b) => a2.value === b.value && a2.expiry === b.expiry);
  }
  function compareOptionalUint8Arrays(arrA, arrB) {
    if (arrA == null && arrB == null) {
      return true;
    }
    if (arrA != null && arrB != null) {
      return equals3(arrA, arrB);
    }
    return false;
  }
  function compareArrays(arrA, arrB, compare3) {
    if (arrA.length !== arrB.length) {
      return false;
    }
    for (let i2 = 0; i2 < arrA.length; i2++) {
      if (!compare3(arrA[i2], arrB[i2])) {
        return false;
      }
    }
    return true;
  }
  function compareMaps(mapA, mapB, compare3) {
    if (mapA.size !== mapB.size) {
      return false;
    }
    for (const [key, value2] of mapA.entries()) {
      const valueB = mapB.get(key);
      if (valueB == null) {
        return false;
      }
      if (!compare3(value2, valueB)) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
  var NAMESPACE_COMMON = "/peers/";
  function peerIdToDatastoreKey(peerId) {
    if (!isPeerId(peerId) || peerId.type == null) {
      throw new InvalidParametersError("Invalid PeerId");
    }
    const b32key = peerId.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
  async function dedupeFilterAndSortAddresses(peerId, filter2, addresses, existingAddresses, options2) {
    const addressMap = /* @__PURE__ */ new Map();
    for (const addr of addresses) {
      if (addr == null) {
        continue;
      }
      if (addr.multiaddr instanceof Uint8Array) {
        addr.multiaddr = multiaddr(addr.multiaddr);
      }
      if (!isMultiaddr(addr.multiaddr)) {
        throw new InvalidParametersError("Multiaddr was invalid");
      }
      if (!await filter2(peerId, addr.multiaddr, options2)) {
        continue;
      }
      const isCertified = addr.isCertified ?? false;
      const maStr = addr.multiaddr.toString();
      const existingAddr = addressMap.get(maStr);
      if (existingAddr != null) {
        addr.isCertified = existingAddr.isCertified || isCertified;
      } else {
        addressMap.set(maStr, {
          multiaddr: addr.multiaddr,
          isCertified
        });
      }
    }
    return [...addressMap.values()].sort((a2, b) => {
      return a2.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ isCertified, multiaddr: ma }) => {
      const addrPeer = ma.getComponents().find((c2) => c2.code === CODE_P2P)?.value;
      if (peerId.equals(addrPeer)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${peerId}`));
      }
      return {
        isCertified,
        multiaddr: ma.bytes
      };
    });
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
  async function toPeerPB(peerId, data, strategy, options2) {
    if (data == null) {
      throw new InvalidParametersError("Invalid PeerData");
    }
    if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {
      throw new InvalidParametersError("publicKey bytes do not match peer id publicKey bytes");
    }
    const existingPeer = options2.existingPeer?.peer;
    if (existingPeer != null && !peerId.equals(existingPeer.id)) {
      throw new InvalidParametersError("peer id did not match existing peer id");
    }
    let addresses = existingPeer?.addresses ?? [];
    let protocols = new Set(existingPeer?.protocols ?? []);
    let metadata = existingPeer?.metadata ?? /* @__PURE__ */ new Map();
    let tags = existingPeer?.tags ?? /* @__PURE__ */ new Map();
    let peerRecordEnvelope2 = existingPeer?.peerRecordEnvelope;
    if (strategy === "patch") {
      if (data.multiaddrs != null || data.addresses != null) {
        addresses = [];
        if (data.multiaddrs != null) {
          addresses.push(...data.multiaddrs.map((multiaddr2) => ({
            isCertified: false,
            multiaddr: multiaddr2
          })));
        }
        if (data.addresses != null) {
          addresses.push(...data.addresses);
        }
      }
      if (data.protocols != null) {
        protocols = new Set(data.protocols);
      }
      if (data.metadata != null) {
        const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
        metadata = createSortedMap(metadataEntries, {
          validate: validateMetadata
        });
      }
      if (data.tags != null) {
        const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
        tags = createSortedMap(tagsEntries, {
          validate: validateTag,
          map: mapTag
        });
      }
      if (data.peerRecordEnvelope != null) {
        peerRecordEnvelope2 = data.peerRecordEnvelope;
      }
    }
    if (strategy === "merge") {
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
      if (data.protocols != null) {
        protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
      }
      if (data.metadata != null) {
        const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
        for (const [key, value2] of metadataEntries) {
          if (value2 == null) {
            metadata.delete(key);
          } else {
            metadata.set(key, value2);
          }
        }
        metadata = createSortedMap([...metadata.entries()], {
          validate: validateMetadata
        });
      }
      if (data.tags != null) {
        const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
        const mergedTags = new Map(tags);
        for (const [key, value2] of tagsEntries) {
          if (value2 == null) {
            mergedTags.delete(key);
          } else {
            mergedTags.set(key, value2);
          }
        }
        tags = createSortedMap([...mergedTags.entries()], {
          validate: validateTag,
          map: mapTag
        });
      }
      if (data.peerRecordEnvelope != null) {
        peerRecordEnvelope2 = data.peerRecordEnvelope;
      }
    }
    let publicKey2;
    if (existingPeer?.id.publicKey != null) {
      publicKey2 = publicKeyToProtobuf(existingPeer.id.publicKey);
    } else if (data.publicKey != null) {
      publicKey2 = publicKeyToProtobuf(data.publicKey);
    } else if (peerId.publicKey != null) {
      publicKey2 = publicKeyToProtobuf(peerId.publicKey);
    }
    const output = {
      addresses: await dedupeFilterAndSortAddresses(peerId, options2.addressFilter ?? (async () => true), addresses, options2.existingPeer?.peerPB.addresses, options2),
      protocols: [...protocols.values()].sort((a2, b) => {
        return a2.localeCompare(b);
      }),
      metadata,
      tags,
      publicKey: publicKey2,
      peerRecordEnvelope: peerRecordEnvelope2
    };
    output.addresses.forEach((addr) => {
      addr.observed = options2.existingPeer?.peerPB.addresses?.find((addr2) => equals3(addr2.multiaddr, addr2.multiaddr))?.observed ?? Date.now();
    });
    if (peerId.type !== "RSA") {
      delete output.publicKey;
    }
    return output;
  }
  function createSortedMap(entries, options2) {
    const output = /* @__PURE__ */ new Map();
    for (const [key, value2] of entries) {
      if (value2 == null) {
        continue;
      }
      options2.validate(key, value2);
    }
    for (const [key, value2] of entries.sort(([a2], [b]) => {
      return a2.localeCompare(b);
    })) {
      if (value2 != null) {
        output.set(key, options2.map?.(key, value2) ?? value2);
      }
    }
    return output;
  }
  function validateMetadata(key, value2) {
    if (typeof key !== "string") {
      throw new InvalidParametersError("Metadata key must be a string");
    }
    if (!(value2 instanceof Uint8Array)) {
      throw new InvalidParametersError("Metadata value must be a Uint8Array");
    }
  }
  function validateTag(key, tag) {
    if (typeof key !== "string") {
      throw new InvalidParametersError("Tag name must be a string");
    }
    if (tag.value != null) {
      if (parseInt(`${tag.value}`, 10) !== tag.value) {
        throw new InvalidParametersError("Tag value must be an integer");
      }
      if (tag.value < 0 || tag.value > 100) {
        throw new InvalidParametersError("Tag value must be between 0-100");
      }
    }
    if (tag.ttl != null) {
      if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
        throw new InvalidParametersError("Tag ttl must be an integer");
      }
      if (tag.ttl < 0) {
        throw new InvalidParametersError("Tag ttl must be between greater than 0");
      }
    }
  }
  function mapTag(key, tag) {
    let expiry;
    if (tag.expiry != null) {
      expiry = tag.expiry;
    }
    if (tag.ttl != null) {
      expiry = BigInt(Date.now() + Number(tag.ttl));
    }
    const output = {
      value: tag.value ?? 0
    };
    if (expiry != null) {
      output.expiry = expiry;
    }
    return output;
  }

  // node_modules/@libp2p/peer-store/dist/src/store.js
  function keyToPeerId(key) {
    const base32Str = key.toString().split("/")[2];
    const buf2 = CID.parse(base32Str, base32);
    return peerIdFromCID(buf2);
  }
  function decodePeer(key, value2, maxAddressAge) {
    const peerId = keyToPeerId(key);
    return bytesToPeer(peerId, value2, maxAddressAge);
  }
  function mapQuery(query, maxAddressAge) {
    return {
      prefix: NAMESPACE_COMMON,
      filters: (query.filters ?? []).map((fn) => ({ key, value: value2 }) => {
        return fn(decodePeer(key, value2, maxAddressAge));
      }),
      orders: (query.orders ?? []).map((fn) => (a2, b) => {
        return fn(decodePeer(a2.key, a2.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
      })
    };
  }
  var PersistentStore = class {
    peerId;
    datastore;
    locks;
    addressFilter;
    log;
    maxAddressAge;
    maxPeerAge;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:peer-store");
      this.peerId = components.peerId;
      this.datastore = components.datastore;
      this.addressFilter = init.addressFilter;
      this.locks = trackedPeerMap({
        name: "libp2p_peer_store_locks",
        metrics: components.metrics
      });
      this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE;
      this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE;
    }
    getLock(peerId) {
      let lock = this.locks.get(peerId);
      if (lock == null) {
        lock = {
          refs: 0,
          lock: createMortice({
            name: peerId.toString(),
            singleProcess: true
          })
        };
        this.locks.set(peerId, lock);
      }
      lock.refs++;
      return lock;
    }
    maybeRemoveLock(peerId, lock) {
      lock.refs--;
      if (lock.refs === 0) {
        lock.lock.finalize();
        this.locks.delete(peerId);
      }
    }
    async getReadLock(peerId, options2) {
      const lock = this.getLock(peerId);
      try {
        const release = await lock.lock.readLock(options2);
        return () => {
          release();
          this.maybeRemoveLock(peerId, lock);
        };
      } catch (err2) {
        this.maybeRemoveLock(peerId, lock);
        throw err2;
      }
    }
    async getWriteLock(peerId, options2) {
      const lock = this.getLock(peerId);
      try {
        const release = await lock.lock.writeLock(options2);
        return () => {
          release();
          this.maybeRemoveLock(peerId, lock);
        };
      } catch (err2) {
        this.maybeRemoveLock(peerId, lock);
        throw err2;
      }
    }
    async has(peerId, options2) {
      try {
        await this.load(peerId, options2);
        return true;
      } catch (err2) {
        if (err2.name !== "NotFoundError") {
          throw err2;
        }
      }
      return false;
    }
    async delete(peerId, options2) {
      if (this.peerId.equals(peerId)) {
        return;
      }
      await this.datastore.delete(peerIdToDatastoreKey(peerId), options2);
    }
    async load(peerId, options2) {
      const key = peerIdToDatastoreKey(peerId);
      const buf2 = await this.datastore.get(key, options2);
      const peer = Peer.decode(buf2);
      if (this.#peerIsExpired(peerId, peer)) {
        await this.datastore.delete(key, options2);
        throw new NotFoundError();
      }
      return pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
    }
    async save(peerId, data, options2) {
      const existingPeer = await this.#findExistingPeer(peerId, options2);
      const peerPb = await toPeerPB(peerId, data, "patch", {
        ...options2,
        addressFilter: this.addressFilter
      });
      return this.#saveIfDifferent(peerId, peerPb, existingPeer);
    }
    async patch(peerId, data, options2) {
      const existingPeer = await this.#findExistingPeer(peerId, options2);
      const peerPb = await toPeerPB(peerId, data, "patch", {
        ...options2,
        addressFilter: this.addressFilter,
        existingPeer
      });
      return this.#saveIfDifferent(peerId, peerPb, existingPeer);
    }
    async merge(peerId, data, options2) {
      const existingPeer = await this.#findExistingPeer(peerId, options2);
      const peerPb = await toPeerPB(peerId, data, "merge", {
        addressFilter: this.addressFilter,
        existingPeer
      });
      return this.#saveIfDifferent(peerId, peerPb, existingPeer);
    }
    async *all(options2) {
      for await (const { key, value: value2 } of this.datastore.query(mapQuery(options2 ?? {}, this.maxAddressAge), options2)) {
        const peerId = keyToPeerId(key);
        if (peerId.equals(this.peerId)) {
          continue;
        }
        const peer = Peer.decode(value2);
        if (this.#peerIsExpired(peerId, peer)) {
          await this.datastore.delete(key, options2);
          continue;
        }
        yield pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
      }
    }
    async #findExistingPeer(peerId, options2) {
      try {
        const key = peerIdToDatastoreKey(peerId);
        const buf2 = await this.datastore.get(key, options2);
        const peerPB = Peer.decode(buf2);
        if (this.#peerIsExpired(peerId, peerPB)) {
          await this.datastore.delete(key, options2);
          throw new NotFoundError();
        }
        return {
          peerPB,
          peer: pbToPeer(peerId, peerPB, this.maxAddressAge)
        };
      } catch (err2) {
        if (err2.name !== "NotFoundError") {
          this.log.error("invalid peer data found in peer store - %e", err2);
        }
      }
    }
    async #saveIfDifferent(peerId, peer, existingPeer, options2) {
      peer.updated = Date.now();
      const buf2 = Peer.encode(peer);
      await this.datastore.put(peerIdToDatastoreKey(peerId), buf2, options2);
      return {
        peer: pbToPeer(peerId, peer, this.maxAddressAge),
        previous: existingPeer?.peer,
        updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
      };
    }
    #peerIsExpired(peerId, peer) {
      if (peer.updated == null) {
        return true;
      }
      if (this.peerId.equals(peerId)) {
        return false;
      }
      const expired = peer.updated < Date.now() - this.maxPeerAge;
      const minAddressObserved = Date.now() - this.maxAddressAge;
      const addrs = peer.addresses.filter((addr) => {
        return addr.observed != null && addr.observed > minAddressObserved;
      });
      return expired && addrs.length === 0;
    }
  };

  // node_modules/@libp2p/peer-store/dist/src/index.js
  var PersistentPeerStore = class {
    store;
    events;
    peerId;
    log;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:peer-store");
      this.events = components.events;
      this.peerId = components.peerId;
      this.store = new PersistentStore(components, init);
    }
    [Symbol.toStringTag] = "@libp2p/peer-store";
    async forEach(fn, query) {
      for await (const peer of this.store.all(query)) {
        fn(peer);
      }
    }
    async all(query) {
      return src_default11(this.store.all(query));
    }
    async delete(peerId, options2) {
      const release = await this.store.getReadLock(peerId, options2);
      try {
        await this.store.delete(peerId, options2);
      } finally {
        release();
      }
    }
    async has(peerId, options2) {
      const release = await this.store.getReadLock(peerId, options2);
      try {
        return await this.store.has(peerId, options2);
      } finally {
        this.log.trace("has release read lock");
        release?.();
      }
    }
    async get(peerId, options2) {
      const release = await this.store.getReadLock(peerId, options2);
      try {
        return await this.store.load(peerId, options2);
      } finally {
        release?.();
      }
    }
    async getInfo(peerId, options2) {
      const peer = await this.get(peerId, options2);
      return {
        id: peer.id,
        multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      };
    }
    async save(id, data, options2) {
      const release = await this.store.getWriteLock(id, options2);
      try {
        const result = await this.store.save(id, data, options2);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release?.();
      }
    }
    async patch(id, data, options2) {
      const release = await this.store.getWriteLock(id, options2);
      try {
        const result = await this.store.patch(id, data, options2);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release?.();
      }
    }
    async merge(id, data, options2) {
      const release = await this.store.getWriteLock(id, options2);
      try {
        const result = await this.store.merge(id, data, options2);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release?.();
      }
    }
    async consumePeerRecord(buf2, arg1, arg2) {
      const expectedPeer = isPeerId(arg1) ? arg1 : isPeerId(arg1?.expectedPeer) ? arg1.expectedPeer : void 0;
      const options2 = isPeerId(arg1) ? arg2 : arg1 === void 0 ? arg2 : arg1;
      const envelope = await RecordEnvelope.openAndCertify(buf2, PeerRecord2.DOMAIN, options2);
      const peerId = peerIdFromCID(envelope.publicKey.toCID());
      if (expectedPeer?.equals(peerId) === false) {
        this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId);
        return false;
      }
      const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
      let peer;
      try {
        peer = await this.get(peerId, options2);
      } catch (err2) {
        if (err2.name !== "NotFoundError") {
          throw err2;
        }
      }
      if (peer?.peerRecordEnvelope != null) {
        const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
        const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          return false;
        }
      }
      await this.patch(peerRecord.peerId, {
        peerRecordEnvelope: buf2,
        addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
          isCertified: true,
          multiaddr: multiaddr2
        }))
      }, options2);
      return true;
    }
    #emitIfUpdated(id, result) {
      if (!result.updated) {
        return;
      }
      if (this.peerId.equals(id)) {
        this.events.safeDispatchEvent("self:peer:update", { detail: result });
      } else {
        this.events.safeDispatchEvent("peer:update", { detail: result });
      }
    }
  };
  function persistentPeerStore(components, init = {}) {
    return new PersistentPeerStore(components, init);
  }

  // node_modules/libp2p/dist/src/address-manager/dns-mappings.js
  var MAX_DATE = 864e13;
  var DNSMappings = class {
    log;
    mappings;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
      this.mappings = trackedMap({
        name: "libp2p_address_manager_dns_mappings",
        metrics: components.metrics
      });
    }
    has(ma) {
      const config = getNetConfig(ma);
      let host = config.host;
      if ((config.type === "ip4" || config.type === "ip6") && config.sni != null) {
        host = config.sni;
      }
      for (const mapping of this.mappings.values()) {
        if (mapping.domain === host) {
          return true;
        }
      }
      return false;
    }
    add(domain, addresses) {
      addresses.forEach((ip) => {
        this.log("add DNS mapping %s to %s", ip, domain);
        const verified = isPrivateIp(ip) === true;
        this.mappings.set(ip, {
          domain,
          verified,
          expires: verified ? MAX_DATE - Date.now() : 0,
          lastVerified: verified ? MAX_DATE - Date.now() : void 0
        });
      });
    }
    remove(ma) {
      const config = getNetConfig(ma);
      if (config.type !== "ip4" && config.type !== "ip6") {
        return false;
      }
      let wasConfident = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === config.sni) {
          this.log("removing %s to %s DNS mapping %e", ip, mapping.domain);
          this.mappings.delete(ip);
          wasConfident = wasConfident || mapping.verified;
        }
      }
      return wasConfident;
    }
    getAll(addresses) {
      const dnsMappedAddresses = [];
      for (let i2 = 0; i2 < addresses.length; i2++) {
        const address = addresses[i2].multiaddr;
        if (!isNetworkAddress(address)) {
          continue;
        }
        const config = getNetConfig(address);
        for (const [ip, mapping] of this.mappings.entries()) {
          if (config.host !== ip) {
            continue;
          }
          const maWithSni = this.maybeAddSNIComponent(address, mapping.domain);
          if (maWithSni != null) {
            addresses.splice(i2, 1);
            i2--;
            dnsMappedAddresses.push({
              multiaddr: maWithSni,
              verified: mapping.verified,
              type: "dns-mapping",
              expires: mapping.expires,
              lastVerified: mapping.lastVerified
            });
          }
        }
      }
      return dnsMappedAddresses;
    }
    maybeAddSNIComponent(ma, domain) {
      const components = ma.getComponents();
      for (let j = 0; j < components.length; j++) {
        if (components[j].code === CODE_TLS && components[j + 1]?.code !== CODE_SNI) {
          components.splice(j + 1, 0, {
            name: "sni",
            code: CODE_SNI,
            value: domain
          });
          return multiaddr(components);
        }
      }
    }
    confirm(ma, ttl) {
      const config = getNetConfig(ma);
      let host = config.host;
      if ((config.type === "ip4" || config.type === "ip6") && config.sni != null) {
        host = config.sni;
      }
      let startingConfidence = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === host) {
          this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      const config = getNetConfig(ma);
      if (config.type !== "ip4" && config.type !== "ip6") {
        return false;
      }
      const host = config.sni ?? config.host;
      let wasConfident = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === host) {
          this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
      return wasConfident;
    }
  };

  // node_modules/libp2p/dist/src/address-manager/ip-mappings.js
  var IPMappings = class {
    log;
    mappings;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
      this.mappings = trackedMap({
        name: "libp2p_address_manager_ip_mappings",
        metrics: components.metrics
      });
    }
    has(ma) {
      const config = getNetConfig(ma);
      if (config.type !== "ip4" && config.type !== "ip6") {
        return false;
      }
      for (const mappings of this.mappings.values()) {
        for (const mapping of mappings) {
          if (mapping.externalIp === config.host) {
            return true;
          }
        }
      }
      return false;
    }
    add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      const key = `${internalIp}-${internalPort}-${protocol}`;
      const mappings = this.mappings.get(key) ?? [];
      const mapping = {
        internalIp,
        internalPort,
        externalIp,
        externalPort,
        externalFamily: isIPv4(externalIp) ? 4 : 6,
        protocol,
        verified: false,
        expires: 0
      };
      mappings.push(mapping);
      this.mappings.set(key, mappings);
    }
    remove(ma) {
      const config = getNetConfig(ma);
      if (config.type !== "ip4" && config.type !== "ip6") {
        return false;
      }
      let wasConfident = false;
      for (const [key, mappings] of this.mappings.entries()) {
        for (let i2 = 0; i2 < mappings.length; i2++) {
          const mapping = mappings[i2];
          if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {
            this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol);
            wasConfident = wasConfident || mapping.verified;
            mappings.splice(i2, 1);
            i2--;
          }
        }
        if (mappings.length === 0) {
          this.mappings.delete(key);
        }
      }
      return wasConfident;
    }
    getAll(addresses) {
      const ipMappedAddresses = [];
      for (const { multiaddr: ma } of addresses) {
        if (!isNetworkAddress(ma)) {
          continue;
        }
        const config = getNetConfig(ma);
        if (config.type !== "ip4" && config.type !== "ip6") {
          continue;
        }
        let key;
        if (config.protocol === "tcp") {
          key = `${config.host}-${config.port}-tcp`;
        } else if (config.protocol === "udp") {
          key = `${config.host}-${config.port}-udp`;
        }
        if (key == null) {
          continue;
        }
        const mappings = this.mappings.get(key);
        if (mappings == null) {
          continue;
        }
        for (const mapping of mappings) {
          ipMappedAddresses.push({
            multiaddr: this.maybeOverrideIp(ma, mapping.externalIp, mapping.externalFamily, mapping.protocol, mapping.externalPort),
            verified: mapping.verified,
            type: "ip-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
      return ipMappedAddresses;
    }
    maybeOverrideIp(ma, externalIp, externalFamily, protocol, externalPort) {
      const components = ma.getComponents();
      const ipIndex = components.findIndex((c2) => c2.code === CODE_IP4 || c2.code === CODE_IP6);
      const portIndex = components.findIndex((c2) => c2.name === protocol);
      if (ipIndex > -1 && portIndex > -1) {
        components[ipIndex].value = externalIp;
        components[ipIndex].code = externalFamily === 4 ? CODE_IP4 : CODE_IP6;
        components[portIndex].value = `${externalPort}`;
        return multiaddr(components);
      }
      return ma;
    }
    confirm(ma, ttl) {
      if (!isNetworkAddress(ma)) {
        return false;
      }
      const config = getNetConfig(ma);
      let startingConfidence = false;
      for (const mappings of this.mappings.values()) {
        for (const mapping of mappings) {
          if (mapping.externalIp === config.host) {
            this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
            startingConfidence = mapping.verified;
            mapping.verified = true;
            mapping.expires = Date.now() + ttl;
            mapping.lastVerified = Date.now();
          }
        }
      }
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      if (!isNetworkAddress(ma)) {
        return false;
      }
      const config = getNetConfig(ma);
      let wasConfident = false;
      for (const mappings of this.mappings.values()) {
        for (let i2 = 0; i2 < mappings.length; i2++) {
          const mapping = mappings[i2];
          if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {
            this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol);
            wasConfident = wasConfident || mapping.verified;
            mapping.verified = false;
            mapping.expires = Date.now() + ttl;
          }
        }
      }
      return wasConfident;
    }
  };

  // node_modules/libp2p/dist/src/address-manager/observed-addresses.js
  var defaultValues2 = {
    maxObservedAddresses: 10
  };
  var ObservedAddresses = class {
    log;
    addresses;
    maxObservedAddresses;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
      this.addresses = trackedMap({
        name: "libp2p_address_manager_observed_addresses",
        metrics: components.metrics
      });
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
    }
    has(ma) {
      return this.addresses.has(ma.toString());
    }
    removePrefixed(prefix) {
      for (const key of this.addresses.keys()) {
        if (key.toString().startsWith(prefix)) {
          this.addresses.delete(key);
        }
      }
    }
    add(ma) {
      if (this.addresses.size === this.maxObservedAddresses) {
        return;
      }
      if (isPrivate(ma) || isLinkLocal(ma)) {
        return;
      }
      this.log("adding observed address %a", ma);
      this.addresses.set(ma.toString(), {
        verified: false,
        expires: 0
      });
    }
    getAll() {
      return Array.from(this.addresses).map(([ma, metadata]) => ({
        multiaddr: multiaddr(ma),
        verified: metadata.verified,
        type: "observed",
        expires: metadata.expires,
        lastVerified: metadata.lastVerified
      }));
    }
    remove(ma) {
      const startingConfidence = this.addresses.get(ma.toString())?.verified ?? false;
      this.log("removing observed address %a", ma);
      this.addresses.delete(ma.toString());
      return startingConfidence;
    }
    confirm(ma, ttl) {
      const addrString = ma.toString();
      const metadata = this.addresses.get(addrString) ?? {
        verified: false,
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
      const startingConfidence = metadata.verified;
      metadata.verified = true;
      metadata.expires = Date.now() + ttl;
      metadata.lastVerified = Date.now();
      this.log("marking observed address %a as verified", addrString);
      this.addresses.set(addrString, metadata);
      return startingConfidence;
    }
  };

  // node_modules/libp2p/dist/src/address-manager/transport-addresses.js
  var defaultValues3 = {
    maxObservedAddresses: 10
  };
  var TransportAddresses = class {
    log;
    addresses;
    maxObservedAddresses;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
      this.addresses = trackedMap({
        name: "libp2p_address_manager_transport_addresses",
        metrics: components.metrics
      });
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues3.maxObservedAddresses;
    }
    get(multiaddr2, ttl) {
      if (isPrivate(multiaddr2)) {
        return {
          multiaddr: multiaddr2,
          verified: true,
          type: "transport",
          expires: Date.now() + ttl,
          lastVerified: Date.now()
        };
      }
      const key = this.toKey(multiaddr2);
      let metadata = this.addresses.get(key);
      if (metadata == null) {
        metadata = {
          verified: !isNetworkAddress(multiaddr2),
          expires: 0
        };
        this.addresses.set(key, metadata);
      }
      return {
        multiaddr: multiaddr2,
        verified: metadata.verified,
        type: "transport",
        expires: metadata.expires,
        lastVerified: metadata.lastVerified
      };
    }
    has(ma) {
      const key = this.toKey(ma);
      return this.addresses.has(key);
    }
    remove(ma) {
      const key = this.toKey(ma);
      const startingConfidence = this.addresses.get(key)?.verified ?? false;
      this.log("removing observed address %a", ma);
      this.addresses.delete(key);
      return startingConfidence;
    }
    confirm(ma, ttl) {
      const key = this.toKey(ma);
      const metadata = this.addresses.get(key) ?? {
        verified: false,
        expires: 0,
        lastVerified: 0
      };
      const startingConfidence = metadata.verified;
      metadata.verified = true;
      metadata.expires = Date.now() + ttl;
      metadata.lastVerified = Date.now();
      this.addresses.set(key, metadata);
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      const key = this.toKey(ma);
      const metadata = this.addresses.get(key) ?? {
        verified: false,
        expires: 0
      };
      const startingConfidence = metadata.verified;
      metadata.verified = false;
      metadata.expires = Date.now() + ttl;
      this.addresses.set(key, metadata);
      return startingConfidence;
    }
    toKey(ma) {
      if (!isNetworkAddress(ma)) {
        return ma.toString();
      }
      const config = getNetConfig(ma);
      return `${config.host}-${config.port}-${config.protocol}`;
    }
  };

  // node_modules/libp2p/dist/src/address-manager/index.js
  var ONE_MINUTE = 6e4;
  var defaultValues4 = {
    maxObservedAddresses: 10,
    addressVerificationTTL: ONE_MINUTE * 10,
    addressVerificationRetry: ONE_MINUTE * 5
  };
  var defaultAddressFilter = (addrs) => addrs;
  function stripPeerId(ma, peerId) {
    const observedPeerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
    if (observedPeerIdStr != null) {
      const observedPeerId = peerIdFromString(observedPeerIdStr);
      if (observedPeerId.equals(peerId)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));
      }
    }
    return ma;
  }
  var AddressManager = class {
    log;
    components;
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    listen;
    announce;
    appendAnnounce;
    announceFilter;
    observed;
    dnsMappings;
    ipMappings;
    transportAddresses;
    observedAddressFilter;
    addressVerificationTTL;
    addressVerificationRetry;
    /**
     * Responsible for managing the peer addresses.
     * Peers can specify their listen and announce addresses.
     * The listen addresses will be used by the libp2p transports to listen for new connections,
     * while the announce addresses will be used for the peer addresses' to other peers in the network.
     */
    constructor(components, init = {}) {
      const { listen = [], announce = [], appendAnnounce = [] } = init;
      this.components = components;
      this.log = components.logger.forComponent("libp2p:address-manager");
      this.listen = listen.map((ma) => ma.toString());
      this.announce = new Set(announce.map((ma) => ma.toString()));
      this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
      this.observed = new ObservedAddresses(components, init);
      this.dnsMappings = new DNSMappings(components, init);
      this.ipMappings = new IPMappings(components, init);
      this.transportAddresses = new TransportAddresses(components, init);
      this.announceFilter = init.announceFilter ?? defaultAddressFilter;
      this.observedAddressFilter = createScalableCuckooFilter(1024);
      this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues4.addressVerificationTTL;
      this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues4.addressVerificationRetry;
      this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1e3);
      components.events.addEventListener("transport:listening", () => {
        this._updatePeerStoreAddresses();
      });
      components.events.addEventListener("transport:close", () => {
        this._updatePeerStoreAddresses();
      });
    }
    [Symbol.toStringTag] = "@libp2p/address-manager";
    _updatePeerStoreAddresses() {
      const addrs = this.getAddresses().map((ma) => {
        if (ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value === this.components.peerId.toString()) {
          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
        }
        return ma;
      });
      this.components.peerStore.patch(this.components.peerId, {
        multiaddrs: addrs
      }).catch((err2) => {
        this.log.error("error updating addresses - %e", err2);
      });
    }
    /**
     * Get peer listen multiaddrs
     */
    getListenAddrs() {
      return Array.from(this.listen).map((a2) => multiaddr(a2));
    }
    /**
     * Get peer announcing multiaddrs
     */
    getAnnounceAddrs() {
      return Array.from(this.announce).map((a2) => multiaddr(a2));
    }
    /**
     * Get peer announcing multiaddrs
     */
    getAppendAnnounceAddrs() {
      return Array.from(this.appendAnnounce).map((a2) => multiaddr(a2));
    }
    /**
     * Get observed multiaddrs
     */
    getObservedAddrs() {
      return this.observed.getAll().map((addr) => addr.multiaddr);
    }
    /**
     * Add peer observed addresses
     */
    addObservedAddr(addr) {
      const config = getNetConfig(addr);
      let socketAddress;
      switch (config.type) {
        case "ip4": {
          socketAddress = `${config.host}:${config.port}`;
          break;
        }
        case "ip6": {
          socketAddress = `[${config.host}]:${config.port}`;
          break;
        }
        default: {
          return;
        }
      }
      if (this.observedAddressFilter.has(socketAddress)) {
        return;
      }
      this.observedAddressFilter.add(socketAddress);
      addr = stripPeerId(addr, this.components.peerId);
      if (this.ipMappings.has(addr)) {
        return;
      }
      if (this.dnsMappings.has(addr)) {
        return;
      }
      this.observed.add(addr);
    }
    confirmObservedAddr(addr, options2) {
      addr = stripPeerId(addr, this.components.peerId);
      let startingConfidence = true;
      if (options2?.type === "transport" || this.transportAddresses.has(addr)) {
        const transportStartingConfidence = this.transportAddresses.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
        if (!transportStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (options2?.type === "dns-mapping" || this.dnsMappings.has(addr)) {
        const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
        if (!dnsMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (options2?.type === "ip-mapping" || this.ipMappings.has(addr)) {
        const ipMappingStartingConfidence = this.ipMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
        if (!ipMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (options2?.type === "observed" || this.observed.has(addr)) {
        if (this.maybeUpgradeToIPMapping(addr)) {
          this.ipMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
          startingConfidence = false;
        } else {
          const observedStartingConfidence = this.observed.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
          if (!observedStartingConfidence && startingConfidence) {
            startingConfidence = false;
          }
        }
      }
      if (!startingConfidence) {
        this._updatePeerStoreAddresses();
      }
    }
    removeObservedAddr(addr, options2) {
      addr = stripPeerId(addr, this.components.peerId);
      let startingConfidence = false;
      if (this.observed.has(addr)) {
        const observedStartingConfidence = this.observed.remove(addr);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.transportAddresses.has(addr)) {
        const transportStartingConfidence = this.transportAddresses.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
        if (!transportStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.dnsMappings.has(addr)) {
        const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
        if (!dnsMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.ipMappings.has(addr)) {
        const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
        if (!ipMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (startingConfidence) {
        this._updatePeerStoreAddresses();
      }
    }
    getAddresses() {
      const addresses = /* @__PURE__ */ new Set();
      const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
        if (!addr.verified) {
          return false;
        }
        const maStr = addr.multiaddr.toString();
        if (addresses.has(maStr)) {
          return false;
        }
        addresses.add(maStr);
        return true;
      }).map((address) => address.multiaddr);
      return this.announceFilter(multiaddrs.map((str) => {
        const ma = multiaddr(str);
        const lastComponent = ma.getComponents().pop();
        if (lastComponent?.value === this.components.peerId.toString()) {
          return ma;
        }
        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
      }));
    }
    getAddressesWithMetadata() {
      const announceMultiaddrs = this.getAnnounceAddrs();
      if (announceMultiaddrs.length > 0) {
        this.components.transportManager.getListeners().forEach((listener) => {
          listener.updateAnnounceAddrs(announceMultiaddrs);
        });
        return announceMultiaddrs.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          verified: true,
          type: "announce",
          expires: Date.now() + this.addressVerificationTTL,
          lastVerified: Date.now()
        }));
      }
      let addresses = [];
      addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
      const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs();
      if (appendAnnounceMultiaddrs.length > 0) {
        this.components.transportManager.getListeners().forEach((listener) => {
          listener.updateAnnounceAddrs(appendAnnounceMultiaddrs);
        });
        addresses = addresses.concat(appendAnnounceMultiaddrs.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          verified: true,
          type: "announce",
          expires: Date.now() + this.addressVerificationTTL,
          lastVerified: Date.now()
        })));
      }
      addresses = addresses.concat(this.observed.getAll());
      addresses = addresses.concat(this.ipMappings.getAll(addresses));
      addresses = addresses.concat(this.dnsMappings.getAll(addresses));
      return addresses;
    }
    addDNSMapping(domain, addresses) {
      this.dnsMappings.add(domain, addresses);
    }
    removeDNSMapping(domain) {
      if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
        this._updatePeerStoreAddresses();
      }
    }
    addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
      this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
    }
    removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
        this._updatePeerStoreAddresses();
      }
    }
    /**
     * Where an external service (router, gateway, etc) is forwarding traffic to
     * us, attempt to add an IP mapping for the external address - this will
     * include the observed mapping in the address list where we also have a DNS
     * mapping for the external IP.
     *
     * Returns true if we added a new mapping
     */
    maybeUpgradeToIPMapping(ma) {
      if (this.ipMappings.has(ma)) {
        return false;
      }
      if (!isNetworkAddress(ma)) {
        return false;
      }
      const config = getNetConfig(ma);
      if (config.type !== "ip4" || isPrivateIp(config.host) === true) {
        return false;
      }
      const listeners = this.components.transportManager.getListeners();
      const transportMatchers = [
        (ma2) => WebSockets.exactMatch(ma2) || WebSocketsSecure.exactMatch(ma2),
        (ma2) => TCP.exactMatch(ma2),
        (ma2) => QUIC_V1.exactMatch(ma2)
      ];
      for (const matcher of transportMatchers) {
        if (!matcher(ma)) {
          continue;
        }
        const transportListeners = listeners.filter((listener) => {
          return listener.getAddrs().filter((ma2) => {
            return getNetConfig(ma2).type === "ip4" && matcher(ma2);
          }).length > 0;
        });
        if (transportListeners.length !== 1) {
          continue;
        }
        const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
          return !isLoopback(ma2);
        }).pop();
        if (linkLocalAddr == null) {
          continue;
        }
        const linkLocalOptions = getNetConfig(linkLocalAddr);
        if (linkLocalOptions.port == null) {
          return false;
        }
        this.observed.remove(ma);
        this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, config.host, config.port, config.protocol);
        return true;
      }
      return false;
    }
  };

  // node_modules/libp2p/dist/src/errors.js
  var messages;
  (function(messages2) {
    messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
    messages2["NOT_FOUND"] = "Not found";
  })(messages || (messages = {}));
  var MissingServiceError = class extends Error {
    constructor(message2 = "Missing service") {
      super(message2);
      this.name = "MissingServiceError";
    }
  };
  var UnmetServiceDependenciesError = class extends Error {
    constructor(message2 = "Unmet service dependencies") {
      super(message2);
      this.name = "UnmetServiceDependenciesError";
    }
  };
  var NoContentRoutersError = class extends Error {
    constructor(message2 = "No content routers available") {
      super(message2);
      this.name = "NoContentRoutersError";
    }
  };
  var NoPeerRoutersError = class extends Error {
    constructor(message2 = "No peer routers available") {
      super(message2);
      this.name = "NoPeerRoutersError";
    }
  };
  var QueriedForSelfError = class extends Error {
    constructor(message2 = "Should not try to find self") {
      super(message2);
      this.name = "QueriedForSelfError";
    }
  };
  var UnhandledProtocolError = class extends Error {
    constructor(message2 = "Unhandled protocol error") {
      super(message2);
      this.name = "UnhandledProtocolError";
    }
  };
  var DuplicateProtocolHandlerError = class extends Error {
    constructor(message2 = "Duplicate protocol handler error") {
      super(message2);
      this.name = "DuplicateProtocolHandlerError";
    }
  };
  var DialDeniedError = class extends Error {
    constructor(message2 = "Dial denied error") {
      super(message2);
      this.name = "DialDeniedError";
    }
  };
  var UnsupportedListenAddressError = class extends Error {
    constructor(message2 = "No transport was configured to listen on this address") {
      super(message2);
      this.name = "UnsupportedListenAddressError";
    }
  };
  var UnsupportedListenAddressesError = class extends Error {
    constructor(message2 = "Configured listen addresses could not be listened on") {
      super(message2);
      this.name = "UnsupportedListenAddressesError";
    }
  };
  var NoValidAddressesError = class extends Error {
    constructor(message2 = "No valid addresses") {
      super(message2);
      this.name = "NoValidAddressesError";
    }
  };
  var ConnectionInterceptedError = class extends Error {
    constructor(message2 = "Connection intercepted") {
      super(message2);
      this.name = "ConnectionInterceptedError";
    }
  };
  var ConnectionDeniedError = class extends Error {
    constructor(message2 = "Connection denied") {
      super(message2);
      this.name = "ConnectionDeniedError";
    }
  };
  var MuxerUnavailableError = class extends Error {
    constructor(message2 = "Stream is not multiplexed") {
      super(message2);
      this.name = "MuxerUnavailableError";
    }
  };
  var EncryptionFailedError = class extends Error {
    constructor(message2 = "Encryption failed") {
      super(message2);
      this.name = "EncryptionFailedError";
    }
  };
  var TransportUnavailableError = class extends Error {
    constructor(message2 = "Transport unavailable") {
      super(message2);
      this.name = "TransportUnavailableError";
    }
  };
  var RecursionLimitError = class extends Error {
    constructor(message2 = "Max recursive depth reached") {
      super(message2);
      this.name = "RecursionLimitError";
    }
  };

  // node_modules/libp2p/dist/src/components.js
  var DefaultComponents = class {
    components = {};
    _started = false;
    constructor(init = {}) {
      this.components = {};
      for (const [key, value2] of Object.entries(init)) {
        this.components[key] = value2;
      }
      if (this.components.logger == null) {
        this.components.logger = defaultLogger();
      }
    }
    isStarted() {
      return this._started;
    }
    async _invokeStartableMethod(methodName) {
      await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
        await startable[methodName]?.();
      }));
    }
    async beforeStart() {
      await this._invokeStartableMethod("beforeStart");
    }
    async start() {
      await this._invokeStartableMethod("start");
      this._started = true;
    }
    async afterStart() {
      await this._invokeStartableMethod("afterStart");
    }
    async beforeStop() {
      await this._invokeStartableMethod("beforeStop");
    }
    async stop() {
      await this._invokeStartableMethod("stop");
      this._started = false;
    }
    async afterStop() {
      await this._invokeStartableMethod("afterStop");
    }
  };
  var OPTIONAL_SERVICES = [
    "metrics",
    "connectionProtector",
    "dns"
  ];
  var NON_SERVICE_PROPERTIES = [
    "components",
    "isStarted",
    "beforeStart",
    "start",
    "afterStart",
    "beforeStop",
    "stop",
    "afterStop",
    "then",
    "_invokeStartableMethod"
  ];
  function defaultComponents(init = {}) {
    const components = new DefaultComponents(init);
    const proxy = new Proxy(components, {
      get(target, prop, receiver) {
        if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
          const service = components.components[prop];
          if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
            throw new MissingServiceError(`${prop} not set`);
          }
          return service;
        }
        return Reflect.get(target, prop, receiver);
      },
      set(target, prop, value2) {
        if (typeof prop === "string") {
          components.components[prop] = value2;
        } else {
          Reflect.set(target, prop, value2);
        }
        return true;
      }
    });
    return proxy;
  }
  function checkServiceDependencies(components) {
    const serviceCapabilities2 = {};
    for (const service of Object.values(components.components)) {
      for (const capability of getServiceCapabilities(service)) {
        serviceCapabilities2[capability] = true;
      }
    }
    for (const service of Object.values(components.components)) {
      for (const capability of getServiceDependencies(service)) {
        if (serviceCapabilities2[capability] !== true) {
          throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
        }
      }
    }
  }
  function getServiceCapabilities(service) {
    if (Array.isArray(service?.[serviceCapabilities])) {
      return service[serviceCapabilities];
    }
    return [];
  }
  function getServiceDependencies(service) {
    if (Array.isArray(service?.[serviceDependencies])) {
      return service[serviceDependencies];
    }
    return [];
  }
  function getServiceName(service) {
    return service?.[Symbol.toStringTag] ?? service?.toString() ?? "unknown";
  }

  // node_modules/libp2p/dist/src/config/connection-gater.browser.js
  function connectionGater(gater = {}) {
    if (gater.denyDialMultiaddr == null) {
      gater.denyDialMultiaddr = (multiaddr2) => {
        if (WebSockets.matches(multiaddr2)) {
          return true;
        }
        return isPrivate(multiaddr2);
      };
    }
    return gater;
  }

  // node_modules/libp2p/dist/src/get-peer.js
  function getPeerAddress(peer) {
    if (isPeerId(peer)) {
      return { peerId: peer, multiaddrs: [] };
    }
    let multiaddrs = Array.isArray(peer) ? peer : [peer];
    let peerId;
    if (multiaddrs.length > 0) {
      const peerIdStr = multiaddrs[0].getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
      peerId = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
      multiaddrs.forEach((ma) => {
        if (!isMultiaddr(ma)) {
          throw new InvalidMultiaddrError("Invalid multiaddr");
        }
        const maPeerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
        if (maPeerIdStr == null) {
          if (peerId != null) {
            throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
          }
        } else {
          const maPeerId = peerIdFromString(maPeerIdStr);
          if (peerId?.equals(maPeerId) !== true) {
            throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
          }
        }
      });
    }
    multiaddrs = multiaddrs.filter((ma) => {
      return !PEER_ID.exactMatch(ma);
    });
    return {
      peerId,
      multiaddrs
    };
  }

  // node_modules/libp2p/dist/src/connection-manager/utils.js
  var DEFAULT_CLOSABLE_PROTOCOLS = [
    // identify
    "/ipfs/id/1.0.0",
    // identify-push
    "/ipfs/id/push/1.0.0",
    // autonat
    "/libp2p/autonat/1.0.0",
    // dcutr
    "/libp2p/dcutr"
  ];
  async function safelyCloseConnectionIfUnused(connection, options2) {
    const streamProtocols = connection?.streams?.map((stream) => stream.protocol) ?? [];
    const closableProtocols = options2?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS;
    if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
      return;
    }
    try {
      await connection?.close(options2);
    } catch (err2) {
      connection?.abort(err2);
    }
  }
  function multiaddrToIpNet(ma) {
    const config = getNetConfig(ma);
    let mask = config.cidr;
    if (config.type !== "ip4" && config.type !== "ip6") {
      throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
    }
    if (mask == null) {
      switch (config.type) {
        case "ip4": {
          mask = 32;
          break;
        }
        case "ip6": {
          mask = 128;
          break;
        }
        default: {
          throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
        }
      }
    }
    return new IpNet(config.host, mask);
  }
  function isDirect(ma) {
    return !Circuit.exactMatch(ma);
  }
  function findExistingConnection(peerId, connections, dialAddresses) {
    if (peerId == null || connections == null) {
      return;
    }
    const existingConnection = connections.sort((a2, b) => {
      if (a2.direct) {
        return -1;
      }
      if (b.direct) {
        return 1;
      }
      return 0;
    }).find((con) => con.limits == null);
    if (existingConnection == null || existingConnection.direct || dialAddresses == null) {
      return existingConnection;
    }
    const wouldUpgradeToDirect = dialAddresses.some((ma) => isDirect(ma));
    if (wouldUpgradeToDirect) {
      return;
    }
    return existingConnection;
  }

  // node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
  var ConnectionPruner = class {
    connectionManager;
    peerStore;
    allow;
    events;
    log;
    constructor(components, init = {}) {
      this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
      this.connectionManager = components.connectionManager;
      this.peerStore = components.peerStore;
      this.events = components.events;
      this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
      this.maybePruneConnections = this.maybePruneConnections.bind(this);
    }
    start() {
      this.events.addEventListener("connection:open", this.maybePruneConnections);
    }
    stop() {
      this.events.removeEventListener("connection:open", this.maybePruneConnections);
    }
    maybePruneConnections() {
      this._maybePruneConnections().catch((err2) => {
        this.log.error("error while pruning connections - %e", err2);
      });
    }
    /**
     * If we have more connections than our maximum, select some excess connections
     * to prune based on peer value
     */
    async _maybePruneConnections() {
      const connections = this.connectionManager.getConnections();
      const numConnections = connections.length;
      const maxConnections = this.connectionManager.getMaxConnections();
      this.log("checking max connections limit %d/%d", numConnections, maxConnections);
      if (numConnections <= maxConnections) {
        return;
      }
      const peerValues = new PeerMap();
      for (const connection of connections) {
        const remotePeer = connection.remotePeer;
        if (peerValues.has(remotePeer)) {
          continue;
        }
        peerValues.set(remotePeer, 0);
        try {
          const peer = await this.peerStore.get(remotePeer);
          peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
            return acc + curr.value;
          }, 0));
        } catch (err2) {
          if (err2.name !== "NotFoundError") {
            this.log.error("error loading peer tags - %e", err2);
          }
        }
      }
      const sortedConnections = this.sortConnections(connections, peerValues);
      const toPrune = Math.max(numConnections - maxConnections, 0);
      const toClose = [];
      for (const connection of sortedConnections) {
        this.log("too many connections open - closing a connection to %p", connection.remotePeer);
        const connectionInAllowList = this.allow.some((ipNet) => {
          if (isNetworkAddress(connection.remoteAddr)) {
            const config = getNetConfig(connection.remoteAddr);
            return ipNet.contains(config.host);
          }
          return true;
        });
        if (!connectionInAllowList) {
          toClose.push(connection);
        }
        if (toClose.length === toPrune) {
          break;
        }
      }
      await Promise.all(toClose.map(async (connection) => {
        await safelyCloseConnectionIfUnused(connection, {
          signal: AbortSignal.timeout(1e3)
        });
      }));
      this.events.safeDispatchEvent("connection:prune", { detail: toClose });
    }
    sortConnections(connections, peerValues) {
      return connections.sort((a2, b) => {
        const connectionALifespan = a2.timeline.open;
        const connectionBLifespan = b.timeline.open;
        if (connectionALifespan < connectionBLifespan) {
          return 1;
        }
        if (connectionALifespan > connectionBLifespan) {
          return -1;
        }
        return 0;
      }).sort((a2, b) => {
        if (a2.direction === "outbound" && b.direction === "inbound") {
          return 1;
        }
        if (a2.direction === "inbound" && b.direction === "outbound") {
          return -1;
        }
        return 0;
      }).sort((a2, b) => {
        if (a2.streams.length > b.streams.length) {
          return 1;
        }
        if (a2.streams.length < b.streams.length) {
          return -1;
        }
        return 0;
      }).sort((a2, b) => {
        const peerAValue = peerValues.get(a2.remotePeer) ?? 0;
        const peerBValue = peerValues.get(b.remotePeer) ?? 0;
        if (peerAValue > peerBValue) {
          return 1;
        }
        if (peerAValue < peerBValue) {
          return -1;
        }
        return 0;
      });
    }
  };

  // node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
  var DIAL_TIMEOUT = 1e4;
  var CONNECTION_CLOSE_TIMEOUT = 1e3;
  var INBOUND_UPGRADE_TIMEOUT = 1e4;
  var PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
  var MAX_PEER_ADDRS_TO_DIAL = 25;
  var INBOUND_CONNECTION_THRESHOLD = 5;
  var MAX_INCOMING_PENDING_CONNECTIONS = 10;
  var MAX_PARALLEL_RECONNECTS = 5;
  var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
  var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
  var MAX_DIAL_QUEUE_LENGTH = 500;
  var MAX_RECURSIVE_DEPTH2 = 32;

  // node_modules/libp2p/dist/src/connection-manager/constants.browser.js
  var MAX_CONNECTIONS = 100;
  var MAX_PARALLEL_DIALS = 50;

  // node_modules/libp2p/dist/src/connection-manager/address-sorter.js
  function reliableTransportsFirst(a2, b) {
    const isATcp = TCP.exactMatch(a2.multiaddr);
    const isBTcp = TCP.exactMatch(b.multiaddr);
    if (isATcp && !isBTcp) {
      return -1;
    }
    if (!isATcp && isBTcp) {
      return 1;
    }
    const isAWebSocketSecure = WebSocketsSecure.exactMatch(a2.multiaddr);
    const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr);
    if (isAWebSocketSecure && !isBWebSocketSecure) {
      return -1;
    }
    if (!isAWebSocketSecure && isBWebSocketSecure) {
      return 1;
    }
    const isAWebSocket = WebSockets.exactMatch(a2.multiaddr);
    const isBWebSocket = WebSockets.exactMatch(b.multiaddr);
    if (isAWebSocket && !isBWebSocket) {
      return -1;
    }
    if (!isAWebSocket && isBWebSocket) {
      return 1;
    }
    const isAWebRTC = WebRTC.exactMatch(a2.multiaddr);
    const isBWebRTC = WebRTC.exactMatch(b.multiaddr);
    if (isAWebRTC && !isBWebRTC) {
      return -1;
    }
    if (!isAWebRTC && isBWebRTC) {
      return 1;
    }
    const isAWebRTCDirect = WebRTCDirect.exactMatch(a2.multiaddr);
    const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr);
    if (isAWebRTCDirect && !isBWebRTCDirect) {
      return -1;
    }
    if (!isAWebRTCDirect && isBWebRTCDirect) {
      return 1;
    }
    const isAWebTransport = WebTransport.exactMatch(a2.multiaddr);
    const isBWebTransport = WebTransport.exactMatch(b.multiaddr);
    if (isAWebTransport && !isBWebTransport) {
      return -1;
    }
    if (!isAWebTransport && isBWebTransport) {
      return 1;
    }
    return 0;
  }
  function loopbackAddressLast(a2, b) {
    const isALoopback = isLoopback(a2.multiaddr);
    const isBLoopback = isLoopback(b.multiaddr);
    if (isALoopback && !isBLoopback) {
      return 1;
    } else if (!isALoopback && isBLoopback) {
      return -1;
    }
    return 0;
  }
  function publicAddressesFirst(a2, b) {
    const isAPrivate = isPrivate(a2.multiaddr);
    const isBPrivate = isPrivate(b.multiaddr);
    if (isAPrivate && !isBPrivate) {
      return 1;
    } else if (!isAPrivate && isBPrivate) {
      return -1;
    }
    return 0;
  }
  function certifiedAddressesFirst(a2, b) {
    if (a2.isCertified && !b.isCertified) {
      return -1;
    } else if (!a2.isCertified && b.isCertified) {
      return 1;
    }
    return 0;
  }
  function circuitRelayAddressesLast(a2, b) {
    const isACircuit = Circuit.exactMatch(a2.multiaddr);
    const isBCircuit = Circuit.exactMatch(b.multiaddr);
    if (isACircuit && !isBCircuit) {
      return 1;
    } else if (!isACircuit && isBCircuit) {
      return -1;
    }
    return 0;
  }
  function defaultAddressSorter(addresses) {
    return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
  }

  // node_modules/libp2p/dist/src/connection-manager/resolvers/dnsaddr.js
  var DNSAddrResolver = class {
    dns;
    canResolve(ma) {
      return ma.getComponents().some(({ name: name9 }) => name9 === "dnsaddr");
    }
    async resolve(ma, options2) {
      const hostname = ma.getComponents().find((component) => component.name === "dnsaddr")?.value;
      if (hostname == null) {
        return [ma];
      }
      const resolver = this.getDNS(options2);
      const result = await resolver.query(`_dnsaddr.${hostname}`, {
        signal: options2?.signal,
        types: [
          RecordType.TXT
        ]
      });
      const peerId = ma.getComponents().find((component) => component.name === "p2p")?.value;
      const output = [];
      for (const answer of result.Answer) {
        const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
        if (addr == null) {
          continue;
        }
        if (peerId != null && !addr.includes(peerId)) {
          continue;
        }
        output.push(multiaddr(addr));
      }
      return output;
    }
    getDNS(options2) {
      if (options2.dns != null) {
        return options2.dns;
      }
      if (this.dns == null) {
        this.dns = dns();
      }
      return this.dns;
    }
  };
  var dnsaddrResolver = new DNSAddrResolver();

  // node_modules/libp2p/dist/src/connection-manager/resolvers/index.js
  async function resolveMultiaddr(address, resolvers2, options2) {
    const depth = options2.depth ?? 0;
    if (depth > (options2.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH2)) {
      throw new RecursionLimitError("Max recursive depth reached");
    }
    let resolved = false;
    const output = [];
    for (const resolver of Object.values(resolvers2)) {
      if (resolver.canResolve(address)) {
        resolved = true;
        const addresses = await resolver.resolve(address, options2);
        for (const address2 of addresses) {
          output.push(...await resolveMultiaddr(address2, resolvers2, {
            ...options2,
            depth: depth + 1
          }));
        }
      }
    }
    if (resolved === false) {
      output.push(address);
    }
    return output;
  }

  // node_modules/libp2p/dist/src/connection-manager/dial-queue.js
  var defaultOptions3 = {
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
    maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
    dialTimeout: DIAL_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    }
  };
  var DialQueue = class {
    queue;
    components;
    addressSorter;
    maxPeerAddrsToDial;
    maxDialQueueLength;
    dialTimeout;
    shutDownController;
    connections;
    log;
    resolvers;
    constructor(components, init = {}) {
      this.addressSorter = init.addressSorter;
      this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions3.maxPeerAddrsToDial;
      this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions3.maxDialQueueLength;
      this.dialTimeout = init.dialTimeout ?? defaultOptions3.dialTimeout;
      this.connections = init.connections ?? new PeerMap();
      this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
      this.components = components;
      this.resolvers = init.resolvers ?? defaultOptions3.resolvers;
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
      this.queue = new PriorityQueue({
        concurrency: init.maxParallelDials ?? defaultOptions3.maxParallelDials,
        metricName: "libp2p_dial_queue",
        metrics: components.metrics
      });
      this.queue.addEventListener("failure", (event) => {
        if (event.detail?.error.name !== AbortError.name) {
          this.log.error("error in dial queue - %e", event.detail.error);
        }
      });
    }
    start() {
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
    }
    /**
     * Clears any pending dials
     */
    stop() {
      this.shutDownController.abort();
      this.queue.abort();
    }
    /**
     * Connects to a given peer, multiaddr or list of multiaddrs.
     *
     * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
     * multiaddrs are passed only those will be dialled.
     *
     * Where a list of multiaddrs is passed, if any contain a peer id then all
     * multiaddrs in the list must contain the same peer id.
     *
     * The dial to the first address that is successfully able to upgrade a
     * connection will be used, all other dials will be aborted when that happens.
     */
    async dial(peerIdOrMultiaddr, options2 = {}) {
      const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
      if (peerId != null && options2.force !== true) {
        const existingConnection = findExistingConnection(peerId, this.connections.get(peerId), multiaddrs);
        if (existingConnection != null) {
          this.log("already connected to %a", existingConnection.remoteAddr);
          options2.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
          return existingConnection;
        }
      }
      const existingDial = this.queue.queue.find((job) => {
        if (peerId?.equals(job.options.peerId) === true) {
          return true;
        }
        const addresses = job.options.multiaddrs;
        if (addresses == null) {
          return false;
        }
        for (const multiaddr2 of multiaddrs) {
          if (addresses.has(multiaddr2.toString())) {
            return true;
          }
        }
        return false;
      });
      if (existingDial != null) {
        this.log("joining existing dial target for %p", peerId);
        for (const multiaddr2 of multiaddrs) {
          existingDial.options.multiaddrs.add(multiaddr2.toString());
        }
        options2.onProgress?.(new CustomProgressEvent("dial-queue:already-in-dial-queue"));
        return existingDial.join(options2);
      }
      if (this.queue.size >= this.maxDialQueueLength) {
        throw new DialError("Dial queue is full");
      }
      this.log("creating dial target for %p", peerId, multiaddrs.map((ma) => ma.toString()));
      options2.onProgress?.(new CustomProgressEvent("dial-queue:add-to-dial-queue"));
      return this.queue.add(async (options3) => {
        options3.onProgress?.(new CustomProgressEvent("dial-queue:start-dial"));
        const signal = anySignal([
          this.shutDownController.signal,
          options3.signal
        ]);
        setMaxListeners(Infinity, signal);
        try {
          return await this.dialPeer(options3, signal);
        } finally {
          signal.clear();
        }
      }, {
        peerId,
        priority: options2.priority ?? DEFAULT_DIAL_PRIORITY,
        multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
        signal: options2.signal ?? AbortSignal.timeout(this.dialTimeout),
        onProgress: options2.onProgress
      });
    }
    async dialPeer(options2, signal) {
      const peerId = options2.peerId;
      const multiaddrs = options2.multiaddrs;
      const failedMultiaddrs = /* @__PURE__ */ new Set();
      let forcePeerLookup = options2.multiaddrs.size === 0;
      let dialed = 0;
      let dialIteration = 0;
      const errors = [];
      this.log("starting dial to %p", peerId);
      while (forcePeerLookup || multiaddrs.size > 0) {
        dialIteration++;
        forcePeerLookup = false;
        const addrsToDial = [];
        const addrs = new Set(options2.multiaddrs);
        multiaddrs.clear();
        this.log("calculating addrs to dial %p from %s", peerId, [...addrs]);
        const calculatedAddrs = await this.calculateMultiaddrs(peerId, addrs, {
          ...options2,
          signal
        });
        for (const addr of calculatedAddrs) {
          if (failedMultiaddrs.has(addr.multiaddr.toString())) {
            this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId);
            continue;
          }
          addrsToDial.push(addr);
        }
        this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId, addrsToDial.map((ma) => ma.multiaddr.toString()));
        options2?.onProgress?.(new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
        for (const address of addrsToDial) {
          if (dialed === this.maxPeerAddrsToDial) {
            this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options2.peerId);
            throw new DialError("Peer had more than maxPeerAddrsToDial");
          }
          dialed++;
          try {
            const conn = await this.components.transportManager.dial(address.multiaddr, {
              ...options2,
              signal
            });
            this.log("dial to %a succeeded", address.multiaddr);
            try {
              await this.components.peerStore.merge(conn.remotePeer, {
                multiaddrs: [
                  conn.remoteAddr
                ],
                metadata: {
                  [LAST_DIAL_SUCCESS_KEY]: fromString2(Date.now().toString())
                }
              });
            } catch (err2) {
              this.log.error("could not update last dial failure key for %p - %e", peerId, err2);
            }
            return conn;
          } catch (err2) {
            this.log.error("dial failed to %a - %e", address.multiaddr, err2);
            failedMultiaddrs.add(address.multiaddr.toString());
            if (peerId != null) {
              try {
                await this.components.peerStore.merge(peerId, {
                  metadata: {
                    [LAST_DIAL_FAILURE_KEY]: fromString2(Date.now().toString())
                  }
                });
              } catch (err3) {
                this.log.error("could not update last dial failure key for %p - %e", peerId, err3);
              }
            }
            if (signal.aborted) {
              throw new TimeoutError(err2.message);
            }
            errors.push(err2);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      }
      throw new AggregateError(errors, "All multiaddr dials failed");
    }
    // eslint-disable-next-line complexity
    async calculateMultiaddrs(peerId, multiaddrs = /* @__PURE__ */ new Set(), options2 = {}) {
      const addrs = [...multiaddrs].map((ma) => ({
        multiaddr: multiaddr(ma),
        isCertified: false
      }));
      if (peerId != null) {
        if (this.components.peerId.equals(peerId)) {
          throw new DialError("Tried to dial self");
        }
        if (await this.components.connectionGater.denyDialPeer?.(peerId) === true) {
          throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
        }
        if (addrs.length === 0) {
          this.log("loading multiaddrs for %p", peerId);
          try {
            const peer = await this.components.peerStore.get(peerId);
            addrs.push(...peer.addresses);
            this.log("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          } catch (err2) {
            if (err2.name !== "NotFoundError") {
              throw err2;
            }
          }
        }
        if (addrs.length === 0) {
          this.log("looking up multiaddrs for %p in the peer routing", peerId);
          try {
            const peerInfo = await this.components.peerRouting.findPeer(peerId, options2);
            this.log("found multiaddrs for %p in the peer routing", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
            addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
              multiaddr: multiaddr2,
              isCertified: false
            })));
          } catch (err2) {
            if (err2.name === "NoPeerRoutersError") {
              this.log("no peer routers configured", peerId);
            } else {
              this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId, err2);
            }
          }
        }
      }
      let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
        const result = await resolveMultiaddr(addr.multiaddr, this.resolvers, {
          dns: this.components.dns,
          log: this.log,
          ...options2
        });
        if (result.length === 1 && result[0].equals(addr.multiaddr)) {
          return addr;
        }
        return result.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          isCertified: false
        }));
      }))).flat();
      if (peerId != null) {
        const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
        resolvedAddresses = resolvedAddresses.map((addr) => {
          const lastComponent = addr.multiaddr.getComponents().pop();
          if (lastComponent?.name !== "p2p") {
            return {
              multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
              isCertified: addr.isCertified
            };
          }
          return addr;
        });
      }
      const filteredAddrs = resolvedAddresses.filter((addr) => {
        if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
          return false;
        }
        const addrPeerId = addr.multiaddr.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
        if (peerId != null && addrPeerId != null) {
          return peerId.equals(addrPeerId);
        }
        return true;
      });
      const dedupedAddrs = /* @__PURE__ */ new Map();
      for (const addr of filteredAddrs) {
        const maStr = addr.multiaddr.toString();
        const existing = dedupedAddrs.get(maStr);
        if (existing != null) {
          existing.isCertified = existing.isCertified || addr.isCertified || false;
          continue;
        }
        dedupedAddrs.set(maStr, addr);
      }
      const dedupedMultiaddrs = [...dedupedAddrs.values()];
      if (dedupedMultiaddrs.length === 0) {
        throw new NoValidAddressesError("The dial request has no valid addresses");
      }
      const gatedAddrs = [];
      for (const addr of dedupedMultiaddrs) {
        if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
          continue;
        }
        gatedAddrs.push(addr);
      }
      const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
      if (sortedGatedAddrs.length === 0) {
        throw new DialDeniedError("The connection gater denied all addresses in the dial request");
      }
      this.log.trace("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      this.log.trace("addresses for %p after filtering", peerId ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      return sortedGatedAddrs;
    }
    async isDialable(multiaddr2, options2 = {}) {
      if (!Array.isArray(multiaddr2)) {
        multiaddr2 = [multiaddr2];
      }
      try {
        const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options2);
        if (options2.runOnLimitedConnection === false) {
          return addresses.find((addr) => {
            return !Circuit.matches(addr.multiaddr);
          }) != null;
        }
        return true;
      } catch {
      }
      return false;
    }
  };

  // node_modules/is-network-error/index.js
  var objectToString = Object.prototype.toString;
  var isError = (value2) => objectToString.call(value2) === "[object Error]";
  var errorMessages = /* @__PURE__ */ new Set([
    "network error",
    // Chrome
    "Failed to fetch",
    // Chrome
    "NetworkError when attempting to fetch resource.",
    // Firefox
    "The Internet connection appears to be offline.",
    // Safari 16
    "Network request failed",
    // `cross-fetch`
    "fetch failed",
    // Undici (Node.js)
    "terminated",
    // Undici (Node.js)
    " A network error occurred.",
    // Bun (WebKit)
    "Network connection lost"
    // Cloudflare Workers (fetch)
  ]);
  function isNetworkError(error) {
    const isValid2 = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
    if (!isValid2) {
      return false;
    }
    const { message: message2, stack } = error;
    if (message2 === "Load failed") {
      return stack === void 0 || "__sentry_captured__" in error;
    }
    if (message2.startsWith("error sending request for url")) {
      return true;
    }
    return errorMessages.has(message2);
  }

  // node_modules/p-retry/index.js
  function validateRetries(retries) {
    if (typeof retries === "number") {
      if (retries < 0) {
        throw new TypeError("Expected `retries` to be a non-negative number.");
      }
      if (Number.isNaN(retries)) {
        throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
      }
    } else if (retries !== void 0) {
      throw new TypeError("Expected `retries` to be a number or Infinity.");
    }
  }
  function validateNumberOption(name9, value2, { min = 0, allowInfinity = false } = {}) {
    if (value2 === void 0) {
      return;
    }
    if (typeof value2 !== "number" || Number.isNaN(value2)) {
      throw new TypeError(`Expected \`${name9}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
    }
    if (!allowInfinity && !Number.isFinite(value2)) {
      throw new TypeError(`Expected \`${name9}\` to be a finite number.`);
    }
    if (value2 < min) {
      throw new TypeError(`Expected \`${name9}\` to be \u2265 ${min}.`);
    }
  }
  var AbortError7 = class extends Error {
    constructor(message2) {
      super();
      if (message2 instanceof Error) {
        this.originalError = message2;
        ({ message: message2 } = message2);
      } else {
        this.originalError = new Error(message2);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message2;
    }
  };
  function calculateDelay(retriesConsumed, options2) {
    const attempt = Math.max(1, retriesConsumed + 1);
    const random = options2.randomize ? Math.random() + 1 : 1;
    let timeout = Math.round(random * options2.minTimeout * options2.factor ** (attempt - 1));
    timeout = Math.min(timeout, options2.maxTimeout);
    return timeout;
  }
  function calculateRemainingTime(start2, max2) {
    if (!Number.isFinite(max2)) {
      return max2;
    }
    return max2 - (performance.now() - start2);
  }
  async function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options: options2 }) {
    const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
    if (normalizedError instanceof AbortError7) {
      throw normalizedError.originalError;
    }
    const retriesLeft = Number.isFinite(options2.retries) ? Math.max(0, options2.retries - retriesConsumed) : options2.retries;
    const maxRetryTime = options2.maxRetryTime ?? Number.POSITIVE_INFINITY;
    const context = Object.freeze({
      error: normalizedError,
      attemptNumber,
      retriesLeft,
      retriesConsumed
    });
    await options2.onFailedAttempt(context);
    if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
      throw normalizedError;
    }
    const consumeRetry = await options2.shouldConsumeRetry(context);
    const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
    if (remainingTime <= 0 || retriesLeft <= 0) {
      throw normalizedError;
    }
    if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
      if (consumeRetry) {
        throw normalizedError;
      }
      options2.signal?.throwIfAborted();
      return false;
    }
    if (!await options2.shouldRetry(context)) {
      throw normalizedError;
    }
    if (!consumeRetry) {
      options2.signal?.throwIfAborted();
      return false;
    }
    const delayTime = calculateDelay(retriesConsumed, options2);
    const finalDelay = Math.min(delayTime, remainingTime);
    if (finalDelay > 0) {
      await new Promise((resolve8, reject) => {
        const onAbort = () => {
          clearTimeout(timeoutToken);
          options2.signal?.removeEventListener("abort", onAbort);
          reject(options2.signal.reason);
        };
        const timeoutToken = setTimeout(() => {
          options2.signal?.removeEventListener("abort", onAbort);
          resolve8();
        }, finalDelay);
        if (options2.unref) {
          timeoutToken.unref?.();
        }
        options2.signal?.addEventListener("abort", onAbort, { once: true });
      });
    }
    options2.signal?.throwIfAborted();
    return true;
  }
  async function pRetry(input, options2 = {}) {
    options2 = { ...options2 };
    validateRetries(options2.retries);
    if (Object.hasOwn(options2, "forever")) {
      throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
    }
    options2.retries ??= 10;
    options2.factor ??= 2;
    options2.minTimeout ??= 1e3;
    options2.maxTimeout ??= Number.POSITIVE_INFINITY;
    options2.maxRetryTime ??= Number.POSITIVE_INFINITY;
    options2.randomize ??= false;
    options2.onFailedAttempt ??= () => {
    };
    options2.shouldRetry ??= () => true;
    options2.shouldConsumeRetry ??= () => true;
    validateNumberOption("factor", options2.factor, { min: 0, allowInfinity: false });
    validateNumberOption("minTimeout", options2.minTimeout, { min: 0, allowInfinity: false });
    validateNumberOption("maxTimeout", options2.maxTimeout, { min: 0, allowInfinity: true });
    validateNumberOption("maxRetryTime", options2.maxRetryTime, { min: 0, allowInfinity: true });
    if (!(options2.factor > 0)) {
      options2.factor = 1;
    }
    options2.signal?.throwIfAborted();
    let attemptNumber = 0;
    let retriesConsumed = 0;
    const startTime = performance.now();
    while (Number.isFinite(options2.retries) ? retriesConsumed <= options2.retries : true) {
      attemptNumber++;
      try {
        options2.signal?.throwIfAborted();
        const result = await input(attemptNumber);
        options2.signal?.throwIfAborted();
        return result;
      } catch (error) {
        if (await onAttemptFailure({
          error,
          attemptNumber,
          retriesConsumed,
          startTime,
          options: options2
        })) {
          retriesConsumed++;
        }
      }
    }
    throw new Error("Retry attempts exhausted without throwing an error.");
  }

  // node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
  var ReconnectQueue = class {
    log;
    queue;
    started;
    peerStore;
    retries;
    retryInterval;
    backoffFactor;
    connectionManager;
    events;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:reconnect-queue");
      this.peerStore = components.peerStore;
      this.connectionManager = components.connectionManager;
      this.queue = new PeerQueue({
        concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
        metricName: "libp2p_reconnect_queue",
        metrics: components.metrics
      });
      this.started = false;
      this.retries = init.retries ?? 5;
      this.backoffFactor = init.backoffFactor;
      this.retryInterval = init.retryInterval;
      this.events = components.events;
      components.events.addEventListener("peer:disconnect", (evt) => {
        this.maybeReconnect(evt.detail).catch((err2) => {
          this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err2);
        });
      });
    }
    async maybeReconnect(peerId) {
      if (!this.started) {
        return;
      }
      const peer = await this.peerStore.get(peerId);
      if (!hasKeepAliveTag(peer)) {
        return;
      }
      if (this.queue.has(peerId)) {
        return;
      }
      this.queue.add(async (options2) => {
        await pRetry(async (attempt) => {
          if (!this.started) {
            return;
          }
          try {
            await this.connectionManager.openConnection(peerId, {
              signal: options2?.signal
            });
          } catch (err2) {
            this.log("reconnecting to %p attempt %d of %d failed - %e", peerId, attempt, this.retries, err2);
            throw err2;
          }
        }, {
          signal: options2?.signal,
          retries: this.retries,
          factor: this.backoffFactor,
          minTimeout: this.retryInterval
        });
      }, {
        peerId
      }).catch(async (err2) => {
        this.log.error("failed to reconnect to %p - %e", peerId, err2);
        const tags = {};
        [...peer.tags.keys()].forEach((key) => {
          if (key.startsWith(KEEP_ALIVE)) {
            tags[key] = void 0;
          }
        });
        await this.peerStore.merge(peerId, {
          tags
        });
        this.events.safeDispatchEvent("peer:reconnect-failure", {
          detail: peerId
        });
      }).catch(async (err2) => {
        this.log.error("failed to remove keep-alive tag from %p - %e", peerId, err2);
      });
    }
    start() {
      this.started = true;
    }
    async afterStart() {
      void Promise.resolve().then(async () => {
        const keepAlivePeers = await this.peerStore.all({
          filters: [
            (peer) => hasKeepAliveTag(peer)
          ]
        });
        await Promise.all(keepAlivePeers.map(async (peer) => {
          await this.connectionManager.openConnection(peer.id).catch((err2) => {
            this.log.error("could not open connection to keepalive peer - %e", err2);
          });
        }));
      }).catch((err2) => {
        this.log.error("error reconnect to peers after start - %e", err2);
      });
    }
    stop() {
      this.started = false;
      this.queue.abort();
    }
  };
  function hasKeepAliveTag(peer) {
    for (const tag of peer.tags.keys()) {
      if (tag.startsWith(KEEP_ALIVE)) {
        return true;
      }
    }
    return false;
  }

  // node_modules/libp2p/dist/src/connection-manager/index.js
  var DEFAULT_DIAL_PRIORITY = 50;
  var defaultOptions4 = {
    maxConnections: MAX_CONNECTIONS,
    inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
    maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
  };
  var DefaultConnectionManager = class {
    started;
    connections;
    allow;
    deny;
    maxIncomingPendingConnections;
    incomingPendingConnections;
    outboundPendingConnections;
    maxConnections;
    dialQueue;
    reconnectQueue;
    connectionPruner;
    inboundConnectionRateLimiter;
    peerStore;
    metrics;
    events;
    log;
    peerId;
    constructor(components, init = {}) {
      this.maxConnections = init.maxConnections ?? defaultOptions4.maxConnections;
      if (this.maxConnections < 1) {
        throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
      }
      this.connections = new PeerMap();
      this.started = false;
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.metrics = components.metrics;
      this.events = components.events;
      this.log = components.logger.forComponent("libp2p:connection-manager");
      this.onConnect = this.onConnect.bind(this);
      this.onDisconnect = this.onDisconnect.bind(this);
      this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(multiaddr(str)));
      this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(multiaddr(str)));
      this.incomingPendingConnections = 0;
      this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions4.maxIncomingPendingConnections;
      this.outboundPendingConnections = 0;
      this.inboundConnectionRateLimiter = new RateLimiter({
        points: init.inboundConnectionThreshold ?? defaultOptions4.inboundConnectionThreshold,
        duration: 1
      });
      this.connectionPruner = new ConnectionPruner({
        connectionManager: this,
        peerStore: components.peerStore,
        events: components.events,
        logger: components.logger
      }, {
        allow: init.allow?.map((a2) => multiaddr(a2))
      });
      this.dialQueue = new DialQueue(components, {
        addressSorter: init.addressSorter,
        maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
        maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
        maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
        dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
        resolvers: init.resolvers ?? {
          dnsaddr: dnsaddrResolver
        },
        connections: this.connections
      });
      this.reconnectQueue = new ReconnectQueue({
        events: components.events,
        peerStore: components.peerStore,
        logger: components.logger,
        connectionManager: this
      }, {
        retries: init.reconnectRetries,
        retryInterval: init.reconnectRetryInterval,
        backoffFactor: init.reconnectBackoffFactor,
        maxParallelReconnects: init.maxParallelReconnects
      });
    }
    [Symbol.toStringTag] = "@libp2p/connection-manager";
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */
    async start() {
      this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
        calculate: () => {
          const metric = {
            inbound: 0,
            "inbound pending": this.incomingPendingConnections,
            outbound: 0,
            "outbound pending": this.outboundPendingConnections
          };
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              metric[conn.direction]++;
            }
          }
          return metric;
        }
      });
      this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
        label: "protocol",
        calculate: () => {
          const metric = {};
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              for (const stream of conn.streams) {
                const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                metric[key] = (metric[key] ?? 0) + 1;
              }
            }
          }
          return metric;
        }
      });
      this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
        label: "protocol",
        calculate: () => {
          const allStreams = {};
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              const streams = {};
              for (const stream of conn.streams) {
                const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                streams[key] = (streams[key] ?? 0) + 1;
              }
              for (const [protocol, count] of Object.entries(streams)) {
                allStreams[protocol] = allStreams[protocol] ?? [];
                allStreams[protocol].push(count);
              }
            }
          }
          const metric = {};
          for (let [protocol, counts] of Object.entries(allStreams)) {
            counts = counts.sort((a2, b) => a2 - b);
            const index = Math.floor(counts.length * 0.9);
            metric[protocol] = counts[index];
          }
          return metric;
        }
      });
      this.events.addEventListener("connection:open", this.onConnect);
      this.events.addEventListener("connection:close", this.onDisconnect);
      await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
      this.started = true;
      this.log("started");
    }
    /**
     * Stops the Connection Manager
     */
    async stop() {
      this.events.removeEventListener("connection:open", this.onConnect);
      this.events.removeEventListener("connection:close", this.onDisconnect);
      await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
      const tasks = [];
      for (const connectionList of this.connections.values()) {
        for (const connection of connectionList) {
          tasks.push(Promise.all([
            pEvent(connection, "close", {
              signal: AbortSignal.timeout(500)
            }),
            connection.close({
              signal: AbortSignal.timeout(500)
            })
          ]).catch((err2) => {
            connection.abort(err2);
          }));
        }
      }
      this.log("closing %d connections", tasks.length);
      await Promise.all(tasks);
      this.connections.clear();
      this.log("stopped");
    }
    getMaxConnections() {
      return this.maxConnections;
    }
    setMaxConnections(maxConnections) {
      if (this.maxConnections < 1) {
        throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
      }
      let needsPrune = false;
      if (maxConnections < this.maxConnections) {
        needsPrune = true;
      }
      this.maxConnections = maxConnections;
      if (needsPrune) {
        this.connectionPruner.maybePruneConnections();
      }
    }
    onConnect(evt) {
      void this._onConnect(evt).catch((err2) => {
        this.log.error("could not connect - %e", err2);
      });
    }
    /**
     * Tracks the incoming connection and check the connection limit
     */
    async _onConnect(evt) {
      const { detail: connection } = evt;
      if (!this.started) {
        await connection.close();
        return;
      }
      if (connection.status !== "open") {
        return;
      }
      const peerId = connection.remotePeer;
      const isNewPeer = !this.connections.has(peerId);
      const storedConns = this.connections.get(peerId) ?? [];
      storedConns.push(connection);
      this.connections.set(peerId, storedConns);
      if (peerId.publicKey != null && peerId.type === "RSA") {
        await this.peerStore.patch(peerId, {
          publicKey: peerId.publicKey
        });
      }
      if (isNewPeer) {
        this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
      }
    }
    /**
     * Removes the connection from tracking
     */
    onDisconnect(evt) {
      const { detail: connection } = evt;
      const peerId = connection.remotePeer;
      const peerConns = this.connections.get(peerId) ?? [];
      const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId, filteredPeerConns);
      if (filteredPeerConns.length === 0) {
        this.log.trace("peer %p disconnected, removing connection map entry", peerId);
        this.connections.delete(peerId);
        this.events.safeDispatchEvent("peer:disconnect", { detail: peerId });
      }
    }
    getConnections(peerId) {
      if (peerId != null) {
        return this.connections.get(peerId) ?? [];
      }
      let conns = [];
      for (const c2 of this.connections.values()) {
        conns = conns.concat(c2);
      }
      return conns;
    }
    getConnectionsMap() {
      return this.connections;
    }
    async openConnection(peerIdOrMultiaddr, options2 = {}) {
      if (!this.started) {
        throw new NotStartedError("Not started");
      }
      this.outboundPendingConnections++;
      try {
        options2.signal?.throwIfAborted();
        const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
        if (this.peerId.equals(peerId)) {
          throw new InvalidPeerIdError("Can not dial self");
        }
        if (peerId != null && options2.force !== true) {
          this.log("dial %p", peerId);
          const existingConnection = findExistingConnection(peerId, this.getConnections(peerId), multiaddrs);
          if (existingConnection != null) {
            this.log("had an existing connection to %p as %a", peerId, existingConnection.remoteAddr);
            options2.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
            return existingConnection;
          }
        }
        const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
          ...options2,
          priority: options2.priority ?? DEFAULT_DIAL_PRIORITY
        });
        if (connection.status !== "open") {
          throw new ConnectionClosedError("Remote closed connection during opening");
        }
        let peerConnections = this.connections.get(connection.remotePeer);
        if (peerConnections == null) {
          peerConnections = [];
          this.connections.set(connection.remotePeer, peerConnections);
        }
        let trackedConnection = false;
        for (const conn of peerConnections) {
          if (conn.id === connection.id) {
            trackedConnection = true;
          }
          if (options2.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
            connection.abort(new InvalidMultiaddrError("Duplicate multiaddr connection"));
            return conn;
          }
        }
        if (!trackedConnection) {
          peerConnections.push(connection);
        }
        return connection;
      } finally {
        this.outboundPendingConnections--;
      }
    }
    async openStream(peerIdOrMultiaddr, protocol, options2 = {}) {
      const connection = await this.openConnection(peerIdOrMultiaddr, options2);
      return connection.newStream(protocol, options2);
    }
    async closeConnections(peerId, options2 = {}) {
      const connections = this.connections.get(peerId) ?? [];
      await Promise.all(connections.map(async (connection) => {
        try {
          await Promise.all([
            pEvent(connection, "close", options2),
            connection.close(options2)
          ]);
        } catch (err2) {
          connection.abort(err2);
        }
      }));
    }
    acceptIncomingConnection(maConn) {
      const denyConnection = this.deny.some((ipNet) => {
        if (isNetworkAddress(maConn.remoteAddr)) {
          const config = getNetConfig(maConn.remoteAddr);
          return ipNet.contains(config.host);
        }
        return false;
      });
      if (denyConnection) {
        this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
        return false;
      }
      const allowConnection = this.allow.some((ipNet) => {
        if (isNetworkAddress(maConn.remoteAddr)) {
          const config = getNetConfig(maConn.remoteAddr);
          return ipNet.contains(config.host);
        }
        return true;
      });
      if (allowConnection) {
        this.incomingPendingConnections++;
        return true;
      }
      if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
        this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
        return false;
      }
      if (isNetworkAddress(maConn.remoteAddr)) {
        const config = getNetConfig(maConn.remoteAddr);
        try {
          this.inboundConnectionRateLimiter.consume(config.host, 1);
        } catch {
          this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, config.host);
          return false;
        }
      }
      if (this.getConnections().length < this.maxConnections) {
        this.incomingPendingConnections++;
        return true;
      }
      this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
      return false;
    }
    afterUpgradeInbound() {
      this.incomingPendingConnections--;
    }
    getDialQueue() {
      const statusMap = {
        queued: "queued",
        running: "active",
        errored: "error",
        complete: "success"
      };
      return this.dialQueue.queue.queue.map((job) => {
        return {
          id: job.id,
          status: statusMap[job.status],
          peerId: job.options.peerId,
          multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
        };
      });
    }
    async isDialable(multiaddr2, options2 = {}) {
      return this.dialQueue.isDialable(multiaddr2, options2);
    }
  };

  // node_modules/libp2p/dist/src/connection-monitor.js
  var DEFAULT_PING_INTERVAL_MS = 1e4;
  var PROTOCOL_VERSION = "1.0.0";
  var PROTOCOL_NAME = "ping";
  var PROTOCOL_PREFIX = "ipfs";
  var PING_LENGTH = 32;
  var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
  var ConnectionMonitor = class {
    protocol;
    components;
    log;
    heartbeatInterval;
    pingIntervalMs;
    abortController;
    timeout;
    abortConnectionOnPingFailure;
    constructor(components, init = {}) {
      this.components = components;
      this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
      this.log = components.logger.forComponent("libp2p:connection-monitor");
      this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
      this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
      this.timeout = new AdaptiveTimeout({
        ...init.pingTimeout ?? {},
        metrics: components.metrics,
        metricName: "libp2p_connection_monitor_ping_time_milliseconds"
      });
    }
    [Symbol.toStringTag] = "@libp2p/connection-monitor";
    [serviceCapabilities] = [
      "@libp2p/connection-monitor"
    ];
    start() {
      this.abortController = new AbortController();
      setMaxListeners(Infinity, this.abortController.signal);
      this.heartbeatInterval = setInterval(() => {
        this.components.connectionManager.getConnections().forEach((conn) => {
          Promise.resolve().then(async () => {
            let start2 = Date.now();
            try {
              const signal = this.timeout.getTimeoutSignal({
                signal: this.abortController?.signal
              });
              const stream = await conn.newStream(this.protocol, {
                signal,
                runOnLimitedConnection: true
              });
              const bs = byteStream(stream);
              start2 = Date.now();
              await Promise.all([
                bs.write(randomBytes2(PING_LENGTH), {
                  signal
                }),
                bs.read({
                  bytes: PING_LENGTH,
                  signal
                })
              ]);
              conn.rtt = Date.now() - start2;
              await stream.close({
                signal
              });
            } catch (err2) {
              if (err2.name !== "UnsupportedProtocolError") {
                throw err2;
              }
              conn.rtt = (Date.now() - start2) / 2;
            }
          }).catch((err2) => {
            this.log.error("error during heartbeat - %e", err2);
            if (this.abortConnectionOnPingFailure) {
              this.log.error("aborting connection due to ping failure");
              conn.abort(err2);
            } else {
              this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
            }
          });
        });
      }, this.pingIntervalMs);
    }
    stop() {
      this.abortController?.abort();
      if (this.heartbeatInterval != null) {
        clearInterval(this.heartbeatInterval);
      }
    }
  };

  // node_modules/libp2p/dist/src/content-routing.js
  var CompoundContentRouting = class {
    routers;
    started;
    components;
    constructor(components, init) {
      this.routers = init.routers ?? [];
      this.started = false;
      this.components = components;
      this.findProviders = components.metrics?.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        },
        getAttributesFromYieldedValue: (value2, attrs) => {
          return {
            ...attrs,
            providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value2.id.toString()]
          };
        }
      }) ?? this.findProviders;
      this.provide = components.metrics?.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        }
      }) ?? this.provide;
      this.cancelReprovide = components.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        }
      }) ?? this.cancelReprovide;
      this.put = components.metrics?.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
        optionsIndex: 2,
        getAttributesFromArgs: ([key]) => {
          return {
            key: toString2(key, "base36")
          };
        }
      }) ?? this.put;
      this.get = components.metrics?.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([key]) => {
          return {
            key: toString2(key, "base36")
          };
        }
      }) ?? this.get;
    }
    [Symbol.toStringTag] = "@libp2p/content-routing";
    isStarted() {
      return this.started;
    }
    async start() {
      this.started = true;
    }
    async stop() {
      this.started = false;
    }
    /**
     * Iterates over all content routers in parallel to find providers of the given key
     */
    async *findProviders(key, options2 = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      const self2 = this;
      const seen = new PeerSet();
      for await (const peer of src_default(...self2.routers.filter((router) => router.findProviders instanceof Function).map((router) => router.findProviders(key, options2)))) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.components.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options2);
        }
        if (seen.has(peer.id)) {
          continue;
        }
        seen.add(peer.id);
        yield peer;
      }
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */
    async provide(key, options2 = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      await Promise.all(this.routers.filter((router) => router.provide instanceof Function).map(async (router) => {
        await router.provide(key, options2);
      }));
    }
    async cancelReprovide(key, options2 = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      await Promise.all(this.routers.filter((router) => router.cancelReprovide instanceof Function).map(async (router) => {
        await router.cancelReprovide(key, options2);
      }));
    }
    /**
     * Store the given key/value pair in the available content routings
     */
    async put(key, value2, options2) {
      if (!this.isStarted()) {
        throw new NotStartedError();
      }
      await Promise.all(this.routers.filter((router) => router.put instanceof Function).map(async (router) => {
        await router.put(key, value2, options2);
      }));
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */
    async get(key, options2) {
      if (!this.isStarted()) {
        throw new NotStartedError();
      }
      return Promise.any(this.routers.filter((router) => router.get instanceof Function).map(async (router) => {
        return router.get(key, options2);
      }));
    }
  };

  // node_modules/it-parallel/dist/src/index.js
  var CustomEvent2 = globalThis.CustomEvent ?? Event;
  async function* parallel(source, options2 = {}) {
    let concurrency = options2.concurrency ?? Infinity;
    if (concurrency < 1) {
      concurrency = Infinity;
    }
    const ordered = options2.ordered ?? false;
    const emitter = new EventTarget();
    const ops = [];
    let slotAvailable = pDefer();
    let resultAvailable = pDefer();
    let sourceFinished = false;
    let sourceErr;
    let opErred = false;
    emitter.addEventListener("task-complete", () => {
      resultAvailable.resolve();
    });
    void Promise.resolve().then(async () => {
      try {
        for await (const task of source) {
          if (ops.length === concurrency) {
            slotAvailable = pDefer();
            await slotAvailable.promise;
          }
          if (opErred) {
            break;
          }
          const op = {
            done: false
          };
          ops.push(op);
          task().then((result) => {
            op.done = true;
            op.ok = true;
            op.value = result;
            emitter.dispatchEvent(new CustomEvent2("task-complete"));
          }, (err2) => {
            op.done = true;
            op.err = err2;
            emitter.dispatchEvent(new CustomEvent2("task-complete"));
          });
        }
        sourceFinished = true;
        emitter.dispatchEvent(new CustomEvent2("task-complete"));
      } catch (err2) {
        sourceErr = err2;
        emitter.dispatchEvent(new CustomEvent2("task-complete"));
      }
    });
    function valuesAvailable() {
      if (ordered) {
        return ops[0]?.done;
      }
      return Boolean(ops.find((op) => op.done));
    }
    function* yieldOrderedValues() {
      while (ops.length > 0 && ops[0].done) {
        const op = ops[0];
        ops.shift();
        if (op.ok) {
          yield op.value;
        } else {
          opErred = true;
          slotAvailable.resolve();
          throw op.err;
        }
        slotAvailable.resolve();
      }
    }
    function* yieldUnOrderedValues() {
      while (valuesAvailable()) {
        for (let i2 = 0; i2 < ops.length; i2++) {
          if (ops[i2].done) {
            const op = ops[i2];
            ops.splice(i2, 1);
            i2--;
            if (op.ok) {
              yield op.value;
            } else {
              opErred = true;
              slotAvailable.resolve();
              throw op.err;
            }
            slotAvailable.resolve();
          }
        }
      }
    }
    while (true) {
      if (!valuesAvailable()) {
        resultAvailable = pDefer();
        await resultAvailable.promise;
      }
      if (sourceErr != null) {
        throw sourceErr;
      }
      if (ordered) {
        yield* yieldOrderedValues();
      } else {
        yield* yieldUnOrderedValues();
      }
      if (sourceErr != null) {
        throw sourceErr;
      }
      if (sourceFinished && ops.length === 0) {
        break;
      }
    }
  }

  // node_modules/libp2p/dist/src/peer-routing.js
  var DefaultPeerRouting = class {
    log;
    peerId;
    peerStore;
    routers;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:peer-routing");
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.routers = init.routers ?? [];
      this.findPeer = components.metrics?.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([peer], attrs) => {
          return {
            ...attrs,
            peer: peer.toString()
          };
        }
      }) ?? this.findPeer;
      this.getClosestPeers = components.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([key], attrs) => {
          return {
            ...attrs,
            key: toString2(key, "base36")
          };
        },
        getAttributesFromYieldedValue: (value2, attrs) => {
          return {
            ...attrs,
            peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value2.id.toString()]
          };
        }
      }) ?? this.getClosestPeers;
    }
    [Symbol.toStringTag] = "@libp2p/peer-routing";
    /**
     * Iterates over all peer routers in parallel to find the given peer
     */
    async findPeer(id, options2) {
      if (this.routers.length === 0) {
        throw new NoPeerRoutersError("No peer routers available");
      }
      if (id.toString() === this.peerId.toString()) {
        throw new QueriedForSelfError("Should not try to find self");
      }
      const self2 = this;
      const source = src_default(...this.routers.filter((router) => router.findPeer instanceof Function).map((router) => (async function* () {
        try {
          yield await router.findPeer(id, options2);
        } catch (err2) {
          self2.log.error("router failed to find peer - %e", err2);
        }
      })()));
      for await (const peer of source) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options2);
        }
        return peer;
      }
      throw new NotFoundError();
    }
    /**
     * Attempt to find the closest peers on the network to the given key
     */
    async *getClosestPeers(key, options2 = {}) {
      if (this.routers.length === 0) {
        throw new NoPeerRoutersError("No peer routers available");
      }
      const self2 = this;
      const seen = createScalableCuckooFilter(1024);
      for await (const peer of parallel((async function* () {
        const source = src_default(...self2.routers.filter((router) => router.getClosestPeers instanceof Function).map((router) => router.getClosestPeers(key, options2)));
        for await (let peer2 of source) {
          yield async () => {
            if (peer2.multiaddrs.length === 0) {
              try {
                peer2 = await self2.findPeer(peer2.id, {
                  ...options2,
                  useCache: false
                });
              } catch (err2) {
                self2.log.error("could not find peer multiaddrs - %e", err2);
                return;
              }
            }
            return peer2;
          };
        }
      })())) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options2);
        }
        if (seen.has(peer.id.toMultihash().bytes)) {
          continue;
        }
        seen.add(peer.id.toMultihash().bytes);
        yield peer;
      }
    }
  };

  // node_modules/libp2p/dist/src/random-walk.js
  var RandomWalk = class extends TypedEventEmitter {
    peerRouting;
    log;
    walking;
    walkers;
    shutdownController;
    walkController;
    needNext;
    constructor(components) {
      super();
      this.log = components.logger.forComponent("libp2p:random-walk");
      this.peerRouting = components.peerRouting;
      this.walkers = 0;
      this.walking = false;
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
    }
    [Symbol.toStringTag] = "@libp2p/random-walk";
    start() {
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
    }
    stop() {
      this.shutdownController.abort();
    }
    async *walk(options2) {
      if (!this.walking) {
        this.startWalk();
      }
      this.walkers++;
      const signal = anySignal([this.shutdownController.signal, options2?.signal]);
      setMaxListeners(Infinity, signal);
      try {
        while (true) {
          this.needNext?.resolve();
          this.needNext = pDefer();
          const event = await pEvent(this, "walk:peer", {
            signal,
            rejectionEvents: [
              "walk:error"
            ]
          });
          yield event.detail;
        }
      } catch (err2) {
        if (err2.detail != null) {
          throw err2.detail;
        }
        throw err2;
      } finally {
        signal.clear();
        this.walkers--;
        if (this.walkers === 0) {
          this.walkController?.abort();
          this.walkController = void 0;
        }
      }
    }
    startWalk() {
      this.walking = true;
      this.walkController = new AbortController();
      setMaxListeners(Infinity, this.walkController.signal);
      const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
      setMaxListeners(Infinity, signal);
      const start2 = Date.now();
      let found = 0;
      Promise.resolve().then(async () => {
        this.log("start walk");
        while (this.walkers > 0) {
          try {
            const data = randomBytes2(32);
            let s2 = Date.now();
            for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
              if (signal.aborted) {
                this.log("aborting walk");
              }
              signal.throwIfAborted();
              this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s2, this.walkers);
              found++;
              this.safeDispatchEvent("walk:peer", {
                detail: peer
              });
              if (this.walkers === 1 && this.needNext != null) {
                this.log("wait for need next");
                await raceSignal(this.needNext.promise, signal);
              }
              s2 = Date.now();
            }
            this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
          } catch (err2) {
            this.log.error("random walk errored - %e", err2);
            this.safeDispatchEvent("walk:error", {
              detail: err2
            });
          }
        }
        this.log("no walkers left, ended walk");
      }).catch((err2) => {
        this.log.error("random walk errored - %e", err2);
      }).finally(() => {
        this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
        this.walking = false;
      });
    }
  };

  // node_modules/libp2p/dist/src/registrar.js
  var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
  var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
  var Registrar = class {
    log;
    topologies;
    handlers;
    components;
    middleware;
    constructor(components) {
      this.components = components;
      this.log = components.logger.forComponent("libp2p:registrar");
      this.middleware = /* @__PURE__ */ new Map();
      this.topologies = /* @__PURE__ */ new Map();
      components.metrics?.registerMetricGroup("libp2p_registrar_topologies", {
        calculate: () => {
          const output = {};
          for (const [key, value2] of this.topologies) {
            output[key] = value2.size;
          }
          return output;
        }
      });
      this.handlers = trackedMap({
        name: "libp2p_registrar_protocol_handlers",
        metrics: components.metrics
      });
      this._onDisconnect = this._onDisconnect.bind(this);
      this._onPeerUpdate = this._onPeerUpdate.bind(this);
      this._onPeerIdentify = this._onPeerIdentify.bind(this);
      this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
      this.components.events.addEventListener("peer:update", this._onPeerUpdate);
      this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
    }
    [Symbol.toStringTag] = "@libp2p/registrar";
    getProtocols() {
      return Array.from(/* @__PURE__ */ new Set([
        ...this.handlers.keys()
      ])).sort();
    }
    getHandler(protocol) {
      const handler = this.handlers.get(protocol);
      if (handler == null) {
        throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
      }
      return handler;
    }
    getTopologies(protocol) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        return [];
      }
      return [
        ...topologies.values()
      ];
    }
    /**
     * Registers the `handler` for each protocol
     */
    async handle(protocol, handler, opts) {
      if (this.handlers.has(protocol) && opts?.force !== true) {
        throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
      }
      this.handlers.set(protocol, {
        handler,
        options: {
          maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS2,
          maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS2,
          ...opts
        }
      });
      await this.components.peerStore.merge(this.components.peerId, {
        protocols: [protocol]
      }, opts);
    }
    /**
     * Removes the handler for each protocol. The protocol
     * will no longer be supported on streams.
     */
    async unhandle(protocols, options2) {
      const protocolList = Array.isArray(protocols) ? protocols : [protocols];
      protocolList.forEach((protocol) => {
        this.handlers.delete(protocol);
      });
      await this.components.peerStore.patch(this.components.peerId, {
        protocols: this.getProtocols()
      }, options2);
    }
    /**
     * Register handlers for a set of multicodecs given
     */
    async register(protocol, topology) {
      if (topology == null) {
        throw new InvalidParametersError("invalid topology");
      }
      const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
      let topologies = this.topologies.get(protocol);
      if (topologies == null) {
        topologies = /* @__PURE__ */ new Map();
        this.topologies.set(protocol, topologies);
      }
      topologies.set(id, topology);
      return id;
    }
    /**
     * Unregister topology
     */
    unregister(id) {
      for (const [protocol, topologies] of this.topologies.entries()) {
        if (topologies.has(id)) {
          topologies.delete(id);
          if (topologies.size === 0) {
            this.topologies.delete(protocol);
          }
        }
      }
    }
    use(protocol, middleware) {
      this.middleware.set(protocol, middleware);
    }
    unuse(protocol) {
      this.middleware.delete(protocol);
    }
    getMiddleware(protocol) {
      return this.middleware.get(protocol) ?? [];
    }
    /**
     * Remove a disconnected peer from the record
     */
    async _onDisconnect(evt) {
      const remotePeer = evt.detail;
      const options2 = {
        signal: AbortSignal.timeout(5e3)
      };
      try {
        const peer = await this.components.peerStore.get(remotePeer, options2);
        for (const protocol of peer.protocols) {
          const topologies = this.topologies.get(protocol);
          if (topologies == null) {
            continue;
          }
          await Promise.all([...topologies.values()].map(async (topology) => {
            if (topology.filter?.has(remotePeer) === false) {
              return;
            }
            topology.filter?.remove(remotePeer);
            await topology.onDisconnect?.(remotePeer);
          }));
        }
      } catch (err2) {
        if (err2.name === "NotFoundError") {
          return;
        }
        this.log.error("could not inform topologies of disconnecting peer %p - %e", remotePeer, err2);
      }
    }
    /**
     * When a peer is updated, if they have removed supported protocols notify any
     * topologies interested in the removed protocols.
     */
    async _onPeerUpdate(evt) {
      const { peer, previous } = evt.detail;
      const removed = (previous?.protocols ?? []).filter((protocol) => !peer.protocols.includes(protocol));
      try {
        for (const protocol of removed) {
          const topologies = this.topologies.get(protocol);
          if (topologies == null) {
            continue;
          }
          await Promise.all([...topologies.values()].map(async (topology) => {
            if (topology.filter?.has(peer.id) === false) {
              return;
            }
            topology.filter?.remove(peer.id);
            await topology.onDisconnect?.(peer.id);
          }));
        }
      } catch (err2) {
        this.log.error("could not inform topologies of updated peer %p - %e", peer.id, err2);
      }
    }
    /**
     * After identify has completed and we have received the list of supported
     * protocols, notify any topologies interested in those protocols.
     */
    async _onPeerIdentify(evt) {
      const protocols = evt.detail.protocols;
      const connection = evt.detail.connection;
      const peerId = evt.detail.peerId;
      try {
        for (const protocol of protocols) {
          const topologies = this.topologies.get(protocol);
          if (topologies == null) {
            continue;
          }
          await Promise.all([...topologies.values()].map(async (topology) => {
            if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
              return;
            }
            if (topology.filter?.has(peerId) === true) {
              return;
            }
            topology.filter?.add(peerId);
            await topology.onConnect?.(peerId, connection);
          }));
        }
      } catch (err2) {
        this.log.error("could not inform topologies of updated peer after identify %p - %e", peerId, err2);
      }
    }
  };

  // node_modules/libp2p/dist/src/transport-manager.js
  var DefaultTransportManager = class {
    log;
    components;
    transports;
    listeners;
    faultTolerance;
    started;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:transports");
      this.components = components;
      this.started = false;
      this.transports = trackedMap({
        name: "libp2p_transport_manager_transports",
        metrics: this.components.metrics
      });
      this.listeners = trackedMap({
        name: "libp2p_transport_manager_listeners",
        metrics: this.components.metrics
      });
      this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
    }
    [Symbol.toStringTag] = "@libp2p/transport-manager";
    /**
     * Adds a `Transport` to the manager
     */
    add(transport) {
      const tag = transport[Symbol.toStringTag];
      if (tag == null) {
        throw new InvalidParametersError("Transport must have a valid tag");
      }
      if (this.transports.has(tag)) {
        throw new InvalidParametersError(`There is already a transport with the tag ${tag}`);
      }
      this.log("adding transport %s", tag);
      this.transports.set(tag, transport);
      if (!this.listeners.has(tag)) {
        this.listeners.set(tag, []);
      }
    }
    isStarted() {
      return this.started;
    }
    start() {
      this.started = true;
    }
    async afterStart() {
      const addrs = this.components.addressManager.getListenAddrs();
      await this.listen(addrs);
    }
    /**
     * Stops all listeners
     */
    async stop() {
      const tasks = [];
      for (const [key, listeners] of this.listeners) {
        this.log("closing listeners for %s", key);
        while (listeners.length > 0) {
          const listener = listeners.pop();
          if (listener == null) {
            continue;
          }
          tasks.push(listener.close());
        }
      }
      await Promise.all(tasks);
      this.log("all listeners closed");
      for (const key of this.listeners.keys()) {
        this.listeners.set(key, []);
      }
      this.started = false;
    }
    /**
     * Dials the given Multiaddr over it's supported transport
     */
    async dial(ma, options2) {
      const transport = this.dialTransportForMultiaddr(ma);
      if (transport == null) {
        throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
      }
      options2?.onProgress?.(new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
      return transport.dial(ma, {
        ...options2,
        upgrader: this.components.upgrader
      });
    }
    /**
     * Returns all Multiaddr's the listeners are using
     */
    getAddrs() {
      let addrs = [];
      for (const listeners of this.listeners.values()) {
        for (const listener of listeners) {
          addrs = [...addrs, ...listener.getAddrs()];
        }
      }
      return addrs;
    }
    /**
     * Returns all the transports instances
     */
    getTransports() {
      return Array.of(...this.transports.values());
    }
    /**
     * Returns all the listener instances
     */
    getListeners() {
      return Array.of(...this.listeners.values()).flat();
    }
    /**
     * Finds a transport that matches the given Multiaddr
     */
    dialTransportForMultiaddr(ma) {
      for (const transport of this.transports.values()) {
        const addrs = transport.dialFilter([ma]);
        if (addrs.length > 0) {
          return transport;
        }
      }
    }
    /**
     * Finds a transport that matches the given Multiaddr
     */
    listenTransportForMultiaddr(ma) {
      for (const transport of this.transports.values()) {
        const addrs = transport.listenFilter([ma]);
        if (addrs.length > 0) {
          return transport;
        }
      }
    }
    /**
     * Starts listeners for each listen Multiaddr
     */
    async listen(addrs) {
      if (!this.isStarted()) {
        throw new NotStartedError("Not started");
      }
      if (addrs == null || addrs.length === 0) {
        this.log("no addresses were provided for listening, this node is dial only");
        return;
      }
      const listenStats = {
        errors: /* @__PURE__ */ new Map(),
        ipv4: {
          success: 0,
          attempts: 0
        },
        ipv6: {
          success: 0,
          attempts: 0
        }
      };
      addrs.forEach((ma) => {
        listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
      });
      const tasks = [];
      for (const [key, transport] of this.transports.entries()) {
        const supportedAddrs = transport.listenFilter(addrs);
        for (const addr of supportedAddrs) {
          this.log("creating listener for %s on %a", key, addr);
          const listener = transport.createListener({
            upgrader: this.components.upgrader
          });
          let listeners = this.listeners.get(key) ?? [];
          if (listeners == null) {
            listeners = [];
            this.listeners.set(key, listeners);
          }
          listeners.push(listener);
          listener.addEventListener("listening", () => {
            this.components.events.safeDispatchEvent("transport:listening", {
              detail: listener
            });
          });
          listener.addEventListener("close", () => {
            const index = listeners.findIndex((l2) => l2 === listener);
            listeners.splice(index, 1);
            this.components.events.safeDispatchEvent("transport:close", {
              detail: listener
            });
          });
          if (IP4.matches(addr)) {
            listenStats.ipv4.attempts++;
          } else if (IP6.matches(addr)) {
            listenStats.ipv6.attempts++;
          }
          tasks.push(listener.listen(addr).then(() => {
            listenStats.errors.delete(addr.toString());
            if (IP4.matches(addr)) {
              listenStats.ipv4.success++;
            }
            if (IP6.matches(addr)) {
              listenStats.ipv6.success++;
            }
          }, (err2) => {
            this.log.error("transport %s could not listen on address %a - %e", key, addr, err2);
            listenStats.errors.set(addr.toString(), err2);
            throw err2;
          }));
        }
      }
      const results = await Promise.allSettled(tasks);
      if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
        return;
      }
      if (this.ipv6Unsupported(listenStats)) {
        this.log("all IPv4 addresses succeed but all IPv6 failed");
        return;
      }
      if (this.faultTolerance === FaultTolerance.NO_FATAL) {
        this.log("failed to listen on any address but fault tolerance allows this");
        return;
      }
      throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err2]) => {
        return `
  ${addr}: ${`${getErrorMessage(err2)}`.split("\n").join("\n  ")}
`;
      }).join("")}`);
    }
    ipv6Unsupported(listenStats) {
      if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
        return false;
      }
      const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
      const allIpv6Failed = listenStats.ipv6.success === 0;
      return allIpv4Succeeded && allIpv6Failed;
    }
    /**
     * Removes the given transport from the manager.
     * If a transport has any running listeners, they will be closed.
     */
    async remove(key) {
      const listeners = this.listeners.get(key) ?? [];
      this.log.trace("removing transport %s", key);
      const tasks = [];
      this.log.trace("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
      await Promise.all(tasks);
      this.transports.delete(key);
      this.listeners.delete(key);
    }
    /**
     * Removes all transports from the manager.
     * If any listeners are running, they will be closed.
     *
     * @async
     */
    async removeAll() {
      const tasks = [];
      for (const key of this.transports.keys()) {
        tasks.push(this.remove(key));
      }
      await Promise.all(tasks);
    }
  };
  function getErrorMessage(err2) {
    if (err2.stack != null && err2.stack.trim() !== "") {
      return err2.stack;
    }
    if (err2.message != null) {
      return err2.message;
    }
    return err2.toString();
  }

  // node_modules/@libp2p/multistream-select/dist/src/constants.js
  var PROTOCOL_ID = "/multistream/1.0.0";
  var MAX_PROTOCOL_LENGTH = 1024;

  // node_modules/@libp2p/multistream-select/dist/src/multistream.js
  var NewLine = fromString2("\n");
  async function readString(reader2, options2) {
    const buf2 = await reader2.read(options2);
    const arr = buf2.subarray();
    if (arr.byteLength === 0 || arr[arr.length - 1] !== NewLine[0]) {
      throw new InvalidMessageError("Missing newline");
    }
    return toString2(arr).trimEnd();
  }

  // node_modules/@libp2p/multistream-select/dist/src/select.js
  async function select(stream, protocols, options2 = {}) {
    protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
    if (protocols.length === 0) {
      throw new Error("At least one protocol must be specified");
    }
    const log18 = stream.log.newScope("mss:select");
    const lp = lpStream(stream, {
      ...options2,
      maxDataLength: MAX_PROTOCOL_LENGTH
    });
    for (let i2 = 0; i2 < protocols.length; i2++) {
      const protocol = protocols[i2];
      let response;
      if (i2 === 0) {
        log18.trace('write ["%s", "%s"]', PROTOCOL_ID, protocol);
        const p1 = fromString2(`${PROTOCOL_ID}
`);
        const p2 = fromString2(`${protocol}
`);
        await lp.writeV([p1, p2], options2);
        log18.trace("reading multistream-select header");
        response = await readString(lp, options2);
        log18.trace('read "%s"', response);
        if (response !== PROTOCOL_ID) {
          log18.error("did not read multistream-select header from response");
          break;
        }
      } else {
        log18.trace('write "%s"', protocol);
        await lp.write(fromString2(`${protocol}
`), options2);
      }
      log18.trace("reading protocol response");
      response = await readString(lp, options2);
      log18.trace('read "%s"', response);
      if (response === protocol) {
        log18.trace('selected "%s" after negotiation', response);
        lp.unwrap();
        return protocol;
      }
    }
    throw new UnsupportedProtocolError(`Protocol selection failed - could not negotiate ${protocols}`);
  }

  // node_modules/@libp2p/multistream-select/dist/src/handle.js
  async function handle(stream, protocols, options2 = {}) {
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    const log18 = stream.log.newScope("mss:handle");
    const lp = lpStream(stream, {
      ...options2,
      maxDataLength: MAX_PROTOCOL_LENGTH,
      maxLengthLength: 2
      // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
    });
    while (true) {
      log18.trace("reading incoming string");
      const protocol = await readString(lp, options2);
      log18.trace('read "%s"', protocol);
      if (protocol === PROTOCOL_ID) {
        log18.trace('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
        await lp.write(fromString2(`${PROTOCOL_ID}
`), options2);
        log18.trace('responded with "%s" for "%s"', PROTOCOL_ID, protocol);
        continue;
      }
      if (protocols.includes(protocol)) {
        log18.trace('respond with "%s" for "%s"', protocol, protocol);
        await lp.write(fromString2(`${protocol}
`), options2);
        log18.trace('responded with "%s" for "%s"', protocol, protocol);
        lp.unwrap();
        return protocol;
      }
      if (protocol === "ls") {
        const protos = new Uint8ArrayList(...protocols.map((p2) => encode9.single(fromString2(`${p2}
`))), fromString2("\n"));
        log18.trace('respond with "%s" for %s', protocols, protocol);
        await lp.write(protos, options2);
        log18.trace('responded with "%s" for %s', protocols, protocol);
        continue;
      }
      log18.trace('respond with "na" for "%s"', protocol);
      await lp.write(fromString2("na\n"), options2);
      log18('responded with "na" for "%s"', protocol);
    }
  }

  // node_modules/libp2p/dist/src/connection.js
  var Connection = class extends TypedEventEmitter {
    id;
    remoteAddr;
    remotePeer;
    direction;
    timeline;
    direct;
    multiplexer;
    encryption;
    limits;
    log;
    maConn;
    muxer;
    components;
    outboundStreamProtocolNegotiationTimeout;
    inboundStreamProtocolNegotiationTimeout;
    closeTimeout;
    constructor(components, init) {
      super();
      this.components = components;
      this.id = init.id;
      this.remoteAddr = init.maConn.remoteAddr;
      this.remotePeer = init.remotePeer;
      this.direction = init.direction ?? "outbound";
      this.timeline = init.maConn.timeline;
      this.encryption = init.cryptoProtocol;
      this.limits = init.limits;
      this.maConn = init.maConn;
      this.log = init.maConn.log;
      this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
      this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
      this.closeTimeout = init.closeTimeout ?? CONNECTION_CLOSE_TIMEOUT;
      this.direct = isDirect(init.maConn.remoteAddr);
      this.onIncomingStream = this.onIncomingStream.bind(this);
      if (this.remoteAddr.getComponents().find((component) => component.code === CODE_P2P) == null) {
        this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
      }
      if (init.muxer != null) {
        this.multiplexer = init.muxer.protocol;
        this.muxer = init.muxer;
        this.muxer.addEventListener("stream", this.onIncomingStream);
      }
      this.maConn.addEventListener("close", (evt) => {
        this.dispatchEvent(new StreamCloseEvent(evt.local, evt.error));
      });
    }
    [Symbol.toStringTag] = "Connection";
    [connectionSymbol] = true;
    get streams() {
      return this.muxer?.streams ?? [];
    }
    get status() {
      return this.maConn.status;
    }
    /**
     * Create a new stream over this connection
     */
    newStream = async (protocols, options2 = {}) => {
      if (this.muxer == null) {
        throw new MuxerUnavailableError("Connection is not multiplexed");
      }
      if (this.muxer.status !== "open") {
        throw new ConnectionClosedError(`The connection muxer is "${this.muxer.status}" and not "open"`);
      }
      if (this.maConn.status !== "open") {
        throw new ConnectionClosedError(`The connection is "${this.status}" and not "open"`);
      }
      if (this.limits != null && options2?.runOnLimitedConnection !== true) {
        throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
      }
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      this.log.trace("starting new stream for protocols %s", protocols);
      const muxedStream = await this.muxer.createStream({
        ...options2,
        // most underlying transports only support negotiating a single protocol
        // so only pass the early protocol if a single protocol has been requested
        // otherwise fall back to mss
        protocol: protocols.length === 1 ? protocols[0] : void 0
      });
      this.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
      try {
        if (options2.signal == null) {
          muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
          const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
          setMaxListeners(Infinity, signal);
          options2 = {
            ...options2,
            signal
          };
        }
        if (muxedStream.protocol === "") {
          muxedStream.log.trace("selecting protocol from protocols %s", protocols);
          muxedStream.protocol = await select(muxedStream, protocols, options2);
          muxedStream.log("negotiated protocol %s", muxedStream.protocol);
        } else {
          muxedStream.log("pre-negotiated protocol %s", muxedStream.protocol);
        }
        const outgoingLimit = findOutgoingStreamLimit(muxedStream.protocol, this.components.registrar, options2);
        const streamCount = countStreams(muxedStream.protocol, "outbound", this);
        if (streamCount > outgoingLimit) {
          const err2 = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${muxedStream.protocol}" - ${streamCount}/${outgoingLimit}`);
          muxedStream.abort(err2);
          throw err2;
        }
        await this.components.peerStore.merge(this.remotePeer, {
          protocols: [muxedStream.protocol]
        });
        this.components.metrics?.trackProtocolStream(muxedStream);
        const middleware = this.components.registrar.getMiddleware(muxedStream.protocol);
        return await this.runMiddlewareChain(muxedStream, this, middleware);
      } catch (err2) {
        if (muxedStream.status === "open") {
          muxedStream.abort(err2);
        } else {
          this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", this.direction === "inbound" ? "from" : "to", this.remoteAddr, protocols, err2);
        }
        throw err2;
      }
    };
    async onIncomingStream(evt) {
      const muxedStream = evt.detail;
      const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
      setMaxListeners(Infinity, signal);
      muxedStream.log("start protocol negotiation, timing out after %dms", this.inboundStreamProtocolNegotiationTimeout);
      try {
        if (muxedStream.protocol === "") {
          const protocols = this.components.registrar.getProtocols();
          muxedStream.log.trace("selecting protocol from protocols %s", protocols);
          muxedStream.protocol = await handle(muxedStream, protocols, {
            signal
          });
          muxedStream.log("negotiated protocol %s", muxedStream.protocol);
        } else {
          muxedStream.log("pre-negotiated protocol %s", muxedStream.protocol);
        }
        const incomingLimit = findIncomingStreamLimit(muxedStream.protocol, this.components.registrar);
        const streamCount = countStreams(muxedStream.protocol, "inbound", this);
        if (streamCount > incomingLimit) {
          throw new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${muxedStream.protocol}" - limit ${incomingLimit}`);
        }
        await this.components.peerStore.merge(this.remotePeer, {
          protocols: [muxedStream.protocol]
        }, {
          signal
        });
        this.components.metrics?.trackProtocolStream(muxedStream);
        const { handler, options: options2 } = this.components.registrar.getHandler(muxedStream.protocol);
        if (this.limits != null && options2.runOnLimitedConnection !== true) {
          throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
        }
        const middleware = this.components.registrar.getMiddleware(muxedStream.protocol);
        middleware.push(async (stream, connection, next) => {
          await handler(stream, connection);
          next(stream, connection);
        });
        await this.runMiddlewareChain(muxedStream, this, middleware);
      } catch (err2) {
        muxedStream.abort(err2);
      }
    }
    async runMiddlewareChain(stream, connection, middleware) {
      for (let i2 = 0; i2 < middleware.length; i2++) {
        const mw = middleware[i2];
        stream.log.trace("running middleware", i2, mw);
        await new Promise((resolve8, reject) => {
          try {
            const result = mw(stream, connection, (s2, c2) => {
              stream = s2;
              connection = c2;
              resolve8();
            });
            if (result instanceof Promise) {
              result.catch(reject);
            }
          } catch (err2) {
            reject(err2);
          }
        });
        stream.log.trace("ran middleware", i2, mw);
      }
      return stream;
    }
    /**
     * Close the connection
     */
    async close(options2 = {}) {
      this.log("closing connection to %a", this.remoteAddr);
      if (options2.signal == null) {
        const signal = AbortSignal.timeout(this.closeTimeout);
        setMaxListeners(Infinity, signal);
        options2 = {
          ...options2,
          signal
        };
      }
      await this.muxer?.close(options2);
      await this.maConn.close(options2);
    }
    abort(err2) {
      this.muxer?.abort(err2);
      this.maConn.abort(err2);
    }
  };
  function createConnection(components, init) {
    return new Connection(components, init);
  }
  function findIncomingStreamLimit(protocol, registrar) {
    try {
      const { options: options2 } = registrar.getHandler(protocol);
      if (options2.maxInboundStreams != null) {
        return options2.maxInboundStreams;
      }
    } catch (err2) {
      if (err2.name !== "UnhandledProtocolError") {
        throw err2;
      }
    }
    return DEFAULT_MAX_INBOUND_STREAMS2;
  }
  function findOutgoingStreamLimit(protocol, registrar, options2 = {}) {
    try {
      const { options: options3 } = registrar.getHandler(protocol);
      if (options3.maxOutboundStreams != null) {
        return options3.maxOutboundStreams;
      }
    } catch (err2) {
      if (err2.name !== "UnhandledProtocolError") {
        throw err2;
      }
    }
    return options2.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
  }
  function countStreams(protocol, direction, connection) {
    let streamCount = 0;
    connection.streams.forEach((stream) => {
      if (stream.direction === direction && stream.protocol === protocol) {
        streamCount++;
      }
    });
    return streamCount;
  }

  // node_modules/libp2p/dist/src/upgrader.js
  var Upgrader = class {
    components;
    connectionEncrypters;
    streamMuxers;
    inboundUpgradeTimeout;
    inboundStreamProtocolNegotiationTimeout;
    outboundStreamProtocolNegotiationTimeout;
    events;
    metrics;
    connectionCloseTimeout;
    constructor(components, init) {
      this.components = components;
      this.connectionEncrypters = trackedMap({
        name: "libp2p_upgrader_connection_encrypters",
        metrics: this.components.metrics
      });
      init.connectionEncrypters.forEach((encrypter) => {
        this.connectionEncrypters.set(encrypter.protocol, encrypter);
      });
      this.streamMuxers = trackedMap({
        name: "libp2p_upgrader_stream_multiplexers",
        metrics: this.components.metrics
      });
      init.streamMuxers.forEach((muxer) => {
        this.streamMuxers.set(muxer.protocol, muxer);
      });
      this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
      this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
      this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
      this.connectionCloseTimeout = init.connectionCloseTimeout ?? CONNECTION_CLOSE_TIMEOUT;
      this.events = components.events;
      this.metrics = {
        dials: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),
        errors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
        inboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
        outboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
      };
    }
    [Symbol.toStringTag] = "@libp2p/upgrader";
    async shouldBlockConnection(method, ...args) {
      const denyOperation = this.components.connectionGater[method];
      if (denyOperation == null) {
        return;
      }
      const result = await denyOperation.apply(this.components.connectionGater, args);
      if (result === true) {
        throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
      }
    }
    createInboundAbortSignal(signal) {
      const output = anySignal([
        AbortSignal.timeout(this.inboundUpgradeTimeout),
        signal
      ]);
      setMaxListeners(Infinity, output);
      return output;
    }
    async upgradeInbound(maConn, opts) {
      let accepted = false;
      const signal = this.createInboundAbortSignal(opts.signal);
      try {
        this.metrics.dials?.increment({
          inbound: true
        });
        accepted = this.components.connectionManager.acceptIncomingConnection(maConn);
        if (!accepted) {
          throw new ConnectionDeniedError("Connection denied");
        }
        await raceSignal(this.shouldBlockConnection("denyInboundConnection", maConn), signal);
        await this._performUpgrade(maConn, "inbound", {
          ...opts,
          signal
        });
      } catch (err2) {
        this.metrics.errors?.increment({
          inbound: true
        });
        this.metrics.inboundErrors?.increment({
          [err2.name ?? "Error"]: true
        });
        throw err2;
      } finally {
        signal.clear();
        if (accepted) {
          this.components.connectionManager.afterUpgradeInbound();
        }
      }
    }
    async upgradeOutbound(maConn, opts) {
      try {
        this.metrics.dials?.increment({
          outbound: true
        });
        const idStr = maConn.remoteAddr.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
        let remotePeerId;
        if (idStr != null) {
          remotePeerId = peerIdFromString(idStr);
          await raceSignal(this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn), opts.signal);
        }
        let direction = "outbound";
        if (opts.initiator === false) {
          direction = "inbound";
        }
        return await this._performUpgrade(maConn, direction, opts);
      } catch (err2) {
        this.metrics.errors?.increment({
          outbound: true
        });
        this.metrics.outboundErrors?.increment({
          [err2.name ?? "Error"]: true
        });
        throw err2;
      }
    }
    async _performUpgrade(maConn, direction, opts) {
      let stream = maConn;
      let remotePeer;
      let muxerFactory;
      let muxer;
      let cryptoProtocol;
      const id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
      maConn.log = maConn.log.newScope(`${direction}:${id}`);
      this.components.metrics?.trackMultiaddrConnection(maConn);
      maConn.log.trace("starting the %s connection upgrade", direction);
      if (opts?.skipProtection !== true) {
        const protector = this.components.connectionProtector;
        if (protector != null) {
          maConn.log("protecting the %s connection", direction);
          stream = await protector.protect(stream, opts);
        }
      }
      try {
        if (isEncryptionSkipped(opts)) {
          if (opts.remotePeer == null) {
            throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`);
          }
          cryptoProtocol = "native";
          remotePeer = opts.remotePeer;
        } else {
          const peerIdString = maConn.remoteAddr.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
          let remotePeerFromMultiaddr;
          if (peerIdString != null) {
            remotePeerFromMultiaddr = peerIdFromString(peerIdString);
          }
          opts?.onProgress?.(new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
          ({
            connection: stream,
            remotePeer,
            protocol: cryptoProtocol,
            streamMuxer: muxerFactory
          } = await (direction === "inbound" ? this._encryptInbound(stream, {
            ...opts,
            remotePeer: remotePeerFromMultiaddr
          }) : this._encryptOutbound(stream, {
            ...opts,
            remotePeer: remotePeerFromMultiaddr
          })));
        }
        if (remotePeer.equals(this.components.peerId)) {
          const err2 = new InvalidPeerIdError("Can not dial self");
          maConn.abort(err2);
          throw err2;
        }
        await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn);
        if (opts?.muxerFactory != null) {
          muxerFactory = opts.muxerFactory;
        } else if (muxerFactory == null && this.streamMuxers.size > 0) {
          opts?.onProgress?.(new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
          muxerFactory = await (direction === "inbound" ? this._multiplexInbound(stream, this.streamMuxers, opts) : this._multiplexOutbound(stream, this.streamMuxers, opts));
        }
      } catch (err2) {
        maConn.log.error("failed to upgrade %s connection %s %a - %e", direction, direction === "inbound" ? "from" : "to", maConn.remoteAddr, err2);
        throw err2;
      }
      if (muxerFactory != null) {
        maConn.log("create muxer %s", muxerFactory.protocol);
        muxer = muxerFactory.createStreamMuxer(stream);
      }
      await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
      const conn = this._createConnection({
        id,
        cryptoProtocol,
        direction,
        maConn,
        stream,
        muxer,
        remotePeer,
        limits: opts?.limits,
        closeTimeout: this.connectionCloseTimeout
      });
      conn.log("successfully upgraded connection");
      return conn;
    }
    /**
     * A convenience method for generating a new `Connection`
     */
    _createConnection(opts) {
      const connection = createConnection(this.components, {
        ...opts,
        outboundStreamProtocolNegotiationTimeout: this.outboundStreamProtocolNegotiationTimeout,
        inboundStreamProtocolNegotiationTimeout: this.inboundStreamProtocolNegotiationTimeout
      });
      connection.addEventListener("close", () => {
        this.events.safeDispatchEvent("connection:close", {
          detail: connection
        });
      });
      this.events.safeDispatchEvent("connection:open", {
        detail: connection
      });
      return connection;
    }
    /**
     * Attempts to encrypt the incoming `connection` with the provided `cryptos`
     */
    async _encryptInbound(connection, options2) {
      const protocols = Array.from(this.connectionEncrypters.keys());
      try {
        const protocol = await handle(connection, protocols, options2);
        const encrypter = this.connectionEncrypters.get(protocol);
        if (encrypter == null) {
          throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
        }
        connection.log("encrypting inbound connection using %s", protocol);
        return {
          ...await encrypter.secureInbound(connection, options2),
          protocol
        };
      } catch (err2) {
        throw new EncryptionFailedError(err2.message);
      }
    }
    /**
     * Attempts to encrypt the given `connection` with the provided connection encrypters.
     * The first `ConnectionEncrypter` module to succeed will be used
     */
    async _encryptOutbound(connection, options2) {
      const protocols = Array.from(this.connectionEncrypters.keys());
      try {
        connection.log.trace("selecting encrypter from %s", protocols);
        const protocol = await select(connection, protocols, options2);
        const encrypter = this.connectionEncrypters.get(protocol);
        if (encrypter == null) {
          throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
        }
        connection.log("encrypting outbound connection using %s", protocol);
        return {
          ...await encrypter.secureOutbound(connection, options2),
          protocol
        };
      } catch (err2) {
        throw new EncryptionFailedError(err2.message);
      }
    }
    /**
     * Selects one of the given muxers via multistream-select. That
     * muxer will be used for all future streams on the connection.
     */
    async _multiplexOutbound(maConn, muxers, options2) {
      const protocols = Array.from(muxers.keys());
      maConn.log("outbound selecting muxer %s", protocols);
      try {
        maConn.log.trace("selecting stream muxer from %s", protocols);
        const protocol = await select(maConn, protocols, options2);
        const muxerFactory = muxers.get(protocol);
        if (muxerFactory == null) {
          throw new MuxerUnavailableError(`No muxer configured for protocol "${protocol}"`);
        }
        maConn.log("selected %s as muxer protocol", protocol);
        return muxerFactory;
      } catch (err2) {
        maConn.log.error("error multiplexing outbound connection - %e", err2);
        throw new MuxerUnavailableError(String(err2));
      }
    }
    /**
     * Registers support for one of the given muxers via multistream-select. The
     * selected muxer will be used for all future streams on the connection.
     */
    async _multiplexInbound(maConn, muxers, options2) {
      const protocols = Array.from(muxers.keys());
      maConn.log("inbound handling muxers %s", protocols);
      try {
        maConn.log.trace("selecting stream muxer from %s", protocols);
        const protocol = await handle(maConn, protocols, options2);
        const muxerFactory = muxers.get(protocol);
        if (muxerFactory == null) {
          throw new MuxerUnavailableError(`No muxer configured for protocol "${protocol}"`);
        }
        maConn.log("selected %s as muxer protocol", protocol);
        return muxerFactory;
      } catch (err2) {
        maConn.log.error("error multiplexing inbound connection - %e", err2);
        throw err2;
      }
    }
    getConnectionEncrypters() {
      return this.connectionEncrypters;
    }
    getStreamMuxers() {
      return this.streamMuxers;
    }
  };
  function isEncryptionSkipped(opts) {
    return opts.skipEncryption === true;
  }

  // node_modules/libp2p/dist/src/version.js
  var version = "3.1.0";
  var name7 = "js-libp2p";

  // node_modules/libp2p/dist/src/user-agent.browser.js
  function userAgent(name9, version3) {
    return `${name9 ?? name7}/${version3 ?? version} browser/${globalThis.navigator.userAgent}`;
  }

  // node_modules/libp2p/dist/src/libp2p.js
  var Libp2p = class extends TypedEventEmitter {
    peerId;
    peerStore;
    contentRouting;
    peerRouting;
    metrics;
    services;
    logger;
    status;
    components;
    log;
    // eslint-disable-next-line complexity
    constructor(init) {
      super();
      this.status = "stopped";
      const events = new TypedEventEmitter();
      const originalDispatch = events.dispatchEvent.bind(events);
      events.dispatchEvent = (evt) => {
        const internalResult = originalDispatch(evt);
        const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
        return internalResult || externalResult;
      };
      setMaxListeners(Infinity, events);
      this.peerId = init.peerId;
      this.logger = init.logger ?? defaultLogger();
      this.log = this.logger.forComponent("libp2p");
      this.services = {};
      const nodeInfoName = init.nodeInfo?.name ?? name7;
      const nodeInfoVersion = init.nodeInfo?.version ?? version;
      const components = this.components = defaultComponents({
        peerId: init.peerId,
        privateKey: init.privateKey,
        nodeInfo: {
          name: nodeInfoName,
          version: nodeInfoVersion,
          userAgent: init.nodeInfo?.userAgent ?? userAgent(nodeInfoName, nodeInfoVersion)
        },
        logger: this.logger,
        events,
        datastore: init.datastore ?? new MemoryDatastore(),
        connectionGater: connectionGater(init.connectionGater),
        dns: init.dns
      });
      if (init.metrics != null) {
        this.metrics = this.configureComponent("metrics", init.metrics(this.components));
      }
      this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
        addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
        ...init.peerStore
      }));
      components.events.addEventListener("peer:update", (evt) => {
        if (evt.detail.previous == null) {
          const peerInfo = {
            id: evt.detail.peer.id,
            multiaddrs: evt.detail.peer.addresses.map((a2) => a2.multiaddr)
          };
          components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
        }
      });
      if (init.connectionProtector != null) {
        this.configureComponent("connectionProtector", init.connectionProtector(components));
      }
      this.components.upgrader = new Upgrader(this.components, {
        connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
        streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
        inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout,
        inboundStreamProtocolNegotiationTimeout: init.connectionManager?.inboundStreamProtocolNegotiationTimeout,
        outboundStreamProtocolNegotiationTimeout: init.connectionManager?.outboundStreamProtocolNegotiationTimeout,
        connectionCloseTimeout: init.connectionManager?.connectionCloseTimeout
      });
      this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
      this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
      if (init.connectionMonitor?.enabled !== false) {
        this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
      }
      this.configureComponent("registrar", new Registrar(this.components));
      this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
      const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
      this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
        routers: peerRouters
      }));
      const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
      this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
        routers: contentRouters
      }));
      this.configureComponent("randomWalk", new RandomWalk(this.components));
      (init.peerDiscovery ?? []).forEach((fn, index) => {
        const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
        service.addEventListener("peer", (evt) => {
          this.#onDiscoveryPeer(evt);
        });
      });
      init.transports?.forEach((fn, index) => {
        this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
      });
      if (init.services != null) {
        for (const name9 of Object.keys(init.services)) {
          const createService = init.services[name9];
          const service = createService(this.components);
          if (service == null) {
            this.log.error("service factory %s returned null or undefined instance", name9);
            continue;
          }
          this.services[name9] = service;
          this.configureComponent(name9, service);
          if (service[contentRoutingSymbol] != null) {
            this.log("registering service %s for content routing", name9);
            contentRouters.push(service[contentRoutingSymbol]);
          }
          if (service[peerRoutingSymbol] != null) {
            this.log("registering service %s for peer routing", name9);
            peerRouters.push(service[peerRoutingSymbol]);
          }
          if (service[peerDiscoverySymbol] != null) {
            this.log("registering service %s for peer discovery", name9);
            service[peerDiscoverySymbol].addEventListener?.("peer", (evt) => {
              this.#onDiscoveryPeer(evt);
            });
          }
        }
      }
      checkServiceDependencies(components);
    }
    configureComponent(name9, component) {
      if (component == null) {
        this.log.error("component %s was null or undefined", name9);
      }
      this.components[name9] = component;
      return component;
    }
    /**
     * Starts the libp2p node and all its subsystems
     */
    async start() {
      if (this.status !== "stopped") {
        return;
      }
      this.status = "starting";
      this.log("libp2p is starting");
      try {
        await this.components.beforeStart?.();
        await this.components.start();
        await this.components.afterStart?.();
        this.status = "started";
        this.safeDispatchEvent("start", { detail: this });
        this.log("libp2p has started with peer id %p", this.peerId);
      } catch (err2) {
        this.log.error("an error occurred starting libp2p - %e", err2);
        this.status = "started";
        await this.stop();
        throw err2;
      }
    }
    /**
     * Stop the libp2p node by closing its listeners and open connections
     */
    async stop() {
      if (this.status !== "started") {
        return;
      }
      this.log("libp2p is stopping");
      this.status = "stopping";
      await this.components.beforeStop?.();
      await this.components.stop();
      await this.components.afterStop?.();
      this.status = "stopped";
      this.safeDispatchEvent("stop", { detail: this });
      this.log("libp2p has stopped");
    }
    getConnections(peerId) {
      return this.components.connectionManager.getConnections(peerId);
    }
    getDialQueue() {
      return this.components.connectionManager.getDialQueue();
    }
    getPeers() {
      const peerSet2 = new PeerSet();
      for (const conn of this.components.connectionManager.getConnections()) {
        peerSet2.add(conn.remotePeer);
      }
      return Array.from(peerSet2);
    }
    async dial(peer, options2 = {}) {
      return this.components.connectionManager.openConnection(peer, {
        // ensure any userland dials take top priority in the queue
        priority: 75,
        ...options2
      });
    }
    async dialProtocol(peer, protocols, options2 = {}) {
      if (protocols == null) {
        throw new InvalidParametersError("no protocols were provided to open a stream");
      }
      protocols = Array.isArray(protocols) ? protocols : [protocols];
      if (protocols.length === 0) {
        throw new InvalidParametersError("no protocols were provided to open a stream");
      }
      return this.components.connectionManager.openStream(peer, protocols, options2);
    }
    getMultiaddrs() {
      return this.components.addressManager.getAddresses();
    }
    getProtocols() {
      return this.components.registrar.getProtocols();
    }
    async hangUp(peer, options2 = {}) {
      if (isMultiaddr(peer)) {
        peer = peerIdFromString(peer.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value ?? "");
      }
      await this.components.connectionManager.closeConnections(peer, options2);
    }
    async getPublicKey(peer, options2 = {}) {
      this.log("getPublicKey %p", peer);
      if (peer.publicKey != null) {
        return peer.publicKey;
      }
      try {
        const peerInfo = await this.peerStore.get(peer, options2);
        if (peerInfo.id.publicKey != null) {
          return peerInfo.id.publicKey;
        }
      } catch (err2) {
        if (err2.name !== "NotFoundError") {
          throw err2;
        }
      }
      const peerKey = concat([
        fromString2("/pk/"),
        peer.toMultihash().bytes
      ]);
      const bytes = await this.contentRouting.get(peerKey, options2);
      const publicKey2 = publicKeyFromProtobuf(bytes);
      await this.peerStore.patch(peer, {
        publicKey: publicKey2
      }, options2);
      return publicKey2;
    }
    async handle(protocols, handler, options2) {
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      await Promise.all(protocols.map(async (protocol) => {
        await this.components.registrar.handle(protocol, handler, options2);
      }));
    }
    async unhandle(protocols, options2) {
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      await Promise.all(protocols.map(async (protocol) => {
        await this.components.registrar.unhandle(protocol, options2);
      }));
    }
    async register(protocol, topology, options2) {
      return this.components.registrar.register(protocol, topology, options2);
    }
    unregister(id) {
      this.components.registrar.unregister(id);
    }
    use(protocol, middleware) {
      this.components.registrar.use(protocol, Array.isArray(middleware) ? middleware : [middleware]);
    }
    unuse(protocol) {
      this.components.registrar.unuse(protocol);
    }
    async isDialable(multiaddr2, options2 = {}) {
      return this.components.connectionManager.isDialable(multiaddr2, options2);
    }
    /**
     * Called whenever peer discovery services emit `peer` events and adds peers
     * to the peer store.
     */
    #onDiscoveryPeer(evt) {
      const { detail: peer } = evt;
      if (peer.id.toString() === this.peerId.toString()) {
        this.log.error("peer discovery mechanism discovered self");
        return;
      }
      void this.components.peerStore.merge(peer.id, {
        multiaddrs: peer.multiaddrs
      }).catch((err2) => {
        this.log.error("could not update multiaddrs of discovered peer - %e", err2);
      });
    }
  };

  // node_modules/libp2p/dist/src/index.js
  async function createLibp2p(options2 = {}) {
    options2.privateKey ??= await generateKeyPair("Ed25519");
    const node = new Libp2p({
      ...await validateConfig(options2),
      peerId: peerIdFromPrivateKey(options2.privateKey)
    });
    if (options2.start !== false) {
      await node.start();
    }
    return node;
  }
  var LIBP2P_METHODS = ["dial", "dialProtocol", "hangUp", "handle", "unhandle", "getMultiaddrs", "getProtocols"];
  function isLibp2p(obj) {
    if (obj == null) {
      return false;
    }
    if (obj instanceof Libp2p) {
      return true;
    }
    return LIBP2P_METHODS.every((m2) => typeof obj[m2] === "function");
  }

  // node_modules/@libp2p/keychain/dist/src/keychain.js
  var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);

  // node_modules/@libp2p/keychain/dist/src/constants.js
  var DEK_INIT = {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  };

  // node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js
  var aes_gcm_browser_exports = {};
  __export(aes_gcm_browser_exports, {
    create: () => create2,
    derivedEmptyPasswordKey: () => derivedEmptyPasswordKey
  });
  var derivedEmptyPasswordKey = {
    alg: "A128GCM",
    ext: true,
    /* spell-checker:disable-next-line */
    k: "scm9jmO_4BJAgdwWGVulLg",
    key_ops: ["encrypt", "decrypt"],
    kty: "oct"
  };
  function create2(opts) {
    const algorithm = opts?.algorithm ?? "AES-GCM";
    let keyLength = opts?.keyLength ?? 16;
    const nonceLength = opts?.nonceLength ?? 12;
    const digest2 = opts?.digest ?? "SHA-256";
    const saltLength = opts?.saltLength ?? 16;
    const iterations = opts?.iterations ?? 32767;
    const crypto2 = webcrypto_default.get();
    keyLength *= 8;
    async function encrypt(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString2(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      }
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt(data, password) {
      const salt = data.subarray(0, saltLength);
      const nonce = data.subarray(saltLength, saltLength + nonceLength);
      const ciphertext = data.subarray(saltLength + nonceLength);
      const aesGcm = { name: algorithm, iv: nonce };
      if (typeof password === "string") {
        password = fromString2(password);
      }
      let cryptoKey;
      if (password.length === 0) {
        try {
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
          const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
          cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        } catch {
          cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["decrypt"]);
        }
      } else {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      }
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    const cipher = {
      encrypt,
      decrypt
    };
    return cipher;
  }

  // node_modules/asn1js/build/index.es.js
  var index_es_exports = {};
  __export(index_es_exports, {
    Any: () => Any,
    BaseBlock: () => BaseBlock,
    BaseStringBlock: () => BaseStringBlock,
    BitString: () => BitString,
    BmpString: () => BmpString,
    Boolean: () => Boolean2,
    CharacterString: () => CharacterString,
    Choice: () => Choice,
    Constructed: () => Constructed,
    DATE: () => DATE,
    DateTime: () => DateTime,
    Duration: () => Duration,
    EndOfContent: () => EndOfContent,
    Enumerated: () => Enumerated,
    GeneralString: () => GeneralString,
    GeneralizedTime: () => GeneralizedTime,
    GraphicString: () => GraphicString,
    HexBlock: () => HexBlock,
    IA5String: () => IA5String,
    Integer: () => Integer,
    Null: () => Null,
    NumericString: () => NumericString,
    ObjectIdentifier: () => ObjectIdentifier,
    OctetString: () => OctetString,
    Primitive: () => Primitive,
    PrintableString: () => PrintableString,
    RawData: () => RawData,
    RelativeObjectIdentifier: () => RelativeObjectIdentifier,
    Repeated: () => Repeated,
    Sequence: () => Sequence,
    Set: () => Set2,
    TIME: () => TIME,
    TeletexString: () => TeletexString,
    TimeOfDay: () => TimeOfDay,
    UTCTime: () => UTCTime,
    UniversalString: () => UniversalString,
    Utf8String: () => Utf8String,
    ValueBlock: () => ValueBlock,
    VideotexString: () => VideotexString,
    ViewWriter: () => ViewWriter,
    VisibleString: () => VisibleString,
    compareSchema: () => compareSchema,
    fromBER: () => fromBER,
    verifySchema: () => verifySchema
  });
  var pvtsutils = __toESM(require_build());

  // node_modules/pvutils/build/utils.es.js
  function utilFromBase(inputBuffer, inputBase) {
    let result = 0;
    if (inputBuffer.length === 1) {
      return inputBuffer[0];
    }
    for (let i2 = inputBuffer.length - 1; i2 >= 0; i2--) {
      result += inputBuffer[inputBuffer.length - 1 - i2] * Math.pow(2, inputBase * i2);
    }
    return result;
  }
  function utilToBase(value2, base3, reserved = -1) {
    const internalReserved = reserved;
    let internalValue = value2;
    let result = 0;
    let biggest = Math.pow(2, base3);
    for (let i2 = 1; i2 < 8; i2++) {
      if (value2 < biggest) {
        let retBuf;
        if (internalReserved < 0) {
          retBuf = new ArrayBuffer(i2);
          result = i2;
        } else {
          if (internalReserved < i2) {
            return new ArrayBuffer(0);
          }
          retBuf = new ArrayBuffer(internalReserved);
          result = internalReserved;
        }
        const retView = new Uint8Array(retBuf);
        for (let j = i2 - 1; j >= 0; j--) {
          const basis = Math.pow(2, j * base3);
          retView[result - j - 1] = Math.floor(internalValue / basis);
          internalValue -= retView[result - j - 1] * basis;
        }
        return retBuf;
      }
      biggest *= Math.pow(2, base3);
    }
    return new ArrayBuffer(0);
  }
  function utilConcatView(...views) {
    let outputLength = 0;
    let prevLength = 0;
    for (const view of views) {
      outputLength += view.length;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const view of views) {
      retView.set(view, prevLength);
      prevLength += view.length;
    }
    return retView;
  }
  function utilDecodeTC() {
    const buf2 = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
      const condition1 = buf2[0] === 255 && buf2[1] & 128;
      const condition2 = buf2[0] === 0 && (buf2[1] & 128) === 0;
      if (condition1 || condition2) {
        this.warnings.push("Needlessly long format");
      }
    }
    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const bigIntView = new Uint8Array(bigIntBuffer);
    for (let i2 = 0; i2 < this.valueHex.byteLength; i2++) {
      bigIntView[i2] = 0;
    }
    bigIntView[0] = buf2[0] & 128;
    const bigInt = utilFromBase(bigIntView, 8);
    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const smallIntView = new Uint8Array(smallIntBuffer);
    for (let j = 0; j < this.valueHex.byteLength; j++) {
      smallIntView[j] = buf2[j];
    }
    smallIntView[0] &= 127;
    const smallInt = utilFromBase(smallIntView, 8);
    return smallInt - bigInt;
  }
  function utilEncodeTC(value2) {
    const modValue = value2 < 0 ? value2 * -1 : value2;
    let bigInt = 128;
    for (let i2 = 1; i2 < 8; i2++) {
      if (modValue <= bigInt) {
        if (value2 < 0) {
          const smallInt = bigInt - modValue;
          const retBuf2 = utilToBase(smallInt, 8, i2);
          const retView2 = new Uint8Array(retBuf2);
          retView2[0] |= 128;
          return retBuf2;
        }
        let retBuf = utilToBase(modValue, 8, i2);
        let retView = new Uint8Array(retBuf);
        if (retView[0] & 128) {
          const tempBuf = retBuf.slice(0);
          const tempView = new Uint8Array(tempBuf);
          retBuf = new ArrayBuffer(retBuf.byteLength + 1);
          retView = new Uint8Array(retBuf);
          for (let k = 0; k < tempBuf.byteLength; k++) {
            retView[k + 1] = tempView[k];
          }
          retView[0] = 0;
        }
        return retBuf;
      }
      bigInt *= Math.pow(2, 8);
    }
    return new ArrayBuffer(0);
  }
  function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
      return false;
    }
    const view1 = new Uint8Array(inputBuffer1);
    const view2 = new Uint8Array(inputBuffer2);
    for (let i2 = 0; i2 < view1.length; i2++) {
      if (view1[i2] !== view2[i2]) {
        return false;
      }
    }
    return true;
  }
  function padNumber(inputNumber, fullLength) {
    const str = inputNumber.toString(10);
    if (fullLength < str.length) {
      return "";
    }
    const dif = fullLength - str.length;
    const padding = new Array(dif);
    for (let i2 = 0; i2 < dif; i2++) {
      padding[i2] = "0";
    }
    const paddingString = padding.join("");
    return paddingString.concat(str);
  }
  var log22 = Math.log(2);

  // node_modules/asn1js/build/index.es.js
  function assertBigInt() {
    if (typeof BigInt === "undefined") {
      throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
    }
  }
  function concat3(buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (let i2 = 0; i2 < buffers.length; i2++) {
      const buffer2 = buffers[i2];
      outputLength += buffer2.byteLength;
    }
    const retView = new Uint8Array(outputLength);
    for (let i2 = 0; i2 < buffers.length; i2++) {
      const buffer2 = buffers[i2];
      retView.set(new Uint8Array(buffer2), prevLength);
      prevLength += buffer2.byteLength;
    }
    return retView.buffer;
  }
  function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof Uint8Array)) {
      baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
      return false;
    }
    if (!inputBuffer.byteLength) {
      baseBlock.error = "Wrong parameter: inputBuffer has zero length";
      return false;
    }
    if (inputOffset < 0) {
      baseBlock.error = "Wrong parameter: inputOffset less than zero";
      return false;
    }
    if (inputLength < 0) {
      baseBlock.error = "Wrong parameter: inputLength less than zero";
      return false;
    }
    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
      baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return false;
    }
    return true;
  }
  var ViewWriter = class {
    constructor() {
      this.items = [];
    }
    write(buf2) {
      this.items.push(buf2);
    }
    final() {
      return concat3(this.items);
    }
  };
  var powers2 = [new Uint8Array([1])];
  var digitsString = "0123456789";
  var NAME = "name";
  var VALUE_HEX_VIEW = "valueHexView";
  var IS_HEX_ONLY = "isHexOnly";
  var ID_BLOCK = "idBlock";
  var TAG_CLASS = "tagClass";
  var TAG_NUMBER = "tagNumber";
  var IS_CONSTRUCTED = "isConstructed";
  var FROM_BER = "fromBER";
  var TO_BER = "toBER";
  var LOCAL = "local";
  var EMPTY_STRING = "";
  var EMPTY_BUFFER = new ArrayBuffer(0);
  var EMPTY_VIEW = new Uint8Array(0);
  var END_OF_CONTENT_NAME = "EndOfContent";
  var OCTET_STRING_NAME = "OCTET STRING";
  var BIT_STRING_NAME = "BIT STRING";
  function HexBlock(BaseClass) {
    var _a4;
    return _a4 = class Some extends BaseClass {
      get valueHex() {
        return this.valueHexView.slice().buffer;
      }
      set valueHex(value2) {
        this.valueHexView = new Uint8Array(value2);
      }
      constructor(...args) {
        var _b2;
        super(...args);
        const params = args[0] || {};
        this.isHexOnly = (_b2 = params.isHexOnly) !== null && _b2 !== void 0 ? _b2 : false;
        this.valueHexView = params.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        const endLength = inputOffset + inputLength;
        this.valueHexView = view.subarray(inputOffset, endLength);
        if (!this.valueHexView.length) {
          this.warnings.push("Zero buffer length");
          return inputOffset;
        }
        this.blockLength = inputLength;
        return endLength;
      }
      toBER(sizeOnly = false) {
        if (!this.isHexOnly) {
          this.error = "Flag 'isHexOnly' is not set, abort";
          return EMPTY_BUFFER;
        }
        if (sizeOnly) {
          return new ArrayBuffer(this.valueHexView.byteLength);
        }
        return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isHexOnly: this.isHexOnly,
          valueHex: pvtsutils.Convert.ToHex(this.valueHexView)
        };
      }
    }, _a4.NAME = "hexBlock", _a4;
  }
  var LocalBaseBlock = class {
    static blockName() {
      return this.NAME;
    }
    get valueBeforeDecode() {
      return this.valueBeforeDecodeView.slice().buffer;
    }
    set valueBeforeDecode(value2) {
      this.valueBeforeDecodeView = new Uint8Array(value2);
    }
    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
      this.blockLength = blockLength;
      this.error = error;
      this.warnings = warnings;
      this.valueBeforeDecodeView = pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);
    }
    toJSON() {
      return {
        blockName: this.constructor.NAME,
        blockLength: this.blockLength,
        error: this.error,
        warnings: this.warnings,
        valueBeforeDecode: pvtsutils.Convert.ToHex(this.valueBeforeDecodeView)
      };
    }
  };
  LocalBaseBlock.NAME = "baseBlock";
  var ValueBlock = class extends LocalBaseBlock {
    fromBER(_inputBuffer, _inputOffset, _inputLength) {
      throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
    }
    toBER(_sizeOnly, _writer) {
      throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
    }
  };
  ValueBlock.NAME = "valueBlock";
  var LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
    constructor({ idBlock = {} } = {}) {
      var _a4, _b2, _c, _d;
      super();
      if (idBlock) {
        this.isHexOnly = (_a4 = idBlock.isHexOnly) !== null && _a4 !== void 0 ? _a4 : false;
        this.valueHexView = idBlock.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
        this.tagClass = (_b2 = idBlock.tagClass) !== null && _b2 !== void 0 ? _b2 : -1;
        this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
        this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
      } else {
        this.tagClass = -1;
        this.tagNumber = -1;
        this.isConstructed = false;
      }
    }
    toBER(sizeOnly = false) {
      let firstOctet = 0;
      switch (this.tagClass) {
        case 1:
          firstOctet |= 0;
          break;
        case 2:
          firstOctet |= 64;
          break;
        case 3:
          firstOctet |= 128;
          break;
        case 4:
          firstOctet |= 192;
          break;
        default:
          this.error = "Unknown tag class";
          return EMPTY_BUFFER;
      }
      if (this.isConstructed)
        firstOctet |= 32;
      if (this.tagNumber < 31 && !this.isHexOnly) {
        const retView2 = new Uint8Array(1);
        if (!sizeOnly) {
          let number = this.tagNumber;
          number &= 31;
          firstOctet |= number;
          retView2[0] = firstOctet;
        }
        return retView2.buffer;
      }
      if (!this.isHexOnly) {
        const encodedBuf = utilToBase(this.tagNumber, 7);
        const encodedView = new Uint8Array(encodedBuf);
        const size = encodedBuf.byteLength;
        const retView2 = new Uint8Array(size + 1);
        retView2[0] = firstOctet | 31;
        if (!sizeOnly) {
          for (let i2 = 0; i2 < size - 1; i2++)
            retView2[i2 + 1] = encodedView[i2] | 128;
          retView2[size] = encodedView[size - 1];
        }
        return retView2.buffer;
      }
      const retView = new Uint8Array(this.valueHexView.byteLength + 1);
      retView[0] = firstOctet | 31;
      if (!sizeOnly) {
        const curView = this.valueHexView;
        for (let i2 = 0; i2 < curView.length - 1; i2++)
          retView[i2 + 1] = curView[i2] | 128;
        retView[this.valueHexView.byteLength] = curView[curView.length - 1];
      }
      return retView.buffer;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
        return -1;
      }
      const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
      if (intBuffer.length === 0) {
        this.error = "Zero buffer length";
        return -1;
      }
      const tagClassMask = intBuffer[0] & 192;
      switch (tagClassMask) {
        case 0:
          this.tagClass = 1;
          break;
        case 64:
          this.tagClass = 2;
          break;
        case 128:
          this.tagClass = 3;
          break;
        case 192:
          this.tagClass = 4;
          break;
        default:
          this.error = "Unknown tag class";
          return -1;
      }
      this.isConstructed = (intBuffer[0] & 32) === 32;
      this.isHexOnly = false;
      const tagNumberMask = intBuffer[0] & 31;
      if (tagNumberMask !== 31) {
        this.tagNumber = tagNumberMask;
        this.blockLength = 1;
      } else {
        let count = 1;
        let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
        let tagNumberBufferMaxLength = 255;
        while (intBuffer[count] & 128) {
          intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
          count++;
          if (count >= intBuffer.length) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
          }
          if (count === tagNumberBufferMaxLength) {
            tagNumberBufferMaxLength += 255;
            const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
            for (let i2 = 0; i2 < intTagNumberBuffer.length; i2++)
              tempBufferView2[i2] = intTagNumberBuffer[i2];
            intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
          }
        }
        this.blockLength = count + 1;
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        const tempBufferView = new Uint8Array(count);
        for (let i2 = 0; i2 < count; i2++)
          tempBufferView[i2] = intTagNumberBuffer[i2];
        intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
        intTagNumberBuffer.set(tempBufferView);
        if (this.blockLength <= 9)
          this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Tag too long, represented as hex-coded");
        }
      }
      if (this.tagClass === 1 && this.isConstructed) {
        switch (this.tagNumber) {
          case 1:
          case 2:
          case 5:
          case 6:
          case 9:
          case 13:
          case 14:
          case 23:
          case 24:
          case 31:
          case 32:
          case 33:
          case 34:
            this.error = "Constructed encoding used for primitive type";
            return -1;
        }
      }
      return inputOffset + this.blockLength;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        tagClass: this.tagClass,
        tagNumber: this.tagNumber,
        isConstructed: this.isConstructed
      };
    }
  };
  LocalIdentificationBlock.NAME = "identificationBlock";
  var LocalLengthBlock = class extends LocalBaseBlock {
    constructor({ lenBlock = {} } = {}) {
      var _a4, _b2, _c;
      super();
      this.isIndefiniteForm = (_a4 = lenBlock.isIndefiniteForm) !== null && _a4 !== void 0 ? _a4 : false;
      this.longFormUsed = (_b2 = lenBlock.longFormUsed) !== null && _b2 !== void 0 ? _b2 : false;
      this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
      if (intBuffer.length === 0) {
        this.error = "Zero buffer length";
        return -1;
      }
      if (intBuffer[0] === 255) {
        this.error = "Length block 0xFF is reserved by standard";
        return -1;
      }
      this.isIndefiniteForm = intBuffer[0] === 128;
      if (this.isIndefiniteForm) {
        this.blockLength = 1;
        return inputOffset + this.blockLength;
      }
      this.longFormUsed = !!(intBuffer[0] & 128);
      if (this.longFormUsed === false) {
        this.length = intBuffer[0];
        this.blockLength = 1;
        return inputOffset + this.blockLength;
      }
      const count = intBuffer[0] & 127;
      if (count > 8) {
        this.error = "Too big integer";
        return -1;
      }
      if (count + 1 > intBuffer.length) {
        this.error = "End of input reached before message was fully decoded";
        return -1;
      }
      const lenOffset = inputOffset + 1;
      const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
      if (lengthBufferView[count - 1] === 0)
        this.warnings.push("Needlessly long encoded length");
      this.length = utilFromBase(lengthBufferView, 8);
      if (this.longFormUsed && this.length <= 127)
        this.warnings.push("Unnecessary usage of long length form");
      this.blockLength = count + 1;
      return inputOffset + this.blockLength;
    }
    toBER(sizeOnly = false) {
      let retBuf;
      let retView;
      if (this.length > 127)
        this.longFormUsed = true;
      if (this.isIndefiniteForm) {
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
          retView = new Uint8Array(retBuf);
          retView[0] = 128;
        }
        return retBuf;
      }
      if (this.longFormUsed) {
        const encodedBuf = utilToBase(this.length, 8);
        if (encodedBuf.byteLength > 127) {
          this.error = "Too big length";
          return EMPTY_BUFFER;
        }
        retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
        if (sizeOnly)
          return retBuf;
        const encodedView = new Uint8Array(encodedBuf);
        retView = new Uint8Array(retBuf);
        retView[0] = encodedBuf.byteLength | 128;
        for (let i2 = 0; i2 < encodedBuf.byteLength; i2++)
          retView[i2 + 1] = encodedView[i2];
        return retBuf;
      }
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = this.length;
      }
      return retBuf;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isIndefiniteForm: this.isIndefiniteForm,
        longFormUsed: this.longFormUsed,
        length: this.length
      };
    }
  };
  LocalLengthBlock.NAME = "lengthBlock";
  var typeStore = {};
  var BaseBlock = class extends LocalBaseBlock {
    constructor({ name: name9 = EMPTY_STRING, optional: optional2 = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
      super(parameters);
      this.name = name9;
      this.optional = optional2;
      if (primitiveSchema) {
        this.primitiveSchema = primitiveSchema;
      }
      this.idBlock = new LocalIdentificationBlock(parameters);
      this.lenBlock = new LocalLengthBlock(parameters);
      this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }
      if (!this.idBlock.error.length)
        this.blockLength += this.idBlock.blockLength;
      if (!this.lenBlock.error.length)
        this.blockLength += this.lenBlock.blockLength;
      if (!this.valueBlock.error.length)
        this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    }
    toBER(sizeOnly, writer) {
      const _writer = writer || new ViewWriter();
      if (!writer) {
        prepareIndefiniteForm(this);
      }
      const idBlockBuf = this.idBlock.toBER(sizeOnly);
      _writer.write(idBlockBuf);
      if (this.lenBlock.isIndefiniteForm) {
        _writer.write(new Uint8Array([128]).buffer);
        this.valueBlock.toBER(sizeOnly, _writer);
        _writer.write(new ArrayBuffer(2));
      } else {
        const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
        this.lenBlock.length = valueBlockBuf.byteLength;
        const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
        _writer.write(lenBlockBuf);
        _writer.write(valueBlockBuf);
      }
      if (!writer) {
        return _writer.final();
      }
      return EMPTY_BUFFER;
    }
    toJSON() {
      const object = {
        ...super.toJSON(),
        idBlock: this.idBlock.toJSON(),
        lenBlock: this.lenBlock.toJSON(),
        valueBlock: this.valueBlock.toJSON(),
        name: this.name,
        optional: this.optional
      };
      if (this.primitiveSchema)
        object.primitiveSchema = this.primitiveSchema.toJSON();
      return object;
    }
    toString(encoding = "ascii") {
      if (encoding === "ascii") {
        return this.onAsciiEncoding();
      }
      return pvtsutils.Convert.ToHex(this.toBER());
    }
    onAsciiEncoding() {
      const name9 = this.constructor.NAME;
      const value2 = pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
      return `${name9} : ${value2}`;
    }
    isEqual(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof this.constructor)) {
        return false;
      }
      const thisRaw = this.toBER();
      const otherRaw = other.toBER();
      return isEqualBuffer(thisRaw, otherRaw);
    }
  };
  BaseBlock.NAME = "BaseBlock";
  function prepareIndefiniteForm(baseBlock) {
    var _a4;
    if (baseBlock instanceof typeStore.Constructed) {
      for (const value2 of baseBlock.valueBlock.value) {
        if (prepareIndefiniteForm(value2)) {
          baseBlock.lenBlock.isIndefiniteForm = true;
        }
      }
    }
    return !!((_a4 = baseBlock.lenBlock) === null || _a4 === void 0 ? void 0 : _a4.isIndefiniteForm);
  }
  var BaseStringBlock = class extends BaseBlock {
    getValue() {
      return this.valueBlock.value;
    }
    setValue(value2) {
      this.valueBlock.value = value2;
    }
    constructor({ value: value2 = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
      super(parameters, stringValueBlockType);
      if (value2) {
        this.fromString(value2);
      }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }
      this.fromBuffer(this.valueBlock.valueHexView);
      if (!this.idBlock.error.length)
        this.blockLength += this.idBlock.blockLength;
      if (!this.lenBlock.error.length)
        this.blockLength += this.lenBlock.blockLength;
      if (!this.valueBlock.error.length)
        this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    }
    onAsciiEncoding() {
      return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
    }
  };
  BaseStringBlock.NAME = "BaseStringBlock";
  var LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
    constructor({ isHexOnly = true, ...parameters } = {}) {
      super(parameters);
      this.isHexOnly = isHexOnly;
    }
  };
  LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
  var _a$w;
  var Primitive = class extends BaseBlock {
    constructor(parameters = {}) {
      super(parameters, LocalPrimitiveValueBlock);
      this.idBlock.isConstructed = false;
    }
  };
  _a$w = Primitive;
  (() => {
    typeStore.Primitive = _a$w;
  })();
  Primitive.NAME = "PRIMITIVE";
  function localChangeType(inputObject, newType) {
    if (inputObject instanceof newType) {
      return inputObject;
    }
    const newObject = new newType();
    newObject.idBlock = inputObject.idBlock;
    newObject.lenBlock = inputObject.lenBlock;
    newObject.warnings = inputObject.warnings;
    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
    return newObject;
  }
  function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
    const incomingOffset = inputOffset;
    let returnObject = new BaseBlock({}, ValueBlock);
    const baseBlock = new LocalBaseBlock();
    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
      returnObject.error = baseBlock.error;
      return {
        offset: -1,
        result: returnObject
      };
    }
    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
    if (!intBuffer.length) {
      returnObject.error = "Zero buffer length";
      return {
        offset: -1,
        result: returnObject
      };
    }
    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.idBlock.warnings.length) {
      returnObject.warnings.concat(returnObject.idBlock.warnings);
    }
    if (resultOffset === -1) {
      returnObject.error = returnObject.idBlock.error;
      return {
        offset: -1,
        result: returnObject
      };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.idBlock.blockLength;
    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.lenBlock.warnings.length) {
      returnObject.warnings.concat(returnObject.lenBlock.warnings);
    }
    if (resultOffset === -1) {
      returnObject.error = returnObject.lenBlock.error;
      return {
        offset: -1,
        result: returnObject
      };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.lenBlock.blockLength;
    if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
      returnObject.error = "Indefinite length form used for primitive encoding form";
      return {
        offset: -1,
        result: returnObject
      };
    }
    let newASN1Type = BaseBlock;
    switch (returnObject.idBlock.tagClass) {
      case 1:
        if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
          returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        }
        switch (returnObject.idBlock.tagNumber) {
          case 0:
            if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
              returnObject.error = "Type [UNIVERSAL 0] is reserved";
              return {
                offset: -1,
                result: returnObject
              };
            }
            newASN1Type = typeStore.EndOfContent;
            break;
          case 1:
            newASN1Type = typeStore.Boolean;
            break;
          case 2:
            newASN1Type = typeStore.Integer;
            break;
          case 3:
            newASN1Type = typeStore.BitString;
            break;
          case 4:
            newASN1Type = typeStore.OctetString;
            break;
          case 5:
            newASN1Type = typeStore.Null;
            break;
          case 6:
            newASN1Type = typeStore.ObjectIdentifier;
            break;
          case 10:
            newASN1Type = typeStore.Enumerated;
            break;
          case 12:
            newASN1Type = typeStore.Utf8String;
            break;
          case 13:
            newASN1Type = typeStore.RelativeObjectIdentifier;
            break;
          case 14:
            newASN1Type = typeStore.TIME;
            break;
          case 15:
            returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
            return {
              offset: -1,
              result: returnObject
            };
          case 16:
            newASN1Type = typeStore.Sequence;
            break;
          case 17:
            newASN1Type = typeStore.Set;
            break;
          case 18:
            newASN1Type = typeStore.NumericString;
            break;
          case 19:
            newASN1Type = typeStore.PrintableString;
            break;
          case 20:
            newASN1Type = typeStore.TeletexString;
            break;
          case 21:
            newASN1Type = typeStore.VideotexString;
            break;
          case 22:
            newASN1Type = typeStore.IA5String;
            break;
          case 23:
            newASN1Type = typeStore.UTCTime;
            break;
          case 24:
            newASN1Type = typeStore.GeneralizedTime;
            break;
          case 25:
            newASN1Type = typeStore.GraphicString;
            break;
          case 26:
            newASN1Type = typeStore.VisibleString;
            break;
          case 27:
            newASN1Type = typeStore.GeneralString;
            break;
          case 28:
            newASN1Type = typeStore.UniversalString;
            break;
          case 29:
            newASN1Type = typeStore.CharacterString;
            break;
          case 30:
            newASN1Type = typeStore.BmpString;
            break;
          case 31:
            newASN1Type = typeStore.DATE;
            break;
          case 32:
            newASN1Type = typeStore.TimeOfDay;
            break;
          case 33:
            newASN1Type = typeStore.DateTime;
            break;
          case 34:
            newASN1Type = typeStore.Duration;
            break;
          default: {
            const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
            newObject.idBlock = returnObject.idBlock;
            newObject.lenBlock = returnObject.lenBlock;
            newObject.warnings = returnObject.warnings;
            returnObject = newObject;
          }
        }
        break;
      case 2:
      case 3:
      case 4:
      default: {
        newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
      }
    }
    returnObject = localChangeType(returnObject, newASN1Type);
    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
    return {
      offset: resultOffset,
      result: returnObject
    };
  }
  function fromBER(inputBuffer) {
    if (!inputBuffer.byteLength) {
      const result = new BaseBlock({}, ValueBlock);
      result.error = "Input buffer has zero length";
      return {
        offset: -1,
        result
      };
    }
    return localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
  }
  function checkLen(indefiniteLength, length4) {
    if (indefiniteLength) {
      return 1;
    }
    return length4;
  }
  var LocalConstructedValueBlock = class extends ValueBlock {
    constructor({ value: value2 = [], isIndefiniteForm = false, ...parameters } = {}) {
      super(parameters);
      this.value = value2;
      this.isIndefiniteForm = isIndefiniteForm;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
      if (this.valueBeforeDecodeView.length === 0) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      let currentOffset = inputOffset;
      while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
        const returnObject = localFromBER(view, currentOffset, inputLength);
        if (returnObject.offset === -1) {
          this.error = returnObject.result.error;
          this.warnings.concat(returnObject.result.warnings);
          return -1;
        }
        currentOffset = returnObject.offset;
        this.blockLength += returnObject.result.blockLength;
        inputLength -= returnObject.result.blockLength;
        this.value.push(returnObject.result);
        if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
          break;
        }
      }
      if (this.isIndefiniteForm) {
        if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
          this.value.pop();
        } else {
          this.warnings.push("No EndOfContent block encoded");
        }
      }
      return currentOffset;
    }
    toBER(sizeOnly, writer) {
      const _writer = writer || new ViewWriter();
      for (let i2 = 0; i2 < this.value.length; i2++) {
        this.value[i2].toBER(sizeOnly, _writer);
      }
      if (!writer) {
        return _writer.final();
      }
      return EMPTY_BUFFER;
    }
    toJSON() {
      const object = {
        ...super.toJSON(),
        isIndefiniteForm: this.isIndefiniteForm,
        value: []
      };
      for (const value2 of this.value) {
        object.value.push(value2.toJSON());
      }
      return object;
    }
  };
  LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
  var _a$v;
  var Constructed = class extends BaseBlock {
    constructor(parameters = {}) {
      super(parameters, LocalConstructedValueBlock);
      this.idBlock.isConstructed = true;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
      const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
      if (resultOffset === -1) {
        this.error = this.valueBlock.error;
        return resultOffset;
      }
      if (!this.idBlock.error.length)
        this.blockLength += this.idBlock.blockLength;
      if (!this.lenBlock.error.length)
        this.blockLength += this.lenBlock.blockLength;
      if (!this.valueBlock.error.length)
        this.blockLength += this.valueBlock.blockLength;
      return resultOffset;
    }
    onAsciiEncoding() {
      const values = [];
      for (const value2 of this.valueBlock.value) {
        values.push(value2.toString("ascii").split("\n").map((o2) => `  ${o2}`).join("\n"));
      }
      const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
      return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
    }
  };
  _a$v = Constructed;
  (() => {
    typeStore.Constructed = _a$v;
  })();
  Constructed.NAME = "CONSTRUCTED";
  var LocalEndOfContentValueBlock = class extends ValueBlock {
    fromBER(inputBuffer, inputOffset, _inputLength) {
      return inputOffset;
    }
    toBER(_sizeOnly) {
      return EMPTY_BUFFER;
    }
  };
  LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
  var _a$u;
  var EndOfContent = class extends BaseBlock {
    constructor(parameters = {}) {
      super(parameters, LocalEndOfContentValueBlock);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 0;
    }
  };
  _a$u = EndOfContent;
  (() => {
    typeStore.EndOfContent = _a$u;
  })();
  EndOfContent.NAME = END_OF_CONTENT_NAME;
  var _a$t;
  var Null = class extends BaseBlock {
    constructor(parameters = {}) {
      super(parameters, ValueBlock);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 5;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      if (this.lenBlock.length > 0)
        this.warnings.push("Non-zero length of value block for Null type");
      if (!this.idBlock.error.length)
        this.blockLength += this.idBlock.blockLength;
      if (!this.lenBlock.error.length)
        this.blockLength += this.lenBlock.blockLength;
      this.blockLength += inputLength;
      if (inputOffset + inputLength > inputBuffer.byteLength) {
        this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return -1;
      }
      return inputOffset + inputLength;
    }
    toBER(sizeOnly, writer) {
      const retBuf = new ArrayBuffer(2);
      if (!sizeOnly) {
        const retView = new Uint8Array(retBuf);
        retView[0] = 5;
        retView[1] = 0;
      }
      if (writer) {
        writer.write(retBuf);
      }
      return retBuf;
    }
    onAsciiEncoding() {
      return `${this.constructor.NAME}`;
    }
  };
  _a$t = Null;
  (() => {
    typeStore.Null = _a$t;
  })();
  Null.NAME = "NULL";
  var LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
    get value() {
      for (const octet of this.valueHexView) {
        if (octet > 0) {
          return true;
        }
      }
      return false;
    }
    set value(value2) {
      this.valueHexView[0] = value2 ? 255 : 0;
    }
    constructor({ value: value2, ...parameters } = {}) {
      super(parameters);
      if (parameters.valueHex) {
        this.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);
      } else {
        this.valueHexView = new Uint8Array(1);
      }
      if (value2) {
        this.value = value2;
      }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
        return -1;
      }
      this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
      if (inputLength > 1)
        this.warnings.push("Boolean value encoded in more then 1 octet");
      this.isHexOnly = true;
      utilDecodeTC.call(this);
      this.blockLength = inputLength;
      return inputOffset + inputLength;
    }
    toBER() {
      return this.valueHexView.slice();
    }
    toJSON() {
      return {
        ...super.toJSON(),
        value: this.value
      };
    }
  };
  LocalBooleanValueBlock.NAME = "BooleanValueBlock";
  var _a$s;
  var Boolean2 = class extends BaseBlock {
    getValue() {
      return this.valueBlock.value;
    }
    setValue(value2) {
      this.valueBlock.value = value2;
    }
    constructor(parameters = {}) {
      super(parameters, LocalBooleanValueBlock);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 1;
    }
    onAsciiEncoding() {
      return `${this.constructor.NAME} : ${this.getValue}`;
    }
  };
  _a$s = Boolean2;
  (() => {
    typeStore.Boolean = _a$s;
  })();
  Boolean2.NAME = "BOOLEAN";
  var LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
    constructor({ isConstructed = false, ...parameters } = {}) {
      super(parameters);
      this.isConstructed = isConstructed;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      let resultOffset = 0;
      if (this.isConstructed) {
        this.isHexOnly = false;
        resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1)
          return resultOffset;
        for (let i2 = 0; i2 < this.value.length; i2++) {
          const currentBlockName = this.value[i2].constructor.NAME;
          if (currentBlockName === END_OF_CONTENT_NAME) {
            if (this.isIndefiniteForm)
              break;
            else {
              this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
              return -1;
            }
          }
          if (currentBlockName !== OCTET_STRING_NAME) {
            this.error = "OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
      } else {
        this.isHexOnly = true;
        resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        this.blockLength = inputLength;
      }
      return resultOffset;
    }
    toBER(sizeOnly, writer) {
      if (this.isConstructed)
        return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
      return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isConstructed: this.isConstructed
      };
    }
  };
  LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
  var _a$r;
  var OctetString = class extends BaseBlock {
    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
      var _b2, _c;
      (_b2 = parameters.isConstructed) !== null && _b2 !== void 0 ? _b2 : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
      super({
        idBlock: {
          isConstructed: parameters.isConstructed,
          ...idBlock
        },
        lenBlock: {
          ...lenBlock,
          isIndefiniteForm: !!parameters.isIndefiniteForm
        },
        ...parameters
      }, LocalOctetStringValueBlock);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 4;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      this.valueBlock.isConstructed = this.idBlock.isConstructed;
      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
      if (inputLength === 0) {
        if (this.idBlock.error.length === 0)
          this.blockLength += this.idBlock.blockLength;
        if (this.lenBlock.error.length === 0)
          this.blockLength += this.lenBlock.blockLength;
        return inputOffset;
      }
      if (!this.valueBlock.isConstructed) {
        const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
        const buf2 = view.subarray(inputOffset, inputOffset + inputLength);
        try {
          if (buf2.byteLength) {
            const asn = localFromBER(buf2, 0, buf2.byteLength);
            if (asn.offset !== -1 && asn.offset === inputLength) {
              this.valueBlock.value = [asn.result];
            }
          }
        } catch {
        }
      }
      return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    onAsciiEncoding() {
      if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
        return Constructed.prototype.onAsciiEncoding.call(this);
      }
      const name9 = this.constructor.NAME;
      const value2 = pvtsutils.Convert.ToHex(this.valueBlock.valueHexView);
      return `${name9} : ${value2}`;
    }
    getValue() {
      if (!this.idBlock.isConstructed) {
        return this.valueBlock.valueHexView.slice().buffer;
      }
      const array = [];
      for (const content of this.valueBlock.value) {
        if (content instanceof _a$r) {
          array.push(content.valueBlock.valueHexView);
        }
      }
      return pvtsutils.BufferSourceConverter.concat(array);
    }
  };
  _a$r = OctetString;
  (() => {
    typeStore.OctetString = _a$r;
  })();
  OctetString.NAME = OCTET_STRING_NAME;
  var LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
      super(parameters);
      this.unusedBits = unusedBits;
      this.isConstructed = isConstructed;
      this.blockLength = this.valueHexView.byteLength;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      if (!inputLength) {
        return inputOffset;
      }
      let resultOffset = -1;
      if (this.isConstructed) {
        resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1)
          return resultOffset;
        for (const value2 of this.value) {
          const currentBlockName = value2.constructor.NAME;
          if (currentBlockName === END_OF_CONTENT_NAME) {
            if (this.isIndefiniteForm)
              break;
            else {
              this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
              return -1;
            }
          }
          if (currentBlockName !== BIT_STRING_NAME) {
            this.error = "BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
          const valueBlock = value2.valueBlock;
          if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
            this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
            return -1;
          }
          this.unusedBits = valueBlock.unusedBits;
        }
        return resultOffset;
      }
      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
        return -1;
      }
      const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
      this.unusedBits = intBuffer[0];
      if (this.unusedBits > 7) {
        this.error = "Unused bits for BitString must be in range 0-7";
        return -1;
      }
      if (!this.unusedBits) {
        const buf2 = intBuffer.subarray(1);
        try {
          if (buf2.byteLength) {
            const asn = localFromBER(buf2, 0, buf2.byteLength);
            if (asn.offset !== -1 && asn.offset === inputLength - 1) {
              this.value = [asn.result];
            }
          }
        } catch {
        }
      }
      this.valueHexView = intBuffer.subarray(1);
      this.blockLength = intBuffer.length;
      return inputOffset + inputLength;
    }
    toBER(sizeOnly, writer) {
      if (this.isConstructed) {
        return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength + 1);
      }
      if (!this.valueHexView.byteLength) {
        return EMPTY_BUFFER;
      }
      const retView = new Uint8Array(this.valueHexView.length + 1);
      retView[0] = this.unusedBits;
      retView.set(this.valueHexView, 1);
      return retView.buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        unusedBits: this.unusedBits,
        isConstructed: this.isConstructed
      };
    }
  };
  LocalBitStringValueBlock.NAME = "BitStringValueBlock";
  var _a$q;
  var BitString = class extends BaseBlock {
    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
      var _b2, _c;
      (_b2 = parameters.isConstructed) !== null && _b2 !== void 0 ? _b2 : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
      super({
        idBlock: {
          isConstructed: parameters.isConstructed,
          ...idBlock
        },
        lenBlock: {
          ...lenBlock,
          isIndefiniteForm: !!parameters.isIndefiniteForm
        },
        ...parameters
      }, LocalBitStringValueBlock);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 3;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      this.valueBlock.isConstructed = this.idBlock.isConstructed;
      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
      return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    onAsciiEncoding() {
      if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
        return Constructed.prototype.onAsciiEncoding.call(this);
      } else {
        const bits2 = [];
        const valueHex = this.valueBlock.valueHexView;
        for (const byte of valueHex) {
          bits2.push(byte.toString(2).padStart(8, "0"));
        }
        const bitsStr = bits2.join("");
        const name9 = this.constructor.NAME;
        const value2 = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
        return `${name9} : ${value2}`;
      }
    }
  };
  _a$q = BitString;
  (() => {
    typeStore.BitString = _a$q;
  })();
  BitString.NAME = BIT_STRING_NAME;
  var _a$p;
  function viewAdd(first2, second3) {
    const c2 = new Uint8Array([0]);
    const firstView = new Uint8Array(first2);
    const secondView = new Uint8Array(second3);
    let firstViewCopy = firstView.slice(0);
    const firstViewCopyLength = firstViewCopy.length - 1;
    const secondViewCopy = secondView.slice(0);
    const secondViewCopyLength = secondViewCopy.length - 1;
    let value2 = 0;
    const max2 = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
    let counter = 0;
    for (let i2 = max2; i2 >= 0; i2--, counter++) {
      switch (true) {
        case counter < secondViewCopy.length:
          value2 = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c2[0];
          break;
        default:
          value2 = firstViewCopy[firstViewCopyLength - counter] + c2[0];
      }
      c2[0] = value2 / 10;
      switch (true) {
        case counter >= firstViewCopy.length:
          firstViewCopy = utilConcatView(new Uint8Array([value2 % 10]), firstViewCopy);
          break;
        default:
          firstViewCopy[firstViewCopyLength - counter] = value2 % 10;
      }
    }
    if (c2[0] > 0)
      firstViewCopy = utilConcatView(c2, firstViewCopy);
    return firstViewCopy;
  }
  function power2(n2) {
    if (n2 >= powers2.length) {
      for (let p2 = powers2.length; p2 <= n2; p2++) {
        const c2 = new Uint8Array([0]);
        let digits = powers2[p2 - 1].slice(0);
        for (let i2 = digits.length - 1; i2 >= 0; i2--) {
          const newValue = new Uint8Array([(digits[i2] << 1) + c2[0]]);
          c2[0] = newValue[0] / 10;
          digits[i2] = newValue[0] % 10;
        }
        if (c2[0] > 0)
          digits = utilConcatView(c2, digits);
        powers2.push(digits);
      }
    }
    return powers2[n2];
  }
  function viewSub(first2, second3) {
    let b = 0;
    const firstView = new Uint8Array(first2);
    const secondView = new Uint8Array(second3);
    const firstViewCopy = firstView.slice(0);
    const firstViewCopyLength = firstViewCopy.length - 1;
    const secondViewCopy = secondView.slice(0);
    const secondViewCopyLength = secondViewCopy.length - 1;
    let value2;
    let counter = 0;
    for (let i2 = secondViewCopyLength; i2 >= 0; i2--, counter++) {
      value2 = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
      switch (true) {
        case value2 < 0:
          b = 1;
          firstViewCopy[firstViewCopyLength - counter] = value2 + 10;
          break;
        default:
          b = 0;
          firstViewCopy[firstViewCopyLength - counter] = value2;
      }
    }
    if (b > 0) {
      for (let i2 = firstViewCopyLength - secondViewCopyLength + 1; i2 >= 0; i2--, counter++) {
        value2 = firstViewCopy[firstViewCopyLength - counter] - b;
        if (value2 < 0) {
          b = 1;
          firstViewCopy[firstViewCopyLength - counter] = value2 + 10;
        } else {
          b = 0;
          firstViewCopy[firstViewCopyLength - counter] = value2;
          break;
        }
      }
    }
    return firstViewCopy.slice();
  }
  var LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
    setValueHex() {
      if (this.valueHexView.length >= 4) {
        this.warnings.push("Too big Integer for decoding, hex only");
        this.isHexOnly = true;
        this._valueDec = 0;
      } else {
        this.isHexOnly = false;
        if (this.valueHexView.length > 0) {
          this._valueDec = utilDecodeTC.call(this);
        }
      }
    }
    constructor({ value: value2, ...parameters } = {}) {
      super(parameters);
      this._valueDec = 0;
      if (parameters.valueHex) {
        this.setValueHex();
      }
      if (value2 !== void 0) {
        this.valueDec = value2;
      }
    }
    set valueDec(v) {
      this._valueDec = v;
      this.isHexOnly = false;
      this.valueHexView = new Uint8Array(utilEncodeTC(v));
    }
    get valueDec() {
      return this._valueDec;
    }
    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
      const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
      if (offset === -1)
        return offset;
      const view = this.valueHexView;
      if (view[0] === 0 && (view[1] & 128) !== 0) {
        this.valueHexView = view.subarray(1);
      } else {
        if (expectedLength !== 0) {
          if (view.length < expectedLength) {
            if (expectedLength - view.length > 1)
              expectedLength = view.length + 1;
            this.valueHexView = view.subarray(expectedLength - view.length);
          }
        }
      }
      return offset;
    }
    toDER(sizeOnly = false) {
      const view = this.valueHexView;
      switch (true) {
        case (view[0] & 128) !== 0:
          {
            const updatedView = new Uint8Array(this.valueHexView.length + 1);
            updatedView[0] = 0;
            updatedView.set(view, 1);
            this.valueHexView = updatedView;
          }
          break;
        case (view[0] === 0 && (view[1] & 128) === 0):
          {
            this.valueHexView = this.valueHexView.subarray(1);
          }
          break;
      }
      return this.toBER(sizeOnly);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1) {
        return resultOffset;
      }
      this.setValueHex();
      return resultOffset;
    }
    toBER(sizeOnly) {
      return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        valueDec: this.valueDec
      };
    }
    toString() {
      const firstBit = this.valueHexView.length * 8 - 1;
      let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
      let bitNumber = 0;
      let currentByte;
      const asn1View = this.valueHexView;
      let result = "";
      let flag = false;
      for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
        currentByte = asn1View[byteNumber];
        for (let i2 = 0; i2 < 8; i2++) {
          if ((currentByte & 1) === 1) {
            switch (bitNumber) {
              case firstBit:
                digits = viewSub(power2(bitNumber), digits);
                result = "-";
                break;
              default:
                digits = viewAdd(digits, power2(bitNumber));
            }
          }
          bitNumber++;
          currentByte >>= 1;
        }
      }
      for (let i2 = 0; i2 < digits.length; i2++) {
        if (digits[i2])
          flag = true;
        if (flag)
          result += digitsString.charAt(digits[i2]);
      }
      if (flag === false)
        result += digitsString.charAt(0);
      return result;
    }
  };
  _a$p = LocalIntegerValueBlock;
  LocalIntegerValueBlock.NAME = "IntegerValueBlock";
  (() => {
    Object.defineProperty(_a$p.prototype, "valueHex", {
      set: function(v) {
        this.valueHexView = new Uint8Array(v);
        this.setValueHex();
      },
      get: function() {
        return this.valueHexView.slice().buffer;
      }
    });
  })();
  var _a$o;
  var Integer = class extends BaseBlock {
    constructor(parameters = {}) {
      super(parameters, LocalIntegerValueBlock);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 2;
    }
    toBigInt() {
      assertBigInt();
      return BigInt(this.valueBlock.toString());
    }
    static fromBigInt(value2) {
      assertBigInt();
      const bigIntValue = BigInt(value2);
      const writer = new ViewWriter();
      const hex = bigIntValue.toString(16).replace(/^-/, "");
      const view = new Uint8Array(pvtsutils.Convert.FromHex(hex));
      if (bigIntValue < 0) {
        const first2 = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
        first2[0] |= 128;
        const firstInt = BigInt(`0x${pvtsutils.Convert.ToHex(first2)}`);
        const secondInt = firstInt + bigIntValue;
        const second3 = pvtsutils.BufferSourceConverter.toUint8Array(pvtsutils.Convert.FromHex(secondInt.toString(16)));
        second3[0] |= 128;
        writer.write(second3);
      } else {
        if (view[0] & 128) {
          writer.write(new Uint8Array([0]));
        }
        writer.write(view);
      }
      const res = new _a$o({ valueHex: writer.final() });
      return res;
    }
    convertToDER() {
      const integer2 = new _a$o({ valueHex: this.valueBlock.valueHexView });
      integer2.valueBlock.toDER();
      return integer2;
    }
    convertFromDER() {
      return new _a$o({
        valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
      });
    }
    onAsciiEncoding() {
      return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
    }
  };
  _a$o = Integer;
  (() => {
    typeStore.Integer = _a$o;
  })();
  Integer.NAME = "INTEGER";
  var _a$n;
  var Enumerated = class extends Integer {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 10;
    }
  };
  _a$n = Enumerated;
  (() => {
    typeStore.Enumerated = _a$n;
  })();
  Enumerated.NAME = "ENUMERATED";
  var LocalSidValueBlock = class extends HexBlock(ValueBlock) {
    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
      super(parameters);
      this.valueDec = valueDec;
      this.isFirstSid = isFirstSid;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      if (!inputLength) {
        return inputOffset;
      }
      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
        return -1;
      }
      const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
      this.valueHexView = new Uint8Array(inputLength);
      for (let i2 = 0; i2 < inputLength; i2++) {
        this.valueHexView[i2] = intBuffer[i2] & 127;
        this.blockLength++;
        if ((intBuffer[i2] & 128) === 0)
          break;
      }
      const tempView = new Uint8Array(this.blockLength);
      for (let i2 = 0; i2 < this.blockLength; i2++) {
        tempView[i2] = this.valueHexView[i2];
      }
      this.valueHexView = tempView;
      if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
        this.error = "End of input reached before message was fully decoded";
        return -1;
      }
      if (this.valueHexView[0] === 0)
        this.warnings.push("Needlessly long format of SID encoding");
      if (this.blockLength <= 8)
        this.valueDec = utilFromBase(this.valueHexView, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Too big SID for decoding, hex only");
      }
      return inputOffset + this.blockLength;
    }
    set valueBigInt(value2) {
      assertBigInt();
      let bits2 = BigInt(value2).toString(2);
      while (bits2.length % 7) {
        bits2 = "0" + bits2;
      }
      const bytes = new Uint8Array(bits2.length / 7);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        bytes[i2] = parseInt(bits2.slice(i2 * 7, i2 * 7 + 7), 2) + (i2 + 1 < bytes.length ? 128 : 0);
      }
      this.fromBER(bytes.buffer, 0, bytes.length);
    }
    toBER(sizeOnly) {
      if (this.isHexOnly) {
        if (sizeOnly)
          return new ArrayBuffer(this.valueHexView.byteLength);
        const curView = this.valueHexView;
        const retView2 = new Uint8Array(this.blockLength);
        for (let i2 = 0; i2 < this.blockLength - 1; i2++)
          retView2[i2] = curView[i2] | 128;
        retView2[this.blockLength - 1] = curView[this.blockLength - 1];
        return retView2.buffer;
      }
      const encodedBuf = utilToBase(this.valueDec, 7);
      if (encodedBuf.byteLength === 0) {
        this.error = "Error during encoding SID value";
        return EMPTY_BUFFER;
      }
      const retView = new Uint8Array(encodedBuf.byteLength);
      if (!sizeOnly) {
        const encodedView = new Uint8Array(encodedBuf);
        const len = encodedBuf.byteLength - 1;
        for (let i2 = 0; i2 < len; i2++)
          retView[i2] = encodedView[i2] | 128;
        retView[len] = encodedView[len];
      }
      return retView;
    }
    toString() {
      let result = "";
      if (this.isHexOnly)
        result = pvtsutils.Convert.ToHex(this.valueHexView);
      else {
        if (this.isFirstSid) {
          let sidValue = this.valueDec;
          if (this.valueDec <= 39)
            result = "0.";
          else {
            if (this.valueDec <= 79) {
              result = "1.";
              sidValue -= 40;
            } else {
              result = "2.";
              sidValue -= 80;
            }
          }
          result += sidValue.toString();
        } else
          result = this.valueDec.toString();
      }
      return result;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        valueDec: this.valueDec,
        isFirstSid: this.isFirstSid
      };
    }
  };
  LocalSidValueBlock.NAME = "sidBlock";
  var LocalObjectIdentifierValueBlock = class extends ValueBlock {
    constructor({ value: value2 = EMPTY_STRING, ...parameters } = {}) {
      super(parameters);
      this.value = [];
      if (value2) {
        this.fromString(value2);
      }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      let resultOffset = inputOffset;
      while (inputLength > 0) {
        const sidBlock = new LocalSidValueBlock();
        resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
        if (resultOffset === -1) {
          this.blockLength = 0;
          this.error = sidBlock.error;
          return resultOffset;
        }
        if (this.value.length === 0)
          sidBlock.isFirstSid = true;
        this.blockLength += sidBlock.blockLength;
        inputLength -= sidBlock.blockLength;
        this.value.push(sidBlock);
      }
      return resultOffset;
    }
    toBER(sizeOnly) {
      const retBuffers = [];
      for (let i2 = 0; i2 < this.value.length; i2++) {
        const valueBuf = this.value[i2].toBER(sizeOnly);
        if (valueBuf.byteLength === 0) {
          this.error = this.value[i2].error;
          return EMPTY_BUFFER;
        }
        retBuffers.push(valueBuf);
      }
      return concat3(retBuffers);
    }
    fromString(string2) {
      this.value = [];
      let pos1 = 0;
      let pos2 = 0;
      let sid = "";
      let flag = false;
      do {
        pos2 = string2.indexOf(".", pos1);
        if (pos2 === -1)
          sid = string2.substring(pos1);
        else
          sid = string2.substring(pos1, pos2);
        pos1 = pos2 + 1;
        if (flag) {
          const sidBlock = this.value[0];
          let plus = 0;
          switch (sidBlock.valueDec) {
            case 0:
              break;
            case 1:
              plus = 40;
              break;
            case 2:
              plus = 80;
              break;
            default:
              this.value = [];
              return;
          }
          const parsedSID = parseInt(sid, 10);
          if (isNaN(parsedSID))
            return;
          sidBlock.valueDec = parsedSID + plus;
          flag = false;
        } else {
          const sidBlock = new LocalSidValueBlock();
          if (sid > Number.MAX_SAFE_INTEGER) {
            assertBigInt();
            const sidValue = BigInt(sid);
            sidBlock.valueBigInt = sidValue;
          } else {
            sidBlock.valueDec = parseInt(sid, 10);
            if (isNaN(sidBlock.valueDec))
              return;
          }
          if (!this.value.length) {
            sidBlock.isFirstSid = true;
            flag = true;
          }
          this.value.push(sidBlock);
        }
      } while (pos2 !== -1);
    }
    toString() {
      let result = "";
      let isHexOnly = false;
      for (let i2 = 0; i2 < this.value.length; i2++) {
        isHexOnly = this.value[i2].isHexOnly;
        let sidStr = this.value[i2].toString();
        if (i2 !== 0)
          result = `${result}.`;
        if (isHexOnly) {
          sidStr = `{${sidStr}}`;
          if (this.value[i2].isFirstSid)
            result = `2.{${sidStr} - 80}`;
          else
            result += sidStr;
        } else
          result += sidStr;
      }
      return result;
    }
    toJSON() {
      const object = {
        ...super.toJSON(),
        value: this.toString(),
        sidArray: []
      };
      for (let i2 = 0; i2 < this.value.length; i2++) {
        object.sidArray.push(this.value[i2].toJSON());
      }
      return object;
    }
  };
  LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
  var _a$m;
  var ObjectIdentifier = class extends BaseBlock {
    getValue() {
      return this.valueBlock.toString();
    }
    setValue(value2) {
      this.valueBlock.fromString(value2);
    }
    constructor(parameters = {}) {
      super(parameters, LocalObjectIdentifierValueBlock);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 6;
    }
    onAsciiEncoding() {
      return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        value: this.getValue()
      };
    }
  };
  _a$m = ObjectIdentifier;
  (() => {
    typeStore.ObjectIdentifier = _a$m;
  })();
  ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
  var LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
    constructor({ valueDec = 0, ...parameters } = {}) {
      super(parameters);
      this.valueDec = valueDec;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      if (inputLength === 0)
        return inputOffset;
      const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      if (!checkBufferParams(this, inputView, inputOffset, inputLength))
        return -1;
      const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
      this.valueHexView = new Uint8Array(inputLength);
      for (let i2 = 0; i2 < inputLength; i2++) {
        this.valueHexView[i2] = intBuffer[i2] & 127;
        this.blockLength++;
        if ((intBuffer[i2] & 128) === 0)
          break;
      }
      const tempView = new Uint8Array(this.blockLength);
      for (let i2 = 0; i2 < this.blockLength; i2++)
        tempView[i2] = this.valueHexView[i2];
      this.valueHexView = tempView;
      if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
        this.error = "End of input reached before message was fully decoded";
        return -1;
      }
      if (this.valueHexView[0] === 0)
        this.warnings.push("Needlessly long format of SID encoding");
      if (this.blockLength <= 8)
        this.valueDec = utilFromBase(this.valueHexView, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Too big SID for decoding, hex only");
      }
      return inputOffset + this.blockLength;
    }
    toBER(sizeOnly) {
      if (this.isHexOnly) {
        if (sizeOnly)
          return new ArrayBuffer(this.valueHexView.byteLength);
        const curView = this.valueHexView;
        const retView2 = new Uint8Array(this.blockLength);
        for (let i2 = 0; i2 < this.blockLength - 1; i2++)
          retView2[i2] = curView[i2] | 128;
        retView2[this.blockLength - 1] = curView[this.blockLength - 1];
        return retView2.buffer;
      }
      const encodedBuf = utilToBase(this.valueDec, 7);
      if (encodedBuf.byteLength === 0) {
        this.error = "Error during encoding SID value";
        return EMPTY_BUFFER;
      }
      const retView = new Uint8Array(encodedBuf.byteLength);
      if (!sizeOnly) {
        const encodedView = new Uint8Array(encodedBuf);
        const len = encodedBuf.byteLength - 1;
        for (let i2 = 0; i2 < len; i2++)
          retView[i2] = encodedView[i2] | 128;
        retView[len] = encodedView[len];
      }
      return retView.buffer;
    }
    toString() {
      let result = "";
      if (this.isHexOnly)
        result = pvtsutils.Convert.ToHex(this.valueHexView);
      else {
        result = this.valueDec.toString();
      }
      return result;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        valueDec: this.valueDec
      };
    }
  };
  LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
  var LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
    constructor({ value: value2 = EMPTY_STRING, ...parameters } = {}) {
      super(parameters);
      this.value = [];
      if (value2) {
        this.fromString(value2);
      }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      let resultOffset = inputOffset;
      while (inputLength > 0) {
        const sidBlock = new LocalRelativeSidValueBlock();
        resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
        if (resultOffset === -1) {
          this.blockLength = 0;
          this.error = sidBlock.error;
          return resultOffset;
        }
        this.blockLength += sidBlock.blockLength;
        inputLength -= sidBlock.blockLength;
        this.value.push(sidBlock);
      }
      return resultOffset;
    }
    toBER(sizeOnly, _writer) {
      const retBuffers = [];
      for (let i2 = 0; i2 < this.value.length; i2++) {
        const valueBuf = this.value[i2].toBER(sizeOnly);
        if (valueBuf.byteLength === 0) {
          this.error = this.value[i2].error;
          return EMPTY_BUFFER;
        }
        retBuffers.push(valueBuf);
      }
      return concat3(retBuffers);
    }
    fromString(string2) {
      this.value = [];
      let pos1 = 0;
      let pos2 = 0;
      let sid = "";
      do {
        pos2 = string2.indexOf(".", pos1);
        if (pos2 === -1)
          sid = string2.substring(pos1);
        else
          sid = string2.substring(pos1, pos2);
        pos1 = pos2 + 1;
        const sidBlock = new LocalRelativeSidValueBlock();
        sidBlock.valueDec = parseInt(sid, 10);
        if (isNaN(sidBlock.valueDec))
          return true;
        this.value.push(sidBlock);
      } while (pos2 !== -1);
      return true;
    }
    toString() {
      let result = "";
      let isHexOnly = false;
      for (let i2 = 0; i2 < this.value.length; i2++) {
        isHexOnly = this.value[i2].isHexOnly;
        let sidStr = this.value[i2].toString();
        if (i2 !== 0)
          result = `${result}.`;
        if (isHexOnly) {
          sidStr = `{${sidStr}}`;
          result += sidStr;
        } else
          result += sidStr;
      }
      return result;
    }
    toJSON() {
      const object = {
        ...super.toJSON(),
        value: this.toString(),
        sidArray: []
      };
      for (let i2 = 0; i2 < this.value.length; i2++)
        object.sidArray.push(this.value[i2].toJSON());
      return object;
    }
  };
  LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
  var _a$l;
  var RelativeObjectIdentifier = class extends BaseBlock {
    getValue() {
      return this.valueBlock.toString();
    }
    setValue(value2) {
      this.valueBlock.fromString(value2);
    }
    constructor(parameters = {}) {
      super(parameters, LocalRelativeObjectIdentifierValueBlock);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 13;
    }
    onAsciiEncoding() {
      return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        value: this.getValue()
      };
    }
  };
  _a$l = RelativeObjectIdentifier;
  (() => {
    typeStore.RelativeObjectIdentifier = _a$l;
  })();
  RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
  var _a$k;
  var Sequence = class extends Constructed {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 16;
    }
  };
  _a$k = Sequence;
  (() => {
    typeStore.Sequence = _a$k;
  })();
  Sequence.NAME = "SEQUENCE";
  var _a$j;
  var Set2 = class extends Constructed {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 17;
    }
  };
  _a$j = Set2;
  (() => {
    typeStore.Set = _a$j;
  })();
  Set2.NAME = "SET";
  var LocalStringValueBlock = class extends HexBlock(ValueBlock) {
    constructor({ ...parameters } = {}) {
      super(parameters);
      this.isHexOnly = true;
      this.value = EMPTY_STRING;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        value: this.value
      };
    }
  };
  LocalStringValueBlock.NAME = "StringValueBlock";
  var LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
  };
  LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
  var LocalSimpleStringBlock = class extends BaseStringBlock {
    constructor({ ...parameters } = {}) {
      super(parameters, LocalSimpleStringValueBlock);
    }
    fromBuffer(inputBuffer) {
      this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));
    }
    fromString(inputString) {
      const strLen = inputString.length;
      const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
      for (let i2 = 0; i2 < strLen; i2++)
        view[i2] = inputString.charCodeAt(i2);
      this.valueBlock.value = inputString;
    }
  };
  LocalSimpleStringBlock.NAME = "SIMPLE STRING";
  var LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
      this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
      try {
        this.valueBlock.value = pvtsutils.Convert.ToUtf8String(inputBuffer);
      } catch (ex) {
        this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
        this.valueBlock.value = pvtsutils.Convert.ToBinary(inputBuffer);
      }
    }
    fromString(inputString) {
      this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf8String(inputString));
      this.valueBlock.value = inputString;
    }
  };
  LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
  var _a$i;
  var Utf8String = class extends LocalUtf8StringValueBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 12;
    }
  };
  _a$i = Utf8String;
  (() => {
    typeStore.Utf8String = _a$i;
  })();
  Utf8String.NAME = "UTF8String";
  var LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
      this.valueBlock.value = pvtsutils.Convert.ToUtf16String(inputBuffer);
      this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);
    }
    fromString(inputString) {
      this.valueBlock.value = inputString;
      this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf16String(inputString));
    }
  };
  LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
  var _a$h;
  var BmpString = class extends LocalBmpStringValueBlock {
    constructor({ ...parameters } = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 30;
    }
  };
  _a$h = BmpString;
  (() => {
    typeStore.BmpString = _a$h;
  })();
  BmpString.NAME = "BMPString";
  var LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
      const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
      const valueView = new Uint8Array(copyBuffer);
      for (let i2 = 0; i2 < valueView.length; i2 += 4) {
        valueView[i2] = valueView[i2 + 3];
        valueView[i2 + 1] = valueView[i2 + 2];
        valueView[i2 + 2] = 0;
        valueView[i2 + 3] = 0;
      }
      this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
    }
    fromString(inputString) {
      const strLength = inputString.length;
      const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
      for (let i2 = 0; i2 < strLength; i2++) {
        const codeBuf = utilToBase(inputString.charCodeAt(i2), 8);
        const codeView = new Uint8Array(codeBuf);
        if (codeView.length > 4)
          continue;
        const dif = 4 - codeView.length;
        for (let j = codeView.length - 1; j >= 0; j--)
          valueHexView[i2 * 4 + j + dif] = codeView[j];
      }
      this.valueBlock.value = inputString;
    }
  };
  LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
  var _a$g;
  var UniversalString = class extends LocalUniversalStringValueBlock {
    constructor({ ...parameters } = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 28;
    }
  };
  _a$g = UniversalString;
  (() => {
    typeStore.UniversalString = _a$g;
  })();
  UniversalString.NAME = "UniversalString";
  var _a$f;
  var NumericString = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 18;
    }
  };
  _a$f = NumericString;
  (() => {
    typeStore.NumericString = _a$f;
  })();
  NumericString.NAME = "NumericString";
  var _a$e;
  var PrintableString = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 19;
    }
  };
  _a$e = PrintableString;
  (() => {
    typeStore.PrintableString = _a$e;
  })();
  PrintableString.NAME = "PrintableString";
  var _a$d;
  var TeletexString = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 20;
    }
  };
  _a$d = TeletexString;
  (() => {
    typeStore.TeletexString = _a$d;
  })();
  TeletexString.NAME = "TeletexString";
  var _a$c;
  var VideotexString = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 21;
    }
  };
  _a$c = VideotexString;
  (() => {
    typeStore.VideotexString = _a$c;
  })();
  VideotexString.NAME = "VideotexString";
  var _a$b;
  var IA5String = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 22;
    }
  };
  _a$b = IA5String;
  (() => {
    typeStore.IA5String = _a$b;
  })();
  IA5String.NAME = "IA5String";
  var _a$a;
  var GraphicString = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 25;
    }
  };
  _a$a = GraphicString;
  (() => {
    typeStore.GraphicString = _a$a;
  })();
  GraphicString.NAME = "GraphicString";
  var _a$9;
  var VisibleString = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 26;
    }
  };
  _a$9 = VisibleString;
  (() => {
    typeStore.VisibleString = _a$9;
  })();
  VisibleString.NAME = "VisibleString";
  var _a$8;
  var GeneralString = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 27;
    }
  };
  _a$8 = GeneralString;
  (() => {
    typeStore.GeneralString = _a$8;
  })();
  GeneralString.NAME = "GeneralString";
  var _a$7;
  var CharacterString = class extends LocalSimpleStringBlock {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 29;
    }
  };
  _a$7 = CharacterString;
  (() => {
    typeStore.CharacterString = _a$7;
  })();
  CharacterString.NAME = "CharacterString";
  var _a$6;
  var UTCTime = class extends VisibleString {
    constructor({ value: value2, valueDate, ...parameters } = {}) {
      super(parameters);
      this.year = 0;
      this.month = 0;
      this.day = 0;
      this.hour = 0;
      this.minute = 0;
      this.second = 0;
      if (value2) {
        this.fromString(value2);
        this.valueBlock.valueHexView = new Uint8Array(value2.length);
        for (let i2 = 0; i2 < value2.length; i2++)
          this.valueBlock.valueHexView[i2] = value2.charCodeAt(i2);
      }
      if (valueDate) {
        this.fromDate(valueDate);
        this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
      }
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 23;
    }
    fromBuffer(inputBuffer) {
      this.fromString(String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));
    }
    toBuffer() {
      const str = this.toString();
      const buffer2 = new ArrayBuffer(str.length);
      const view = new Uint8Array(buffer2);
      for (let i2 = 0; i2 < str.length; i2++)
        view[i2] = str.charCodeAt(i2);
      return buffer2;
    }
    fromDate(inputDate) {
      this.year = inputDate.getUTCFullYear();
      this.month = inputDate.getUTCMonth() + 1;
      this.day = inputDate.getUTCDate();
      this.hour = inputDate.getUTCHours();
      this.minute = inputDate.getUTCMinutes();
      this.second = inputDate.getUTCSeconds();
    }
    toDate() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
    }
    fromString(inputString) {
      const parser2 = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
      const parserArray = parser2.exec(inputString);
      if (parserArray === null) {
        this.error = "Wrong input string for conversion";
        return;
      }
      const year = parseInt(parserArray[1], 10);
      if (year >= 50)
        this.year = 1900 + year;
      else
        this.year = 2e3 + year;
      this.month = parseInt(parserArray[2], 10);
      this.day = parseInt(parserArray[3], 10);
      this.hour = parseInt(parserArray[4], 10);
      this.minute = parseInt(parserArray[5], 10);
      this.second = parseInt(parserArray[6], 10);
    }
    toString(encoding = "iso") {
      if (encoding === "iso") {
        const outputArray = new Array(7);
        outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
        outputArray[1] = padNumber(this.month, 2);
        outputArray[2] = padNumber(this.day, 2);
        outputArray[3] = padNumber(this.hour, 2);
        outputArray[4] = padNumber(this.minute, 2);
        outputArray[5] = padNumber(this.second, 2);
        outputArray[6] = "Z";
        return outputArray.join("");
      }
      return super.toString(encoding);
    }
    onAsciiEncoding() {
      return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        year: this.year,
        month: this.month,
        day: this.day,
        hour: this.hour,
        minute: this.minute,
        second: this.second
      };
    }
  };
  _a$6 = UTCTime;
  (() => {
    typeStore.UTCTime = _a$6;
  })();
  UTCTime.NAME = "UTCTime";
  var _a$5;
  var GeneralizedTime = class extends UTCTime {
    constructor(parameters = {}) {
      var _b2;
      super(parameters);
      (_b2 = this.millisecond) !== null && _b2 !== void 0 ? _b2 : this.millisecond = 0;
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 24;
    }
    fromDate(inputDate) {
      super.fromDate(inputDate);
      this.millisecond = inputDate.getUTCMilliseconds();
    }
    toDate() {
      const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
      return new Date(utcDate);
    }
    fromString(inputString) {
      let isUTC = false;
      let timeString = "";
      let dateTimeString = "";
      let fractionPart = 0;
      let parser2;
      let hourDifference = 0;
      let minuteDifference = 0;
      if (inputString[inputString.length - 1] === "Z") {
        timeString = inputString.substring(0, inputString.length - 1);
        isUTC = true;
      } else {
        const number = new Number(inputString[inputString.length - 1]);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        timeString = inputString;
      }
      if (isUTC) {
        if (timeString.indexOf("+") !== -1)
          throw new Error("Wrong input string for conversion");
        if (timeString.indexOf("-") !== -1)
          throw new Error("Wrong input string for conversion");
      } else {
        let multiplier = 1;
        let differencePosition = timeString.indexOf("+");
        let differenceString = "";
        if (differencePosition === -1) {
          differencePosition = timeString.indexOf("-");
          multiplier = -1;
        }
        if (differencePosition !== -1) {
          differenceString = timeString.substring(differencePosition + 1);
          timeString = timeString.substring(0, differencePosition);
          if (differenceString.length !== 2 && differenceString.length !== 4)
            throw new Error("Wrong input string for conversion");
          let number = parseInt(differenceString.substring(0, 2), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          hourDifference = multiplier * number;
          if (differenceString.length === 4) {
            number = parseInt(differenceString.substring(2, 4), 10);
            if (isNaN(number.valueOf()))
              throw new Error("Wrong input string for conversion");
            minuteDifference = multiplier * number;
          }
        }
      }
      let fractionPointPosition = timeString.indexOf(".");
      if (fractionPointPosition === -1)
        fractionPointPosition = timeString.indexOf(",");
      if (fractionPointPosition !== -1) {
        const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
        if (isNaN(fractionPartCheck.valueOf()))
          throw new Error("Wrong input string for conversion");
        fractionPart = fractionPartCheck.valueOf();
        dateTimeString = timeString.substring(0, fractionPointPosition);
      } else
        dateTimeString = timeString;
      switch (true) {
        case dateTimeString.length === 8:
          parser2 = /(\d{4})(\d{2})(\d{2})/ig;
          if (fractionPointPosition !== -1)
            throw new Error("Wrong input string for conversion");
          break;
        case dateTimeString.length === 10:
          parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
          if (fractionPointPosition !== -1) {
            let fractionResult = 60 * fractionPart;
            this.minute = Math.floor(fractionResult);
            fractionResult = 60 * (fractionResult - this.minute);
            this.second = Math.floor(fractionResult);
            fractionResult = 1e3 * (fractionResult - this.second);
            this.millisecond = Math.floor(fractionResult);
          }
          break;
        case dateTimeString.length === 12:
          parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
          if (fractionPointPosition !== -1) {
            let fractionResult = 60 * fractionPart;
            this.second = Math.floor(fractionResult);
            fractionResult = 1e3 * (fractionResult - this.second);
            this.millisecond = Math.floor(fractionResult);
          }
          break;
        case dateTimeString.length === 14:
          parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
          if (fractionPointPosition !== -1) {
            const fractionResult = 1e3 * fractionPart;
            this.millisecond = Math.floor(fractionResult);
          }
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
      const parserArray = parser2.exec(dateTimeString);
      if (parserArray === null)
        throw new Error("Wrong input string for conversion");
      for (let j = 1; j < parserArray.length; j++) {
        switch (j) {
          case 1:
            this.year = parseInt(parserArray[j], 10);
            break;
          case 2:
            this.month = parseInt(parserArray[j], 10);
            break;
          case 3:
            this.day = parseInt(parserArray[j], 10);
            break;
          case 4:
            this.hour = parseInt(parserArray[j], 10) + hourDifference;
            break;
          case 5:
            this.minute = parseInt(parserArray[j], 10) + minuteDifference;
            break;
          case 6:
            this.second = parseInt(parserArray[j], 10);
            break;
          default:
            throw new Error("Wrong input string for conversion");
        }
      }
      if (isUTC === false) {
        const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
        this.year = tempDate.getUTCFullYear();
        this.month = tempDate.getUTCMonth();
        this.day = tempDate.getUTCDay();
        this.hour = tempDate.getUTCHours();
        this.minute = tempDate.getUTCMinutes();
        this.second = tempDate.getUTCSeconds();
        this.millisecond = tempDate.getUTCMilliseconds();
      }
    }
    toString(encoding = "iso") {
      if (encoding === "iso") {
        const outputArray = [];
        outputArray.push(padNumber(this.year, 4));
        outputArray.push(padNumber(this.month, 2));
        outputArray.push(padNumber(this.day, 2));
        outputArray.push(padNumber(this.hour, 2));
        outputArray.push(padNumber(this.minute, 2));
        outputArray.push(padNumber(this.second, 2));
        if (this.millisecond !== 0) {
          outputArray.push(".");
          outputArray.push(padNumber(this.millisecond, 3));
        }
        outputArray.push("Z");
        return outputArray.join("");
      }
      return super.toString(encoding);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        millisecond: this.millisecond
      };
    }
  };
  _a$5 = GeneralizedTime;
  (() => {
    typeStore.GeneralizedTime = _a$5;
  })();
  GeneralizedTime.NAME = "GeneralizedTime";
  var _a$4;
  var DATE = class extends Utf8String {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 31;
    }
  };
  _a$4 = DATE;
  (() => {
    typeStore.DATE = _a$4;
  })();
  DATE.NAME = "DATE";
  var _a$3;
  var TimeOfDay = class extends Utf8String {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 32;
    }
  };
  _a$3 = TimeOfDay;
  (() => {
    typeStore.TimeOfDay = _a$3;
  })();
  TimeOfDay.NAME = "TimeOfDay";
  var _a$2;
  var DateTime = class extends Utf8String {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 33;
    }
  };
  _a$2 = DateTime;
  (() => {
    typeStore.DateTime = _a$2;
  })();
  DateTime.NAME = "DateTime";
  var _a$1;
  var Duration = class extends Utf8String {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 34;
    }
  };
  _a$1 = Duration;
  (() => {
    typeStore.Duration = _a$1;
  })();
  Duration.NAME = "Duration";
  var _a;
  var TIME = class extends Utf8String {
    constructor(parameters = {}) {
      super(parameters);
      this.idBlock.tagClass = 1;
      this.idBlock.tagNumber = 14;
    }
  };
  _a = TIME;
  (() => {
    typeStore.TIME = _a;
  })();
  TIME.NAME = "TIME";
  var Any = class {
    constructor({ name: name9 = EMPTY_STRING, optional: optional2 = false } = {}) {
      this.name = name9;
      this.optional = optional2;
    }
  };
  var Choice = class extends Any {
    constructor({ value: value2 = [], ...parameters } = {}) {
      super(parameters);
      this.value = value2;
    }
  };
  var Repeated = class extends Any {
    constructor({ value: value2 = new Any(), local = false, ...parameters } = {}) {
      super(parameters);
      this.value = value2;
      this.local = local;
    }
  };
  var RawData = class {
    get data() {
      return this.dataView.slice().buffer;
    }
    set data(value2) {
      this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(value2);
    }
    constructor({ data = EMPTY_VIEW } = {}) {
      this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(data);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const endLength = inputOffset + inputLength;
      this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
      return endLength;
    }
    toBER(_sizeOnly) {
      return this.dataView.slice().buffer;
    }
  };
  function compareSchema(root, inputData, inputSchema) {
    if (inputSchema instanceof Choice) {
      for (const element of inputSchema.value) {
        const result = compareSchema(root, inputData, element);
        if (result.verified) {
          return {
            verified: true,
            result: root
          };
        }
      }
      {
        const _result = {
          verified: false,
          result: { error: "Wrong values for Choice type" }
        };
        if (inputSchema.hasOwnProperty(NAME))
          _result.name = inputSchema.name;
        return _result;
      }
    }
    if (inputSchema instanceof Any) {
      if (inputSchema.hasOwnProperty(NAME))
        root[inputSchema.name] = inputData;
      return {
        verified: true,
        result: root
      };
    }
    if (root instanceof Object === false) {
      return {
        verified: false,
        result: { error: "Wrong root object" }
      };
    }
    if (inputData instanceof Object === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 data" }
      };
    }
    if (inputSchema instanceof Object === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    if (ID_BLOCK in inputSchema === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    if (FROM_BER in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    if (TO_BER in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const encodedId = inputSchema.idBlock.toBER(false);
    if (encodedId.byteLength === 0) {
      return {
        verified: false,
        result: { error: "Error encoding idBlock for ASN.1 schema" }
      };
    }
    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
    if (decodedOffset === -1) {
      return {
        verified: false,
        result: { error: "Error decoding idBlock for ASN.1 schema" }
      };
    }
    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
      return {
        verified: false,
        result: root
      };
    }
    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
      return {
        verified: false,
        result: root
      };
    }
    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
      return {
        verified: false,
        result: root
      };
    }
    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
      return {
        verified: false,
        result: root
      };
    }
    if (inputSchema.idBlock.isHexOnly) {
      if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      const schemaView = inputSchema.idBlock.valueHexView;
      const asn1View = inputData.idBlock.valueHexView;
      if (schemaView.length !== asn1View.length) {
        return {
          verified: false,
          result: root
        };
      }
      for (let i2 = 0; i2 < schemaView.length; i2++) {
        if (schemaView[i2] !== asn1View[1]) {
          return {
            verified: false,
            result: root
          };
        }
      }
    }
    if (inputSchema.name) {
      inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
      if (inputSchema.name)
        root[inputSchema.name] = inputData;
    }
    if (inputSchema instanceof typeStore.Constructed) {
      let admission = 0;
      let result = {
        verified: false,
        result: { error: "Unknown error" }
      };
      let maxLength = inputSchema.valueBlock.value.length;
      if (maxLength > 0) {
        if (inputSchema.valueBlock.value[0] instanceof Repeated) {
          maxLength = inputData.valueBlock.value.length;
        }
      }
      if (maxLength === 0) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
        let _optional = true;
        for (let i2 = 0; i2 < inputSchema.valueBlock.value.length; i2++)
          _optional = _optional && (inputSchema.valueBlock.value[i2].optional || false);
        if (_optional) {
          return {
            verified: true,
            result: root
          };
        }
        if (inputSchema.name) {
          inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
          if (inputSchema.name)
            delete root[inputSchema.name];
        }
        root.error = "Inconsistent object length";
        return {
          verified: false,
          result: root
        };
      }
      for (let i2 = 0; i2 < maxLength; i2++) {
        if (i2 - admission >= inputData.valueBlock.value.length) {
          if (inputSchema.valueBlock.value[i2].optional === false) {
            const _result = {
              verified: false,
              result: root
            };
            root.error = "Inconsistent length between ASN.1 data and schema";
            if (inputSchema.name) {
              inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
              if (inputSchema.name) {
                delete root[inputSchema.name];
                _result.name = inputSchema.name;
              }
            }
            return _result;
          }
        } else {
          if (inputSchema.valueBlock.value[0] instanceof Repeated) {
            result = compareSchema(root, inputData.valueBlock.value[i2], inputSchema.valueBlock.value[0].value);
            if (result.verified === false) {
              if (inputSchema.valueBlock.value[0].optional)
                admission++;
              else {
                if (inputSchema.name) {
                  inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                  if (inputSchema.name)
                    delete root[inputSchema.name];
                }
                return result;
              }
            }
            if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
              let arrayRoot = {};
              if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
                arrayRoot = inputData;
              else
                arrayRoot = root;
              if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
                arrayRoot[inputSchema.valueBlock.value[0].name] = [];
              arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i2]);
            }
          } else {
            result = compareSchema(root, inputData.valueBlock.value[i2 - admission], inputSchema.valueBlock.value[i2]);
            if (result.verified === false) {
              if (inputSchema.valueBlock.value[i2].optional)
                admission++;
              else {
                if (inputSchema.name) {
                  inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                  if (inputSchema.name)
                    delete root[inputSchema.name];
                }
                return result;
              }
            }
          }
        }
      }
      if (result.verified === false) {
        const _result = {
          verified: false,
          result: root
        };
        if (inputSchema.name) {
          inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
          if (inputSchema.name) {
            delete root[inputSchema.name];
            _result.name = inputSchema.name;
          }
        }
        return _result;
      }
      return {
        verified: true,
        result: root
      };
    }
    if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
      const asn1 = localFromBER(inputData.valueBlock.valueHexView);
      if (asn1.offset === -1) {
        const _result = {
          verified: false,
          result: asn1.result
        };
        if (inputSchema.name) {
          inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
          if (inputSchema.name) {
            delete root[inputSchema.name];
            _result.name = inputSchema.name;
          }
        }
        return _result;
      }
      return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
    }
    return {
      verified: true,
      result: root
    };
  }
  function verifySchema(inputBuffer, inputSchema) {
    if (inputSchema instanceof Object === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema type" }
      };
    }
    const asn1 = localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));
    if (asn1.offset === -1) {
      return {
        verified: false,
        result: asn1.result
      };
    }
    return compareSchema(asn1.result, asn1.result, inputSchema);
  }

  // node_modules/@libp2p/keychain/dist/src/utils/constants.js
  var SALT_LENGTH = 16;
  var KEY_SIZE = 32;
  var ITERATIONS = 1e4;

  // node_modules/@libp2p/keychain/dist/src/utils/export.js
  async function exporter(privateKey, password) {
    const cipher = aes_gcm_browser_exports.create();
    const encryptedKey = await cipher.encrypt(privateKey, password);
    return base64.encode(encryptedKey);
  }
  async function exportPrivateKey(key, password, format3) {
    if (key.type === "RSA") {
      return exportRSAPrivateKey(key, password, format3);
    }
    if (key.type === "Ed25519") {
      return exportEd25519PrivateKey(key, password, format3);
    }
    if (key.type === "secp256k1") {
      return exportSecp256k1PrivateKey(key, password, format3);
    }
    if (key.type === "ECDSA") {
      return exportECDSAPrivateKey(key, password, format3);
    }
    throw new UnsupportedKeyTypeError();
  }
  async function exportEd25519PrivateKey(key, password, format3 = "libp2p-key") {
    if (format3 === "libp2p-key") {
      return exporter(privateKeyToProtobuf(key), password);
    } else {
      throw new InvalidParametersError(`export format '${format3}' is not supported`);
    }
  }
  async function exportSecp256k1PrivateKey(key, password, format3 = "libp2p-key") {
    if (format3 === "libp2p-key") {
      return exporter(privateKeyToProtobuf(key), password);
    } else {
      throw new InvalidParametersError("Export format is not supported");
    }
  }
  async function exportECDSAPrivateKey(key, password, format3 = "libp2p-key") {
    if (format3 === "libp2p-key") {
      return exporter(privateKeyToProtobuf(key), password);
    } else {
      throw new InvalidParametersError(`export format '${format3}' is not supported`);
    }
  }
  async function exportRSAPrivateKey(key, password, format3 = "pkcs-8") {
    if (format3 === "pkcs-8") {
      return exportToPem(key, password);
    } else if (format3 === "libp2p-key") {
      return exporter(privateKeyToProtobuf(key), password);
    } else {
      throw new InvalidParametersError("Export format is not supported");
    }
  }
  async function exportToPem(privateKey, password) {
    const crypto2 = webcrypto_default.get();
    const keyWrapper = new Sequence({
      value: [
        // version (0)
        new Integer({ value: 0 }),
        // privateKeyAlgorithm
        new Sequence({
          value: [
            // rsaEncryption OID
            new ObjectIdentifier({
              value: "1.2.840.113549.1.1.1"
            }),
            new Null()
          ]
        }),
        // PrivateKey
        new OctetString({
          valueHex: privateKey.raw
        })
      ]
    });
    const keyBuf = keyWrapper.toBER();
    const keyArr = new Uint8Array(keyBuf, 0, keyBuf.byteLength);
    const salt = randomBytes2(SALT_LENGTH);
    const encryptionKey = await pbkdf2Async(sha5122, password, salt, {
      c: ITERATIONS,
      dkLen: KEY_SIZE
    });
    const iv = randomBytes2(16);
    const cryptoKey = await crypto2.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["encrypt"]);
    const encrypted = await crypto2.subtle.encrypt({
      name: "AES-CBC",
      iv
    }, cryptoKey, keyArr);
    const pbkdf2Params = new Sequence({
      value: [
        // salt
        new OctetString({ valueHex: salt }),
        // iteration count
        new Integer({ value: ITERATIONS }),
        // key length
        new Integer({ value: KEY_SIZE }),
        // AlgorithmIdentifier
        new Sequence({
          value: [
            // hmacWithSHA512
            new ObjectIdentifier({ value: "1.2.840.113549.2.11" }),
            new Null()
          ]
        })
      ]
    });
    const encryptionAlgorithm = new Sequence({
      value: [
        // pkcs5PBES2
        new ObjectIdentifier({
          value: "1.2.840.113549.1.5.13"
        }),
        new Sequence({
          value: [
            // keyDerivationFunc
            new Sequence({
              value: [
                // pkcs5PBKDF2
                new ObjectIdentifier({
                  value: "1.2.840.113549.1.5.12"
                }),
                // PBKDF2-params
                pbkdf2Params
              ]
            }),
            // encryptionScheme
            new Sequence({
              value: [
                // aes256-CBC
                new ObjectIdentifier({
                  value: "2.16.840.1.101.3.4.1.42"
                }),
                // iv
                new OctetString({
                  valueHex: iv
                })
              ]
            })
          ]
        })
      ]
    });
    const finalWrapper = new Sequence({
      value: [
        encryptionAlgorithm,
        new OctetString({ valueHex: encrypted })
      ]
    });
    const finalWrapperBuf = finalWrapper.toBER();
    const finalWrapperArr = new Uint8Array(finalWrapperBuf, 0, finalWrapperBuf.byteLength);
    return [
      "-----BEGIN ENCRYPTED PRIVATE KEY-----",
      ...toString2(finalWrapperArr, "base64pad").split(/(.{64})/).filter(Boolean),
      "-----END ENCRYPTED PRIVATE KEY-----"
    ].join("\n");
  }

  // node_modules/@libp2p/keychain/dist/src/utils/import.js
  async function importPrivateKey(encryptedKey, password) {
    try {
      const key = await importer(encryptedKey, password);
      return privateKeyFromProtobuf(key);
    } catch {
    }
    if (!encryptedKey.includes("BEGIN")) {
      throw new InvalidParametersError("Encrypted key was not a libp2p-key or a PEM file");
    }
    return importFromPem(encryptedKey, password);
  }
  async function importer(privateKey, password) {
    const encryptedKey = base64.decode(privateKey);
    const cipher = aes_gcm_browser_exports.create();
    return cipher.decrypt(encryptedKey, password);
  }
  async function importFromPem(pem, password) {
    const crypto2 = webcrypto_default.get();
    let plaintext;
    if (pem.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")) {
      const key2 = fromString2(pem.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----", "").replace("-----END ENCRYPTED PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
      const { result } = fromBER(key2);
      const { iv, salt, iterations, keySize, cipherText } = findEncryptedPEMData(result);
      const encryptionKey = await pbkdf2Async(sha5122, password, salt, {
        c: iterations,
        dkLen: keySize
      });
      const cryptoKey = await crypto2.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["decrypt"]);
      const decrypted = toUint8Array(await crypto2.subtle.decrypt({
        name: "AES-CBC",
        iv
      }, cryptoKey, cipherText));
      const { result: decryptedResult } = fromBER(decrypted);
      plaintext = findPEMData(decryptedResult);
    } else if (pem.includes("-----BEGIN PRIVATE KEY-----")) {
      const key2 = fromString2(pem.replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
      const { result } = fromBER(key2);
      plaintext = findPEMData(result);
    } else {
      throw new InvalidParametersError("Could not parse private key from PEM data");
    }
    const key = privateKeyFromRaw(plaintext);
    if (key.type !== "RSA") {
      throw new InvalidParametersError("Could not parse RSA private key from PEM data");
    }
    return key;
  }
  function findEncryptedPEMData(root) {
    const encryptionAlgorithm = root.valueBlock.value[0];
    const scheme = encryptionAlgorithm.valueBlock.value[0].toString();
    if (scheme !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.13") {
      throw new InvalidParametersError("Only pkcs5PBES2 encrypted private keys are supported");
    }
    const keyDerivationFunc = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[0];
    const keyDerivationFuncName = keyDerivationFunc.valueBlock.value[0].toString();
    if (keyDerivationFuncName !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.12") {
      throw new InvalidParametersError("Only pkcs5PBKDF2 key derivation functions are supported");
    }
    const pbkdf2Params = keyDerivationFunc.valueBlock.value[1];
    const salt = toUint8Array(pbkdf2Params.valueBlock.value[0].getValue());
    let iterations = ITERATIONS;
    let keySize = KEY_SIZE;
    if (pbkdf2Params.valueBlock.value.length === 3) {
      iterations = Number(pbkdf2Params.valueBlock.value[1].toBigInt());
      keySize = Number(pbkdf2Params.valueBlock.value[2].toBigInt());
    } else if (pbkdf2Params.valueBlock.value.length === 2) {
      throw new InvalidParametersError("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key");
    }
    const encryptionScheme = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[1];
    const encryptionSchemeName = encryptionScheme.valueBlock.value[0].toString();
    if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.2.840.113549.3.7") {
    } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.3.14.3.2.7") {
    } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2") {
    } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22") {
    } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42") {
    } else {
      throw new InvalidParametersError("Only AES-CBC encryption schemes are supported");
    }
    const iv = toUint8Array(encryptionScheme.valueBlock.value[1].getValue());
    return {
      cipherText: toUint8Array(root.valueBlock.value[1].getValue()),
      salt,
      iterations,
      keySize,
      iv
    };
  }
  function findPEMData(seq) {
    return toUint8Array(seq.valueBlock.value[2].getValue());
  }
  function toUint8Array(buf2) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }

  // node_modules/@libp2p/keychain/dist/src/keychain.js
  var keyPrefix = "/pkcs8/";
  var infoPrefix = "/info/";
  var privates = /* @__PURE__ */ new WeakMap();
  var NIST = {
    minKeyLength: 112 / 8,
    minSaltLength: 128 / 8,
    minIterationCount: 1e3
  };
  function validateKeyName(name9) {
    if (name9 == null) {
      return false;
    }
    if (typeof name9 !== "string") {
      return false;
    }
    return name9 === (0, import_sanitize_filename.default)(name9.trim()) && name9.length > 0;
  }
  async function randomDelay() {
    const min = 200;
    const max2 = 1e3;
    const delay3 = Math.random() * (max2 - min) + min;
    await new Promise((resolve8) => setTimeout(resolve8, delay3));
  }
  function DsName(name9) {
    return new Key(keyPrefix + name9);
  }
  function DsInfoName(name9) {
    return new Key(infoPrefix + name9);
  }
  async function keyId(key) {
    const pb = privateKeyToProtobuf(key);
    const hash = await sha256.digest(pb);
    return base58btc.encode(hash.bytes).substring(1);
  }
  var Keychain = class {
    components;
    init;
    log;
    self;
    /**
     * Creates a new instance of a key chain
     */
    constructor(components, init) {
      this.components = components;
      this.log = components.logger.forComponent("libp2p:keychain");
      this.init = {
        ...init,
        dek: {
          ...DEK_INIT,
          ...init.dek
        }
      };
      this.self = init.selfKey ?? "self";
      if (this.init.pass != null && this.init.pass?.length < 20) {
        throw new Error("pass must be least 20 characters");
      }
      if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
        throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
      }
      if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
        throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
      }
      if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
        throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
      }
      const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf22(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
      privates.set(this, { dek });
    }
    [Symbol.toStringTag] = "@libp2p/keychain";
    [serviceCapabilities] = [
      "@libp2p/keychain"
    ];
    /**
     * Generates the options for a keychain.  A random salt is produced.
     *
     * @returns {object}
     */
    static generateOptions() {
      const options2 = Object.assign({}, this.options);
      const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
      if (options2.dek != null) {
        options2.dek.salt = toString2(randomBytes2(saltLength), "base64");
      }
      return options2;
    }
    /**
     * Gets an object that can encrypt/decrypt protected data.
     * The default options for a keychain.
     *
     * @returns {object}
     */
    static get options() {
      return {
        dek: {
          ...DEK_INIT
        }
      };
    }
    async findKeyByName(name9) {
      if (!validateKeyName(name9)) {
        await randomDelay();
        throw new InvalidParametersError(`Invalid key name '${name9}'`);
      }
      const datastoreName = DsInfoName(name9);
      try {
        const res = await this.components.datastore.get(datastoreName);
        return JSON.parse(toString2(res));
      } catch (err2) {
        await randomDelay();
        this.log.error("could not read key from datastore - %e", err2);
        throw new NotFoundError(`Key '${name9}' does not exist.`);
      }
    }
    async findKeyById(id) {
      try {
        const query = {
          prefix: infoPrefix
        };
        for await (const value2 of this.components.datastore.query(query)) {
          const key = JSON.parse(toString2(value2.value));
          if (key.id === id) {
            return key;
          }
        }
        throw new InvalidParametersError(`Key with id '${id}' does not exist.`);
      } catch (err2) {
        await randomDelay();
        throw err2;
      }
    }
    async importKey(name9, key) {
      if (!validateKeyName(name9)) {
        await randomDelay();
        throw new InvalidParametersError(`Invalid key name '${name9}'`);
      }
      if (key == null) {
        await randomDelay();
        throw new InvalidParametersError("Key is required");
      }
      const datastoreName = DsName(name9);
      const exists2 = await this.components.datastore.has(datastoreName);
      if (exists2) {
        await randomDelay();
        throw new InvalidParametersError(`Key '${name9}' already exists`);
      }
      let kid;
      let pem;
      try {
        kid = await keyId(key);
        const cached = privates.get(this);
        if (cached == null) {
          throw new InvalidParametersError("dek missing");
        }
        const dek = cached.dek;
        pem = await exportPrivateKey(key, dek, key.type === "RSA" ? "pkcs-8" : "libp2p-key");
      } catch (err2) {
        await randomDelay();
        throw err2;
      }
      const keyInfo = {
        name: name9,
        id: kid
      };
      const batch2 = this.components.datastore.batch();
      batch2.put(datastoreName, fromString2(pem));
      batch2.put(DsInfoName(name9), fromString2(JSON.stringify(keyInfo)));
      await batch2.commit();
      return keyInfo;
    }
    async exportKey(name9) {
      if (!validateKeyName(name9)) {
        await randomDelay();
        throw new InvalidParametersError(`Invalid key name '${name9}'`);
      }
      const datastoreName = DsName(name9);
      try {
        const res = await this.components.datastore.get(datastoreName);
        const pem = toString2(res);
        const cached = privates.get(this);
        if (cached == null) {
          throw new InvalidParametersError("dek missing");
        }
        const dek = cached.dek;
        return await importPrivateKey(pem, dek);
      } catch (err2) {
        await randomDelay();
        throw err2;
      }
    }
    async removeKey(name9) {
      if (!validateKeyName(name9) || name9 === this.self) {
        await randomDelay();
        throw new InvalidParametersError(`Invalid key name '${name9}'`);
      }
      const datastoreName = DsName(name9);
      const keyInfo = await this.findKeyByName(name9);
      const batch2 = this.components.datastore.batch();
      batch2.delete(datastoreName);
      batch2.delete(DsInfoName(name9));
      await batch2.commit();
      return keyInfo;
    }
    /**
     * List all the keys.
     *
     * @returns {Promise<KeyInfo[]>}
     */
    async listKeys() {
      const query = {
        prefix: infoPrefix
      };
      const info = [];
      for await (const value2 of this.components.datastore.query(query)) {
        info.push(JSON.parse(toString2(value2.value)));
      }
      return info;
    }
    /**
     * Rename a key
     *
     * @param {string} oldName - The old local key name; must already exist.
     * @param {string} newName - The new local key name; must not already exist.
     * @returns {Promise<KeyInfo>}
     */
    async renameKey(oldName, newName) {
      if (!validateKeyName(oldName) || oldName === this.self) {
        await randomDelay();
        throw new InvalidParametersError(`Invalid old key name '${oldName}'`);
      }
      if (!validateKeyName(newName) || newName === this.self) {
        await randomDelay();
        throw new InvalidParametersError(`Invalid new key name '${newName}'`);
      }
      const oldDatastoreName = DsName(oldName);
      const newDatastoreName = DsName(newName);
      const oldInfoName = DsInfoName(oldName);
      const newInfoName = DsInfoName(newName);
      const exists2 = await this.components.datastore.has(newDatastoreName);
      if (exists2) {
        await randomDelay();
        throw new InvalidParametersError(`Key '${newName}' already exists`);
      }
      try {
        const pem = await this.components.datastore.get(oldDatastoreName);
        const res = await this.components.datastore.get(oldInfoName);
        const keyInfo = JSON.parse(toString2(res));
        keyInfo.name = newName;
        const batch2 = this.components.datastore.batch();
        batch2.put(newDatastoreName, pem);
        batch2.put(newInfoName, fromString2(JSON.stringify(keyInfo)));
        batch2.delete(oldDatastoreName);
        batch2.delete(oldInfoName);
        await batch2.commit();
        return keyInfo;
      } catch (err2) {
        await randomDelay();
        throw err2;
      }
    }
    /**
     * Rotate keychain password and re-encrypt all associated keys
     */
    async rotateKeychainPass(oldPass, newPass) {
      if (typeof oldPass !== "string") {
        await randomDelay();
        throw new InvalidParametersError(`Invalid old pass type '${typeof oldPass}'`);
      }
      if (typeof newPass !== "string") {
        await randomDelay();
        throw new InvalidParametersError(`Invalid new pass type '${typeof newPass}'`);
      }
      if (newPass.length < 20) {
        await randomDelay();
        throw new InvalidParametersError(`Invalid pass length ${newPass.length}`);
      }
      this.log("recreating keychain");
      const cached = privates.get(this);
      if (cached == null) {
        throw new InvalidParametersError("dek missing");
      }
      const oldDek = cached.dek;
      this.init.pass = newPass;
      const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf22(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
      privates.set(this, { dek: newDek });
      const keys = await this.listKeys();
      for (const key of keys) {
        const res = await this.components.datastore.get(DsName(key.name));
        const pem = toString2(res);
        const privateKey = await importPrivateKey(pem, oldDek);
        const password = newDek.toString();
        const keyAsPEM = await exportPrivateKey(privateKey, password, privateKey.type === "RSA" ? "pkcs-8" : "libp2p-key");
        const batch2 = this.components.datastore.batch();
        const keyInfo = {
          name: key.name,
          id: key.id
        };
        batch2.put(DsName(key.name), fromString2(keyAsPEM));
        batch2.put(DsInfoName(key.name), fromString2(JSON.stringify(keyInfo)));
        await batch2.commit();
      }
      this.log("keychain reconstructed");
    }
  };

  // node_modules/@libp2p/keychain/dist/src/index.js
  function keychain(init = {}) {
    return (components) => {
      return new Keychain(components, init);
    };
  }

  // node_modules/@libp2p/config/dist/src/load-private-key.js
  async function loadOrCreateSelfKey(datastore, init = {}) {
    const selfKey = init.selfKey ?? "self";
    const chain = keychain(init)({
      datastore,
      logger: defaultLogger()
    });
    let privateKey;
    if (await datastore.has(new Key(`/pkcs8/${selfKey}`))) {
      privateKey = await chain.exportKey(selfKey);
    } else {
      privateKey = await generateKeyPair(init.keyType ?? "Ed25519");
      await chain.importKey(selfKey, privateKey);
    }
    return privateKey;
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
  var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
  var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
  var DUMP_SESSION_KEYS = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);
  var CHACHA_TAG_LENGTH = 16;

  // node_modules/@noble/ciphers/utils.js
  function isBytes2(a2) {
    return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
  }
  function abool2(b) {
    if (typeof b !== "boolean")
      throw new Error(`boolean expected, not ${b}`);
  }
  function anumber2(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error("positive integer expected, got " + n2);
  }
  function abytes2(value2, length4, title = "") {
    const bytes = isBytes2(value2);
    const len = value2?.length;
    const needsLen = length4 !== void 0;
    if (!bytes || needsLen && len !== length4) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length4}` : "";
      const got = bytes ? `length=${len}` : `type=${typeof value2}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value2;
  }
  function aexists2(instance2, checkFinished = true) {
    if (instance2.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance2.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput2(out, instance2) {
    abytes2(out, void 0, "output");
    const min = instance2.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean2(...arrays) {
    for (let i2 = 0; i2 < arrays.length; i2++) {
      arrays[i2].fill(0);
    }
  }
  function createView2(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function checkOpts2(defaults2, opts) {
    if (opts == null || typeof opts !== "object")
      throw new Error("options must be defined");
    const merged = Object.assign(defaults2, opts);
    return merged;
  }
  function equalBytes(a2, b) {
    if (a2.length !== b.length)
      return false;
    let diff = 0;
    for (let i2 = 0; i2 < a2.length; i2++)
      diff |= a2[i2] ^ b[i2];
    return diff === 0;
  }
  var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
    function wrappedCipher(key, ...args) {
      abytes2(key, void 0, "key");
      if (!isLE)
        throw new Error("Non little-endian hardware is not yet supported");
      if (params.nonceLength !== void 0) {
        const nonce = args[0];
        abytes2(nonce, params.varSizeNonce ? void 0 : params.nonceLength, "nonce");
      }
      const tagl = params.tagLength;
      if (tagl && args[1] !== void 0)
        abytes2(args[1], void 0, "AAD");
      const cipher = constructor(key, ...args);
      const checkOutput = (fnLength, output) => {
        if (output !== void 0) {
          if (fnLength !== 2)
            throw new Error("cipher output not supported");
          abytes2(output, void 0, "output");
        }
      };
      let called = false;
      const wrCipher = {
        encrypt(data, output) {
          if (called)
            throw new Error("cannot encrypt() twice with same key + nonce");
          called = true;
          abytes2(data);
          checkOutput(cipher.encrypt.length, output);
          return cipher.encrypt(data, output);
        },
        decrypt(data, output) {
          abytes2(data);
          if (tagl && data.length < tagl)
            throw new Error('"ciphertext" expected length bigger than tagLength=' + tagl);
          checkOutput(cipher.decrypt.length, output);
          return cipher.decrypt(data, output);
        }
      };
      return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
  };
  function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === void 0)
      return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
      throw new Error('"output" expected Uint8Array of length ' + expectedLength + ", got: " + out.length);
    if (onlyAligned && !isAligned32(out))
      throw new Error("invalid output, must be aligned");
    return out;
  }
  function u64Lengths(dataLength, aadLength, isLE2) {
    abool2(isLE2);
    const num = new Uint8Array(16);
    const view = createView2(num);
    view.setBigUint64(0, BigInt(aadLength), isLE2);
    view.setBigUint64(8, BigInt(dataLength), isLE2);
    return num;
  }
  function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
  }
  function copyBytes2(bytes) {
    return Uint8Array.from(bytes);
  }

  // node_modules/@noble/ciphers/_arx.js
  var encodeStr = (str) => Uint8Array.from(str.split(""), (c2) => c2.charCodeAt(0));
  var sigma16 = encodeStr("expand 16-byte k");
  var sigma32 = encodeStr("expand 32-byte k");
  var sigma16_32 = u32(sigma16);
  var sigma32_32 = u32(sigma32);
  function rotl2(a2, b) {
    return a2 << b | a2 >>> 32 - b;
  }
  function isAligned322(b) {
    return b.byteOffset % 4 === 0;
  }
  var BLOCK_LEN = 64;
  var BLOCK_LEN32 = 16;
  var MAX_COUNTER = 2 ** 32 - 1;
  var U32_EMPTY = Uint32Array.of();
  function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = u32(block);
    const isAligned = isAligned322(data) && isAligned322(output);
    const d32 = isAligned ? u32(data) : U32_EMPTY;
    const o32 = isAligned ? u32(output) : U32_EMPTY;
    for (let pos = 0; pos < len; counter++) {
      core(sigma, key, nonce, b32, counter, rounds);
      if (counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      const take2 = Math.min(BLOCK_LEN, len - pos);
      if (isAligned && take2 === BLOCK_LEN) {
        const pos32 = pos / 4;
        if (pos % 4 !== 0)
          throw new Error("arx: invalid block position");
        for (let j = 0, posj; j < BLOCK_LEN32; j++) {
          posj = pos32 + j;
          o32[posj] = d32[posj] ^ b32[j];
        }
        pos += BLOCK_LEN;
        continue;
      }
      for (let j = 0, posj; j < take2; j++) {
        posj = pos + j;
        output[posj] = data[posj] ^ block[j];
      }
      pos += take2;
    }
  }
  function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts2({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
    if (typeof core !== "function")
      throw new Error("core must be a function");
    anumber2(counterLength);
    anumber2(rounds);
    abool2(counterRight);
    abool2(allowShortKeys);
    return (key, nonce, data, output, counter = 0) => {
      abytes2(key, void 0, "key");
      abytes2(nonce, void 0, "nonce");
      abytes2(data, void 0, "data");
      const len = data.length;
      if (output === void 0)
        output = new Uint8Array(len);
      abytes2(output, void 0, "output");
      anumber2(counter);
      if (counter < 0 || counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      if (output.length < len)
        throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
      const toClean = [];
      let l2 = key.length;
      let k;
      let sigma;
      if (l2 === 32) {
        toClean.push(k = copyBytes2(key));
        sigma = sigma32_32;
      } else if (l2 === 16 && allowShortKeys) {
        k = new Uint8Array(32);
        k.set(key);
        k.set(key, 16);
        sigma = sigma16_32;
        toClean.push(k);
      } else {
        abytes2(key, 32, "arx key");
        throw new Error("invalid key size");
      }
      if (!isAligned322(nonce))
        toClean.push(nonce = copyBytes2(nonce));
      const k32 = u32(k);
      if (extendNonceFn) {
        if (nonce.length !== 24)
          throw new Error(`arx: extended nonce must be 24 bytes`);
        extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
        nonce = nonce.subarray(16);
      }
      const nonceNcLen = 16 - counterLength;
      if (nonceNcLen !== nonce.length)
        throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
      if (nonceNcLen !== 12) {
        const nc = new Uint8Array(12);
        nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
        nonce = nc;
        toClean.push(nonce);
      }
      const n32 = u32(nonce);
      runCipher(core, sigma, k32, n32, data, output, counter, rounds);
      clean2(...toClean);
      return output;
    };
  }

  // node_modules/@noble/ciphers/_poly1305.js
  function u8to16(a2, i2) {
    return a2[i2++] & 255 | (a2[i2++] & 255) << 8;
  }
  var Poly1305 = class {
    blockLen = 16;
    outputLen = 16;
    buffer = new Uint8Array(16);
    r = new Uint16Array(10);
    // Allocating 1 array with .subarray() here is slower than 3
    h = new Uint16Array(10);
    pad = new Uint16Array(8);
    pos = 0;
    finished = false;
    // Can be speed-up using BigUint64Array, at the cost of complexity
    constructor(key) {
      key = copyBytes2(abytes2(key, 32, "key"));
      const t0 = u8to16(key, 0);
      const t1 = u8to16(key, 2);
      const t2 = u8to16(key, 4);
      const t3 = u8to16(key, 6);
      const t4 = u8to16(key, 8);
      const t5 = u8to16(key, 10);
      const t6 = u8to16(key, 12);
      const t7 = u8to16(key, 14);
      this.r[0] = t0 & 8191;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      for (let i2 = 0; i2 < 8; i2++)
        this.pad[i2] = u8to16(key, 16 + 2 * i2);
    }
    process(data, offset, isLast = false) {
      const hibit = isLast ? 0 : 1 << 11;
      const { h, r: r2 } = this;
      const r0 = r2[0];
      const r1 = r2[1];
      const r22 = r2[2];
      const r3 = r2[3];
      const r4 = r2[4];
      const r5 = r2[5];
      const r6 = r2[6];
      const r7 = r2[7];
      const r8 = r2[8];
      const r9 = r2[9];
      const t0 = u8to16(data, offset + 0);
      const t1 = u8to16(data, offset + 2);
      const t2 = u8to16(data, offset + 4);
      const t3 = u8to16(data, offset + 6);
      const t4 = u8to16(data, offset + 8);
      const t5 = u8to16(data, offset + 10);
      const t6 = u8to16(data, offset + 12);
      const t7 = u8to16(data, offset + 14);
      let h0 = h[0] + (t0 & 8191);
      let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
      let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
      let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
      let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
      let h5 = h[5] + (t4 >>> 1 & 8191);
      let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
      let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
      let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
      let h9 = h[9] + (t7 >>> 5 | hibit);
      let c2 = 0;
      let d0 = c2 + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
      c2 = d0 >>> 13;
      d0 &= 8191;
      d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r22) + h9 * (5 * r1);
      c2 += d0 >>> 13;
      d0 &= 8191;
      let d1 = c2 + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
      c2 = d1 >>> 13;
      d1 &= 8191;
      d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r22);
      c2 += d1 >>> 13;
      d1 &= 8191;
      let d2 = c2 + h0 * r22 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
      c2 = d2 >>> 13;
      d2 &= 8191;
      d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
      c2 += d2 >>> 13;
      d2 &= 8191;
      let d3 = c2 + h0 * r3 + h1 * r22 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
      c2 = d3 >>> 13;
      d3 &= 8191;
      d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
      c2 += d3 >>> 13;
      d3 &= 8191;
      let d4 = c2 + h0 * r4 + h1 * r3 + h2 * r22 + h3 * r1 + h4 * r0;
      c2 = d4 >>> 13;
      d4 &= 8191;
      d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
      c2 += d4 >>> 13;
      d4 &= 8191;
      let d5 = c2 + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r22 + h4 * r1;
      c2 = d5 >>> 13;
      d5 &= 8191;
      d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
      c2 += d5 >>> 13;
      d5 &= 8191;
      let d6 = c2 + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r22;
      c2 = d6 >>> 13;
      d6 &= 8191;
      d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
      c2 += d6 >>> 13;
      d6 &= 8191;
      let d7 = c2 + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
      c2 = d7 >>> 13;
      d7 &= 8191;
      d7 += h5 * r22 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
      c2 += d7 >>> 13;
      d7 &= 8191;
      let d8 = c2 + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
      c2 = d8 >>> 13;
      d8 &= 8191;
      d8 += h5 * r3 + h6 * r22 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
      c2 += d8 >>> 13;
      d8 &= 8191;
      let d9 = c2 + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
      c2 = d9 >>> 13;
      d9 &= 8191;
      d9 += h5 * r4 + h6 * r3 + h7 * r22 + h8 * r1 + h9 * r0;
      c2 += d9 >>> 13;
      d9 &= 8191;
      c2 = (c2 << 2) + c2 | 0;
      c2 = c2 + d0 | 0;
      d0 = c2 & 8191;
      c2 = c2 >>> 13;
      d1 += c2;
      h[0] = d0;
      h[1] = d1;
      h[2] = d2;
      h[3] = d3;
      h[4] = d4;
      h[5] = d5;
      h[6] = d6;
      h[7] = d7;
      h[8] = d8;
      h[9] = d9;
    }
    finalize() {
      const { h, pad } = this;
      const g = new Uint16Array(10);
      let c2 = h[1] >>> 13;
      h[1] &= 8191;
      for (let i2 = 2; i2 < 10; i2++) {
        h[i2] += c2;
        c2 = h[i2] >>> 13;
        h[i2] &= 8191;
      }
      h[0] += c2 * 5;
      c2 = h[0] >>> 13;
      h[0] &= 8191;
      h[1] += c2;
      c2 = h[1] >>> 13;
      h[1] &= 8191;
      h[2] += c2;
      g[0] = h[0] + 5;
      c2 = g[0] >>> 13;
      g[0] &= 8191;
      for (let i2 = 1; i2 < 10; i2++) {
        g[i2] = h[i2] + c2;
        c2 = g[i2] >>> 13;
        g[i2] &= 8191;
      }
      g[9] -= 1 << 13;
      let mask = (c2 ^ 1) - 1;
      for (let i2 = 0; i2 < 10; i2++)
        g[i2] &= mask;
      mask = ~mask;
      for (let i2 = 0; i2 < 10; i2++)
        h[i2] = h[i2] & mask | g[i2];
      h[0] = (h[0] | h[1] << 13) & 65535;
      h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
      h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
      h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
      h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
      h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
      h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
      h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
      let f2 = h[0] + pad[0];
      h[0] = f2 & 65535;
      for (let i2 = 1; i2 < 8; i2++) {
        f2 = (h[i2] + pad[i2] | 0) + (f2 >>> 16) | 0;
        h[i2] = f2 & 65535;
      }
      clean2(g);
    }
    update(data) {
      aexists2(this);
      abytes2(data);
      data = copyBytes2(data);
      const { buffer: buffer2, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(data, pos);
          continue;
        }
        buffer2.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(buffer2, 0, false);
          this.pos = 0;
        }
      }
      return this;
    }
    destroy() {
      clean2(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(out) {
      aexists2(this);
      aoutput2(out, this);
      this.finished = true;
      const { buffer: buffer2, h } = this;
      let { pos } = this;
      if (pos) {
        buffer2[pos++] = 1;
        for (; pos < 16; pos++)
          buffer2[pos] = 0;
        this.process(buffer2, 0, true);
      }
      this.finalize();
      let opos = 0;
      for (let i2 = 0; i2 < 8; i2++) {
        out[opos++] = h[i2] >>> 0;
        out[opos++] = h[i2] >>> 8;
      }
      return out;
    }
    digest() {
      const { buffer: buffer2, outputLen } = this;
      this.digestInto(buffer2);
      const res = buffer2.slice(0, outputLen);
      this.destroy();
      return res;
    }
  };
  function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key) => hashCons(key).update(msg).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key) => hashCons(key);
    return hashC;
  }
  var poly1305 = /* @__PURE__ */ (() => wrapConstructorWithKey((key) => new Poly1305(key)))();

  // node_modules/@noble/ciphers/chacha.js
  function chachaCore(s2, k, n2, out, cnt, rounds = 20) {
    let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n2[0], y14 = n2[1], y15 = n2[2];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let r2 = 0; r2 < rounds; r2 += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl2(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl2(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl2(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl2(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl2(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl2(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl2(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl2(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl2(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl2(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl2(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl2(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl2(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl2(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl2(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl2(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl2(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl2(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl2(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl2(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl2(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl2(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl2(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl2(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl2(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl2(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl2(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl2(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl2(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl2(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl2(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl2(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function hchacha(s2, k, i2, out) {
    let x00 = s2[0], x01 = s2[1], x02 = s2[2], x03 = s2[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i2[0], x13 = i2[1], x14 = i2[2], x15 = i2[3];
    for (let r2 = 0; r2 < 20; r2 += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl2(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl2(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl2(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl2(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl2(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl2(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl2(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl2(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl2(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl2(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl2(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl2(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl2(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl2(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl2(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl2(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl2(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl2(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl2(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl2(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl2(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl2(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl2(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl2(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl2(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl2(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl2(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl2(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl2(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl2(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl2(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl2(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = x00;
    out[oi++] = x01;
    out[oi++] = x02;
    out[oi++] = x03;
    out[oi++] = x12;
    out[oi++] = x13;
    out[oi++] = x14;
    out[oi++] = x15;
  }
  var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 4,
    allowShortKeys: false
  });
  var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
  });
  var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
  var updatePadded = (h, msg) => {
    h.update(msg);
    const leftover = msg.length % 16;
    if (leftover)
      h.update(ZEROS16.subarray(leftover));
  };
  var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
  function computeTag(fn, key, nonce, ciphertext, AAD) {
    if (AAD !== void 0)
      abytes2(AAD, void 0, "AAD");
    const authKey = fn(key, nonce, ZEROS32);
    const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);
    const h = poly1305.create(authKey);
    if (AAD)
      updatePadded(h, AAD);
    updatePadded(h, ciphertext);
    h.update(lengths);
    const res = h.digest();
    clean2(authKey, lengths);
    return res;
  }
  var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
    const tagLength = 16;
    return {
      encrypt(plaintext, output) {
        const plength = plaintext.length;
        output = getOutput(plength + tagLength, output, false);
        output.set(plaintext);
        const oPlain = output.subarray(0, -tagLength);
        xorStream(key, nonce, oPlain, oPlain, 1);
        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
        output.set(tag, plength);
        clean2(tag);
        return output;
      },
      decrypt(ciphertext, output) {
        output = getOutput(ciphertext.length - tagLength, output, false);
        const data = ciphertext.subarray(0, -tagLength);
        const passedTag = ciphertext.subarray(-tagLength);
        const tag = computeTag(xorStream, key, nonce, data, AAD);
        if (!equalBytes(passedTag, tag))
          throw new Error("invalid tag");
        output.set(ciphertext.subarray(0, -tagLength));
        xorStream(key, nonce, output, output, 1);
        clean2(tag);
        return output;
      }
    };
  };
  var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
  var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

  // node_modules/@noble/hashes/hkdf.js
  function extract(hash, ikm, salt) {
    ahash(hash);
    if (salt === void 0)
      salt = new Uint8Array(hash.outputLen);
    return hmac(hash, salt, ikm);
  }
  var HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);
  var EMPTY_BUFFER2 = /* @__PURE__ */ Uint8Array.of();
  function expand(hash, prk, info, length4 = 32) {
    ahash(hash);
    anumber(length4, "length");
    const olen = hash.outputLen;
    if (length4 > 255 * olen)
      throw new Error("Length must be <= 255*HashLen");
    const blocks = Math.ceil(length4 / olen);
    if (info === void 0)
      info = EMPTY_BUFFER2;
    else
      abytes(info, void 0, "info");
    const okm = new Uint8Array(blocks * olen);
    const HMAC = hmac.create(hash, prk);
    const HMACTmp = HMAC._cloneInto();
    const T = new Uint8Array(HMAC.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
      HKDF_COUNTER[0] = counter + 1;
      HMACTmp.update(counter === 0 ? EMPTY_BUFFER2 : T).update(info).update(HKDF_COUNTER).digestInto(T);
      okm.set(T, olen * counter);
      HMAC._cloneInto(HMACTmp);
    }
    HMAC.destroy();
    HMACTmp.destroy();
    clean(T, HKDF_COUNTER);
    return okm.slice(0, length4);
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
  var pureJsCrypto = {
    hashSHA256(data) {
      return sha2562(data.subarray());
    },
    getHKDF(ck, ikm) {
      const prk = extract(sha2562, ikm, ck);
      const okmU8Array = expand(sha2562, prk, void 0, 96);
      const okm = okmU8Array;
      const k1 = okm.subarray(0, 32);
      const k2 = okm.subarray(32, 64);
      const k3 = okm.subarray(64, 96);
      return [k1, k2, k3];
    },
    generateX25519KeyPair() {
      const secretKey = x25519.utils.randomSecretKey();
      const publicKey2 = x25519.getPublicKey(secretKey);
      return {
        publicKey: publicKey2,
        privateKey: secretKey
      };
    },
    generateX25519KeyPairFromSeed(seed) {
      const publicKey2 = x25519.getPublicKey(seed);
      return {
        publicKey: publicKey2,
        privateKey: seed
      };
    },
    generateX25519SharedKey(privateKey, publicKey2) {
      return x25519.getSharedSecret(privateKey.subarray(), publicKey2.subarray());
    },
    chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
      return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());
    },
    chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
      return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
    }
  };

  // node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
  var defaultCrypto = pureJsCrypto;

  // node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
  function wrapCrypto(crypto2) {
    return {
      generateKeypair: crypto2.generateX25519KeyPair,
      dh: (keypair, publicKey2) => crypto2.generateX25519SharedKey(keypair.privateKey, publicKey2).subarray(0, 32),
      encrypt: crypto2.chaCha20Poly1305Encrypt,
      decrypt: crypto2.chaCha20Poly1305Decrypt,
      hash: crypto2.hashSHA256,
      hkdf: crypto2.getHKDF
    };
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
  var uint16BEEncode = (value2) => {
    const target = allocUnsafe(2);
    target[0] = value2 >> 8;
    target[1] = value2;
    return target;
  };
  uint16BEEncode.bytes = 2;
  var uint16BEDecode = (data) => {
    if (data.length < 2) {
      throw RangeError("Could not decode int16BE");
    }
    if (data instanceof Uint8Array) {
      let value2 = 0;
      value2 += data[0] << 8;
      value2 += data[1];
      return value2;
    }
    return data.getUint16(0);
  };
  uint16BEDecode.bytes = 2;

  // node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
  function registerMetrics(metrics) {
    return {
      xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
        help: "Total count of noise xxHandshakes successes_"
      }),
      xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
        help: "Total count of noise xxHandshakes errors"
      }),
      encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
        help: "Total count of noise encrypted packets successfully"
      }),
      decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
        help: "Total count of noise decrypted packets"
      }),
      decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
        help: "Total count of noise decrypt errors"
      })
    };
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
  function logLocalStaticKeys(s2, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (s2) {
      keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString2(s2.publicKey, "hex")}`);
      keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString2(s2.privateKey, "hex")}`);
    } else {
      keyLogger("Missing local static keys.");
    }
  }
  function logLocalEphemeralKeys(e2, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (e2) {
      keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString2(e2.publicKey, "hex")}`);
      keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString2(e2.privateKey, "hex")}`);
    } else {
      keyLogger("Missing local ephemeral keys.");
    }
  }
  function logRemoteStaticKey(rs, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (rs) {
      keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString2(rs.subarray(), "hex")}`);
    } else {
      keyLogger("Missing remote static public key.");
    }
  }
  function logRemoteEphemeralKey(re, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (re) {
      keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString2(re.subarray(), "hex")}`);
    } else {
      keyLogger("Missing remote ephemeral keys.");
    }
  }
  function logCipherState(cs1, cs2, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && toString2(cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && toString2(cs2.k, "hex")}`);
  }

  // node_modules/uint8arrays/dist/src/xor.js
  function xor(a2, b) {
    if (a2.length !== b.length) {
      throw new Error("Inputs should have the same length");
    }
    const result = allocUnsafe(a2.length);
    for (let i2 = 0; i2 < a2.length; i2++) {
      result[i2] = a2[i2] ^ b[i2];
    }
    return asUint8Array(result);
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
  var InvalidCryptoExchangeError2 = class _InvalidCryptoExchangeError extends Error {
    code;
    constructor(message2 = "Invalid crypto exchange") {
      super(message2);
      this.code = _InvalidCryptoExchangeError.code;
    }
    static code = "ERR_INVALID_CRYPTO_EXCHANGE";
  };

  // node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
  var MIN_NONCE = 0;
  var MAX_NONCE = 4294967295;
  var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
  var Nonce = class {
    n;
    bytes;
    view;
    constructor(n2 = MIN_NONCE) {
      this.n = n2;
      this.bytes = alloc(12);
      this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
      this.view.setUint32(4, n2, true);
    }
    increment() {
      this.n++;
      this.view.setUint32(4, this.n, true);
    }
    getBytes() {
      return this.bytes;
    }
    getUint64() {
      return this.n;
    }
    assertValue() {
      if (this.n > MAX_NONCE) {
        throw new Error(ERR_MAX_NONCE);
      }
    }
  };

  // node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js
  var ZEROLEN = alloc(0);
  var CipherState = class {
    k;
    n;
    crypto;
    constructor(crypto2, k = void 0, n2 = 0) {
      this.crypto = crypto2;
      this.k = k;
      this.n = new Nonce(n2);
    }
    hasKey() {
      return Boolean(this.k);
    }
    encryptWithAd(ad, plaintext) {
      if (!this.hasKey()) {
        return plaintext;
      }
      this.n.assertValue();
      const e2 = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
      this.n.increment();
      return e2;
    }
    decryptWithAd(ad, ciphertext, dst) {
      if (!this.hasKey()) {
        return ciphertext;
      }
      this.n.assertValue();
      const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
      this.n.increment();
      return plaintext;
    }
  };
  var SymmetricState = class {
    cs;
    ck;
    h;
    crypto;
    constructor(crypto2, protocolName) {
      this.crypto = crypto2;
      const protocolNameBytes = fromString2(protocolName, "utf-8");
      this.h = hashProtocolName(crypto2, protocolNameBytes);
      this.ck = this.h;
      this.cs = new CipherState(crypto2);
    }
    mixKey(ikm) {
      const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
      this.ck = ck;
      this.cs = new CipherState(this.crypto, tempK);
    }
    mixHash(data) {
      this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));
    }
    encryptAndHash(plaintext) {
      const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
      this.mixHash(ciphertext);
      return ciphertext;
    }
    decryptAndHash(ciphertext) {
      const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
      this.mixHash(ciphertext);
      return plaintext;
    }
    split() {
      const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
      return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];
    }
  };
  var AbstractHandshakeState = class {
    ss;
    s;
    e;
    rs;
    re;
    initiator;
    crypto;
    constructor(init) {
      const { crypto: crypto2, protocolName, prologue, initiator, s: s2, e: e2, rs, re } = init;
      this.crypto = crypto2;
      this.ss = new SymmetricState(crypto2, protocolName);
      this.ss.mixHash(prologue);
      this.initiator = initiator;
      this.s = s2;
      this.e = e2;
      this.rs = rs;
      this.re = re;
    }
    writeE() {
      if (this.e) {
        throw new Error("ephemeral keypair is already set");
      }
      const e2 = this.crypto.generateKeypair();
      this.ss.mixHash(e2.publicKey);
      this.e = e2;
      return e2.publicKey;
    }
    writeS() {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      return this.ss.encryptAndHash(this.s.publicKey);
    }
    writeEE() {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.re));
    }
    writeES() {
      if (this.initiator) {
        if (!this.e) {
          throw new Error("ephemeral keypair is not set");
        }
        if (!this.rs) {
          throw new Error("remote static public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.e, this.rs));
      } else {
        if (!this.s) {
          throw new Error("static keypair is not set");
        }
        if (!this.re) {
          throw new Error("remote ephemeral public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.s, this.re));
      }
    }
    writeSE() {
      if (this.initiator) {
        if (!this.s) {
          throw new Error("static keypair is not set");
        }
        if (!this.re) {
          throw new Error("remote ephemeral public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.s, this.re));
      } else {
        if (!this.e) {
          throw new Error("ephemeral keypair is not set");
        }
        if (!this.rs) {
          throw new Error("remote static public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.e, this.rs));
      }
    }
    readE(message2, offset = 0) {
      if (this.re) {
        throw new Error("remote ephemeral public key is already set");
      }
      if (message2.byteLength < offset + 32) {
        throw new Error("message is not long enough");
      }
      this.re = message2.sublist(offset, offset + 32);
      this.ss.mixHash(this.re);
    }
    readS(message2, offset = 0) {
      if (this.rs) {
        throw new Error("remote static public key is already set");
      }
      const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
      if (message2.byteLength < offset + cipherLength) {
        throw new Error("message is not long enough");
      }
      const temp = message2.sublist(offset, offset + cipherLength);
      this.rs = this.ss.decryptAndHash(temp);
      return cipherLength;
    }
    readEE() {
      this.writeEE();
    }
    readES() {
      this.writeES();
    }
    readSE() {
      this.writeSE();
    }
  };
  var XXHandshakeState = class extends AbstractHandshakeState {
    // e
    writeMessageA(payload) {
      return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));
    }
    // e, ee, s, es
    writeMessageB(payload) {
      const e2 = this.writeE();
      this.writeEE();
      const encS = this.writeS();
      this.writeES();
      return new Uint8ArrayList(e2, encS, this.ss.encryptAndHash(payload));
    }
    // s, se
    writeMessageC(payload) {
      const encS = this.writeS();
      this.writeSE();
      return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));
    }
    // e
    readMessageA(message2) {
      try {
        this.readE(message2);
        return this.ss.decryptAndHash(message2.sublist(32));
      } catch (e2) {
        throw new InvalidCryptoExchangeError2(`handshake stage 0 validation fail: ${e2.message}`);
      }
    }
    // e, ee, s, es
    readMessageB(message2) {
      try {
        this.readE(message2);
        this.readEE();
        const consumed = this.readS(message2, 32);
        this.readES();
        return this.ss.decryptAndHash(message2.sublist(32 + consumed));
      } catch (e2) {
        throw new InvalidCryptoExchangeError2(`handshake stage 1 validation fail: ${e2.message}`);
      }
    }
    // s, se
    readMessageC(message2) {
      try {
        const consumed = this.readS(message2);
        this.readSE();
        return this.ss.decryptAndHash(message2.sublist(consumed));
      } catch (e2) {
        throw new InvalidCryptoExchangeError2(`handshake stage 2 validation fail: ${e2.message}`);
      }
    }
  };
  function hashProtocolName(crypto2, protocolName) {
    if (protocolName.length <= 32) {
      const h = alloc(32);
      h.set(protocolName);
      return h;
    } else {
      return crypto2.hash(protocolName);
    }
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
  var NoiseExtensions;
  (function(NoiseExtensions2) {
    let _codec;
    NoiseExtensions2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.webtransportCerthashes != null) {
            for (const value2 of obj.webtransportCerthashes) {
              w.uint32(10);
              w.bytes(value2);
            }
          }
          if (obj.streamMuxers != null) {
            for (const value2 of obj.streamMuxers) {
              w.uint32(18);
              w.string(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            webtransportCerthashes: [],
            streamMuxers: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.webtransportCerthashes != null && obj.webtransportCerthashes.length === opts.limits.webtransportCerthashes) {
                  throw new MaxLengthError('Decode error - map field "webtransportCerthashes" had too many elements');
                }
                obj.webtransportCerthashes.push(reader2.bytes());
                break;
              }
              case 2: {
                if (opts.limits?.streamMuxers != null && obj.streamMuxers.length === opts.limits.streamMuxers) {
                  throw new MaxLengthError('Decode error - map field "streamMuxers" had too many elements');
                }
                obj.streamMuxers.push(reader2.string());
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseExtensions2.encode = (obj) => {
      return encodeMessage(obj, NoiseExtensions2.codec());
    };
    NoiseExtensions2.decode = (buf2, opts) => {
      return decodeMessage(buf2, NoiseExtensions2.codec(), opts);
    };
  })(NoiseExtensions || (NoiseExtensions = {}));
  var NoiseHandshakePayload;
  (function(NoiseHandshakePayload2) {
    let _codec;
    NoiseHandshakePayload2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.identityKey);
          }
          if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.identitySig);
          }
          if (obj.extensions != null) {
            w.uint32(34);
            NoiseExtensions.codec().encode(obj.extensions, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            identityKey: alloc(0),
            identitySig: alloc(0)
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.identityKey = reader2.bytes();
                break;
              }
              case 2: {
                obj.identitySig = reader2.bytes();
                break;
              }
              case 4: {
                obj.extensions = NoiseExtensions.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.extensions
                });
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseHandshakePayload2.encode = (obj) => {
      return encodeMessage(obj, NoiseHandshakePayload2.codec());
    };
    NoiseHandshakePayload2.decode = (buf2, opts) => {
      return decodeMessage(buf2, NoiseHandshakePayload2.codec(), opts);
    };
  })(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

  // node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
  async function createHandshakePayload(privateKey, staticPublicKey, extensions2) {
    const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
    return NoiseHandshakePayload.encode({
      identityKey: publicKeyToProtobuf(privateKey.publicKey),
      identitySig,
      extensions: extensions2
    });
  }
  async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
    try {
      const payload = NoiseHandshakePayload.decode(payloadBytes);
      const publicKey2 = publicKeyFromProtobuf(payload.identityKey);
      if (remoteIdentityKey?.equals(publicKey2) === false) {
        throw new Error(`Payload identity key ${publicKey2} does not match expected remote identity key ${remoteIdentityKey}`);
      }
      if (!remoteStaticKey) {
        throw new Error("Remote static does not exist");
      }
      const signaturePayload = getSignaturePayload(remoteStaticKey);
      if (!await publicKey2.verify(signaturePayload, payload.identitySig)) {
        throw new Error("Invalid payload signature");
      }
      return payload;
    } catch (e2) {
      throw new UnexpectedPeerError(e2.message);
    }
  }
  function getSignaturePayload(publicKey2) {
    const prefix = fromString2("noise-libp2p-static-key:");
    if (publicKey2 instanceof Uint8Array) {
      return concat([prefix, publicKey2], prefix.length + publicKey2.length);
    }
    publicKey2.prepend(prefix);
    return publicKey2;
  }
  var EncryptedMessageStream = class extends AbstractMessageStream {
    stream;
    handshake;
    metrics;
    decoder;
    constructor(stream, handshake, metrics) {
      super({
        log: stream.log,
        inactivityTimeout: stream.inactivityTimeout,
        maxReadBufferLength: stream.maxReadBufferLength,
        direction: stream.direction
      });
      this.stream = stream;
      this.handshake = handshake;
      this.metrics = metrics;
      this.decoder = new LengthPrefixedDecoder({
        lengthDecoder: uint16BEDecode,
        maxBufferSize: 16 * 1024 * 1024,
        encodingLength: () => 2
      });
      const noiseOnMessageDecrypt = (evt) => {
        try {
          for (const buf2 of this.decoder.decode(evt.data)) {
            this.onData(this.decrypt(buf2));
          }
        } catch (err2) {
          this.abort(err2);
        }
      };
      this.stream.addEventListener("message", noiseOnMessageDecrypt);
      const noiseOnClose = (evt) => {
        if (evt.error != null) {
          if (evt.local === true) {
            this.abort(evt.error);
          } else {
            this.onRemoteReset();
          }
        } else {
          this.onTransportClosed();
        }
      };
      this.stream.addEventListener("close", noiseOnClose);
      const noiseOnDrain = () => {
        this.safeDispatchEvent("drain");
      };
      this.stream.addEventListener("drain", noiseOnDrain);
      const noiseOnRemoteCloseWrite = () => {
        this.onRemoteCloseWrite();
      };
      this.stream.addEventListener("remoteCloseWrite", noiseOnRemoteCloseWrite);
    }
    encrypt(chunk) {
      const output = new Uint8ArrayList();
      for (let i2 = 0; i2 < chunk.byteLength; i2 += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
        let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
        if (end > chunk.byteLength) {
          end = chunk.byteLength;
        }
        let data;
        if (chunk instanceof Uint8Array) {
          data = this.handshake.encrypt(chunk.subarray(i2, end));
        } else {
          data = this.handshake.encrypt(chunk.sublist(i2, end));
        }
        this.metrics?.encryptedPackets.increment();
        output.append(uint16BEEncode(data.byteLength));
        output.append(data);
      }
      return output;
    }
    decrypt(chunk) {
      const output = new Uint8ArrayList();
      for (let i2 = 0; i2 < chunk.byteLength; i2 += NOISE_MSG_MAX_LENGTH_BYTES) {
        let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES;
        if (end > chunk.byteLength) {
          end = chunk.byteLength;
        }
        if (end - CHACHA_TAG_LENGTH < i2) {
          throw new Error("Invalid chunk");
        }
        let encrypted;
        if (chunk instanceof Uint8Array) {
          encrypted = chunk.subarray(i2, end);
        } else {
          encrypted = chunk.sublist(i2, end);
        }
        const dst = chunk.subarray(i2, end - CHACHA_TAG_LENGTH);
        try {
          const plaintext = this.handshake.decrypt(encrypted, dst);
          this.metrics?.decryptedPackets.increment();
          output.append(plaintext);
        } catch (e2) {
          this.metrics?.decryptErrors.increment();
          throw e2;
        }
      }
      return output;
    }
    close(options2) {
      return this.stream.close(options2);
    }
    sendPause() {
      this.stream.pause();
    }
    sendResume() {
      this.stream.resume();
    }
    sendReset(err2) {
      this.stream.abort(err2);
    }
    sendData(data) {
      return {
        sentBytes: data.byteLength,
        canSendMore: this.stream.send(this.encrypt(data))
      };
    }
  };
  function toMessageStream(connection, handshake, metrics) {
    return new EncryptedMessageStream(connection, handshake, metrics);
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js
  async function performHandshakeInitiator(init, options2) {
    const { log: log18, connection, crypto: crypto2, privateKey, prologue, s: s2, remoteIdentityKey, extensions: extensions2 } = init;
    const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions2);
    const xx = new XXHandshakeState({
      crypto: crypto2,
      protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
      initiator: true,
      prologue,
      s: s2
    });
    logLocalStaticKeys(xx.s, log18);
    log18.trace("Stage 0 - Initiator starting to send first message.");
    await connection.write(xx.writeMessageA(ZEROLEN), options2);
    log18.trace("Stage 0 - Initiator finished sending first message.");
    logLocalEphemeralKeys(xx.e, log18);
    log18.trace("Stage 1 - Initiator waiting to receive first message from responder...");
    const plaintext = xx.readMessageB(await connection.read(options2));
    log18.trace("Stage 1 - Initiator received the message.");
    logRemoteEphemeralKey(xx.re, log18);
    logRemoteStaticKey(xx.rs, log18);
    log18.trace("Initiator going to check remote's signature...");
    const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
    log18.trace("All good with the signature!");
    log18.trace("Stage 2 - Initiator sending third handshake message.");
    await connection.write(xx.writeMessageC(payload), options2);
    log18.trace("Stage 2 - Initiator sent message with signed payload.");
    const [cs1, cs2] = xx.ss.split();
    logCipherState(cs1, cs2, log18);
    return {
      payload: receivedPayload,
      encrypt: (plaintext2) => cs1.encryptWithAd(ZEROLEN, plaintext2),
      decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)
    };
  }
  async function performHandshakeResponder(init, options2) {
    const { log: log18, connection, crypto: crypto2, privateKey, prologue, s: s2, remoteIdentityKey, extensions: extensions2 } = init;
    const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions2);
    const xx = new XXHandshakeState({
      crypto: crypto2,
      protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
      initiator: false,
      prologue,
      s: s2
    });
    logLocalStaticKeys(xx.s, log18);
    log18.trace("Stage 0 - Responder waiting to receive first message.");
    xx.readMessageA(await connection.read(options2));
    log18.trace("Stage 0 - Responder received first message.");
    logRemoteEphemeralKey(xx.re, log18);
    log18.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
    await connection.write(xx.writeMessageB(payload), options2);
    log18.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
    logLocalEphemeralKeys(xx.e, log18);
    log18.trace("Stage 2 - Responder waiting for third handshake message...");
    const plaintext = xx.readMessageC(await connection.read(options2));
    log18.trace("Stage 2 - Responder received the message, finished handshake.");
    const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
    const [cs1, cs2] = xx.ss.split();
    logCipherState(cs1, cs2, log18);
    return {
      payload: receivedPayload,
      encrypt: (plaintext2) => cs2.encryptWithAd(ZEROLEN, plaintext2),
      decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)
    };
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
  var Noise = class {
    protocol = "/noise";
    crypto;
    prologue;
    staticKey;
    extensions;
    metrics;
    components;
    log;
    constructor(components, init = {}) {
      const { staticNoiseKey, extensions: extensions2, crypto: crypto2, prologueBytes } = init;
      const { metrics } = components;
      this.components = components;
      this.log = components.logger.forComponent("libp2p:noise");
      const _crypto = crypto2 ?? defaultCrypto;
      this.crypto = wrapCrypto(_crypto);
      this.extensions = {
        webtransportCerthashes: [],
        ...extensions2
      };
      this.metrics = metrics ? registerMetrics(metrics) : void 0;
      if (staticNoiseKey) {
        this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
      } else {
        this.staticKey = _crypto.generateX25519KeyPair();
      }
      this.prologue = prologueBytes ?? alloc(0);
    }
    [Symbol.toStringTag] = "@chainsafe/libp2p-noise";
    [serviceCapabilities] = [
      "@libp2p/connection-encryption",
      "@chainsafe/libp2p-noise"
    ];
    /**
     * Encrypt outgoing data to the remote party (handshake as initiator)
     *
     * @param connection - streaming iterable duplex that will be encrypted
     * @param options
     * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
     * @param options.signal - Used to abort the operation
     */
    async secureOutbound(connection, options2) {
      const log18 = connection.log?.newScope("noise") ?? this.log;
      const wrappedConnection = lpStream(connection, {
        lengthEncoder: uint16BEEncode,
        lengthDecoder: uint16BEDecode,
        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake = await this.performHandshakeInitiator(wrappedConnection, this.components.privateKey, log18, options2?.remotePeer?.publicKey, options2);
      const publicKey2 = publicKeyFromProtobuf(handshake.payload.identityKey);
      return {
        connection: toMessageStream(wrappedConnection.unwrap(), handshake, this.metrics),
        remoteExtensions: handshake.payload.extensions,
        remotePeer: peerIdFromPublicKey(publicKey2),
        streamMuxer: options2?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
      };
    }
    getStreamMuxer(protocols) {
      if (protocols == null || protocols.length === 0) {
        return;
      }
      const streamMuxers = this.components.upgrader.getStreamMuxers();
      if (streamMuxers != null) {
        for (const protocol of protocols) {
          const streamMuxer = streamMuxers.get(protocol);
          if (streamMuxer != null) {
            return streamMuxer;
          }
        }
      }
      if (protocols.length) {
        throw new InvalidCryptoExchangeError("Early muxer negotiation was requested but the initiator and responder had no common muxers");
      }
    }
    /**
     * Decrypt incoming data (handshake as responder).
     *
     * @param connection - streaming iterable duplex that will be encrypted
     * @param options
     * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
     * @param options.signal - Used to abort the operation
     */
    async secureInbound(connection, options2) {
      const log18 = connection.log?.newScope("noise") ?? this.log;
      const wrappedConnection = lpStream(connection, {
        lengthEncoder: uint16BEEncode,
        lengthDecoder: uint16BEDecode,
        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake = await this.performHandshakeResponder(wrappedConnection, this.components.privateKey, log18, options2?.remotePeer?.publicKey, options2);
      const publicKey2 = publicKeyFromProtobuf(handshake.payload.identityKey);
      return {
        connection: toMessageStream(wrappedConnection.unwrap(), handshake, this.metrics),
        remoteExtensions: handshake.payload.extensions,
        remotePeer: peerIdFromPublicKey(publicKey2),
        streamMuxer: options2?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
      };
    }
    /**
     * Perform XX handshake as initiator.
     */
    async performHandshakeInitiator(connection, privateKey, log18, remoteIdentityKey, options2) {
      let result;
      const streamMuxers = options2?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
      try {
        result = await performHandshakeInitiator({
          connection,
          privateKey,
          remoteIdentityKey,
          log: log18.newScope("xxhandshake"),
          crypto: this.crypto,
          prologue: this.prologue,
          s: this.staticKey,
          extensions: {
            streamMuxers,
            webtransportCerthashes: [],
            ...this.extensions
          }
        }, options2);
        this.metrics?.xxHandshakeSuccesses.increment();
      } catch (e2) {
        this.metrics?.xxHandshakeErrors.increment();
        throw e2;
      }
      return result;
    }
    /**
     * Perform XX handshake as responder.
     */
    async performHandshakeResponder(connection, privateKey, log18, remoteIdentityKey, options2) {
      let result;
      const streamMuxers = options2?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
      try {
        result = await performHandshakeResponder({
          connection,
          privateKey,
          remoteIdentityKey,
          log: log18.newScope("xxhandshake"),
          crypto: this.crypto,
          prologue: this.prologue,
          s: this.staticKey,
          extensions: {
            streamMuxers,
            webtransportCerthashes: [],
            ...this.extensions
          }
        }, options2);
        this.metrics?.xxHandshakeSuccesses.increment();
      } catch (e2) {
        this.metrics?.xxHandshakeErrors.increment();
        throw e2;
      }
      return result;
    }
  };

  // node_modules/@chainsafe/libp2p-noise/dist/src/index.js
  function noise(init = {}) {
    return (components) => new Noise(components, init);
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/frame.js
  var FrameType;
  (function(FrameType2) {
    FrameType2[FrameType2["Data"] = 0] = "Data";
    FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
    FrameType2[FrameType2["Ping"] = 2] = "Ping";
    FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
  })(FrameType || (FrameType = {}));
  var Flag;
  (function(Flag2) {
    Flag2[Flag2["SYN"] = 1] = "SYN";
    Flag2[Flag2["ACK"] = 2] = "ACK";
    Flag2[Flag2["FIN"] = 4] = "FIN";
    Flag2[Flag2["RST"] = 8] = "RST";
  })(Flag || (Flag = {}));
  var flagCodes = Object.values(Flag).filter((x) => typeof x !== "string");
  var YAMUX_VERSION = 0;
  var GoAwayCode;
  (function(GoAwayCode2) {
    GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
    GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
    GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
  })(GoAwayCode || (GoAwayCode = {}));
  var HEADER_LENGTH = 12;

  // node_modules/@chainsafe/libp2p-yamux/dist/src/errors.js
  var ProtocolError2 = class extends Error {
    static name = "ProtocolError";
    reason;
    constructor(message2, reason) {
      super(message2);
      this.name = "ProtocolError";
      this.reason = reason;
    }
  };
  function isProtocolError(err2) {
    return err2?.reason !== null;
  }
  var InvalidFrameError = class extends ProtocolError2 {
    static name = "InvalidFrameError";
    constructor(message2 = "The frame was invalid") {
      super(message2, GoAwayCode.ProtocolError);
      this.name = "InvalidFrameError";
    }
  };
  var UnRequestedPingError = class extends ProtocolError2 {
    static name = "UnRequestedPingError";
    constructor(message2 = "Un-requested ping error") {
      super(message2, GoAwayCode.ProtocolError);
      this.name = "UnRequestedPingError";
    }
  };
  var NotMatchingPingError = class extends ProtocolError2 {
    static name = "NotMatchingPingError";
    constructor(message2 = "Not matching ping error") {
      super(message2, GoAwayCode.ProtocolError);
      this.name = "NotMatchingPingError";
    }
  };
  var StreamAlreadyExistsError = class extends ProtocolError2 {
    static name = "StreamAlreadyExistsError";
    constructor(message2 = "Stream already exists") {
      super(message2, GoAwayCode.ProtocolError);
      this.name = "StreamAlreadyExistsError";
    }
  };
  var DecodeInvalidVersionError = class extends ProtocolError2 {
    static name = "DecodeInvalidVersionError";
    constructor(message2 = "Decode invalid version") {
      super(message2, GoAwayCode.ProtocolError);
      this.name = "DecodeInvalidVersionError";
    }
  };
  var BothClientsError = class extends ProtocolError2 {
    static name = "BothClientsError";
    constructor(message2 = "Both clients") {
      super(message2, GoAwayCode.ProtocolError);
      this.name = "BothClientsError";
    }
  };
  var ReceiveWindowExceededError = class extends ProtocolError2 {
    static name = "ReceiveWindowExceededError";
    constructor(message2 = "Receive window exceeded") {
      super(message2, GoAwayCode.ProtocolError);
      this.name = "ReceiveWindowExceededError";
    }
  };

  // node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js
  var PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
    InvalidFrameError.name,
    UnRequestedPingError.name,
    NotMatchingPingError.name,
    StreamAlreadyExistsError.name,
    DecodeInvalidVersionError.name,
    BothClientsError.name,
    ReceiveWindowExceededError.name
  ]);
  var INITIAL_STREAM_WINDOW = 256 * 1024;
  var MAX_STREAM_WINDOW = 16 * 1024 * 1024;

  // node_modules/@chainsafe/libp2p-yamux/dist/src/config.js
  var defaultConfig = {
    enableKeepAlive: true,
    keepAliveInterval: 3e4,
    maxInboundStreams: 1e3,
    maxOutboundStreams: 1e3,
    maxMessageSize: 64 * 1024,
    maxEarlyStreams: 10,
    streamOptions: {
      initialStreamWindowSize: INITIAL_STREAM_WINDOW,
      maxStreamWindowSize: MAX_STREAM_WINDOW,
      inactivityTimeout: 12e4,
      maxReadBufferLength: 4194304,
      maxWriteBufferLength: Infinity
    }
  };
  function verifyConfig(config) {
    if (config.keepAliveInterval != null && config.keepAliveInterval <= 0) {
      throw new InvalidParametersError("keep-alive interval must be positive");
    }
    if (config.maxInboundStreams != null && config.maxInboundStreams < 0) {
      throw new InvalidParametersError("max inbound streams must be larger or equal 0");
    }
    if (config.maxOutboundStreams != null && config.maxOutboundStreams < 0) {
      throw new InvalidParametersError("max outbound streams must be larger or equal 0");
    }
    if (config.maxMessageSize != null && config.maxMessageSize < 1024) {
      throw new InvalidParametersError("MaxMessageSize must be greater than a kilobyte");
    }
    if (config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {
      throw new InvalidParametersError("InitialStreamWindowSize must be larger or equal 256 kB");
    }
    if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize < config.streamOptions?.initialStreamWindowSize) {
      throw new InvalidParametersError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");
    }
    if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize > 2 ** 32 - 1) {
      throw new InvalidParametersError("MaxStreamWindowSize must be less than equal MAX_UINT32");
    }
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/decode.js
  function isDataFrame(frame) {
    return frame.header.type === FrameType.Data && frame.data !== null;
  }
  var twoPow24 = 2 ** 24;
  function decodeHeader(data) {
    if (data[0] !== YAMUX_VERSION) {
      throw new InvalidFrameError("Invalid frame version");
    }
    return {
      type: data[1],
      flag: (data[2] << 8) + data[3],
      streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
      length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
    };
  }
  var Decoder2 = class {
    /** Buffer for in-progress frames */
    buffer;
    constructor() {
      this.buffer = new Uint8ArrayList();
    }
    /**
     * Emits frames from the decoder source.
     *
     * Note: If `readData` is emitted, it _must_ be called before the next iteration
     * Otherwise an error is thrown
     */
    *emitFrames(buf2) {
      this.buffer.append(buf2);
      while (true) {
        const frame = this.readFrame();
        if (frame === void 0) {
          break;
        }
        yield frame;
      }
    }
    readFrame() {
      let frameSize = HEADER_LENGTH;
      if (this.buffer.byteLength < HEADER_LENGTH) {
        return;
      }
      const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
      if (header.type === FrameType.Data) {
        frameSize += header.length;
        if (this.buffer.byteLength < frameSize) {
          return;
        }
        const data = this.buffer.sublist(HEADER_LENGTH, frameSize);
        this.buffer.consume(frameSize);
        return { header, data };
      }
      this.buffer.consume(frameSize);
      return { header };
    }
  };

  // node_modules/@chainsafe/libp2p-yamux/dist/src/encode.js
  function encodeHeader(header) {
    const frame = new Uint8Array(HEADER_LENGTH);
    frame[1] = header.type;
    frame[2] = header.flag >>> 8;
    frame[3] = header.flag;
    frame[4] = header.streamID >>> 24;
    frame[5] = header.streamID >>> 16;
    frame[6] = header.streamID >>> 8;
    frame[7] = header.streamID;
    frame[8] = header.length >>> 24;
    frame[9] = header.length >>> 16;
    frame[10] = header.length >>> 8;
    frame[11] = header.length;
    return frame;
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js
  var StreamState;
  (function(StreamState2) {
    StreamState2[StreamState2["Init"] = 0] = "Init";
    StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
    StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
    StreamState2[StreamState2["Established"] = 3] = "Established";
    StreamState2[StreamState2["Finished"] = 4] = "Finished";
    StreamState2[StreamState2["Paused"] = 5] = "Paused";
  })(StreamState || (StreamState = {}));
  var YamuxStream = class extends AbstractStream {
    streamId;
    state;
    /** The number of available bytes to send */
    sendWindowCapacity;
    /** The number of bytes available to receive in a full window */
    recvWindow;
    /** The number of available bytes to receive */
    recvWindowCapacity;
    maxStreamWindowSize;
    /**
     * An 'epoch' is the time it takes to process and read data
     *
     * Used in conjunction with RTT to determine whether to increase the recvWindow
     */
    epochStart;
    getRTT;
    sendFrame;
    constructor(init) {
      const initialWindowSize = init.initialStreamWindowSize ?? INITIAL_STREAM_WINDOW;
      super({
        ...init,
        maxMessageSize: initialWindowSize - HEADER_LENGTH
      });
      this.streamId = init.streamId;
      this.state = init.state;
      this.sendWindowCapacity = initialWindowSize;
      this.recvWindow = initialWindowSize;
      this.recvWindowCapacity = this.recvWindow;
      this.maxStreamWindowSize = init.maxStreamWindowSize ?? MAX_STREAM_WINDOW;
      this.epochStart = Date.now();
      this.getRTT = init.getRTT;
      this.sendFrame = init.sendFrame;
      const setStateToFinishedOnCloseListener = () => {
        this.state = StreamState.Finished;
      };
      this.addEventListener("close", setStateToFinishedOnCloseListener);
    }
    /**
     * Send a data message to the remote muxer
     */
    sendData(buf2) {
      const totalBytes = buf2.byteLength;
      let sentBytes = 0;
      let canSendMore = true;
      this.log?.trace("send window capacity is %d bytes", this.sendWindowCapacity);
      while (buf2.byteLength > 0) {
        if (this.sendWindowCapacity === 0) {
          canSendMore = false;
          this.log?.trace("sent %d/%d bytes, exhausted send window, waiting for window update", sentBytes, totalBytes);
          break;
        }
        const toSend = Math.min(this.sendWindowCapacity, buf2.byteLength);
        const flags = this.getSendFlags();
        const data = buf2.sublist(0, toSend);
        buf2.consume(toSend);
        const muxerSendMore = this.sendFrame({
          type: FrameType.Data,
          flag: flags,
          streamID: this.streamId,
          length: toSend
        }, data);
        this.sendWindowCapacity -= toSend;
        sentBytes += toSend;
        if (!muxerSendMore) {
          canSendMore = muxerSendMore;
          this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity", sentBytes, totalBytes);
          break;
        }
      }
      return {
        sentBytes,
        canSendMore
      };
    }
    /**
     * Send a reset message to the remote muxer
     */
    sendReset() {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: this.streamId,
        length: 0
      });
    }
    /**
     * Send a message to the remote muxer, informing them no more data messages
     * will be sent by this end of the stream
     */
    async sendCloseWrite() {
      const flags = this.getSendFlags() | Flag.FIN;
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: flags,
        streamID: this.streamId,
        length: 0
      });
    }
    /**
     * Send a message to the remote muxer, informing them no more data messages
     * will be read by this end of the stream - this is a no-op on Yamux streams
     */
    async sendCloseRead(options2) {
      options2?.signal?.throwIfAborted();
    }
    /**
     * Stop sending window updates temporarily - in the interim the the remote
     * send window will exhaust and the remote will stop sending data
     */
    sendPause() {
      this.state = StreamState.Paused;
    }
    /**
     * Start sending window updates as normal
     */
    sendResume() {
      this.state = StreamState.Established;
      this.sendWindowUpdate();
    }
    /**
     * handleWindowUpdate is called when the stream receives a window update frame
     */
    handleWindowUpdate(frame) {
      this.processFlags(frame.header.flag);
      this.sendWindowCapacity += frame.header.length;
      this.maxMessageSize = this.sendWindowCapacity - HEADER_LENGTH;
      if (this.maxMessageSize < 0) {
        this.maxMessageSize = 0;
      }
      if (this.maxMessageSize === 0) {
        return;
      }
      if (this.writeBuffer.byteLength > 0) {
        this.log?.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s", frame.header.length, this.writeBuffer.byteLength, this.sendingData);
        this.safeDispatchEvent("drain");
      }
    }
    /**
     * handleData is called when the stream receives a data frame
     */
    handleData(frame) {
      if (!isDataFrame(frame)) {
        throw new InvalidFrameError("Frame was not data frame");
      }
      this.processFlags(frame.header.flag);
      if (this.recvWindowCapacity < frame.header.length) {
        throw new ReceiveWindowExceededError("Receive window exceeded");
      }
      this.recvWindowCapacity -= frame.header.length;
      this.onData(frame.data);
      this.sendWindowUpdate();
    }
    /**
     * processFlags is used to update the state of the stream based on set flags, if any.
     */
    processFlags(flags) {
      if ((flags & Flag.ACK) === Flag.ACK) {
        if (this.state === StreamState.SYNSent) {
          this.state = StreamState.Established;
        }
      }
      if ((flags & Flag.FIN) === Flag.FIN) {
        this.onRemoteCloseWrite();
      }
      if ((flags & Flag.RST) === Flag.RST) {
        this.onRemoteReset();
      }
    }
    /**
     * getSendFlags determines any flags that are appropriate
     * based on the current stream state.
     *
     * The state is updated as a side-effect.
     */
    getSendFlags() {
      switch (this.state) {
        case StreamState.Init:
          this.state = StreamState.SYNSent;
          return Flag.SYN;
        case StreamState.SYNReceived:
          this.state = StreamState.Established;
          return Flag.ACK;
        default:
          return 0;
      }
    }
    /**
     * Potentially sends a window update enabling further remote writes to take
     * place.
     */
    sendWindowUpdate() {
      if (this.state === StreamState.Paused) {
        this.epochStart = Date.now();
        return;
      }
      const flags = this.getSendFlags();
      const now = Date.now();
      const rtt = this.getRTT();
      if (flags === 0 && rtt > -1 && now - this.epochStart <= rtt * 4) {
        this.recvWindow = Math.min(this.recvWindow * 2, this.maxStreamWindowSize);
      }
      if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
        return;
      }
      const delta = this.recvWindow - this.recvWindowCapacity;
      this.recvWindowCapacity = this.recvWindow;
      this.epochStart = now;
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: flags,
        streamID: this.streamId,
        length: delta
      });
    }
  };

  // node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
  function debugFrame(header) {
    return {
      type: FrameType[header.type],
      flags: [
        (header.flag & Flag.SYN) === Flag.SYN ? "SYN" : void 0,
        (header.flag & Flag.ACK) === Flag.ACK ? "ACK" : void 0,
        (header.flag & Flag.FIN) === Flag.FIN ? "FIN" : void 0,
        (header.flag & Flag.RST) === Flag.RST ? "RST" : void 0
      ].filter(Boolean),
      streamID: header.streamID,
      length: header.length
    };
  }
  var YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
  var Yamux = class {
    protocol = YAMUX_PROTOCOL_ID;
    _init;
    constructor(init = {}) {
      this._init = init;
    }
    [Symbol.toStringTag] = "@chainsafe/libp2p-yamux";
    [serviceCapabilities] = [
      "@libp2p/stream-multiplexing"
    ];
    createStreamMuxer(maConn) {
      return new YamuxMuxer(maConn, {
        ...this._init
      });
    }
  };
  var YamuxMuxer = class extends AbstractStreamMuxer {
    /** The next stream id to be used when initiating a new stream */
    nextStreamID;
    /** The next ping id to be used when pinging */
    nextPingID;
    /** Tracking info for the currently active ping */
    activePing;
    /** Round trip time */
    rtt;
    /** True if client, false if server */
    client;
    localGoAway;
    remoteGoAway;
    /** Number of tracked inbound streams */
    numInboundStreams;
    /** Number of tracked outbound streams */
    numOutboundStreams;
    decoder;
    keepAlive;
    enableKeepAlive;
    keepAliveInterval;
    maxInboundStreams;
    maxOutboundStreams;
    constructor(maConn, init = {}) {
      super(maConn, {
        ...init,
        protocol: YAMUX_PROTOCOL_ID,
        name: "yamux"
      });
      this.client = maConn.direction === "outbound";
      verifyConfig(init);
      this.enableKeepAlive = init.enableKeepAlive ?? defaultConfig.enableKeepAlive;
      this.keepAliveInterval = init.keepAliveInterval ?? defaultConfig.keepAliveInterval;
      this.maxInboundStreams = init.maxInboundStreams ?? defaultConfig.maxInboundStreams;
      this.maxOutboundStreams = init.maxOutboundStreams ?? defaultConfig.maxOutboundStreams;
      this.decoder = new Decoder2();
      this.numInboundStreams = 0;
      this.numOutboundStreams = 0;
      this.nextStreamID = this.client ? 1 : 2;
      this.nextPingID = 0;
      this.rtt = -1;
      this.log.trace("muxer created");
      if (this.enableKeepAlive) {
        this.log.trace("muxer keepalive enabled interval=%s", this.keepAliveInterval);
        this.keepAlive = repeatingTask(async (options2) => {
          try {
            await this.ping(options2);
          } catch (err2) {
            this.log.error("ping error: %s", err2);
          }
        }, this.keepAliveInterval, {
          // send an initial ping to establish RTT
          runImmediately: true
        });
        this.keepAlive.start();
      }
    }
    onData(buf2) {
      for (const frame of this.decoder.emitFrames(buf2)) {
        this.handleFrame(frame);
      }
    }
    onCreateStream() {
      if (this.remoteGoAway !== void 0) {
        throw new MuxerClosedError("Muxer closed remotely");
      }
      if (this.localGoAway !== void 0) {
        throw new MuxerClosedError("Muxer closed locally");
      }
      const id = this.nextStreamID;
      this.nextStreamID += 2;
      if (this.numOutboundStreams >= this.maxOutboundStreams) {
        throw new TooManyOutboundProtocolStreamsError("max outbound streams exceeded");
      }
      this.log.trace("new outgoing stream id=%s", id);
      const stream = this._newStream(id, StreamState.Init, "outbound");
      this.numOutboundStreams++;
      queueMicrotask(() => {
        stream.sendWindowUpdate();
      });
      return stream;
    }
    /**
     * Initiate a ping and wait for a response
     *
     * Note: only a single ping will be initiated at a time.
     * If a ping is already in progress, a new ping will not be initiated.
     *
     * @returns the round-trip-time in milliseconds
     */
    async ping(options2) {
      if (this.remoteGoAway !== void 0) {
        throw new MuxerClosedError("Muxer closed remotely");
      }
      if (this.localGoAway !== void 0) {
        throw new MuxerClosedError("Muxer closed locally");
      }
      if (this.activePing != null) {
        return raceSignal(this.activePing.promise, options2?.signal);
      }
      this.activePing = Object.assign(Promise.withResolvers(), {
        id: this.nextPingID++,
        start: Date.now()
      });
      this.sendPing(this.activePing.id);
      try {
        this.rtt = await raceSignal(this.activePing.promise, options2?.signal);
      } finally {
        this.activePing = void 0;
      }
      return this.rtt;
    }
    /**
     * Get the ping round trip time
     *
     * Note: Will return 0 if no successful ping has yet been completed
     *
     * @returns the round-trip-time in milliseconds
     */
    getRTT() {
      return this.rtt;
    }
    /**
     * Close the muxer
     */
    async close(options2 = {}) {
      if (this.status !== "open") {
        return;
      }
      try {
        const reason = options2?.reason ?? GoAwayCode.NormalTermination;
        this.log.trace("muxer close reason=%s", GoAwayCode[reason]);
        await super.close(options2);
        this.sendGoAway(reason);
      } finally {
        this.keepAlive?.stop();
      }
    }
    abort(err2) {
      if (this.status !== "open") {
        return;
      }
      try {
        super.abort(err2);
        let reason = GoAwayCode.InternalError;
        if (isProtocolError(err2)) {
          reason = err2.reason;
        }
        this.log.error("muxer abort reason=%s error=%s", reason, err2);
        this.sendGoAway(reason);
      } finally {
        this.keepAlive?.stop();
      }
    }
    onTransportClosed() {
      try {
        super.onTransportClosed();
      } finally {
        this.keepAlive?.stop();
      }
    }
    /** Create a new stream */
    _newStream(streamId, state, direction) {
      if (this.streams.find((s2) => s2.streamId === streamId) != null) {
        throw new InvalidParametersError("Stream already exists with that id");
      }
      const stream = new YamuxStream({
        ...this.streamOptions,
        id: `${streamId}`,
        streamId,
        state,
        direction,
        sendFrame: this.sendFrame.bind(this),
        log: this.log.newScope(`${direction}:${streamId}`),
        getRTT: this.getRTT.bind(this)
      });
      stream.addEventListener("close", () => {
        this.closeStream(streamId);
      }, {
        once: true
      });
      return stream;
    }
    /**
     * closeStream is used to close a stream once both sides have
     * issued a close.
     */
    closeStream(id) {
      if (this.client === (id % 2 === 0)) {
        this.numInboundStreams--;
      } else {
        this.numOutboundStreams--;
      }
    }
    handleFrame(frame) {
      const { streamID, type, length: length4 } = frame.header;
      this.log.trace("received frame %o", debugFrame(frame.header));
      if (streamID === 0) {
        switch (type) {
          case FrameType.Ping: {
            this.handlePing(frame.header);
            return;
          }
          case FrameType.GoAway: {
            this.handleGoAway(length4);
            return;
          }
          default:
            throw new InvalidFrameError("Invalid frame type");
        }
      } else {
        switch (frame.header.type) {
          case FrameType.Data:
          case FrameType.WindowUpdate: {
            this.handleStreamMessage(frame);
            return;
          }
          default:
            throw new InvalidFrameError("Invalid frame type");
        }
      }
    }
    handlePing(header) {
      if (header.flag === Flag.SYN) {
        this.log.trace("received ping request pingId=%s", header.length);
        this.sendPing(header.length, Flag.ACK);
      } else if (header.flag === Flag.ACK) {
        this.log.trace("received ping response pingId=%s", header.length);
        this.handlePingResponse(header.length);
      } else {
        throw new InvalidFrameError("Invalid frame flag");
      }
    }
    handlePingResponse(pingId) {
      if (this.activePing === void 0) {
        throw new UnRequestedPingError("ping not requested");
      }
      if (this.activePing.id !== pingId) {
        throw new NotMatchingPingError("ping doesn't match our id");
      }
      this.activePing.resolve(Date.now() - this.activePing.start);
    }
    handleGoAway(reason) {
      this.log.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
      this.remoteGoAway = reason;
      if (reason === GoAwayCode.NormalTermination) {
        this.onTransportClosed();
      } else {
        this.abort(new Error("Remote sent GoAway"));
      }
    }
    handleStreamMessage(frame) {
      const { streamID, flag, type } = frame.header;
      if ((flag & Flag.SYN) === Flag.SYN) {
        this.incomingStream(streamID);
      }
      const stream = this.streams.find((s2) => s2.streamId === streamID);
      if (stream === void 0) {
        this.log.trace("frame for missing stream id=%s", streamID);
        return;
      }
      switch (type) {
        case FrameType.WindowUpdate: {
          stream.handleWindowUpdate(frame);
          return;
        }
        case FrameType.Data: {
          stream.handleData(frame);
          return;
        }
        default:
          throw new Error("unreachable");
      }
    }
    incomingStream(id) {
      if (this.client !== (id % 2 === 0)) {
        throw new InvalidParametersError("Both endpoints are clients");
      }
      if (this.streams.find((s2) => s2.streamId === id)) {
        return;
      }
      this.log.trace("new incoming stream id=%s", id);
      if (this.localGoAway !== void 0) {
        this.sendFrame({
          type: FrameType.WindowUpdate,
          flag: Flag.RST,
          streamID: id,
          length: 0
        });
        return;
      }
      if (this.numInboundStreams >= this.maxInboundStreams) {
        this.log("maxIncomingStreams exceeded, forcing stream reset");
        this.sendFrame({
          type: FrameType.WindowUpdate,
          flag: Flag.RST,
          streamID: id,
          length: 0
        });
        return;
      }
      const stream = this._newStream(id, StreamState.SYNReceived, "inbound");
      this.numInboundStreams++;
      this.onRemoteStream(stream);
    }
    sendFrame(header, data) {
      let encoded;
      if (header.type === FrameType.Data) {
        if (data == null) {
          throw new InvalidFrameError("Invalid frame");
        }
        encoded = new Uint8ArrayList(encodeHeader(header), data);
      } else {
        encoded = encodeHeader(header);
      }
      this.log.trace("sending frame %o", debugFrame(header));
      return this.send(encoded);
    }
    sendPing(pingId, flag = Flag.SYN) {
      if (flag === Flag.SYN) {
        this.log.trace("sending ping request pingId=%s", pingId);
      } else {
        this.log.trace("sending ping response pingId=%s", pingId);
      }
      this.sendFrame({
        type: FrameType.Ping,
        flag,
        streamID: 0,
        length: pingId
      });
    }
    sendGoAway(reason = GoAwayCode.NormalTermination) {
      this.log("sending GoAway reason=%s", GoAwayCode[reason]);
      this.localGoAway = reason;
      this.sendFrame({
        type: FrameType.GoAway,
        flag: 0,
        streamID: 0,
        length: reason
      });
    }
  };

  // node_modules/@chainsafe/libp2p-yamux/dist/src/index.js
  function yamux(init = {}) {
    return () => new Yamux(init);
  }

  // node_modules/@libp2p/autonat/dist/src/constants.js
  var PROTOCOL_PREFIX2 = "libp2p";
  var PROTOCOL_NAME2 = "autonat";
  var PROTOCOL_VERSION2 = "1.0.0";
  var TIMEOUT = 3e4;
  var MAX_INBOUND_STREAMS = 2;
  var MAX_OUTBOUND_STREAMS = 20;
  var DEFAULT_CONNECTION_THRESHOLD = 80;
  var MAX_MESSAGE_SIZE = 8192;

  // node_modules/@libp2p/autonat/dist/src/pb/index.js
  var Message;
  (function(Message5) {
    let MessageType2;
    (function(MessageType3) {
      MessageType3["DIAL"] = "DIAL";
      MessageType3["DIAL_RESPONSE"] = "DIAL_RESPONSE";
    })(MessageType2 = Message5.MessageType || (Message5.MessageType = {}));
    let __MessageTypeValues2;
    (function(__MessageTypeValues3) {
      __MessageTypeValues3[__MessageTypeValues3["DIAL"] = 0] = "DIAL";
      __MessageTypeValues3[__MessageTypeValues3["DIAL_RESPONSE"] = 1] = "DIAL_RESPONSE";
    })(__MessageTypeValues2 || (__MessageTypeValues2 = {}));
    (function(MessageType3) {
      MessageType3.codec = () => {
        return enumeration(__MessageTypeValues2);
      };
    })(MessageType2 = Message5.MessageType || (Message5.MessageType = {}));
    let ResponseStatus;
    (function(ResponseStatus2) {
      ResponseStatus2["OK"] = "OK";
      ResponseStatus2["E_DIAL_ERROR"] = "E_DIAL_ERROR";
      ResponseStatus2["E_DIAL_REFUSED"] = "E_DIAL_REFUSED";
      ResponseStatus2["E_BAD_REQUEST"] = "E_BAD_REQUEST";
      ResponseStatus2["E_INTERNAL_ERROR"] = "E_INTERNAL_ERROR";
    })(ResponseStatus = Message5.ResponseStatus || (Message5.ResponseStatus = {}));
    let __ResponseStatusValues;
    (function(__ResponseStatusValues2) {
      __ResponseStatusValues2[__ResponseStatusValues2["OK"] = 0] = "OK";
      __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_ERROR"] = 100] = "E_DIAL_ERROR";
      __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_REFUSED"] = 101] = "E_DIAL_REFUSED";
      __ResponseStatusValues2[__ResponseStatusValues2["E_BAD_REQUEST"] = 200] = "E_BAD_REQUEST";
      __ResponseStatusValues2[__ResponseStatusValues2["E_INTERNAL_ERROR"] = 300] = "E_INTERNAL_ERROR";
    })(__ResponseStatusValues || (__ResponseStatusValues = {}));
    (function(ResponseStatus2) {
      ResponseStatus2.codec = () => {
        return enumeration(__ResponseStatusValues);
      };
    })(ResponseStatus = Message5.ResponseStatus || (Message5.ResponseStatus = {}));
    let PeerInfo2;
    (function(PeerInfo3) {
      let _codec2;
      PeerInfo3.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.id != null) {
              w.uint32(10);
              w.bytes(obj.id);
            }
            if (obj.addrs != null) {
              for (const value2 of obj.addrs) {
                w.uint32(18);
                w.bytes(value2);
              }
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length4, opts = {}) => {
            const obj = {
              addrs: []
            };
            const end = length4 == null ? reader2.len : reader2.pos + length4;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.id = reader2.bytes();
                  break;
                }
                case 2: {
                  if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                    throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
                  }
                  obj.addrs.push(reader2.bytes());
                  break;
                }
                default: {
                  reader2.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      PeerInfo3.encode = (obj) => {
        return encodeMessage(obj, PeerInfo3.codec());
      };
      PeerInfo3.decode = (buf2, opts) => {
        return decodeMessage(buf2, PeerInfo3.codec(), opts);
      };
    })(PeerInfo2 = Message5.PeerInfo || (Message5.PeerInfo = {}));
    let Dial;
    (function(Dial2) {
      let _codec2;
      Dial2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.peer != null) {
              w.uint32(10);
              Message5.PeerInfo.codec().encode(obj.peer, w);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length4, opts = {}) => {
            const obj = {};
            const end = length4 == null ? reader2.len : reader2.pos + length4;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.peer = Message5.PeerInfo.codec().decode(reader2, reader2.uint32(), {
                    limits: opts.limits?.peer
                  });
                  break;
                }
                default: {
                  reader2.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Dial2.encode = (obj) => {
        return encodeMessage(obj, Dial2.codec());
      };
      Dial2.decode = (buf2, opts) => {
        return decodeMessage(buf2, Dial2.codec(), opts);
      };
    })(Dial = Message5.Dial || (Message5.Dial = {}));
    let DialResponse;
    (function(DialResponse2) {
      let _codec2;
      DialResponse2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w.fork();
            }
            if (obj.status != null) {
              w.uint32(8);
              Message5.ResponseStatus.codec().encode(obj.status, w);
            }
            if (obj.statusText != null) {
              w.uint32(18);
              w.string(obj.statusText);
            }
            if (obj.addr != null) {
              w.uint32(26);
              w.bytes(obj.addr);
            }
            if (opts.lengthDelimited !== false) {
              w.ldelim();
            }
          }, (reader2, length4, opts = {}) => {
            const obj = {};
            const end = length4 == null ? reader2.len : reader2.pos + length4;
            while (reader2.pos < end) {
              const tag = reader2.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.status = Message5.ResponseStatus.codec().decode(reader2);
                  break;
                }
                case 2: {
                  obj.statusText = reader2.string();
                  break;
                }
                case 3: {
                  obj.addr = reader2.bytes();
                  break;
                }
                default: {
                  reader2.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      DialResponse2.encode = (obj) => {
        return encodeMessage(obj, DialResponse2.codec());
      };
      DialResponse2.decode = (buf2, opts) => {
        return decodeMessage(buf2, DialResponse2.codec(), opts);
      };
    })(DialResponse = Message5.DialResponse || (Message5.DialResponse = {}));
    let _codec;
    Message5.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.type != null) {
            w.uint32(8);
            Message5.MessageType.codec().encode(obj.type, w);
          }
          if (obj.dial != null) {
            w.uint32(18);
            Message5.Dial.codec().encode(obj.dial, w);
          }
          if (obj.dialResponse != null) {
            w.uint32(26);
            Message5.DialResponse.codec().encode(obj.dialResponse, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.type = Message5.MessageType.codec().decode(reader2);
                break;
              }
              case 2: {
                obj.dial = Message5.Dial.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.dial
                });
                break;
              }
              case 3: {
                obj.dialResponse = Message5.DialResponse.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.dialResponse
                });
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Message5.encode = (obj) => {
      return encodeMessage(obj, Message5.codec());
    };
    Message5.decode = (buf2, opts) => {
      return decodeMessage(buf2, Message5.codec(), opts);
    };
  })(Message || (Message = {}));

  // node_modules/@libp2p/autonat/dist/src/autonat.js
  var REQUIRED_SUCCESSFUL_DIALS = 4;
  var REQUIRED_FAILED_DIALS = 8;
  var AutoNATService = class {
    components;
    protocol;
    timeout;
    maxInboundStreams;
    maxOutboundStreams;
    maxMessageSize;
    started;
    log;
    topologyId;
    dialResults;
    findPeers;
    addressFilter;
    connectionThreshold;
    constructor(components, init) {
      this.components = components;
      this.log = components.logger.forComponent("libp2p:auto-nat");
      this.started = false;
      this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX2}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
      this.timeout = init.timeout ?? TIMEOUT;
      this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
      this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
      this.connectionThreshold = init.connectionThreshold ?? DEFAULT_CONNECTION_THRESHOLD;
      this.maxMessageSize = init.maxMessageSize ?? MAX_MESSAGE_SIZE;
      this.dialResults = trackedMap({
        name: "libp2p_autonat_dial_results",
        metrics: components.metrics
      });
      this.findPeers = repeatingTask(this.findRandomPeers.bind(this), 6e4);
      this.addressFilter = createScalableCuckooFilter(1024);
    }
    [Symbol.toStringTag] = "@libp2p/autonat";
    [serviceCapabilities] = [
      "@libp2p/autonat"
    ];
    get [serviceDependencies]() {
      return [
        "@libp2p/identify"
      ];
    }
    isStarted() {
      return this.started;
    }
    async start() {
      if (this.started) {
        return;
      }
      await this.components.registrar.handle(this.protocol, (stream, connection) => {
        void this.handleIncomingAutonatStream(stream, connection).catch((err2) => {
          this.log.error("error handling incoming autonat stream - %e", err2);
        });
      }, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
      this.topologyId = await this.components.registrar.register(this.protocol, {
        onConnect: (peerId, connection) => {
          this.verifyExternalAddresses(connection).catch((err2) => {
            this.log.error("could not verify addresses - %e", err2);
          });
        }
      });
      this.findPeers.start();
      this.started = true;
    }
    async stop() {
      await this.components.registrar.unhandle(this.protocol);
      if (this.topologyId != null) {
        await this.components.registrar.unhandle(this.topologyId);
      }
      this.dialResults.clear();
      this.findPeers.stop();
      this.started = false;
    }
    allAddressesAreVerified() {
      return this.components.addressManager.getAddressesWithMetadata().every((addr) => {
        if (addr.expires > Date.now()) {
          return true;
        }
        return addr.verified;
      });
    }
    async findRandomPeers(options2) {
      if (this.allAddressesAreVerified()) {
        return;
      }
      const signal = anySignal([
        AbortSignal.timeout(1e4),
        options2?.signal
      ]);
      try {
        this.log("starting random walk to find peers to run AutoNAT");
        for await (const peer of this.components.randomWalk.walk({ signal })) {
          if (!await this.components.connectionManager.isDialable(peer.multiaddrs)) {
            this.log.trace("random peer %p was not dialable %s", peer.id, peer.multiaddrs.map((ma) => ma.toString()).join(", "));
            continue;
          }
          try {
            this.log.trace("dial random peer %p", peer.id);
            await this.components.connectionManager.openConnection(peer.multiaddrs, {
              signal
            });
          } catch {
          }
          if (this.allAddressesAreVerified()) {
            this.log("stopping random walk, all addresses are verified");
            return;
          }
          if (!this.hasConnectionCapacity()) {
            this.log("stopping random walk, too close to max connections");
            return;
          }
        }
      } catch {
      }
    }
    /**
     * Handle an incoming AutoNAT request
     */
    async handleIncomingAutonatStream(stream, connection) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      try {
        const messages2 = pbStream(stream, {
          maxDataLength: this.maxMessageSize
        }).pb(Message);
        const request = await messages2.read({
          signal
        });
        const response = await this.handleAutonatMessage(request, connection, {
          signal
        });
        await messages2.write(response, {
          signal
        });
        await stream.close({
          signal
        });
      } catch (err2) {
        this.log.error("error handling incoming autonat stream - %e", err2);
        stream.abort(err2);
      }
    }
    async handleAutonatMessage(message2, connection, options2) {
      const ourHosts = this.components.addressManager.getAddresses().map((ma) => getNetConfig(ma).host);
      const dialRequest = message2.dial;
      if (dialRequest == null) {
        this.log.error("dial was missing from message");
        return {
          type: Message.MessageType.DIAL_RESPONSE,
          dialResponse: {
            status: Message.ResponseStatus.E_BAD_REQUEST,
            statusText: "No Dial message found in message"
          }
        };
      }
      let peerId;
      const peer = dialRequest.peer;
      if (peer?.id == null) {
        this.log.error("peerId missing from message");
        return {
          type: Message.MessageType.DIAL_RESPONSE,
          dialResponse: {
            status: Message.ResponseStatus.E_BAD_REQUEST,
            statusText: "missing peer info"
          }
        };
      }
      try {
        const digest2 = decode4(peer.id);
        peerId = peerIdFromMultihash(digest2);
      } catch (err2) {
        this.log.error("invalid PeerId - %e", err2);
        return {
          type: Message.MessageType.DIAL_RESPONSE,
          dialResponse: {
            status: Message.ResponseStatus.E_BAD_REQUEST,
            statusText: "bad peer id"
          }
        };
      }
      this.log("incoming request from %p", peerId);
      if (!connection.remotePeer.equals(peerId)) {
        this.log("target peer %p did not equal sending peer %p", peerId, connection.remotePeer);
        return {
          type: Message.MessageType.DIAL_RESPONSE,
          dialResponse: {
            status: Message.ResponseStatus.E_BAD_REQUEST,
            statusText: "peer id mismatch"
          }
        };
      }
      const multiaddrs = peer.addrs.map((buf2) => multiaddr(buf2)).filter((ma) => {
        try {
          const options3 = getNetConfig(ma);
          if (isPrivate(ma)) {
            return false;
          }
          if (options3.host !== getNetConfig(connection.remoteAddr).host) {
            this.log.trace("not dialing %a - target host did not match remote host %a", ma, connection.remoteAddr);
            return false;
          }
          if (ourHosts.includes(options3.host)) {
            return false;
          }
          if (this.components.transportManager.dialTransportForMultiaddr(ma) == null) {
            this.log.trace("not dialing %a - transport unsupported", ma);
            return false;
          }
          return true;
        } catch {
          return false;
        }
      }).map((ma) => {
        if (ma.getComponents().find((c2) => c2.code === CODE_P2P)?.value == null) {
          ma = ma.encapsulate(`/p2p/${peerId.toString()}`);
        }
        return ma;
      });
      if (multiaddrs.length === 0) {
        this.log("refused to dial all multiaddrs for %p from message", peerId);
        return {
          type: Message.MessageType.DIAL_RESPONSE,
          dialResponse: {
            status: Message.ResponseStatus.E_DIAL_REFUSED,
            statusText: "no dialable addresses"
          }
        };
      }
      this.log("dial multiaddrs %s for peer %p", multiaddrs.map((ma) => ma.toString()).join(", "), peerId);
      let errorMessage = "";
      let lastMultiaddr = multiaddrs[0];
      for (const multiaddr2 of multiaddrs) {
        let connection2;
        lastMultiaddr = multiaddr2;
        try {
          connection2 = await this.components.connectionManager.openConnection(multiaddr2, options2);
          if (!connection2.remoteAddr.equals(multiaddr2)) {
            this.log.error("tried to dial %a but dialed %a", multiaddr2, connection2.remoteAddr);
            throw new Error("Unexpected remote address");
          }
          this.log("successfully dialed %p via %a", peerId, multiaddr2);
          return {
            type: Message.MessageType.DIAL_RESPONSE,
            dialResponse: {
              status: Message.ResponseStatus.OK,
              addr: connection2.remoteAddr.decapsulateCode(CODE_P2P).bytes
            }
          };
        } catch (err2) {
          this.log.error("could not dial %p - %e", peerId, err2);
          errorMessage = err2.message;
        } finally {
          if (connection2 != null) {
            await connection2.close();
          }
        }
      }
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_DIAL_ERROR,
          statusText: errorMessage,
          addr: lastMultiaddr.bytes
        }
      };
    }
    /**
     * The AutoNAT v1 server is not required to send us the address that it
     * dialed successfully.
     *
     * When addresses fail, it can be because they are NATed, or because the peer
     * did't support the transport, we have no way of knowing, so just send them
     * one address so we can treat the response as:
     *
     * - OK - the dial request worked and the address is not NATed
     * - E_DIAL_ERROR - the dial request failed and the address may be NATed
     * - E_DIAL_REFUSED/E_BAD_REQUEST/E_INTERNAL_ERROR - the remote didn't dial the address
     */
    getFirstUnverifiedMultiaddr(segment, supportsIPv6) {
      const addrs = this.components.addressManager.getAddressesWithMetadata().sort((a2, b) => {
        if (a2.type === "observed" && b.type !== "observed") {
          return 1;
        }
        if (b.type === "observed" && a2.type !== "observed") {
          return -1;
        }
        return 0;
      }).filter((addr) => {
        const expired = addr.expires < Date.now();
        if (!expired) {
          return false;
        }
        const options2 = getNetConfig(addr.multiaddr);
        if (options2.type === "ip6") {
          if (!supportsIPv6) {
            return false;
          }
          if (!isGlobalUnicast(addr.multiaddr)) {
            return false;
          }
        }
        if (isPrivate(addr.multiaddr)) {
          return false;
        }
        return true;
      });
      for (const addr of addrs) {
        const addrString = addr.multiaddr.toString();
        let results = this.dialResults.get(addrString);
        if (results != null) {
          if (results.networkSegments.includes(segment)) {
            this.log.trace("%a already has a network segment result from %s", results.multiaddr, segment);
            continue;
          }
          if (results.queue.size > 10) {
            this.log.trace("%a already has enough peers queued", results.multiaddr);
            continue;
          }
        }
        if (results == null) {
          const needsRevalidating = addr.expires < Date.now();
          if (needsRevalidating) {
            this.addressFilter.remove?.(addrString);
          }
          if (this.addressFilter.has(addrString)) {
            continue;
          }
          this.addressFilter.add(addrString);
          this.log.trace("creating dial result %s %s", needsRevalidating ? "to revalidate" : "for", addrString);
          results = {
            multiaddr: addr.multiaddr,
            success: 0,
            failure: 0,
            networkSegments: [],
            verifyingPeers: peerSet(),
            queue: new PeerQueue({
              concurrency: 3,
              maxSize: 50
            }),
            type: addr.type,
            lastVerified: addr.lastVerified
          };
          this.dialResults.set(addrString, results);
        }
        return results;
      }
    }
    /**
     * Removes any multiaddr result objects created for old multiaddrs that we are
     * no longer waiting on
     */
    removeOutdatedMultiaddrResults() {
      const unverifiedMultiaddrs = new Set(this.components.addressManager.getAddressesWithMetadata().filter(({ expires }) => {
        if (expires < Date.now()) {
          return true;
        }
        return false;
      }).map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      for (const multiaddr2 of this.dialResults.keys()) {
        if (!unverifiedMultiaddrs.has(multiaddr2)) {
          this.log.trace("remove results for %a", multiaddr2);
          this.dialResults.delete(multiaddr2);
        }
      }
    }
    /**
     * Our multicodec topology noticed a new peer that supports autonat
     */
    async verifyExternalAddresses(connection) {
      if (!this.isStarted()) {
        return;
      }
      this.removeOutdatedMultiaddrResults();
      const peer = await this.components.peerStore.get(connection.remotePeer);
      const supportsIPv6 = peer.addresses.some(({ multiaddr: multiaddr2 }) => {
        return getNetConfig(multiaddr2).type === "ip6";
      });
      const segment = this.getNetworkSegment(connection.remoteAddr);
      const results = this.getFirstUnverifiedMultiaddr(segment, supportsIPv6);
      if (results == null) {
        this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification", connection.remotePeer);
        return;
      }
      if (!this.hasConnectionCapacity()) {
        if (results.lastVerified != null) {
          this.log("automatically re-verifying %a because we are too close to the connection limit", results.multiaddr);
          this.confirmAddress(results);
        } else {
          this.log("skipping verifying %a because we are too close to the connection limit", results.multiaddr);
        }
        return;
      }
      results.queue.add(async (options2) => {
        await this.askPeerToVerify(connection, segment, options2);
      }, {
        peerId: connection.remotePeer,
        multiaddr: results.multiaddr
      }).catch((err2) => {
        if (results?.result == null) {
          this.log.error("error from %p verifying address %a - %e", connection.remotePeer, results?.multiaddr, err2);
        }
      });
    }
    async askPeerToVerify(connection, segment, options2) {
      let results = this.dialResults.get(options2.multiaddr.toString());
      if (results == null) {
        this.log("%a was verified while %p was queued", options2.multiaddr, connection.remotePeer);
        return;
      }
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      this.log.trace("asking %a to verify multiaddr %s", connection.remoteAddr, options2.multiaddr);
      const stream = await connection.newStream(this.protocol, {
        signal
      });
      try {
        const messages2 = pbStream(stream).pb(Message);
        const [, response] = await Promise.all([
          messages2.write({
            type: Message.MessageType.DIAL,
            dial: {
              peer: {
                id: this.components.peerId.toMultihash().bytes,
                addrs: [options2.multiaddr.bytes]
              }
            }
          }, { signal }),
          messages2.read({ signal })
        ]);
        if (response.type !== Message.MessageType.DIAL_RESPONSE || response.dialResponse == null) {
          this.log("invalid autonat response from %p - %j", connection.remotePeer, response);
          return;
        }
        const status = response.dialResponse.status;
        this.log.trace("autonat response from %p for %a is %s", connection.remotePeer, options2.multiaddr, status);
        if (status !== Message.ResponseStatus.OK && status !== Message.ResponseStatus.E_DIAL_ERROR) {
          return;
        }
        results = this.dialResults.get(options2.multiaddr.toString());
        if (results == null) {
          this.log.trace("peer reported %a as %s but there is no result object", options2.multiaddr, response.dialResponse.status);
          return;
        }
        if (results.networkSegments.includes(segment)) {
          this.log.trace("%a results included network segment %s", options2.multiaddr, segment);
          return;
        }
        if (results.result != null) {
          this.log.trace("already resolved result for %a, ignoring response from", options2.multiaddr, connection.remotePeer);
          return;
        }
        if (results.verifyingPeers.has(connection.remotePeer)) {
          this.log.trace("peer %p has already verified %a, ignoring response", connection.remotePeer, options2.multiaddr);
          return;
        }
        results.verifyingPeers.add(connection.remotePeer);
        results.networkSegments.push(segment);
        if (status === Message.ResponseStatus.OK) {
          results.success++;
          if (results.type !== "observed") {
            this.confirmAddress(results);
            return;
          }
        } else if (status === Message.ResponseStatus.E_DIAL_ERROR) {
          results.failure++;
        }
        this.log("%a success %d failure %d", results.multiaddr, results.success, results.failure);
        if (results.success === REQUIRED_SUCCESSFUL_DIALS) {
          this.confirmAddress(results);
        }
        if (results.failure === REQUIRED_FAILED_DIALS) {
          this.unconfirmAddress(results);
        }
      } finally {
        try {
          await stream.close({
            signal
          });
        } catch (err2) {
          stream.abort(err2);
        }
      }
    }
    hasConnectionCapacity() {
      const connections = this.components.connectionManager.getConnections();
      const currentConnectionCount = connections.length;
      const maxConnections = this.components.connectionManager.getMaxConnections();
      return currentConnectionCount / maxConnections * 100 < this.connectionThreshold;
    }
    confirmAddress(results) {
      this.log("%s address %a is externally dialable", results.type, results.multiaddr);
      this.components.addressManager.confirmObservedAddr(results.multiaddr);
      this.dialResults.delete(results.multiaddr.toString());
      results.result = true;
      results.queue.abort();
    }
    unconfirmAddress(results) {
      this.log("%s address %a is not externally dialable", results.type, results.multiaddr);
      this.components.addressManager.removeObservedAddr(results.multiaddr);
      this.dialResults.delete(results.multiaddr.toString());
      results.result = false;
      results.queue.abort();
    }
    getNetworkSegment(ma) {
      const options2 = getNetConfig(ma);
      switch (options2.type) {
        case "ip4": {
          const octets = options2.host.split(".");
          return octets[0].padStart(3, "0");
        }
        case "ip6": {
          const octets = options2.host.split(":");
          return octets[0].padStart(4, "0");
        }
        default: {
          throw new InvalidParametersError(`Remote address ${ma} was not an IPv4 or Ipv6 address`);
        }
      }
    }
  };

  // node_modules/@libp2p/autonat/dist/src/index.js
  function autoNAT(init = {}) {
    return (components) => {
      return new AutoNATService(components, init);
    };
  }

  // node_modules/@libp2p/bootstrap/dist/src/index.js
  var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
  var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
  var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
  var Bootstrap = class extends TypedEventEmitter {
    static tag = "bootstrap";
    log;
    timer;
    list;
    timeout;
    components;
    _init;
    constructor(components, options2 = { list: [] }) {
      if (options2.list == null || options2.list.length === 0) {
        throw new Error("Bootstrap requires a list of peer addresses");
      }
      super();
      this.components = components;
      this.log = components.logger.forComponent("libp2p:bootstrap");
      this.timeout = options2.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
      this.list = options2.list.map((str) => multiaddr(str)).filter((ma) => {
        if (!P2P.matches(ma)) {
          this.log.error("invalid multiaddr %a", ma);
          return false;
        }
        const peerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
        if (peerIdStr == null) {
          this.log.error("invalid bootstrap multiaddr without peer id");
          return false;
        }
        return true;
      }).map((ma) => {
        return {
          id: peerIdFromString(ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value ?? ""),
          multiaddrs: [ma]
        };
      });
      this._init = options2;
    }
    [peerDiscoverySymbol] = this;
    [Symbol.toStringTag] = "@libp2p/bootstrap";
    [serviceCapabilities] = [
      "@libp2p/peer-discovery"
    ];
    isStarted() {
      return Boolean(this.timer);
    }
    /**
     * Start emitting events
     */
    start() {
      if (this.isStarted()) {
        return;
      }
      this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
      this.timer = setTimeout(() => {
        void this._discoverBootstrapPeers().catch((err2) => {
          this.log.error("failed to discover bootstrap peers - %e", err2);
        });
      }, this.timeout);
    }
    /**
     * Emit each address in the list as a PeerInfo
     */
    async _discoverBootstrapPeers() {
      if (this.timer == null) {
        return;
      }
      for (const peerData of this.list) {
        await this.components.peerStore.merge(peerData.id, {
          tags: {
            [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
              value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
              ttl: this._init.tagTTL
            }
          },
          multiaddrs: peerData.multiaddrs
        });
        if (this.timer == null) {
          return;
        }
        this.safeDispatchEvent("peer", { detail: peerData });
        this.components.connectionManager.openConnection(peerData.id).catch((err2) => {
          this.log.error("could not dial bootstrap peer %p - %e", peerData.id, err2);
        });
      }
    }
    /**
     * Stop emitting events
     */
    stop() {
      if (this.timer != null) {
        clearTimeout(this.timer);
      }
      this.timer = void 0;
    }
  };
  function bootstrap(init) {
    return (components) => new Bootstrap(components, init);
  }

  // node_modules/@libp2p/circuit-relay-v2/dist/src/constants.js
  var second = 1e3;
  var minute = 60 * second;
  var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute;
  var DEFAULT_RESERVATION_CONCURRENCY = 1;
  var DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 5e3;
  var DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100;
  var KEEP_ALIVE_TAG = `${KEEP_ALIVE}-circuit-relay`;
  var DEFAULT_DURATION_LIMIT = 2 * minute;
  var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
  var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
  var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
  var DEFAULT_HOP_TIMEOUT = 30 * second;
  var DEFAULT_ADVERT_BOOT_DELAY = 30 * second;
  var MAX_CONNECTIONS2 = 300;
  var DEFAULT_DISCOVERY_FILTER_SIZE = 4096;
  var DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 1e-3;

  // node_modules/@libp2p/circuit-relay-v2/dist/src/pb/index.js
  var HopMessage;
  (function(HopMessage2) {
    let Type2;
    (function(Type3) {
      Type3["RESERVE"] = "RESERVE";
      Type3["CONNECT"] = "CONNECT";
      Type3["STATUS"] = "STATUS";
    })(Type2 = HopMessage2.Type || (HopMessage2.Type = {}));
    let __TypeValues;
    (function(__TypeValues2) {
      __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
      __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
      __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
    })(__TypeValues || (__TypeValues = {}));
    (function(Type3) {
      Type3.codec = () => {
        return enumeration(__TypeValues);
      };
    })(Type2 = HopMessage2.Type || (HopMessage2.Type = {}));
    let _codec;
    HopMessage2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.type != null) {
            w.uint32(8);
            HopMessage2.Type.codec().encode(obj.type, w);
          }
          if (obj.peer != null) {
            w.uint32(18);
            Peer2.codec().encode(obj.peer, w);
          }
          if (obj.reservation != null) {
            w.uint32(26);
            Reservation.codec().encode(obj.reservation, w);
          }
          if (obj.limit != null) {
            w.uint32(34);
            Limit.codec().encode(obj.limit, w);
          }
          if (obj.status != null) {
            w.uint32(40);
            Status.codec().encode(obj.status, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.type = HopMessage2.Type.codec().decode(reader2);
                break;
              }
              case 2: {
                obj.peer = Peer2.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.peer
                });
                break;
              }
              case 3: {
                obj.reservation = Reservation.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.reservation
                });
                break;
              }
              case 4: {
                obj.limit = Limit.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.limit
                });
                break;
              }
              case 5: {
                obj.status = Status.codec().decode(reader2);
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    HopMessage2.encode = (obj) => {
      return encodeMessage(obj, HopMessage2.codec());
    };
    HopMessage2.decode = (buf2, opts) => {
      return decodeMessage(buf2, HopMessage2.codec(), opts);
    };
  })(HopMessage || (HopMessage = {}));
  var StopMessage;
  (function(StopMessage2) {
    let Type2;
    (function(Type3) {
      Type3["CONNECT"] = "CONNECT";
      Type3["STATUS"] = "STATUS";
    })(Type2 = StopMessage2.Type || (StopMessage2.Type = {}));
    let __TypeValues;
    (function(__TypeValues2) {
      __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
      __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
    })(__TypeValues || (__TypeValues = {}));
    (function(Type3) {
      Type3.codec = () => {
        return enumeration(__TypeValues);
      };
    })(Type2 = StopMessage2.Type || (StopMessage2.Type = {}));
    let _codec;
    StopMessage2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.type != null) {
            w.uint32(8);
            StopMessage2.Type.codec().encode(obj.type, w);
          }
          if (obj.peer != null) {
            w.uint32(18);
            Peer2.codec().encode(obj.peer, w);
          }
          if (obj.limit != null) {
            w.uint32(26);
            Limit.codec().encode(obj.limit, w);
          }
          if (obj.status != null) {
            w.uint32(32);
            Status.codec().encode(obj.status, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.type = StopMessage2.Type.codec().decode(reader2);
                break;
              }
              case 2: {
                obj.peer = Peer2.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.peer
                });
                break;
              }
              case 3: {
                obj.limit = Limit.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.limit
                });
                break;
              }
              case 4: {
                obj.status = Status.codec().decode(reader2);
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    StopMessage2.encode = (obj) => {
      return encodeMessage(obj, StopMessage2.codec());
    };
    StopMessage2.decode = (buf2, opts) => {
      return decodeMessage(buf2, StopMessage2.codec(), opts);
    };
  })(StopMessage || (StopMessage = {}));
  var Peer2;
  (function(Peer3) {
    let _codec;
    Peer3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.id != null && obj.id.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value2 of obj.addrs) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            id: alloc(0),
            addrs: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.id = reader2.bytes();
                break;
              }
              case 2: {
                if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                  throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
                }
                obj.addrs.push(reader2.bytes());
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Peer3.encode = (obj) => {
      return encodeMessage(obj, Peer3.codec());
    };
    Peer3.decode = (buf2, opts) => {
      return decodeMessage(buf2, Peer3.codec(), opts);
    };
  })(Peer2 || (Peer2 = {}));
  var Reservation;
  (function(Reservation2) {
    let _codec;
    Reservation2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.expire != null && obj.expire !== 0n) {
            w.uint32(8);
            w.uint64(obj.expire);
          }
          if (obj.addrs != null) {
            for (const value2 of obj.addrs) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (obj.voucher != null) {
            w.uint32(26);
            Envelope2.codec().encode(obj.voucher, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            expire: 0n,
            addrs: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.expire = reader2.uint64();
                break;
              }
              case 2: {
                if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                  throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
                }
                obj.addrs.push(reader2.bytes());
                break;
              }
              case 3: {
                obj.voucher = Envelope2.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.voucher
                });
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Reservation2.encode = (obj) => {
      return encodeMessage(obj, Reservation2.codec());
    };
    Reservation2.decode = (buf2, opts) => {
      return decodeMessage(buf2, Reservation2.codec(), opts);
    };
  })(Reservation || (Reservation = {}));
  var Limit;
  (function(Limit2) {
    let _codec;
    Limit2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.duration != null) {
            w.uint32(8);
            w.uint32(obj.duration);
          }
          if (obj.data != null) {
            w.uint32(16);
            w.uint64(obj.data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.duration = reader2.uint32();
                break;
              }
              case 2: {
                obj.data = reader2.uint64();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Limit2.encode = (obj) => {
      return encodeMessage(obj, Limit2.codec());
    };
    Limit2.decode = (buf2, opts) => {
      return decodeMessage(buf2, Limit2.codec(), opts);
    };
  })(Limit || (Limit = {}));
  var Status;
  (function(Status2) {
    Status2["UNUSED"] = "UNUSED";
    Status2["OK"] = "OK";
    Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
    Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
    Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
    Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
    Status2["NO_RESERVATION"] = "NO_RESERVATION";
    Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
    Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
  })(Status || (Status = {}));
  var __StatusValues;
  (function(__StatusValues2) {
    __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
    __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
    __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
    __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
    __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
    __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
    __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
    __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
    __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
  })(__StatusValues || (__StatusValues = {}));
  (function(Status2) {
    Status2.codec = () => {
      return enumeration(__StatusValues);
    };
  })(Status || (Status = {}));
  var ReservationVoucher;
  (function(ReservationVoucher2) {
    let _codec;
    ReservationVoucher2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.relay != null && obj.relay.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.relay);
          }
          if (obj.peer != null && obj.peer.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.peer);
          }
          if (obj.expiration != null && obj.expiration !== 0n) {
            w.uint32(24);
            w.uint64(obj.expiration);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            relay: alloc(0),
            peer: alloc(0),
            expiration: 0n
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.relay = reader2.bytes();
                break;
              }
              case 2: {
                obj.peer = reader2.bytes();
                break;
              }
              case 3: {
                obj.expiration = reader2.uint64();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    ReservationVoucher2.encode = (obj) => {
      return encodeMessage(obj, ReservationVoucher2.codec());
    };
    ReservationVoucher2.decode = (buf2, opts) => {
      return decodeMessage(buf2, ReservationVoucher2.codec(), opts);
    };
  })(ReservationVoucher || (ReservationVoucher = {}));
  var Envelope2;
  (function(Envelope3) {
    let _codec;
    Envelope3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.publicKey);
          }
          if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.payloadType);
          }
          if (obj.payload != null) {
            w.uint32(26);
            ReservationVoucher.codec().encode(obj.payload, w);
          }
          if (obj.signature != null && obj.signature.byteLength > 0) {
            w.uint32(42);
            w.bytes(obj.signature);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            publicKey: alloc(0),
            payloadType: alloc(0),
            signature: alloc(0)
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.publicKey = reader2.bytes();
                break;
              }
              case 2: {
                obj.payloadType = reader2.bytes();
                break;
              }
              case 3: {
                obj.payload = ReservationVoucher.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.payload
                });
                break;
              }
              case 5: {
                obj.signature = reader2.bytes();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Envelope3.encode = (obj) => {
      return encodeMessage(obj, Envelope3.codec());
    };
    Envelope3.decode = (buf2, opts) => {
      return decodeMessage(buf2, Envelope3.codec(), opts);
    };
  })(Envelope2 || (Envelope2 = {}));

  // node_modules/@libp2p/circuit-relay-v2/dist/src/errors.js
  var HadEnoughRelaysError = class extends Error {
    static name = "HadEnoughRelaysError";
    name = "HadEnoughRelaysError";
  };
  var DoubleRelayError = class extends Error {
    static name = "DoubleRelayError";
    name = "DoubleRelayError";
  };
  var RelayQueueFullError = class extends Error {
    static name = "RelayQueueFullError";
    name = "RelayQueueFullError";
  };

  // node_modules/@libp2p/circuit-relay-v2/dist/src/utils.js
  function getExpirationMilliseconds(expireTimeSeconds) {
    const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    return Number(expireTimeMillis - BigInt(currentTime));
  }
  var LimitTracker = class {
    expires;
    bytes;
    constructor(limits) {
      if (limits?.duration != null && limits?.duration !== 0) {
        this.expires = Date.now() + limits.duration * 1e3;
      }
      this.bytes = limits?.data;
      if (this.bytes === 0n) {
        this.bytes = void 0;
      }
      this.onData = this.onData.bind(this);
    }
    onData(buf2) {
      if (this.bytes == null) {
        return;
      }
      this.bytes -= BigInt(buf2.byteLength);
      if (this.bytes < 0n) {
        this.bytes = 0n;
      }
    }
    getLimits() {
      if (this.expires == null && this.bytes == null) {
        return;
      }
      const output = {};
      if (this.bytes != null) {
        const self2 = this;
        Object.defineProperty(output, "bytes", {
          get() {
            return self2.bytes;
          }
        });
      }
      if (this.expires != null) {
        const self2 = this;
        Object.defineProperty(output, "seconds", {
          get() {
            return Math.round(((self2.expires ?? 0) - Date.now()) / 1e3);
          }
        });
      }
      return output;
    }
  };
  var CircuitListen = fmt(and(P2P.matchers[0], code7(CODE_P2P_CIRCUIT)));
  var CircuitSearch = fmt(code7(CODE_P2P_CIRCUIT));

  // node_modules/@libp2p/circuit-relay-v2/dist/src/transport/discovery.js
  var RelayDiscovery = class extends TypedEventEmitter {
    components;
    started;
    running;
    topologyId;
    log;
    discoveryController;
    filter;
    queue;
    constructor(components, init = {}) {
      super();
      this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
      this.components = components;
      this.started = false;
      this.running = false;
      this.filter = init.filter;
      this.discoveryController = new AbortController();
      setMaxListeners(Infinity, this.discoveryController.signal);
      this.dialPeer = this.dialPeer.bind(this);
      this.onPeer = this.onPeer.bind(this);
    }
    isStarted() {
      return this.started;
    }
    async start() {
      this.topologyId = await this.components.registrar.register(RELAY_V2_HOP_CODEC, {
        filter: this.filter,
        onConnect: (peerId) => {
          this.log.trace("discovered relay %p queue (length: %d, active %d)", peerId, this.queue?.size, this.queue?.running);
          this.safeDispatchEvent("relay:discover", { detail: peerId });
        }
      });
      this.started = true;
    }
    stop() {
      if (this.topologyId != null) {
        this.components.registrar.unregister(this.topologyId);
      }
      if (this.running) {
        this.stopDiscovery();
      }
      this.started = false;
    }
    /**
     * Try to listen on available hop relay connections.
     * The following order will happen while we do not have enough relays:
     *
     * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to
     * 2. Dial and try to listen on the peers we know that support hop but are not connected
     * 3. Search the network - this requires a peer routing implementation to be configured but will fail gracefully
     * 4. Dial any peers discovered - this covers when no peer routing implementation has been configured but some peer discovery mechanism is also present
     */
    startDiscovery() {
      if (this.running) {
        return;
      }
      this.log("start discovery");
      this.running = true;
      this.discoveryController = new AbortController();
      setMaxListeners(Infinity, this.discoveryController.signal);
      this.components.events.addEventListener("peer:discovery", this.onPeer);
      Promise.resolve().then(async () => {
        this.log("searching peer store for relays");
        const peers = await this.components.peerStore.all({
          filters: [
            // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
            (peer) => {
              return peer.protocols.includes(RELAY_V2_HOP_CODEC);
            }
          ],
          orders: [
            // randomize
            () => Math.random() < 0.5 ? 1 : -1,
            // prefer peers we've connected to in the past
            (a2, b) => {
              const lastDialA = getLastDial(a2);
              const lastDialB = getLastDial(b);
              if (lastDialA > lastDialB) {
                return -1;
              }
              if (lastDialB > lastDialA) {
                return 1;
              }
              return 0;
            }
          ]
        });
        for (const peer of peers) {
          this.log.trace("found relay peer %p in peer store", peer.id);
          this.safeDispatchEvent("relay:discover", { detail: peer.id });
        }
        this.log("found %d relay peers in peer store", peers.length);
        const queue = this.queue = new PeerQueue({
          concurrency: 5
        });
        this.log("start random walk");
        for await (const peer of this.components.randomWalk.walk({ signal: this.discoveryController.signal })) {
          this.log.trace("found random peer %p", peer.id);
          if (queue.has(peer.id)) {
            this.log.trace("random peer %p was already in queue", peer.id);
            continue;
          }
          if (this.components.connectionManager.getConnections(peer.id)?.length > 0) {
            this.log.trace("random peer %p was already connected", peer.id);
            continue;
          }
          if (!await this.components.connectionManager.isDialable(peer.multiaddrs)) {
            this.log.trace("random peer %p was not dialable", peer.id, peer.multiaddrs.map((ma) => ma.toString()));
            continue;
          }
          if (queue.queued > 10) {
            this.log.trace("wait for space in queue for %p", peer.id);
            await queue.onSizeLessThan(10, {
              signal: this.discoveryController.signal
            });
          }
          this.log("adding random peer %p to dial queue (length: %d, active %d)", peer.id, queue.size, queue.running);
          queue.add(this.dialPeer, {
            peerId: peer.id,
            signal: this.discoveryController.signal
          }).catch((err2) => {
            this.log.error("error opening connection to random peer %p - %e", peer.id, err2);
          });
        }
        this.log("stop random walk");
        await queue.onIdle();
      }).catch((err2) => {
        if (!this.discoveryController.signal.aborted) {
          this.log.error("failed when finding relays on the network - %e", err2);
        }
      });
    }
    stopDiscovery() {
      this.log("stop discovery");
      this.running = false;
      this.discoveryController?.abort();
      this.queue?.clear();
      this.components.events.removeEventListener("peer:discovery", this.onPeer);
    }
    onPeer(evt) {
      this.log.trace("maybe dialing discovered peer %p", evt.detail.id);
      this.maybeDialPeer(evt).catch((err2) => {
        this.log.trace("error dialing discovered peer %p - %e", evt.detail.id, err2);
      });
    }
    async maybeDialPeer(evt) {
      if (this.queue == null) {
        return;
      }
      const peerId = evt.detail.id;
      const multiaddrs = evt.detail.multiaddrs;
      if (this.queue.has(peerId)) {
        this.log.trace("random peer %p was already in queue", peerId);
        return;
      }
      if (this.components.connectionManager.getConnections(peerId)?.length > 0) {
        this.log.trace("random peer %p was already connected", peerId);
        return;
      }
      if (!await this.components.connectionManager.isDialable(multiaddrs)) {
        this.log.trace("random peer %p was not dialable", peerId);
        return;
      }
      this.queue?.add(this.dialPeer, {
        peerId: evt.detail.id,
        signal: this.discoveryController.signal
      }).catch((err2) => {
        this.log.error("error opening connection to discovered peer %p - %e", evt.detail.id, err2);
      });
    }
    async dialPeer({ peerId, signal }) {
      const combinedSignal = anySignal([AbortSignal.timeout(5e3), signal]);
      setMaxListeners(Infinity, combinedSignal);
      try {
        await this.components.connectionManager.openConnection(peerId, {
          signal: combinedSignal
        });
      } finally {
        combinedSignal.clear();
      }
    }
  };
  function getLastDial(peer) {
    const lastDial = peer.metadata.get("last-dial-success");
    if (lastDial == null) {
      return 0;
    }
    return new Date(toString2(lastDial)).getTime();
  }

  // node_modules/@libp2p/circuit-relay-v2/dist/src/transport/listener.js
  var CircuitRelayTransportListener = class extends TypedEventEmitter {
    connectionManager;
    addressManager;
    reservationStore;
    listeningAddrs;
    log;
    listenTimeout;
    reservationId;
    relay;
    constructor(components, init = {}) {
      super();
      this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
      this.connectionManager = components.connectionManager;
      this.addressManager = components.addressManager;
      this.reservationStore = components.reservationStore;
      this.listeningAddrs = [];
      this.listenTimeout = init.listenTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
      this.reservationStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
      this.reservationStore.addEventListener("relay:created-reservation", this._onAddRelayPeer);
    }
    _onRemoveRelayPeer = (evt) => {
      this.log("relay removed %p our relay %p", evt.detail.relay, this.relay, this.relay?.equals(evt.detail.relay));
      if (this.relay?.equals(evt.detail.relay) !== true) {
        return;
      }
      this.log("relay peer removed %p", evt.detail.relay);
      this.listeningAddrs.forEach((ma) => {
        this.addressManager.removeObservedAddr(ma);
      });
      this.listeningAddrs = [];
      this.safeDispatchEvent("listening");
    };
    _onAddRelayPeer = (evt) => {
      const { details } = evt.detail;
      if (details.type === "configured") {
        return;
      }
      if (details.id !== this.reservationId) {
        return;
      }
      this.addedRelay(evt.detail);
    };
    async listen(addr) {
      if (CircuitSearch.exactMatch(addr)) {
        this.log("searching for circuit relay servers");
        this.reservationId = this.reservationStore.reserveRelay();
      } else if (CircuitListen.exactMatch(addr)) {
        this.log("listen on specific relay server %a", addr);
        const signal = AbortSignal.timeout(this.listenTimeout);
        setMaxListeners(Infinity, signal);
        const relayAddr = addr.decapsulate("/p2p-circuit");
        const relayConn = await this.connectionManager.openConnection(relayAddr, {
          signal
        });
        if (!this.reservationStore.hasReservation(relayConn.remotePeer)) {
          this.log("making reservation on peer %p", relayConn.remotePeer);
          const reservation = await this.reservationStore.addRelay(relayConn.remotePeer, "configured");
          this.addedRelay(reservation);
        }
      } else {
        throw new ListenError(`Could not listen on p2p-circuit address "${addr}"`);
      }
    }
    getAddrs() {
      return [...this.listeningAddrs.values()].flat();
    }
    updateAnnounceAddrs() {
    }
    async close() {
      this.reservationStore.cancelReservations();
      this.listeningAddrs = [];
      this.reservationStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
      queueMicrotask(() => {
        this.safeDispatchEvent("close");
      });
    }
    addedRelay(reservation) {
      this.log("relay peer added %p", reservation.relay);
      this.relay = reservation.relay;
      this.listeningAddrs = reservation.details.reservation.addrs.map((buf2) => multiaddr(buf2).encapsulate("/p2p-circuit"));
      this.listeningAddrs.forEach((ma) => {
        this.addressManager.confirmObservedAddr(ma, {
          type: "transport"
        });
      });
      queueMicrotask(() => {
        this.safeDispatchEvent("listening");
      });
    }
  };
  function createListener(options2) {
    return new CircuitRelayTransportListener(options2);
  }

  // node_modules/nanoid/url-alphabet/index.js
  var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

  // node_modules/nanoid/index.browser.js
  var nanoid2 = (size = 21) => {
    let id = "";
    let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
    while (size--) {
      id += urlAlphabet[bytes[size] & 63];
    }
    return id;
  };

  // node_modules/@libp2p/circuit-relay-v2/dist/src/transport/reservation-store.js
  var REFRESH_WINDOW = 60 * 1e3 * 10;
  var REFRESH_TIMEOUT = 60 * 1e3 * 5;
  var REFRESH_TIMEOUT_MIN = 30 * 1e3;
  var ReservationStore = class extends TypedEventEmitter {
    peerId;
    connectionManager;
    peerStore;
    events;
    reserveQueue;
    reservations;
    pendingReservations;
    maxReservationQueueLength;
    reservationCompletionTimeout;
    started;
    log;
    relayFilter;
    constructor(components, init) {
      super();
      this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
      this.peerId = components.peerId;
      this.connectionManager = components.connectionManager;
      this.peerStore = components.peerStore;
      this.events = components.events;
      this.reservations = new PeerMap();
      this.pendingReservations = [];
      this.maxReservationQueueLength = init?.maxReservationQueueLength ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH;
      this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
      this.started = false;
      this.relayFilter = createScalableCuckooFilter(100);
      this.reserveQueue = new PeerQueue({
        concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,
        metricName: "libp2p_relay_reservation_queue",
        metrics: components.metrics
      });
      this.events.addEventListener("connection:close", (evt) => {
        const reservation = [...this.reservations.values()].find((reservation2) => reservation2.connection === evt.detail.id);
        if (reservation == null) {
          return;
        }
        this.#removeReservation(evt.detail.remotePeer).catch((err2) => {
          this.log("could not remove relay %p - %e", evt.detail, err2);
        });
      });
    }
    isStarted() {
      return this.started;
    }
    start() {
      this.started = true;
    }
    afterStart() {
      void Promise.resolve().then(async () => {
        const relayPeers = await this.peerStore.all({
          filters: [(peer) => {
            return peer.tags.has(KEEP_ALIVE_TAG);
          }]
        });
        this.log("removing tag from %d old relays", relayPeers.length);
        await Promise.all(relayPeers.map(async (peer) => {
          await this.peerStore.merge(peer.id, {
            tags: {
              [KEEP_ALIVE_TAG]: void 0
            }
          });
        }));
        this.log("redialing %d old relays", relayPeers.length);
        await Promise.all(relayPeers.map(async (peer) => this.addRelay(peer.id, "discovered")));
        this.#checkReservationCount();
      }).catch((err2) => {
        this.log.error("failed to clean up and redial old relays during afterStart - %e", err2);
      });
    }
    stop() {
      this.reserveQueue.clear();
      this.reservations.forEach(({ timeout }) => {
        clearTimeout(timeout);
      });
      this.reservations.clear();
      this.started = false;
    }
    reserveRelay() {
      const id = nanoid2();
      this.pendingReservations.push(id);
      this.#checkReservationCount();
      return id;
    }
    /**
     * If the number of current relays is beneath the configured `maxReservations`
     * value, and the passed peer id is not our own, and we have a non-relayed
     * connection to the remote, and the remote peer speaks the hop protocol, try
     * to reserve a slot on the remote peer
     */
    async addRelay(peerId, type) {
      if (this.peerId.equals(peerId)) {
        this.log.trace("not trying to use self as relay");
        throw new ListenError("Cannot use self as relay");
      }
      if (this.reserveQueue.size > this.maxReservationQueueLength) {
        throw new RelayQueueFullError("The reservation queue is full");
      }
      const existingJob = this.reserveQueue.find(peerId);
      if (existingJob != null) {
        this.log.trace("potential relay peer %p is already in the reservation queue", peerId);
        return existingJob.join();
      }
      if (this.relayFilter.has(peerId.toMultihash().bytes)) {
        throw new ListenError("The relay was previously invalid");
      }
      this.log.trace("try to reserve relay slot with %p", peerId);
      return this.reserveQueue.add(async () => {
        const start2 = Date.now();
        try {
          const existingReservation = this.reservations.get(peerId);
          if (existingReservation != null) {
            const connections = this.connectionManager.getConnections(peerId);
            let connected = false;
            if (connections.length === 0) {
              this.log("already have relay reservation with %p but we are no longer connected", peerId);
            }
            if (connections.map((conn) => conn.id).includes(existingReservation.connection)) {
              this.log("already have relay reservation with %p and the original connection is still open", peerId);
              connected = true;
            }
            if (connected && getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
              this.log("already have relay reservation with %p but we are still connected and it does not expire soon", peerId);
              return {
                relay: peerId,
                details: existingReservation
              };
            }
            await this.#removeReservation(peerId);
          }
          if (type === "discovered" && this.pendingReservations.length === 0) {
            throw new HadEnoughRelaysError("Not making reservation on discovered relay because we do not need any more relays");
          }
          const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
          setMaxListeners(Infinity, signal);
          const connection = await this.connectionManager.openConnection(peerId, {
            signal
          });
          if (Circuit.matches(connection.remoteAddr)) {
            throw new DoubleRelayError("not creating reservation over relayed connection");
          }
          const reservation = await this.#createReservation(connection, {
            signal
          });
          const expiration = getExpirationMilliseconds(reservation.expire);
          this.log("created reservation on relay peer %p, expiry date is %s", peerId, new Date(Date.now() + expiration).toString());
          const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
          const timeout = setTimeout(() => {
            this.log("refresh reservation to relay %p", peerId);
            this.addRelay(peerId, type).catch(async (err2) => {
              this.log.error("could not refresh reservation to relay %p - %e", peerId, err2);
              await this.#removeReservation(peerId);
            }).catch((err2) => {
              this.log.error("could not remove expired reservation to relay %p - %e", peerId, err2);
            });
          }, timeoutDuration);
          let res;
          if (type === "discovered") {
            const id = this.pendingReservations.pop();
            if (id == null) {
              throw new HadEnoughRelaysError("Made reservation on relay but did not need any more discovered relays");
            }
            res = {
              timeout,
              reservation,
              type,
              connection: connection.id,
              id
            };
          } else {
            res = {
              timeout,
              reservation,
              type,
              connection: connection.id
            };
          }
          this.reservations.set(peerId, res);
          await this.peerStore.merge(peerId, {
            tags: {
              [KEEP_ALIVE_TAG]: {
                value: 1,
                ttl: expiration
              }
            }
          });
          this.#checkReservationCount();
          const result = {
            relay: peerId,
            details: res
          };
          this.safeDispatchEvent("relay:created-reservation", {
            detail: result
          });
          return result;
        } catch (err2) {
          if (!(type === "discovered" && err2.name === "HadEnoughRelaysError")) {
            this.log.error("could not reserve slot on %p after %dms - %e", peerId, Date.now() - start2, err2);
          }
          if (err2.name === "DialError" || err2.name === "UnsupportedProtocolError") {
            this.relayFilter.add(peerId.toMultihash().bytes);
          }
          this.#removeReservation(peerId).catch((err3) => {
            this.log.error("could not remove reservation on %p after reserving slot failed - %e", peerId, err3);
          });
          throw err2;
        }
      }, {
        peerId
      });
    }
    hasReservation(peerId) {
      return this.reservations.has(peerId);
    }
    getReservation(peerId) {
      return this.reservations.get(peerId)?.reservation;
    }
    reservationCount(type) {
      if (type == null) {
        return this.reservations.size;
      }
      return [...this.reservations.values()].reduce((acc, curr) => {
        if (curr.type === type) {
          acc++;
        }
        return acc;
      }, 0);
    }
    cancelReservations() {
      [...this.reservations.values()].forEach((reservation) => {
        clearTimeout(reservation.timeout);
      });
      this.reservations.clear();
    }
    async #createReservation(connection, options2) {
      options2.signal?.throwIfAborted();
      this.log("requesting reservation from %p", connection.remotePeer);
      const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options2);
      const pbstr = pbStream(stream);
      const hopstr = pbstr.pb(HopMessage);
      this.log.trace("send RESERVE to %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.RESERVE }, options2);
      let response;
      try {
        this.log.trace("reading response from %p", connection.remotePeer);
        response = await hopstr.read(options2);
      } catch (err2) {
        stream.abort(err2);
        throw err2;
      } finally {
        if (stream.status !== "closed") {
          await stream.close(options2);
        }
      }
      this.log.trace("read response %s", response.status);
      if (response.status === Status.OK && response.reservation != null) {
        const addresses = /* @__PURE__ */ new Set();
        addresses.add(connection.remoteAddr.toString());
        for (const buf2 of response.reservation.addrs) {
          let ma = multiaddr(buf2);
          if (ma.getComponents().find((c2) => c2.code === CODE_P2P) == null) {
            ma = ma.encapsulate(`/p2p/${connection.remotePeer}`);
          }
          ma = multiaddr(ma.toString().replace(`/p2p/${connection.remotePeer}/p2p/${connection.remotePeer}`, `/p2p/${connection.remotePeer}`));
          addresses.add(ma.toString());
        }
        response.reservation.addrs = [...addresses].map((str) => multiaddr(str).bytes);
        return response.reservation;
      }
      const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
      this.log.error(errMsg);
      throw new Error(errMsg);
    }
    /**
     * Remove listen relay
     */
    async #removeReservation(peerId) {
      const reservation = this.reservations.get(peerId);
      if (reservation == null) {
        return;
      }
      this.log("removing relay reservation with %p from local store", peerId);
      clearTimeout(reservation.timeout);
      this.reservations.delete(peerId);
      if (reservation.type === "discovered") {
        this.pendingReservations.push(reservation.id);
      }
      await this.peerStore.merge(peerId, {
        tags: {
          [KEEP_ALIVE_TAG]: void 0
        }
      });
      this.safeDispatchEvent("relay:removed", {
        detail: {
          relay: peerId,
          details: reservation
        }
      });
      this.#checkReservationCount();
    }
    #checkReservationCount() {
      if (this.pendingReservations.length === 0) {
        this.log.trace("have discovered enough relays");
        this.reserveQueue.clear();
        this.safeDispatchEvent("relay:found-enough-relays");
        return;
      }
      this.relayFilter = createScalableCuckooFilter(100);
      this.log("not discovered enough relays %d/%d", this.reservations.size, this.pendingReservations.length);
      this.safeDispatchEvent("relay:not-enough-relays");
    }
  };

  // node_modules/@libp2p/circuit-relay-v2/dist/src/transport/stream-to-conn.js
  var StreamMultiaddrConnection = class extends AbstractMultiaddrConnection {
    stream;
    init;
    constructor(init) {
      super({
        ...init,
        direction: init.stream.direction
      });
      this.init = init;
      this.stream = init.stream;
      this.stream.addEventListener("close", (evt) => {
        this.onTransportClosed(evt.error);
      });
      this.stream.addEventListener("remoteCloseWrite", (evt) => {
        this.onRemoteCloseWrite();
        this.close().catch((err2) => {
          this.abort(err2);
        });
      });
      this.stream.addEventListener("message", (evt) => {
        init.onDataRead?.(evt.data);
        this.onData(evt.data);
      });
      this.stream.addEventListener("drain", () => {
        this.safeDispatchEvent("drain");
      });
    }
    sendData(data) {
      this.init.onDataWrite?.(data);
      return {
        sentBytes: data.byteLength,
        canSendMore: this.stream.send(data)
      };
    }
    async sendClose(options2) {
      await this.stream.close(options2);
    }
    sendReset() {
      this.stream.abort(new Error("An error occurred"));
    }
    sendPause() {
      this.stream.pause();
    }
    sendResume() {
      this.stream.resume();
    }
  };
  function streamToMaConnection(init) {
    return new StreamMultiaddrConnection(init);
  }

  // node_modules/@libp2p/circuit-relay-v2/dist/src/transport/index.js
  var isValidStop = (request) => {
    if (request.peer == null) {
      return false;
    }
    try {
      request.peer.addrs.forEach(multiaddr);
    } catch {
      return false;
    }
    return true;
  };
  var defaults = {
    maxInboundStopStreams: MAX_CONNECTIONS2,
    maxOutboundStopStreams: MAX_CONNECTIONS2,
    stopTimeout: 3e4
  };
  var CircuitRelayTransport = class {
    components;
    discovery;
    reservationStore;
    maxInboundStopStreams;
    maxOutboundStopStreams;
    started;
    log;
    shutdownController;
    constructor(components, init = {}) {
      this.components = components;
      this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
      this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams;
      this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
      this.shutdownController = new AbortController();
      this.discovery = new RelayDiscovery(components, {
        filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)
      });
      this.discovery.addEventListener("relay:discover", (evt) => {
        this.reservationStore.addRelay(evt.detail, "discovered").catch((err2) => {
          if (err2.name !== "HadEnoughRelaysError" && err2.name !== "RelayQueueFullError") {
            this.log.error("could not add discovered relay %p - %e", evt.detail, err2);
          }
        });
      });
      this.reservationStore = new ReservationStore(components, init);
      this.reservationStore.addEventListener("relay:not-enough-relays", () => {
        this.discovery?.startDiscovery();
      });
      this.reservationStore.addEventListener("relay:found-enough-relays", () => {
        this.discovery?.stopDiscovery();
      });
      this.started = false;
      this.onStop = this.onStop.bind(this);
    }
    [Symbol.toStringTag] = "@libp2p/circuit-relay-v2-transport";
    [serviceCapabilities] = [
      "@libp2p/transport",
      "@libp2p/circuit-relay-v2-transport"
    ];
    get [serviceDependencies]() {
      if (this.discovery != null) {
        return [
          "@libp2p/identify"
        ];
      }
      return [];
    }
    [transportSymbol] = true;
    isStarted() {
      return this.started;
    }
    async start() {
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
      await this.components.registrar.handle(RELAY_V2_STOP_CODEC, this.onStop, {
        maxInboundStreams: this.maxInboundStopStreams,
        maxOutboundStreams: this.maxOutboundStopStreams,
        runOnLimitedConnection: true
      });
      await start(this.discovery, this.reservationStore);
      this.started = true;
    }
    async stop() {
      this.shutdownController.abort();
      await stop(this.discovery, this.reservationStore);
      await this.components.registrar.unhandle(RELAY_V2_STOP_CODEC);
      this.started = false;
    }
    /**
     * Dial a peer over a relay
     */
    async dial(ma, options2) {
      const addrs = ma.toString().split("/p2p-circuit");
      const relayAddr = multiaddr(addrs[0]);
      const destinationAddr = multiaddr(addrs[addrs.length - 1]);
      const relayId = relayAddr.getComponents().find((c2) => c2.code === CODE_P2P)?.value;
      const destinationId = destinationAddr.getComponents().find((c2) => c2.code === CODE_P2P)?.value;
      if (relayId == null || destinationId == null) {
        const errMsg = `ircuit relay dial to ${ma.toString()} failed as address did not have both relay and destination PeerIDs`;
        this.log.error(`c${errMsg}`);
        throw new DialError(`C${errMsg}`);
      }
      const relayPeer = peerIdFromString(relayId);
      const destinationPeer = peerIdFromString(destinationId);
      const relayConnections = this.components.connectionManager.getConnections(relayPeer);
      let relayConnection = relayConnections[0];
      if (relayConnection == null) {
        await this.components.peerStore.merge(relayPeer, {
          multiaddrs: [relayAddr]
        });
        options2.onProgress?.(new CustomProgressEvent("circuit-relay:open-connection"));
        relayConnection = await this.components.connectionManager.openConnection(relayPeer, options2);
      } else {
        options2.onProgress?.(new CustomProgressEvent("circuit-relay:reuse-connection"));
      }
      let stream;
      try {
        options2.onProgress?.(new CustomProgressEvent("circuit-relay:open-hop-stream"));
        stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC, options2);
        const hopstr = pbStream(stream).pb(HopMessage);
        options2.onProgress?.(new CustomProgressEvent("circuit-relay:write-connect-message"));
        await hopstr.write({
          type: HopMessage.Type.CONNECT,
          peer: {
            id: destinationPeer.toMultihash().bytes,
            addrs: [multiaddr(destinationAddr).bytes]
          }
        }, options2);
        options2.onProgress?.(new CustomProgressEvent("circuit-relay:read-connect-response"));
        const status = await hopstr.read(options2);
        if (status.status !== Status.OK) {
          throw new InvalidMessageError(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`);
        }
        const limits = new LimitTracker(status.limit);
        const maConn = streamToMaConnection({
          stream: hopstr.unwrap().unwrap(),
          remoteAddr: ma,
          localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),
          onDataRead: limits.onData,
          onDataWrite: limits.onData,
          log: stream.log.newScope("circuit-relay:connection")
        });
        const conn = await this.components.upgrader.upgradeOutbound(maConn, {
          ...options2,
          limits: limits.getLimits()
        });
        conn.log("outbound relayed connection established to %p with limits %o, over connection %s", conn.remotePeer, status.limit ?? "none", relayConnection.id);
        return conn;
      } catch (err2) {
        this.log.error("circuit relay dial to destination %p via relay %p failed - %e", destinationPeer, relayPeer, err2);
        stream?.abort(err2);
        throw err2;
      }
    }
    /**
     * Create a listener
     */
    createListener(options2) {
      return createListener({
        peerId: this.components.peerId,
        connectionManager: this.components.connectionManager,
        addressManager: this.components.addressManager,
        reservationStore: this.reservationStore,
        logger: this.components.logger
      });
    }
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      return multiaddrs.filter((ma) => {
        return CircuitListen.exactMatch(ma) || CircuitSearch.exactMatch(ma);
      });
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      return multiaddrs.filter((ma) => {
        return Circuit.exactMatch(ma);
      });
    }
    /**
     * An incoming STOP request means a remote peer wants to dial us via a relay
     */
    async onStop(stream, connection) {
      const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
      try {
        if (!this.reservationStore.hasReservation(connection.remotePeer)) {
          try {
            this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
            await this.components.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
          } catch (err2) {
            this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e", err2);
          }
        }
        const stopStream = pbStream(stream).pb(StopMessage);
        const request = await stopStream.read({
          signal
        });
        this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
        if (request?.type === void 0) {
          this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
          await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
            signal
          });
          await stream.close({
            signal
          });
          return;
        }
        if (request.type !== StopMessage.Type.CONNECT) {
          this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
          await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
            signal
          });
          await stream.close({
            signal
          });
          return;
        }
        if (!isValidStop(request)) {
          this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
          await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
            signal
          });
          await stream.close({
            signal
          });
          return;
        }
        const remotePeerId = peerIdFromMultihash(decode4(request.peer.id));
        if (await this.components.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
          this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
          await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
            signal
          });
          await stream.close({
            signal
          });
          return;
        }
        this.log.trace("sending success response to %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
          signal
        });
        const limits = new LimitTracker(request.limit);
        const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
        const localAddr = this.components.addressManager.getAddresses()[0];
        const maConn = streamToMaConnection({
          stream: stopStream.unwrap().unwrap(),
          remoteAddr,
          localAddr,
          onDataRead: limits.onData,
          onDataWrite: limits.onData,
          log: stream.log.newScope("circuit-relay:connection")
        });
        await this.components.upgrader.upgradeInbound(maConn, {
          limits: limits.getLimits(),
          signal
        });
        maConn.log("inbound relayed connection established to %p with limits %o, over connection %s", remotePeerId, request.limit ?? "none", connection.id);
      } finally {
        signal?.clear();
      }
    }
  };

  // node_modules/@libp2p/circuit-relay-v2/dist/src/index.js
  function circuitRelayTransport(init = {}) {
    return (components) => {
      return new CircuitRelayTransport(components, init);
    };
  }

  // node_modules/@libp2p/dcutr/dist/src/pb/message.js
  var HolePunch;
  (function(HolePunch2) {
    let Type2;
    (function(Type3) {
      Type3["UNUSED"] = "UNUSED";
      Type3["CONNECT"] = "CONNECT";
      Type3["SYNC"] = "SYNC";
    })(Type2 = HolePunch2.Type || (HolePunch2.Type = {}));
    let __TypeValues;
    (function(__TypeValues2) {
      __TypeValues2[__TypeValues2["UNUSED"] = 0] = "UNUSED";
      __TypeValues2[__TypeValues2["CONNECT"] = 100] = "CONNECT";
      __TypeValues2[__TypeValues2["SYNC"] = 300] = "SYNC";
    })(__TypeValues || (__TypeValues = {}));
    (function(Type3) {
      Type3.codec = () => {
        return enumeration(__TypeValues);
      };
    })(Type2 = HolePunch2.Type || (HolePunch2.Type = {}));
    let _codec;
    HolePunch2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.type != null) {
            w.uint32(8);
            HolePunch2.Type.codec().encode(obj.type, w);
          }
          if (obj.observedAddresses != null) {
            for (const value2 of obj.observedAddresses) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            observedAddresses: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.type = HolePunch2.Type.codec().decode(reader2);
                break;
              }
              case 2: {
                if (opts.limits?.observedAddresses != null && obj.observedAddresses.length === opts.limits.observedAddresses) {
                  throw new MaxLengthError('Decode error - map field "observedAddresses" had too many elements');
                }
                obj.observedAddresses.push(reader2.bytes());
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    HolePunch2.encode = (obj) => {
      return encodeMessage(obj, HolePunch2.codec());
    };
    HolePunch2.decode = (buf2, opts) => {
      return decodeMessage(buf2, HolePunch2.codec(), opts);
    };
  })(HolePunch || (HolePunch = {}));

  // node_modules/@libp2p/dcutr/dist/src/utils.js
  function isPublicAndDialable(ma, transportManager) {
    if (Circuit.matches(ma)) {
      return false;
    }
    const transport = transportManager.dialTransportForMultiaddr(ma);
    if (transport == null) {
      return false;
    }
    if (DNS2.matches(ma)) {
      return true;
    }
    if (!IP.matches(ma)) {
      return false;
    }
    return !isPrivate(ma);
  }

  // node_modules/@libp2p/dcutr/dist/src/dcutr.js
  var MAX_DCUTR_MESSAGE_SIZE = 1024 * 4;
  var DCUTR_DIAL_PRIORITY = 100;
  var defaultValues5 = {
    // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L27
    timeout: 5e3,
    // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L28
    retries: 3,
    maxInboundStreams: 1,
    maxOutboundStreams: 1
  };
  var DefaultDCUtRService = class {
    started;
    timeout;
    retries;
    maxInboundStreams;
    maxOutboundStreams;
    peerStore;
    registrar;
    connectionManager;
    addressManager;
    transportManager;
    topologyId;
    log;
    constructor(components, init) {
      this.log = components.logger.forComponent("libp2p:dcutr");
      this.started = false;
      this.peerStore = components.peerStore;
      this.registrar = components.registrar;
      this.addressManager = components.addressManager;
      this.connectionManager = components.connectionManager;
      this.transportManager = components.transportManager;
      this.timeout = init.timeout ?? defaultValues5.timeout;
      this.retries = init.retries ?? defaultValues5.retries;
      this.maxInboundStreams = init.maxInboundStreams ?? defaultValues5.maxInboundStreams;
      this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues5.maxOutboundStreams;
      this.handleIncomingUpgrade = this.handleIncomingUpgrade.bind(this);
    }
    [Symbol.toStringTag] = "@libp2p/dcutr";
    [serviceDependencies] = [
      "@libp2p/identify"
    ];
    isStarted() {
      return this.started;
    }
    async start() {
      if (this.started) {
        return;
      }
      this.topologyId = await this.registrar.register(multicodec, {
        notifyOnLimitedConnection: true,
        onConnect: (peerId, connection) => {
          if (!Circuit.exactMatch(connection.remoteAddr)) {
            return;
          }
          if (connection.direction !== "inbound") {
            return;
          }
          this.upgradeInbound(connection).catch((err2) => {
            this.log.error("error during outgoing DCUtR attempt - %e", err2);
          });
        }
      });
      await this.registrar.handle(multicodec, this.handleIncomingUpgrade, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnLimitedConnection: true
      });
      this.started = true;
    }
    async stop() {
      await this.registrar.unhandle(multicodec);
      if (this.topologyId != null) {
        this.registrar.unregister(this.topologyId);
      }
      this.started = false;
    }
    /**
     * Perform the inbound connection upgrade as B
     *
     * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
     */
    async upgradeInbound(relayedConnection) {
      if (await this.attemptUnilateralConnectionUpgrade(relayedConnection)) {
        return;
      }
      let stream;
      for (let i2 = 0; i2 < this.retries; i2++) {
        const options2 = {
          signal: AbortSignal.timeout(this.timeout)
        };
        try {
          stream = await relayedConnection.newStream([multicodec], {
            signal: options2.signal,
            runOnLimitedConnection: true
          });
          const pb = pbStream(stream, {
            maxDataLength: MAX_DCUTR_MESSAGE_SIZE
          }).pb(HolePunch);
          this.log("B sending connect to %p", relayedConnection.remotePeer);
          const connectTimer = Date.now();
          await pb.write({
            type: HolePunch.Type.CONNECT,
            observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
          }, options2);
          this.log("B receiving connect from %p", relayedConnection.remotePeer);
          const connect2 = await pb.read(options2);
          if (connect2.type !== HolePunch.Type.CONNECT) {
            this.log("A sent wrong message type");
            throw new InvalidMessageError("DCUtR message type was incorrect");
          }
          const multiaddrs = this.getDialableMultiaddrs(connect2.observedAddresses);
          if (multiaddrs.length === 0) {
            this.log("A did not have any dialable multiaddrs");
            throw new InvalidMessageError("DCUtR connect message had no multiaddrs");
          }
          const rtt = Date.now() - connectTimer;
          this.log("A sending sync, rtt %dms", rtt);
          await pb.write({
            type: HolePunch.Type.SYNC,
            observedAddresses: []
          }, options2);
          this.log("A waiting for half RTT");
          await delay_default(rtt / 2);
          this.log("B dialing", multiaddrs);
          const conn = await this.connectionManager.openConnection(multiaddrs, {
            signal: options2.signal,
            priority: DCUTR_DIAL_PRIORITY,
            force: true,
            initiator: false
          });
          this.log("DCUtR to %p succeeded to address %a, closing relayed connection", relayedConnection.remotePeer, conn.remoteAddr);
          await relayedConnection.close(options2);
          break;
        } catch (err2) {
          this.log.error("error while attempting DCUtR on attempt %d of %d - %e", i2 + 1, this.retries, err2);
          stream?.abort(err2);
          if (i2 === this.retries) {
            throw err2;
          }
        } finally {
          if (stream != null) {
            await stream.close(options2);
          }
        }
      }
    }
    /**
     * This is performed when A has dialed B via a relay but A also has a public
     * address that B can dial directly
     */
    async attemptUnilateralConnectionUpgrade(relayedConnection) {
      const peerInfo = await this.peerStore.get(relayedConnection.remotePeer);
      const publicAddresses = peerInfo.addresses.map((address) => {
        const ma = address.multiaddr;
        if (ma.getComponents().find((c2) => c2.code === CODE_P2P)?.value == null) {
          return ma.encapsulate(`/p2p/${relayedConnection.remotePeer}`);
        }
        return ma;
      }).filter((ma) => {
        return isPublicAndDialable(ma, this.transportManager);
      });
      if (publicAddresses.length > 0) {
        const signal = AbortSignal.timeout(this.timeout);
        try {
          this.log("attempting unilateral connection upgrade to %a", publicAddresses);
          const connection = await this.connectionManager.openConnection(publicAddresses, {
            signal,
            force: true
          });
          if (Circuit.exactMatch(connection.remoteAddr)) {
            throw new Error("Could not open a new, non-limited, connection");
          }
          this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
          await relayedConnection.close({
            signal
          });
          return true;
        } catch (err2) {
          this.log.error("unilateral connection upgrade to %p on addresses %a failed - %e", relayedConnection.remotePeer, publicAddresses, err2);
        }
      } else {
        this.log("peer %p has no public addresses, not attempting unilateral connection upgrade", relayedConnection.remotePeer);
      }
      return false;
    }
    /**
     * Perform the connection upgrade as A
     *
     * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
     */
    async handleIncomingUpgrade(stream, relayedConnection) {
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: MAX_DCUTR_MESSAGE_SIZE
      }).pb(HolePunch);
      this.log("A receiving connect");
      const connect2 = await pb.read(options2);
      if (connect2.type !== HolePunch.Type.CONNECT) {
        this.log("B sent wrong message type");
        throw new InvalidMessageError("DCUtR message type was incorrect");
      }
      if (connect2.observedAddresses.length === 0) {
        this.log("B sent no multiaddrs");
        throw new InvalidMessageError("DCUtR connect message had no multiaddrs");
      }
      const multiaddrs = this.getDialableMultiaddrs(connect2.observedAddresses);
      if (multiaddrs.length === 0) {
        this.log("B had no dialable multiaddrs in %o", connect2.observedAddresses.map((b) => multiaddr(b)));
        throw new InvalidMessageError("DCUtR connect message had no dialable multiaddrs");
      }
      this.log("A sending connect");
      await pb.write({
        type: HolePunch.Type.CONNECT,
        observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
      });
      this.log("A receiving sync");
      const sync = await pb.read(options2);
      if (sync.type !== HolePunch.Type.SYNC) {
        throw new InvalidMessageError("DCUtR message type was incorrect");
      }
      this.log("A dialing", multiaddrs);
      const connection = await this.connectionManager.openConnection(multiaddrs, {
        signal: options2.signal,
        priority: DCUTR_DIAL_PRIORITY,
        force: true
      });
      this.log("DCUtR to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
      await relayedConnection.close(options2);
      await stream.close(options2);
    }
    /**
     * Takes the `addr` and converts it to a Multiaddr if possible
     */
    getDialableMultiaddrs(addrs) {
      const output = [];
      for (const addr of addrs) {
        if (addr == null || addr.length === 0) {
          continue;
        }
        try {
          const ma = multiaddr(addr);
          if (!isPublicAndDialable(ma, this.transportManager)) {
            continue;
          }
          output.push(ma);
        } catch {
        }
      }
      return output;
    }
  };

  // node_modules/@libp2p/dcutr/dist/src/index.js
  var multicodec = "/libp2p/dcutr";
  function dcutr(init = {}) {
    return (components) => new DefaultDCUtRService(components, init);
  }

  // node_modules/@achingbrain/http-parser-js/http-parser.js
  function HTTPParser(type) {
    if (type !== void 0 && type !== HTTPParser.REQUEST && type !== HTTPParser.RESPONSE) {
      throw new Error("type must be REQUEST or RESPONSE");
    }
    if (type === void 0) {
    } else {
      this.initialize(type);
    }
    this.maxHeaderSize = HTTPParser.maxHeaderSize;
  }
  HTTPParser.prototype.initialize = function(type, async_resource) {
    if (type !== HTTPParser.REQUEST && type !== HTTPParser.RESPONSE) {
      throw new Error("type must be REQUEST or RESPONSE");
    }
    this.type = type;
    this.state = type + "_LINE";
    this.info = {
      headers: [],
      upgrade: false
    };
    this.trailers = [];
    this.line = "";
    this.isChunked = false;
    this.connection = "";
    this.headerSize = 0;
    this.body_bytes = null;
    this.isUserCall = false;
    this.hadError = false;
  };
  HTTPParser.encoding = "ascii";
  HTTPParser.maxHeaderSize = 80 * 1024;
  HTTPParser.REQUEST = "REQUEST";
  HTTPParser.RESPONSE = "RESPONSE";
  var kOnHeaders = HTTPParser.kOnHeaders = 1;
  var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;
  var kOnBody = HTTPParser.kOnBody = 3;
  var kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;
  HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {
  };
  var compatMode0_12 = true;
  Object.defineProperty(HTTPParser, "kOnExecute", {
    get: function() {
      compatMode0_12 = false;
      return 99;
    }
  });
  var methods = HTTPParser.methods = [
    "DELETE",
    "GET",
    "HEAD",
    "POST",
    "PUT",
    "CONNECT",
    "OPTIONS",
    "TRACE",
    "COPY",
    "LOCK",
    "MKCOL",
    "MOVE",
    "PROPFIND",
    "PROPPATCH",
    "SEARCH",
    "UNLOCK",
    "BIND",
    "REBIND",
    "UNBIND",
    "ACL",
    "REPORT",
    "MKACTIVITY",
    "CHECKOUT",
    "MERGE",
    "M-SEARCH",
    "NOTIFY",
    "SUBSCRIBE",
    "UNSUBSCRIBE",
    "PATCH",
    "PURGE",
    "MKCALENDAR",
    "LINK",
    "UNLINK",
    "SOURCE"
  ];
  var method_connect = methods.indexOf("CONNECT");
  HTTPParser.prototype.reinitialize = HTTPParser;
  HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.remove = HTTPParser.prototype.free = function() {
  };
  HTTPParser.prototype._compatMode0_11 = false;
  HTTPParser.prototype.getAsyncId = function() {
    return 0;
  };
  var headerState = {
    REQUEST_LINE: true,
    RESPONSE_LINE: true,
    HEADER: true
  };
  HTTPParser.prototype.execute = function(chunk, start2, length4) {
    if (!(this instanceof HTTPParser)) {
      throw new TypeError("not a HTTPParser");
    }
    start2 = start2 || 0;
    length4 = typeof length4 === "number" ? length4 : chunk.length;
    this.chunk = chunk;
    this.offset = start2;
    var end = this.end = start2 + length4;
    try {
      while (this.offset < end) {
        if (this[this.state]()) {
          break;
        }
      }
    } catch (err2) {
      if (this.isUserCall) {
        throw err2;
      }
      this.hadError = true;
      return err2;
    }
    this.chunk = null;
    length4 = this.offset - start2;
    if (headerState[this.state]) {
      this.headerSize += length4;
      if (this.headerSize > (this.maxHeaderSize || HTTPParser.maxHeaderSize)) {
        return new Error("max header size exceeded");
      }
    }
    return length4;
  };
  var stateFinishAllowed = {
    REQUEST_LINE: true,
    RESPONSE_LINE: true,
    BODY_RAW: true
  };
  HTTPParser.prototype.finish = function() {
    if (this.hadError) {
      return;
    }
    if (!stateFinishAllowed[this.state]) {
      return new Error("invalid state for EOF");
    }
    if (this.state === "BODY_RAW") {
      this.userCall()(this[kOnMessageComplete]());
    }
  };
  HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {
  };
  HTTPParser.prototype.userCall = function() {
    this.isUserCall = true;
    var self2 = this;
    return function(ret) {
      self2.isUserCall = false;
      return ret;
    };
  };
  HTTPParser.prototype.nextRequest = function() {
    this.userCall()(this[kOnMessageComplete]());
    this.reinitialize(this.type);
  };
  HTTPParser.prototype.consumeLine = function() {
    var end = this.end, chunk = this.chunk;
    for (var i2 = this.offset; i2 < end; i2++) {
      if (chunk[i2] === 10) {
        var line = this.line + toString2(chunk.subarray(this.offset, i2), HTTPParser.encoding);
        if (line.charAt(line.length - 1) === "\r") {
          line = line.substr(0, line.length - 1);
        }
        this.line = "";
        this.offset = i2 + 1;
        return line;
      }
    }
    this.line += toString2(chunk.subarray(this.offset, this.end), HTTPParser.encoding);
    this.offset = this.end;
  };
  var headerExp = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/;
  var headerContinueExp = /^[ \t]+(.*[^ \t])/;
  HTTPParser.prototype.parseHeader = function(line, headers) {
    if (line.indexOf("\r") !== -1) {
      throw parseErrorCode("HPE_LF_EXPECTED");
    }
    var match = headerExp.exec(line);
    var k = match && match[1];
    if (k) {
      headers.push(k);
      headers.push(match[2]);
    } else {
      var matchContinue = headerContinueExp.exec(line);
      if (matchContinue && headers.length) {
        if (headers[headers.length - 1]) {
          headers[headers.length - 1] += " ";
        }
        headers[headers.length - 1] += matchContinue[1];
      }
    }
  };
  var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
  HTTPParser.prototype.REQUEST_LINE = function() {
    var line = this.consumeLine();
    if (!line) {
      return;
    }
    var match = requestExp.exec(line);
    if (match === null) {
      throw parseErrorCode("HPE_INVALID_CONSTANT");
    }
    this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);
    if (this.info.method === -1) {
      throw new Error("invalid request method");
    }
    this.info.url = match[2];
    this.info.versionMajor = +match[3];
    this.info.versionMinor = +match[4];
    this.body_bytes = 0;
    this.state = "HEADER";
  };
  var responseExp = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
  HTTPParser.prototype.RESPONSE_LINE = function() {
    var line = this.consumeLine();
    if (!line) {
      return;
    }
    var match = responseExp.exec(line);
    if (match === null) {
      throw parseErrorCode("HPE_INVALID_CONSTANT");
    }
    this.info.versionMajor = +match[1];
    this.info.versionMinor = +match[2];
    var statusCode = this.info.statusCode = +match[3];
    this.info.statusMessage = match[4];
    if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {
      this.body_bytes = 0;
    }
    this.state = "HEADER";
  };
  HTTPParser.prototype.shouldKeepAlive = function() {
    if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
      if (this.connection.indexOf("close") !== -1) {
        return false;
      }
    } else if (this.connection.indexOf("keep-alive") === -1) {
      return false;
    }
    if (this.body_bytes !== null || this.isChunked) {
      return true;
    }
    return false;
  };
  HTTPParser.prototype.HEADER = function() {
    var line = this.consumeLine();
    if (line === void 0) {
      return;
    }
    var info = this.info;
    if (line) {
      this.parseHeader(line, info.headers);
    } else {
      var headers = info.headers;
      var hasContentLength = false;
      var currentContentLengthValue;
      var hasUpgradeHeader = false;
      for (var i2 = 0; i2 < headers.length; i2 += 2) {
        switch (headers[i2].toLowerCase()) {
          case "transfer-encoding":
            this.isChunked = headers[i2 + 1].toLowerCase() === "chunked";
            break;
          case "content-length":
            currentContentLengthValue = +headers[i2 + 1];
            if (hasContentLength) {
              if (currentContentLengthValue !== this.body_bytes) {
                throw parseErrorCode("HPE_UNEXPECTED_CONTENT_LENGTH");
              }
            } else {
              hasContentLength = true;
              this.body_bytes = currentContentLengthValue;
            }
            break;
          case "connection":
            this.connection += headers[i2 + 1].toLowerCase();
            break;
          case "upgrade":
            hasUpgradeHeader = true;
            break;
        }
      }
      if (this.isChunked && hasContentLength) {
        hasContentLength = false;
        this.body_bytes = null;
      }
      if (hasUpgradeHeader && this.connection.indexOf("upgrade") != -1) {
        info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;
      } else {
        info.upgrade = info.method === method_connect;
      }
      if (this.isChunked && info.upgrade) {
        this.isChunked = false;
      }
      info.shouldKeepAlive = this.shouldKeepAlive();
      var skipBody;
      if (compatMode0_12) {
        skipBody = this.userCall()(this[kOnHeadersComplete](info));
      } else {
        skipBody = this.userCall()(this[kOnHeadersComplete](
          info.versionMajor,
          info.versionMinor,
          info.headers,
          info.method,
          info.url,
          info.statusCode,
          info.statusMessage,
          info.upgrade,
          info.shouldKeepAlive
        ));
      }
      if (skipBody === 2) {
        this.nextRequest();
        return true;
      } else if (this.isChunked && !skipBody) {
        this.state = "BODY_CHUNKHEAD";
      } else if (skipBody || this.body_bytes === 0) {
        this.nextRequest();
        return info.upgrade;
      } else if (this.body_bytes === null) {
        this.state = "BODY_RAW";
      } else {
        this.state = "BODY_SIZED";
      }
    }
  };
  HTTPParser.prototype.BODY_CHUNKHEAD = function() {
    var line = this.consumeLine();
    if (line === void 0) {
      return;
    }
    this.body_bytes = parseInt(line, 16);
    if (!this.body_bytes) {
      this.state = "BODY_CHUNKTRAILERS";
    } else {
      this.state = "BODY_CHUNK";
    }
  };
  HTTPParser.prototype.BODY_CHUNK = function() {
    var length4 = Math.min(this.end - this.offset, this.body_bytes);
    this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.offset + length4), 0, length4));
    this.offset += length4;
    this.body_bytes -= length4;
    if (!this.body_bytes) {
      this.state = "BODY_CHUNKEMPTYLINE";
    }
  };
  HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {
    var line = this.consumeLine();
    if (line === void 0) {
      return;
    }
    if (line !== "") {
      throw new Error("Expected empty line");
    }
    this.state = "BODY_CHUNKHEAD";
  };
  HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {
    var line = this.consumeLine();
    if (line === void 0) {
      return;
    }
    if (line) {
      this.parseHeader(line, this.trailers);
    } else {
      if (this.trailers.length) {
        this.userCall()(this[kOnHeaders](this.trailers, ""));
      }
      this.nextRequest();
    }
  };
  HTTPParser.prototype.BODY_RAW = function() {
    this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.end), 0, this.end - this.offset));
    this.offset = this.end;
  };
  HTTPParser.prototype.BODY_SIZED = function() {
    var length4 = Math.min(this.end - this.offset, this.body_bytes);
    this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.offset + length4), 0, length4));
    this.offset += length4;
    this.body_bytes -= length4;
    if (!this.body_bytes) {
      this.nextRequest();
    }
  };
  ["Headers", "HeadersComplete", "Body", "MessageComplete"].forEach(function(name9) {
    var k = HTTPParser["kOn" + name9];
    Object.defineProperty(HTTPParser.prototype, "on" + name9, {
      get: function() {
        return this[k];
      },
      set: function(to) {
        this._compatMode0_11 = true;
        method_connect = "CONNECT";
        return this[k] = to;
      }
    });
  });
  function parseErrorCode(code8) {
    var err2 = new Error("Parse Error");
    err2.code = code8;
    return err2;
  }

  // node_modules/get-iterator/dist/src/index.js
  function getIterator(obj) {
    if (obj != null) {
      if (typeof obj[Symbol.iterator] === "function") {
        return obj[Symbol.iterator]();
      }
      if (typeof obj[Symbol.asyncIterator] === "function") {
        return obj[Symbol.asyncIterator]();
      }
      if (typeof obj.next === "function") {
        return obj;
      }
    }
    throw new Error("argument is not an iterator or iterable");
  }

  // node_modules/it-to-browser-readablestream/dist/src/index.js
  function itToBrowserReadableStream(source, queuingStrategy = {}) {
    const iter = getIterator(source);
    const s2 = {
      _cancelled: false,
      async start() {
        this._cancelled = false;
      },
      async pull(controller) {
        try {
          const { value: value2, done } = await iter.next();
          if (this._cancelled) {
            return;
          }
          if (done === true) {
            controller.close();
            return;
          }
          controller.enqueue(value2);
        } catch (err2) {
          controller.error(err2);
        }
      },
      cancel() {
        this._cancelled = true;
      }
    };
    return new globalThis.ReadableStream(s2, queuingStrategy);
  }

  // node_modules/multiformats/dist/src/hashes/sha1-browser.js
  var sha2 = (name9) => async (data) => new Uint8Array(await crypto.subtle.digest(name9, data));
  var sha12 = from2({
    name: "sha-1",
    code: 17,
    encode: sha2("SHA-1")
  });

  // node_modules/@libp2p/http-utils/dist/src/request.js
  var Request = class extends globalThis.Request {
    constructor(input, init = {}) {
      const method = init.method ?? "GET";
      const headers = getHeaders(init);
      const body = init.body;
      if (isWebSocketUpgrade(method, headers)) {
        init.method = "UPGRADE";
      }
      super(input, init);
      Object.defineProperties(this, {
        body: {
          value: body,
          writable: false
        },
        method: {
          value: method,
          writable: false
        },
        headers: {
          value: headers,
          writable: false
        }
      });
    }
  };

  // node_modules/@libp2p/http-utils/dist/src/constants.js
  var STATUS_CODES = {
    100: "Continue",
    // RFC 7231 6.2.1
    101: "Switching Protocols",
    // RFC 7231 6.2.2
    102: "Processing",
    // RFC 2518 10.1 (obsoleted by RFC 4918)
    103: "Early Hints",
    // RFC 8297 2
    200: "OK",
    // RFC 7231 6.3.1
    201: "Created",
    // RFC 7231 6.3.2
    202: "Accepted",
    // RFC 7231 6.3.3
    203: "Non-Authoritative Information",
    // RFC 7231 6.3.4
    204: "No Content",
    // RFC 7231 6.3.5
    205: "Reset Content",
    // RFC 7231 6.3.6
    206: "Partial Content",
    // RFC 7233 4.1
    207: "Multi-Status",
    // RFC 4918 11.1
    208: "Already Reported",
    // RFC 5842 7.1
    226: "IM Used",
    // RFC 3229 10.4.1
    300: "Multiple Choices",
    // RFC 7231 6.4.1
    301: "Moved Permanently",
    // RFC 7231 6.4.2
    302: "Found",
    // RFC 7231 6.4.3
    303: "See Other",
    // RFC 7231 6.4.4
    304: "Not Modified",
    // RFC 7232 4.1
    305: "Use Proxy",
    // RFC 7231 6.4.5
    307: "Temporary Redirect",
    // RFC 7231 6.4.7
    308: "Permanent Redirect",
    // RFC 7238 3
    400: "Bad Request",
    // RFC 7231 6.5.1
    401: "Unauthorized",
    // RFC 7235 3.1
    402: "Payment Required",
    // RFC 7231 6.5.2
    403: "Forbidden",
    // RFC 7231 6.5.3
    404: "Not Found",
    // RFC 7231 6.5.4
    405: "Method Not Allowed",
    // RFC 7231 6.5.5
    406: "Not Acceptable",
    // RFC 7231 6.5.6
    407: "Proxy Authentication Required",
    // RFC 7235 3.2
    408: "Request Timeout",
    // RFC 7231 6.5.7
    409: "Conflict",
    // RFC 7231 6.5.8
    410: "Gone",
    // RFC 7231 6.5.9
    411: "Length Required",
    // RFC 7231 6.5.10
    412: "Precondition Failed",
    // RFC 7232 4.2
    413: "Payload Too Large",
    // RFC 7231 6.5.11
    414: "URI Too Long",
    // RFC 7231 6.5.12
    415: "Unsupported Media Type",
    // RFC 7231 6.5.13
    416: "Range Not Satisfiable",
    // RFC 7233 4.4
    417: "Expectation Failed",
    // RFC 7231 6.5.14
    418: "I'm a Teapot",
    // RFC 7168 2.3.3
    421: "Misdirected Request",
    // RFC 7540 9.1.2
    422: "Unprocessable Entity",
    // RFC 4918 11.2
    423: "Locked",
    // RFC 4918 11.3
    424: "Failed Dependency",
    // RFC 4918 11.4
    425: "Too Early",
    // RFC 8470 5.2
    426: "Upgrade Required",
    // RFC 2817 and RFC 7231 6.5.15
    428: "Precondition Required",
    // RFC 6585 3
    429: "Too Many Requests",
    // RFC 6585 4
    431: "Request Header Fields Too Large",
    // RFC 6585 5
    451: "Unavailable For Legal Reasons",
    // RFC 7725 3
    500: "Internal Server Error",
    // RFC 7231 6.6.1
    501: "Not Implemented",
    // RFC 7231 6.6.2
    502: "Bad Gateway",
    // RFC 7231 6.6.3
    503: "Service Unavailable",
    // RFC 7231 6.6.4
    504: "Gateway Timeout",
    // RFC 7231 6.6.5
    505: "HTTP Version Not Supported",
    // RFC 7231 6.6.6
    506: "Variant Also Negotiates",
    // RFC 2295 8.1
    507: "Insufficient Storage",
    // RFC 4918 11.5
    508: "Loop Detected",
    // RFC 5842 7.2
    509: "Bandwidth Limit Exceeded",
    510: "Not Extended",
    // RFC 2774 7
    511: "Network Authentication Required"
    // RFC 6585 6
  };

  // node_modules/@libp2p/http-utils/dist/src/response.js
  var Response2 = class extends globalThis.Response {
    constructor(body, init = {}) {
      const headers = getHeaders(init);
      const status = init.status ?? 200;
      if (status < 200 || status > 599) {
        init.status = 200;
      }
      super(body, init);
      Object.defineProperties(this, {
        status: {
          value: status,
          writable: false
        },
        statusText: {
          value: STATUS_CODES[status],
          writable: false
        },
        headers: {
          value: headers,
          writable: false
        }
      });
    }
  };

  // node_modules/@libp2p/http-utils/dist/src/index.js
  var DNS_CODECS = ["dns", "dns4", "dns6", "dnsaddr"];
  function toURL(resource, headers) {
    if (resource instanceof URL) {
      return resource;
    }
    const host = getHost(resource, headers);
    const { httpPath } = stripHTTPPath(resource);
    return new URL(`http://${host}${httpPath}`);
  }
  function toUint8Array2(obj) {
    if (obj instanceof Uint8Array) {
      return obj;
    }
    if (obj instanceof DataView) {
      return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);
    }
    return new Uint8Array(obj, 0, obj.byteLength);
  }
  function streamToRequest(info, stream) {
    const init = {
      method: info.method,
      headers: info.headers
    };
    if ((init.method !== "GET" || info.upgrade) && init.method !== "HEAD") {
      let source = stream;
      if (!info.upgrade) {
        source = takeBytes(stream, info.headers.get("content-length"));
      }
      init.body = itToBrowserReadableStream(source);
      init.duplex = "half";
    }
    return new Request(normalizeUrl(info).toString(), init);
  }
  async function responseToStream(res, stream) {
    stream.send(fromString2([
      `HTTP/1.1 ${res.status} ${res.statusText}`,
      ...writeHeaders(res.headers),
      "",
      ""
    ].join("\r\n")));
    if (res.body == null) {
      await stream.close().catch((err2) => {
        stream.abort(err2);
      });
      return;
    }
    const reader2 = res.body.getReader();
    while (true) {
      const result = await reader2.read();
      if (result.value != null) {
        if (!stream.send(result.value)) {
          await stream.onDrain();
        }
      }
      if (result.done) {
        break;
      }
    }
    await stream.close().catch((err2) => {
      stream.abort(err2);
    });
  }
  var NOT_FOUND_RESPONSE = fromString2([
    "HTTP/1.1 404 Not Found",
    "Connection: close",
    "",
    ""
  ].join("\r\n"));
  var BAD_REQUEST = fromString2([
    "HTTP/1.1 400 Bad Request",
    "Connection: close",
    "",
    ""
  ].join("\r\n"));
  var INTERNAL_SERVER_ERROR = fromString2([
    "HTTP/1.1 500 Internal Server Error",
    "Connection: close",
    "",
    ""
  ].join("\r\n"));
  var NOT_IMPLEMENTED_ERROR = fromString2([
    "HTTP/1.1 501 Not Implemented",
    "Connection: close",
    "",
    ""
  ].join("\r\n"));
  function writeHeaders(headers) {
    const output = [];
    if (headers.get("Connection") == null) {
      headers.set("Connection", "close");
    }
    for (const [key, value2] of headers.entries()) {
      output.push(`${key}: ${value2}`);
    }
    return output;
  }
  async function* takeBytes(source, bytes) {
    bytes = parseInt(`${bytes ?? ""}`);
    if (bytes == null || isNaN(bytes)) {
      return source;
    }
    let count = 0;
    for await (const buf2 of source) {
      count += buf2.byteLength;
      if (count > bytes) {
        yield buf2.subarray(0, count - bytes);
        return;
      }
      yield buf2.subarray();
      if (count === bytes) {
        return;
      }
    }
  }
  function toResource(resource, path) {
    if (typeof resource === "string") {
      if (resource.startsWith("/")) {
        resource = multiaddr(resource);
      } else {
        resource = new URL(resource);
      }
    }
    if (isPeerId(resource)) {
      resource = multiaddr(`/p2p/${resource}`);
    }
    if (resource instanceof URL) {
      if (resource.protocol === "multiaddr:") {
        resource = uriToMultiaddr(resource.toString());
      }
    }
    if (isMultiaddr(resource)) {
      resource = [resource];
    }
    if (Array.isArray(resource)) {
      for (const ma of resource) {
        const components = ma.getComponents();
        if (components.some(({ name: name9 }) => name9 === "http")) {
          const uri = multiaddrToUri(ma);
          return new URL(`${uri}${path ?? ""}`);
        }
      }
    }
    if (path == null) {
      return resource;
    }
    if (resource instanceof URL) {
      return new URL(`${resource}${path.substring(1)}`);
    }
    return resource.map((ma) => ma.encapsulate(`/http-path/${encodeURIComponent(path.substring(1))}`));
  }
  function getHeaders(init = {}) {
    if (init.headers instanceof Headers) {
      return init.headers;
    }
    init.headers = new Headers(init.headers);
    return init.headers;
  }
  function isValidHost(host) {
    return host != null && host !== "";
  }
  function getHost(addresses, headers) {
    let host;
    let port = 80;
    let protocol = "http:";
    if (addresses instanceof URL) {
      host = addresses.hostname;
      port = parseInt(addresses.port, 10);
      protocol = addresses.protocol;
    }
    if (!isValidHost(host)) {
      host = headers.get("host") ?? void 0;
    }
    if (!isValidHost(host) && Array.isArray(addresses)) {
      for (const address of addresses) {
        const components = address.getComponents();
        const filtered = components.filter(({ name: name9 }) => DNS_CODECS.includes(name9))?.[0]?.value;
        if (filtered != null) {
          host = filtered;
          break;
        }
      }
    }
    if (!isValidHost(host) && Array.isArray(addresses)) {
      for (const address of addresses) {
        const peerStr = address.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
        try {
          const config = getNetConfig(address);
          if (config.port != null) {
            port = config.port;
          }
        } catch {
        }
        if (peerStr != null) {
          const peerId = peerIdFromString(peerStr);
          host = peerId.toCID().toString(base36);
          break;
        }
      }
    }
    if (!isValidHost(host) && Array.isArray(addresses)) {
      for (const address of addresses) {
        try {
          const config = getNetConfig(address);
          if (config.host != null) {
            host = config.host;
          }
          break;
        } catch {
        }
      }
    }
    if (isValidHost(host)) {
      if (protocol === "http:" && port !== 80) {
        host = `${host}:${port}`;
      }
      if (protocol === "https:" && port !== 443) {
        host = `${host}:${port}`;
      }
      return host;
    }
    throw new InvalidParametersError("Could not determine request host name - a request must have a host header, be made to a DNS or IP-based multiaddr or an http(s) URL");
  }
  function stripHTTPPath(addresses) {
    let httpPath = "/";
    addresses = addresses.map((ma) => {
      return multiaddr(ma.getComponents().filter((component) => {
        if (component.name === "http-path") {
          httpPath = component.value ?? "/";
          return false;
        }
        return true;
      }));
    });
    return {
      httpPath,
      addresses
    };
  }
  function normalizeMethod(method, defaultMethod = ["GET"]) {
    if (method == null) {
      return defaultMethod;
    }
    if (typeof method === "string") {
      method = [method];
    }
    return method.map((m2) => m2.toUpperCase());
  }
  function normalizeUrl(req) {
    const url = req.url ?? "/";
    if (url.startsWith("http")) {
      return new URL(url);
    }
    const host = getHostFromReq(req);
    return new URL(`http://${host}${url}`);
  }
  function getHostFromReq(req) {
    let host = req.headers?.host;
    if (host == null) {
      host = req.headers?.Host;
    }
    if (host == null && typeof req.headers.get === "function") {
      host = req.headers.get("host");
    }
    if (host == null) {
      throw new InvalidParametersError("Could not read host");
    }
    return host;
  }
  function isWebSocketUpgrade(method, headers) {
    return method === "GET" && headers.get("connection")?.toLowerCase() === "upgrade" && headers.get("upgrade")?.toLowerCase() === "websocket";
  }
  function getHeaderFromHeaders(headers, key) {
    if (headers instanceof Headers) {
      return headers.get(key) ?? void 0;
    }
    const header = headers[key];
    if (Array.isArray(header)) {
      return header.join(",");
    }
    return header;
  }
  async function getServerUpgradeHeaders(headers) {
    if (getHeaderFromHeaders(headers, "sec-websocket-version") !== "13") {
      throw new ProtocolError("Invalid version");
    }
    const secWebSocketKey = getHeaderFromHeaders(headers, "sec-websocket-key");
    if (secWebSocketKey == null) {
      throw new ProtocolError("Missing sec-websocket-key");
    }
    const token = `${secWebSocketKey}258EAFA5-E914-47DA-95CA-C5AB0DC85B11`;
    const hash = await sha12.digest(fromString2(token));
    const webSocketAccept = base64pad.encode(hash.digest).substring(1);
    return new Headers({
      Upgrade: "websocket",
      Connection: "upgrade",
      "Sec-WebSocket-Accept": webSocketAccept
    });
  }
  async function readHeaders(stream, options2) {
    const parser2 = new HTTPParser("REQUEST");
    const earlyData = new Uint8ArrayList();
    let headerInfo;
    parser2[HTTPParser.kOnHeadersComplete] = (info) => {
      const headers = new Headers();
      for (let i2 = 0; i2 < info.headers.length; i2 += 2) {
        headers.set(info.headers[i2].toLowerCase(), info.headers[i2 + 1]);
      }
      headerInfo = {
        ...info,
        headers,
        raw: earlyData,
        method: HTTPParser.methods[info.method]
      };
    };
    try {
      while (true) {
        const { data } = await raceEvent(stream, "message", options2?.signal);
        const buf2 = data.subarray();
        const read4 = parser2.execute(buf2, 0, buf2.byteLength);
        if (read4 instanceof Error) {
          throw read4;
        }
        earlyData.append(buf2.subarray(0, read4));
        if (read4 < buf2.byteLength) {
          stream.push(buf2.subarray(read4));
        }
        if (headerInfo != null) {
          return headerInfo;
        }
      }
    } catch (err2) {
      stream.abort(err2);
    } finally {
      parser2.finish();
    }
    throw new Error("Failed to read header info from request");
  }

  // node_modules/@libp2p/http-fetch/dist/src/errors.js
  var InvalidResponseError = class extends Error {
    static name = "InvalidResponseError";
    name = "InvalidResponseError";
  };

  // node_modules/@libp2p/http-fetch/dist/src/read-response.js
  var nullBodyStatus = [101, 204, 205, 304];
  async function readResponse(stream, resource, init) {
    const output = Promise.withResolvers();
    const body = new TransformStream();
    const writer = body.writable.getWriter();
    let headersComplete = false;
    const parser2 = new HTTPParser("RESPONSE");
    parser2.maxHeaderSize = init.maxHeaderSize ?? HTTPParser.maxHeaderSize;
    parser2[HTTPParser.kOnHeadersComplete] = (info) => {
      init.log("response headers complete");
      headersComplete = true;
      const headers = new Headers();
      for (let i2 = 0; i2 < info.headers.length; i2 += 2) {
        headers.append(info.headers[i2], info.headers[i2 + 1]);
      }
      let responseBody = body.readable;
      if (nullBodyStatus.includes(info.statusCode)) {
        body.writable.close().catch(() => {
        });
        body.readable.cancel().catch(() => {
        });
        responseBody = null;
      }
      const response = new Response2(responseBody, {
        status: info.statusCode,
        statusText: info.statusMessage,
        headers
      });
      output.resolve(response);
    };
    parser2[HTTPParser.kOnBody] = (buf2) => {
      init.log("response read body %d bytes", buf2.byteLength);
      writer.write(buf2).catch((err2) => {
        output.reject(err2);
      });
    };
    parser2[HTTPParser.kOnMessageComplete] = () => {
      init.log("response message complete");
      writer.close().catch((err2) => {
        output.reject(err2);
      });
    };
    let read4 = 0;
    stream.addEventListener("message", ({ data }) => {
      init.log("response stream read %d bytes", data.byteLength);
      read4 += data.byteLength;
      const result = parser2.execute(data.subarray(), 0, data.byteLength);
      if (result instanceof Error) {
        stream.abort(result);
        parser2.finish();
      }
    });
    stream.addEventListener("remoteCloseWrite", () => {
      if (!headersComplete) {
        output.reject(new InvalidResponseError(`Response ended before headers were received, read ${read4} bytes`));
      }
      parser2.finish();
    });
    return output.promise;
  }

  // node_modules/@libp2p/http-fetch/dist/src/body/blob.js
  function blobBody(blob, headers) {
    headers.set("Content-Length", `${blob.size}`);
    headers.set("Content-Type", blob.type != null && blob.type !== "" ? blob.type : "application/octet-stream");
    return blob.stream();
  }

  // node_modules/@libp2p/http-fetch/dist/src/body/bytes.js
  function bytesBody(bytes, headers) {
    headers.set("Content-Length", `${bytes.byteLength}`);
    headers.set("Content-Type", "application/octet-stream");
    return new ReadableStream({
      start(controller) {
        controller.enqueue(toUint8Array2(bytes));
        controller.close();
      }
    });
  }

  // node_modules/@libp2p/http-fetch/dist/src/body/form-data.js
  function calculateSize(name9, entry, boundary) {
    const header = [
      `--${boundary}`
    ];
    let contentLength = 0;
    const trailingLinebreak = "\r\n".length;
    if (typeof entry === "string") {
      header.push(`Content-Disposition: form-data; name="${name9}"`, 'Content-Type: text/plain; charset="UTF-8"', `Content-Length: ${entry.length}`, "");
      contentLength = entry.length + trailingLinebreak;
    } else {
      header.push(`Content-Disposition: form-data; name="${name9}"; filename="${encodeURIComponent(entry.name)}"`, "Content-Type: application/octet-stream", `Content-Length: ${entry.size}`, "");
      contentLength = entry.size + trailingLinebreak;
    }
    const buf2 = fromString2(header.join("\r\n"));
    return buf2.byteLength + contentLength;
  }
  function formDataBody(formData, headers) {
    const boundary = `-----------------------------${crypto.randomUUID()}`;
    headers.set("Content-Type", `multipart/form-data; boundary=${boundary}`);
    let length4 = 0;
    for (const [name9, value2] of formData.entries()) {
      length4 += calculateSize(name9, value2, boundary);
    }
    headers.set("Content-Length", `${length4}`);
    const formDataIterator = formData.entries();
    let fileDataReader;
    function queuePart(controller, name9, entry, boundary2) {
      const header = [
        `--${boundary2}`
      ];
      if (typeof entry === "string") {
        header.push(`Content-Disposition: form-data; name="${name9}"`, 'Content-Type: text/plain; charset="UTF-8"', `Content-Length: ${entry.length}`, "", entry, "");
      } else {
        header.push(`Content-Disposition: form-data; name="${name9}"; filename="${encodeURIComponent(entry.name)}"`, "Content-Type: application/octet-stream", `Content-Length: ${entry.size}`, "");
        fileDataReader = entry.stream().getReader();
      }
      controller.enqueue(fromString2(header.join("\r\n")));
    }
    async function getNext(controller, boundary2) {
      if (fileDataReader != null) {
        const result = await fileDataReader.read();
        if (result.value != null) {
          controller.enqueue(result.value);
        }
        if (result.done) {
          controller.enqueue(fromString2("\r\n"));
          fileDataReader = void 0;
        }
        return;
      }
      const { done, value: value2 } = formDataIterator.next();
      if (value2 != null) {
        const [name9, entry] = value2;
        queuePart(controller, name9, entry, boundary2);
      }
      if (done === true) {
        controller.close();
      }
    }
    return new ReadableStream({
      async pull(controller) {
        await getNext(controller, boundary);
      }
    });
  }

  // node_modules/@libp2p/http-fetch/dist/src/body/readable-stream.js
  function readableStreamBody(stream, headers) {
    headers.set("Content-Type", "application/octet-stream");
    headers.set("Transfer-Encoding", "chunked");
    const reader2 = stream.getReader();
    return new ReadableStream({
      async pull(controller) {
        const { done, value: value2 } = await reader2.read();
        if (value2 != null) {
          controller.enqueue(fromString2(`${value2.byteLength}\r
`));
          controller.enqueue(value2);
          controller.enqueue(fromString2("\r\n"));
        }
        if (done) {
          controller.enqueue(fromString2("0\r\n\r\n"));
          controller.close();
        }
      }
    });
  }

  // node_modules/@libp2p/http-fetch/dist/src/body/string.js
  function stringBody(str, headers) {
    headers.set("Content-Length", `${str.length}`);
    headers.set("Content-Type", 'text/plain; charset="UTF-8"');
    return new ReadableStream({
      start(controller) {
        controller.enqueue(fromString2(str));
        controller.close();
      }
    });
  }

  // node_modules/@libp2p/http-fetch/dist/src/utils.js
  function normalizeContent(body, headers) {
    if (body == null) {
      return;
    }
    if (typeof body === "string") {
      return stringBody(body, headers);
    } else if (body instanceof Blob) {
      return blobBody(body, headers);
    } else if (isBytes3(body)) {
      return bytesBody(body, headers);
    } else if (body instanceof URLSearchParams) {
      return stringBody(body.toString(), headers);
    } else if (body instanceof ReadableStream) {
      return readableStreamBody(body, headers);
    } else if (body instanceof FormData) {
      return formDataBody(body, headers);
    }
    throw new Error("Unsupported body type");
  }
  function isBytes3(obj) {
    if (obj == null) {
      return false;
    }
    return obj.byteLength != null;
  }

  // node_modules/@libp2p/http-fetch/dist/src/send-request.js
  async function sendRequest(stream, url, init) {
    const headers = new Headers(init.headers);
    const host = headers.get("host") ?? url.hostname;
    headers.set("host", host);
    if (headers.get("user-agent") == null) {
      headers.set("user-agent", "libp2p/fetch");
    }
    const content = normalizeContent(init.body, headers);
    const req = [
      `${init?.method?.toUpperCase() ?? "GET"} ${url.pathname ?? "/"} HTTP/1.1`,
      ...writeHeaders(headers),
      "",
      ""
    ];
    if (!stream.send(fromString2(req.join("\r\n")))) {
      await stream.onDrain({
        signal: init.signal ?? void 0
      });
    }
    if (content != null) {
      init.log("request sending body");
      await sendBody(stream, content, init);
    }
  }
  async function sendBody(stream, body, init) {
    const reader2 = body.getReader();
    while (true) {
      const { done, value: value2 } = await reader2.read();
      if (value2 != null) {
        init.log("request send %d bytes", value2.byteLength);
        if (!stream.send(value2)) {
          await stream.onDrain({
            signal: init.signal ?? void 0
          });
        }
      }
      if (done) {
        init.log("request finished sending body");
        break;
      }
    }
  }

  // node_modules/@libp2p/http-fetch/dist/src/index.js
  async function fetch2(stream, resource, init = {}) {
    const log18 = stream.log.newScope("http-fetch");
    resource = typeof resource === "string" ? new URL(resource) : resource;
    const [response] = await Promise.all([
      readResponse(stream, resource, {
        ...init,
        log: log18
      }),
      sendRequest(stream, resource, {
        ...init,
        log: log18
      })
    ]);
    await stream.close({
      signal: init.signal ?? void 0
    });
    return response;
  }

  // node_modules/@libp2p/http-websocket/dist/src/events.js
  var ErrorEvent = class extends Event {
    message;
    error;
    filename = "";
    lineno = 0;
    colno = 0;
    constructor(err2) {
      super("error");
      this.error = err2;
      this.message = err2.message;
    }
  };
  var CloseEvent = class extends Event {
    code;
    reason;
    wasClean;
    constructor(type, eventInitDict) {
      super(type);
      this.code = eventInitDict?.code ?? 0;
      this.reason = eventInitDict?.reason ?? "";
      this.wasClean = eventInitDict?.wasClean ?? true;
    }
  };

  // node_modules/@libp2p/http-websocket/dist/src/message.js
  var OP_CODES = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CONNECTION_CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  var MESSAGE_TYPES = {
    0: "CONTINUATION",
    1: "TEXT",
    2: "BINARY",
    8: "CONNECTION_CLOSE",
    9: "PING",
    10: "PONG"
  };
  var CLOSE_MESSAGES = {
    NORMAL_CLOSURE: 1e3,
    GOING_AWAY: 1001,
    PROTOCOL_ERROR: 1002,
    UNSUPPORTED_DATA: 1003,
    RESERVED: 1004,
    NO_STATUS_RECEIVED: 1005,
    ABNORMAL_CLOSURE: 1006,
    INVALID_FRAME_PAYLOAD_DATA: 1007,
    POLICY_VIOLATION: 1008,
    MESSAGE_TOO_BIG: 1009,
    MANDATORY_EXT: 1010,
    INTERNAL_SERVER_ERROR: 1011,
    TLS_HANDSHAKE: 1015
  };
  function decodeMessage2(buf2) {
    let offset = 0;
    if (buf2.byteLength < offset + 1) {
      return;
    }
    const byte0 = buf2.get(offset);
    const opcode = byte0 & 15;
    offset++;
    if (MESSAGE_TYPES[opcode] == null) {
      throw new Error(`Unknown opcode: ${opcode}`);
    }
    if (buf2.byteLength < offset + 1) {
      return;
    }
    const byte1 = buf2.get(offset);
    const isMasked = (byte1 & 128) === 128;
    let length4 = byte1 & 127;
    offset++;
    if (length4 === 126) {
      if (buf2.byteLength < offset + 2) {
        return;
      }
      length4 = buf2.getUint16(offset);
      offset += 2;
    } else if (length4 === 127) {
      if (buf2.byteLength < offset + 8) {
        return;
      }
      length4 = buf2.getUint32(offset);
      offset += 8;
    }
    if (length4 === 0) {
      buf2.consume(offset);
      return {
        type: MESSAGE_TYPES[opcode]
      };
    }
    let mask;
    if (isMasked) {
      if (buf2.byteLength < offset + 4) {
        return;
      }
      mask = buf2.subarray(offset, offset + 4);
      offset += 4;
    }
    if (buf2.byteLength < offset + length4) {
      return;
    }
    let data = buf2.subarray(offset, offset + length4);
    offset += length4;
    if (mask != null) {
      data = applyMask(data, mask);
    }
    buf2.consume(offset);
    return {
      type: MESSAGE_TYPES[opcode],
      data
    };
  }
  function applyMask(data, mask) {
    let m2 = 0;
    for (let i2 = 0; i2 < data.byteLength; i2++) {
      data[i2] = data[i2] ^ mask[m2];
      m2++;
      if (m2 === mask.byteLength) {
        m2 = 0;
      }
    }
    return data;
  }
  function encodeMessage2(opcode, data, maskData) {
    const fin = true;
    const message2 = new Uint8ArrayList(Uint8Array.from([
      (fin ? 128 : 0) | OP_CODES[opcode]
    ]));
    const length4 = data?.byteLength ?? 0;
    if (length4 < 126) {
      message2.append(Uint8Array.from([
        length4 | (maskData === true ? 128 : 0)
      ]));
    } else if (length4 < 65535) {
      const l2 = new Uint8ArrayList(new Uint8Array(3));
      l2.set(0, 126 | (maskData === true ? 128 : 0));
      l2.setUint16(1, length4);
      message2.append(l2);
    } else if (length4 < 18446744073709552e3) {
      const l2 = new Uint8ArrayList(new Uint8Array(9));
      l2.set(0, 127 | (maskData === true ? 128 : 0));
      l2.setUint32(1, length4);
      message2.append(l2);
    } else {
      throw new Error("Payload too large");
    }
    if (maskData === true && data != null) {
      const maskingKey = Uint8Array.from([0, 0, 0, 0]);
      message2.append(maskingKey);
      data = applyMask(data, maskingKey);
    }
    if (data != null) {
      message2.append(data);
    }
    return message2;
  }

  // node_modules/@libp2p/http-websocket/dist/src/utils.js
  function toBytes(data) {
    if (data instanceof Uint8Array || data instanceof ArrayBuffer || data instanceof DataView) {
      return toUint8Array2(data);
    }
    if (typeof data === "string") {
      return fromString2(data);
    }
    if (data instanceof Blob) {
      return data.arrayBuffer().then((buf2) => toUint8Array2(buf2));
    }
    throw new InvalidParametersError("Unsupported data type");
  }
  async function readResponse2(stream, options2) {
    return new Promise((resolve8, reject) => {
      let readHeaders2 = false;
      const parser2 = new HTTPParser("RESPONSE");
      parser2[HTTPParser.kOnHeadersComplete] = (info) => {
        readHeaders2 = true;
        const headers = [];
        for (let i2 = 0; i2 < info.headers.length; i2 += 2) {
          headers.push([info.headers[i2], info.headers[i2 + 1]]);
        }
        resolve8(new Response2(null, {
          status: info.statusCode,
          statusText: info.statusMessage,
          headers: new Headers(headers)
        }));
      };
      Promise.resolve().then(async () => {
        while (true) {
          const { data } = await raceEvent(stream, "message", options2.signal);
          const buf2 = data.subarray();
          const read4 = parser2.execute(buf2, 0, buf2.byteLength);
          if (read4 instanceof Error) {
            throw read4;
          }
          if (read4 < buf2.byteLength) {
            stream.push(buf2.subarray(read4));
          }
          if (readHeaders2) {
            break;
          }
        }
      }).catch((err2) => {
        reject(err2);
      });
    });
  }
  async function* performClientUpgrade(url, protocols = [], headers) {
    const webSocketKey = base64pad.encode(crypto.getRandomValues(new Uint8Array(16))).substring(1);
    headers.set("host", url.hostname);
    headers.set("connection", "upgrade");
    headers.set("upgrade", "websocket");
    headers.set("pragma", "no-cache");
    headers.set("cache-control", "no-cache");
    headers.set("sec-websocket-version", "13");
    headers.set("sec-websocket-key", webSocketKey);
    if (protocols.length > 0) {
      headers.set("sec-websocket-protocol", protocols.join(", "));
    }
    yield fromString2([
      `GET ${url.pathname ?? "/"} HTTP/1.1`,
      ...[...headers.entries()].map(([key, value2]) => `${key}: ${value2}`),
      "",
      ""
    ].join("\r\n"));
  }

  // node_modules/@libp2p/http-websocket/dist/src/websocket.js
  var DATA_MESSAGES = ["BINARY", "TEXT", "CONTINUATION"];
  var MAX_MESSAGE_SIZE2 = 10485760;
  var HTTP_PROTOCOL = "/http/1.1";
  var AbstractWebSocket = class extends TypedEventEmitter {
    binaryType = "arraybuffer";
    bufferedAmount = 0;
    extensions = "";
    protocol = "";
    readyState;
    url;
    CONNECTING = 0;
    OPEN = 1;
    CLOSING = 2;
    CLOSED = 3;
    _onclose;
    _onerror;
    _onmessage;
    _onopen;
    sentClose;
    isClient;
    buffer;
    maxMessageSize;
    _url;
    closeController;
    constructor(url, init = {}) {
      super();
      this.readyState = this.CONNECTING;
      this.url = url.pathname;
      this.sentClose = false;
      this.isClient = init.isClient ?? true;
      this.buffer = new Uint8ArrayList();
      this.closeController = new AbortController();
      this.maxMessageSize = init.maxMessageSize ?? MAX_MESSAGE_SIZE2;
    }
    send(data) {
      if (this.readyState !== this.OPEN) {
        throw new Error("WebSocket was not open");
      }
      const b = toBytes(data);
      if (isPromise2(b)) {
        b.then((b2) => {
          this._send("BINARY", b2);
        }).catch((err2) => {
          this._errored(err2);
        });
      } else {
        this._send("BINARY", b);
      }
    }
    _send(type, data) {
      if (this.readyState !== this.OPEN) {
        return;
      }
      const message2 = encodeMessage2(type, data, this.isClient);
      const byteLength = message2.byteLength;
      this.bufferedAmount += byteLength;
      this._write(message2, (err2) => {
        this.bufferedAmount -= byteLength;
        if (err2 != null) {
          this._errored(err2);
        }
      });
    }
    close(code8, reason) {
      if (this.readyState !== this.OPEN) {
        throw new Error("WebSocket was not open");
      }
      this.readyState = this.CLOSING;
      this.sentClose = true;
      this._send("CONNECTION_CLOSE");
    }
    _errored(err2) {
      this.readyState = this.CLOSED;
      this.dispatchEvent(new ErrorEvent(err2));
    }
    set onclose(listener) {
      this._onclose = listener;
      this.addEventListener("close", listener);
    }
    get onclose() {
      return this._onclose ?? null;
    }
    set onerror(listener) {
      this._onerror = listener;
      this.addEventListener("error", listener);
    }
    get onerror() {
      return this._onerror ?? null;
    }
    set onmessage(listener) {
      this._onmessage = listener;
      this.addEventListener("message", listener);
    }
    get onmessage() {
      return this._onmessage ?? null;
    }
    set onopen(listener) {
      this._onopen = listener;
      this.addEventListener("open", listener);
    }
    get onopen() {
      return this._onopen ?? null;
    }
    _push(buf2) {
      this.buffer.append(buf2);
      if (this.buffer.byteLength > this.maxMessageSize) {
        this.close(CLOSE_MESSAGES.MESSAGE_TOO_BIG, "Max message size exceeded");
        return;
      }
      while (true) {
        const message2 = decodeMessage2(this.buffer);
        if (message2 == null) {
          break;
        }
        if (DATA_MESSAGES.includes(message2.type) && message2.data != null) {
          let data;
          if (this.binaryType === "blob") {
            data = new Blob([message2.data]);
          } else {
            if (message2.data.byteOffset === 0 && message2.data.byteLength === message2.data.buffer.byteLength) {
              data = message2.data.buffer;
            } else {
              data = new ArrayBuffer(message2.data.byteLength);
              new Uint8Array(data, 0, data.byteLength).set(message2.data);
            }
          }
          this.dispatchEvent(new MessageEvent("message", {
            data,
            origin: this._url?.hostname
          }));
        }
        if (message2.type === "PING") {
          this._send("PONG", message2.data);
        }
        if (message2.type === "CONNECTION_CLOSE") {
          if (!this.sentClose) {
            this.close();
          }
          this.closeController.abort();
          this._close(void 0, () => {
            this.readyState = this.CLOSED;
            this.dispatchEvent(new CloseEvent("close"));
          });
        }
      }
    }
    /**
     * To be invoked when the underlying transport is closed by the remote end
     */
    _remoteClosed(err2) {
      this.readyState = this.CLOSING;
      this._close(err2, () => {
        this.readyState = this.CLOSED;
        this.dispatchEvent(new CloseEvent("close"));
      });
    }
  };
  var RequestWebSocket = class extends AbstractWebSocket {
    writer;
    writable;
    constructor(request, writable, init = {}) {
      super(new URL(request.url), {
        ...init,
        isClient: false
      });
      if (request.body == null) {
        throw new InvalidParametersError("Request body cannot be null");
      }
      this.readyState = this.OPEN;
      this.writable = writable;
      this.writer = writable.getWriter();
      const reader2 = request.body.getReader();
      Promise.resolve().then(async () => {
        this.dispatchEvent(new Event("open"));
        while (true) {
          const { value: value2, done } = await reader2.read();
          if (value2 != null) {
            this._push(value2);
          }
          if (done) {
            this._remoteClosed();
            break;
          }
        }
      }).catch((err2) => {
        this._errored(err2);
      });
    }
    _write(buf2, cb) {
      this.writer?.write(buf2).then(() => {
        cb();
      }, (err2) => {
        cb(err2);
      });
    }
    _close(err2, cb) {
      if (err2 != null) {
        this.writable.abort(err2).then(() => {
          cb();
        }, () => {
          cb();
        });
      } else {
        this.writable.close().then(() => {
          cb();
        }, () => {
          cb();
        });
      }
    }
  };
  var WebSocket2 = class extends AbstractWebSocket {
    stream;
    handshakeTimeout;
    drainTimeout;
    constructor(mas, url, connectionManager, init) {
      super(url, {
        ...init,
        isClient: true
      });
      this.handshakeTimeout = init.handshakeTimeout ?? 1e4;
      this.drainTimeout = init.drainTimeout ?? 1e4;
      Promise.resolve().then(async () => {
        const signal = AbortSignal.timeout(this.handshakeTimeout);
        this.stream = await connectionManager.openStream(mas, HTTP_PROTOCOL, {
          ...init,
          signal
        });
        for await (const buf2 of performClientUpgrade(url, init.protocols, getHeaders(init))) {
          if (!this.stream.send(buf2)) {
            await this.stream.onDrain({
              signal
            });
          }
        }
        const res = await readResponse2(this.stream, {
          signal
        });
        if (res.status !== 101) {
          throw new Error("Invalid WebSocket handshake - response status " + res.status);
        }
        await init.onHandshakeResponse?.(res, {
          signal
        });
        this.protocol = res.headers.get("Sec-WebSocket-Protocol") ?? "";
        this.readyState = this.OPEN;
        this.dispatchEvent(new Event("open"));
        for await (const buf2 of this.stream) {
          this._push(buf2);
        }
      }).catch((err2) => {
        this._errored(err2);
      });
    }
    _write(buf2, cb) {
      if (this.stream == null) {
        cb(new Error("WebSocket was not open"));
        return;
      }
      if (!this.stream.send(buf2)) {
        this.stream.onDrain({
          signal: AbortSignal.timeout(this.drainTimeout)
        }).then(() => {
          cb();
        }, (err2) => {
          cb(err2);
        });
      } else {
        cb();
      }
    }
    _close(err2, cb) {
      if (this.stream == null) {
        cb();
        return;
      }
      if (err2 != null) {
        this.stream.abort(err2);
        cb();
        return;
      }
      this.stream.close().catch((err3) => {
        this.stream?.abort(err3);
      }).finally(() => {
        cb();
      });
    }
  };

  // node_modules/@libp2p/http/dist/src/constants.js
  var HTTP_PROTOCOL2 = "/http/1.1";
  var WEBSOCKET_HANDLER = Symbol.for("@libp2p/http/websocket-handler");

  // node_modules/@libp2p/http/dist/src/middleware/cookies.js
  var import_cookie = __toESM(require_dist(), 1);
  var Cookies = class {
    log;
    cookies;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:http:cookies");
      this.cookies = /* @__PURE__ */ new Map();
    }
    async prepareRequest(resource, opts) {
      const credentials = opts.credentials ?? "same-origin";
      if (credentials === "omit") {
        return;
      }
      const origin = opts.headers.get("origin");
      if (origin == null || origin === "null") {
        return;
      }
      const url = toURL(resource, opts.headers);
      const cookies = (this.cookies.get(url.hostname) ?? []).filter((cookie2) => {
        if (cookie2.expires != null && cookie2.expires < Date.now()) {
          return false;
        }
        if (cookie2.path != null && !url.pathname.startsWith(cookie2.path)) {
          return false;
        }
        return true;
      }).map((cookie2) => `${cookie2.name}=${cookie2.value}`).join("; ");
      if (cookies.length > 0) {
        opts.headers.set("cookie", cookies);
      }
    }
    async processResponse(resource, opts, response) {
      const credentials = opts.credentials ?? "same-origin";
      if (credentials === "omit") {
        removeSetCookie(response);
        return;
      }
      const origin = opts.headers.get("origin");
      if (origin == null || origin === "null") {
        return;
      }
      const url = toURL(resource, opts.headers);
      for (const value2 of response.headers.getSetCookie()) {
        const cookies = [
          ...this.cookies.get(url.hostname) ?? [],
          ...toCookies(import_cookie.default.parse(value2))
        ];
        this.cookies.set(url.hostname, cookies);
      }
      removeSetCookie(response);
    }
  };
  function removeSetCookie(response) {
    if (response.headers.has("set-cookie")) {
      response.headers.delete("set-cookie");
    }
    return response;
  }
  function toCookies(parsed) {
    const metadata = {};
    const output = [];
    Object.entries(parsed).forEach(([name9, value2]) => {
      if (name9.toLowerCase() === "domain" && value2 != null) {
        metadata.domain = value2;
      }
      if (name9.toLowerCase() === "max-age" && value2 != null) {
        metadata.expires = Date.now() + parseInt(value2, 10) * 1e3;
      }
      if (!COOKIE_FIELDS.includes(name9.toLowerCase()) && value2 != null) {
        output.push({
          name: name9,
          value: value2
        });
      }
    });
    return output.map((c2) => ({
      ...c2,
      ...metadata
    }));
  }
  var COOKIE_FIELDS = [
    "domain",
    "expires",
    "httponly",
    "max-age",
    "partitioned",
    "path",
    "samesite",
    "secure"
  ];

  // node_modules/@libp2p/http/dist/src/middleware/origin.js
  var Origin = class {
    async prepareRequest(resource, opts) {
      if (opts.headers.get("origin") != null) {
        return;
      }
      if (opts.mode === "no-cors") {
        return;
      }
      const url = toURL(resource, opts.headers);
      opts.headers.set("origin", `${url.protocol}//${url.host}`);
    }
  };

  // node_modules/@libp2p/http/dist/src/routes/utils.js
  function isInitializable(obj) {
    return typeof obj.init === "function";
  }
  function initializeRoute(serviceOrHandler, components) {
    if (isInitializable(serviceOrHandler)) {
      const route = serviceOrHandler;
      route.handler = serviceOrHandler.init(components);
      delete route.init;
      return route;
    }
    return serviceOrHandler;
  }

  // node_modules/@libp2p/http/dist/src/routes/websocket.js
  function webSocketRoute(route) {
    const method = normalizeMethod(route.method, ["GET"]);
    if (route.fallback == null && method.filter((method2) => method2 !== "GET").length > 0) {
      throw new InvalidParametersError("WebSocket handlers only support the GET HTTP method");
    }
    const output = {
      ...route,
      init: (components) => {
        const next = initializeRoute(route, components);
        output[WEBSOCKET_HANDLER] = next.handler;
        return async (req) => {
          if (!isWebSocketUpgrade(req.method, req.headers)) {
            if (route?.fallback != null) {
              return route.fallback(req);
            }
            return new Response2(null, {
              status: 400
            });
          }
          const transform = new TransformStream();
          try {
            const res = new Response2(transform.readable, {
              status: 101,
              headers: await getServerUpgradeHeaders(req.headers)
            });
            const ws = new RequestWebSocket(req, transform.writable, route);
            next.handler(ws);
            return res;
          } catch (err2) {
            return new Response2(null, {
              status: 500
            });
          }
        };
      }
    };
    return output;
  }

  // node_modules/@libp2p/http/dist/src/routes/well-known.js
  var WELL_KNOWN_PROTOCOLS_PATH = "/.well-known/libp2p/protocols";
  function wellKnownRoute(registrar) {
    return webSocketRoute({
      path: WELL_KNOWN_PROTOCOLS_PATH,
      method: ["GET"],
      cors: true,
      handler: (ws) => {
        const map2 = JSON.stringify(registrar.getProtocolMap());
        ws.send(map2);
        ws.close();
      },
      fallback: async (req) => {
        const map2 = JSON.stringify(registrar.getProtocolMap());
        return new Response(map2, {
          headers: {
            "Content-Type": "application/json",
            "Content-Length": `${map2.length}`
          }
        });
      }
    });
  }

  // node_modules/@libp2p/http/dist/src/registrar.js
  var HTTPRegistrar = class {
    log;
    components;
    protocols;
    endpoint;
    constructor(components, init = {}) {
      this.components = components;
      this.log = components.logger.forComponent("libp2p:http:registrar");
      this.protocols = [];
      this.onStream = this.onStream.bind(this);
      this.endpoint = init.server;
      this.handle("", wellKnownRoute(this));
    }
    async start() {
      await this.components.registrar.handle(HTTP_PROTOCOL2, this.onStream.bind(this));
    }
    async stop() {
      await this.components.registrar.unhandle(HTTP_PROTOCOL2);
    }
    async onStream(stream, connection) {
      const info = await readHeaders(stream);
      if (this.canHandle(info)) {
        this.log("handling incoming request %s %s", info.method, info.url);
        const res = await this.onRequest(streamToRequest(info, stream));
        await responseToStream(res, stream);
        await stream.close();
        return;
      }
      if (this.endpoint == null) {
        this.log("cannot handle incoming request %s %s and no endpoint configured", info.method, info.url);
        stream.send(NOT_FOUND_RESPONSE);
        await stream.close();
        return;
      }
      this.log("passing incoming request %s %s to endpoint", info.method, info.url);
      this.endpoint.inject(info, stream, connection).catch((err2) => {
        this.log.error("error injecting request to endpoint - %e", err2);
        stream.abort(err2);
      });
    }
    canHandle(req) {
      const url = normalizeUrl(req).pathname;
      if (this.protocols.find((p2) => p2.route.path === url) != null) {
        this.log.trace("can handle %s", url);
        return true;
      }
      this.log.trace("cannot handle %s", url);
      return false;
    }
    async onRequest(request) {
      this.log("incoming request %s %s", request.method, request.url);
      const handler = this.findHandler(request.url);
      if (handler == null) {
        return new Response(null, {
          status: 404
        });
      }
      let response;
      if (!handler.route.method.includes(request.method)) {
        if (request.method === "OPTIONS") {
          response = new Response(null, {
            status: 204
          });
        } else {
          response = new Response(null, {
            status: 405
          });
        }
      } else {
        response = await handler.route.handler(request);
      }
      addHeaders(response, request, handler);
      this.log("%s %s %d %s", request.method, request.url, response.status, response.statusText);
      return response;
    }
    onWebSocket(ws) {
      const handler = this.findHandler(ws.url);
      if (handler != null) {
        const wsHandler = handler.route[WEBSOCKET_HANDLER];
        if (wsHandler != null) {
          wsHandler(ws);
          return;
        }
      }
      ws.close(CLOSE_MESSAGES.NORMAL_CLOSURE);
    }
    findHandler(url) {
      const pathname = url.startsWith("/") ? url : new URL(url).pathname;
      this.log("search for handler on path %s", pathname);
      const handler = this.protocols.find((p2) => p2.route.path === pathname);
      if (handler != null) {
        this.log("found handler for HTTP protocol %s on path %s", handler.protocol, url);
      }
      return handler;
    }
    handle(protocol, route) {
      route.path = route.path ?? protocol;
      if (this.protocols.find((p2) => p2.protocol === protocol) != null) {
        throw new InvalidParametersError(`HTTP protocol handler for ${protocol} already registered`);
      }
      if (route.path === "" || !route.path.startsWith("/")) {
        route.path = `/${route.path}`;
      }
      route.cors = route.cors ?? true;
      route.method = normalizeMethod(route.method);
      route = initializeRoute(route, this.components);
      this.protocols.push({
        protocol,
        // @ts-expect-error optional fields are filled out above
        route
      });
      this.protocols.sort(({ route: { path: a2 } }, { route: { path: b } }) => b.length - a2.length);
    }
    unhandle(protocol) {
      this.protocols = this.protocols.filter((p2) => p2.protocol === protocol);
    }
    getProtocolMap() {
      const output = {};
      for (const p2 of this.protocols) {
        if (p2.protocol === "") {
          continue;
        }
        output[p2.protocol] = {
          path: p2.route.path
        };
      }
      return output;
    }
  };
  function addHeaders(response, request, handler) {
    const allow = [.../* @__PURE__ */ new Set(["OPTIONS", ...handler.route.method])].join(", ");
    if (handler.route.cors) {
      if (request.headers.get("Access-Control-Request-Method") != null) {
        response.headers.set("access-control-allow-methods", allow);
      }
      if (request.headers.get("Access-Control-Request-Headers") != null) {
        response.headers.set("access-control-allow-headers", request.headers.get("Access-Control-Request-Headers") ?? "");
      }
      if (request.headers.get("Origin") != null) {
        response.headers.set("access-control-allow-origin", request.headers.get("Origin") ?? "");
        response.headers.set("vary", "Origin");
      }
    }
    if (request.method === "OPTIONS") {
      response.headers.set("allow", allow);
    }
  }

  // node_modules/@libp2p/http/dist/src/utils.js
  async function prepareAndSendRequest(resource, opts, sendRequest2) {
    for (const middleware of opts.middleware) {
      await middleware.prepareRequest?.(resource, opts);
    }
    return sendRequest2();
  }
  async function prepareAndConnect(resource, opts, connect2) {
    for (const middleware of opts.middleware) {
      await middleware.prepareRequest?.(resource, opts);
    }
    return connect2();
  }
  async function processResponse(resource, opts, response) {
    for (const middleware of opts.middleware) {
      await middleware.processResponse?.(resource, opts, response);
    }
    return response;
  }

  // node_modules/@libp2p/http/dist/src/http.browser.js
  var HTTP2 = class {
    log;
    components;
    httpRegistrar;
    origin;
    cookies;
    constructor(components, init = {}) {
      this.components = components;
      this.log = components.logger.forComponent("libp2p:http");
      this.httpRegistrar = new HTTPRegistrar(components, init);
      this.origin = new Origin();
      this.cookies = new Cookies(components, init);
    }
    [Symbol.toStringTag] = "@libp2p/http";
    [serviceCapabilities] = [
      "@libp2p/http"
    ];
    async start() {
      await start(this.httpRegistrar);
    }
    async stop() {
      await stop(this.httpRegistrar);
    }
    agent(...args) {
      throw new UnsupportedOperationError("This method is not supported in browsers");
    }
    dispatcher(...args) {
      throw new UnsupportedOperationError("This method is not supported in browsers");
    }
    async connect(resource, init = {}) {
      const url = toResource(resource);
      const headers = getHeaders(init);
      const opts = {
        ...init,
        headers,
        method: "GET",
        middleware: init.middleware?.map((fn) => fn(this.components)) ?? []
      };
      headers.set("connection", "upgrade");
      headers.set("upgrade", "websocket");
      return prepareAndConnect(url, opts, async () => {
        if (url instanceof URL) {
          const socket = new globalThis.WebSocket(url, init.protocols);
          socket.binaryType = "arraybuffer";
          return socket;
        }
        const { addresses, httpPath } = stripHTTPPath(url);
        return new WebSocket2(addresses, new URL(`http://${getHost(url, opts.headers)}${decodeURIComponent(httpPath)}`), this.components.connectionManager, opts);
      });
    }
    async fetch(resource, init = {}) {
      const url = toResource(resource);
      const opts = {
        ...init,
        headers: getHeaders(init),
        method: "GET",
        middleware: [
          this.origin,
          this.cookies,
          ...init.middleware?.map((fn) => fn(this.components)) ?? []
        ]
      };
      const response = await prepareAndSendRequest(url, opts, async () => {
        return this.sendRequest(url, init);
      });
      return processResponse(url, opts, response);
    }
    async connectProtocol(resource, protocol, init) {
      const path = await this.getProtocolPath(resource, protocol, init);
      const url = toResource(resource, path);
      return this.connect(url, init);
    }
    async fetchProtocol(resource, protocol, init = {}) {
      const path = await this.getProtocolPath(resource, protocol, init);
      const url = toResource(resource, path);
      return this.fetch(url, init);
    }
    async getSupportedProtocols(resource, options2 = {}) {
      const url = toResource(resource, WELL_KNOWN_PROTOCOLS_PATH);
      const resp = await this.fetch(url, {
        method: "GET",
        headers: {
          Accept: "application/json"
        },
        signal: options2.signal
      });
      if (resp.status !== 200) {
        throw new Error(`Unexpected status code: ${resp.status}`);
      }
      return resp.json();
    }
    async getProtocolPath(peer, protocol, options2 = {}) {
      const peerMeta = await this.getSupportedProtocols(peer, options2);
      if (peerMeta[protocol] == null) {
        throw new Error(`Peer does not serve protocol: ${protocol}`);
      }
      return peerMeta[protocol].path;
    }
    canHandle(req) {
      return this.httpRegistrar.canHandle(req);
    }
    async onRequest(req) {
      return this.httpRegistrar.onRequest(req);
    }
    onWebSocket(ws) {
      this.httpRegistrar.onWebSocket(ws);
    }
    handle(protocol, handler) {
      this.httpRegistrar.handle(protocol, handler);
    }
    unhandle(protocol) {
      this.httpRegistrar.unhandle(protocol);
    }
    getProtocolMap() {
      return this.httpRegistrar.getProtocolMap();
    }
    async sendRequest(resource, init) {
      if (resource instanceof URL) {
        this.log("making request to %s with global fetch");
        return globalThis.fetch(resource, init);
      }
      this.log("making request to %s with libp2p fetch", resource);
      const host = getHost(resource, getHeaders(init));
      const { addresses, httpPath } = stripHTTPPath(resource);
      const connection = await this.components.connectionManager.openConnection(addresses, {
        signal: init.signal ?? void 0
      });
      const stream = await connection.newStream(HTTP_PROTOCOL2, {
        signal: init.signal ?? void 0
      });
      return fetch2(stream, new URL(`http://${host}${decodeURIComponent(httpPath)}`), init);
    }
  };

  // node_modules/@libp2p/http/dist/src/index.js
  function http(init = {}) {
    return (components) => new HTTP2(components, init);
  }

  // node_modules/@libp2p/identify/dist/src/consts.js
  var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
  var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
  var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
  var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
  var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
  var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
  var MAX_PUSH_CONCURRENCY = 32;
  var PUSH_DEBOUNCE_MS = 1e3;

  // node_modules/@libp2p/identify/dist/src/pb/message.js
  var Identify;
  (function(Identify3) {
    let _codec;
    Identify3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.protocolVersion != null) {
            w.uint32(42);
            w.string(obj.protocolVersion);
          }
          if (obj.agentVersion != null) {
            w.uint32(50);
            w.string(obj.agentVersion);
          }
          if (obj.publicKey != null) {
            w.uint32(10);
            w.bytes(obj.publicKey);
          }
          if (obj.listenAddrs != null) {
            for (const value2 of obj.listenAddrs) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (obj.observedAddr != null) {
            w.uint32(34);
            w.bytes(obj.observedAddr);
          }
          if (obj.protocols != null) {
            for (const value2 of obj.protocols) {
              w.uint32(26);
              w.string(value2);
            }
          }
          if (obj.signedPeerRecord != null) {
            w.uint32(66);
            w.bytes(obj.signedPeerRecord);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            listenAddrs: [],
            protocols: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 5: {
                obj.protocolVersion = reader2.string();
                break;
              }
              case 6: {
                obj.agentVersion = reader2.string();
                break;
              }
              case 1: {
                obj.publicKey = reader2.bytes();
                break;
              }
              case 2: {
                if (opts.limits?.listenAddrs != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                  throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
                }
                obj.listenAddrs.push(reader2.bytes());
                break;
              }
              case 4: {
                obj.observedAddr = reader2.bytes();
                break;
              }
              case 3: {
                if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                  throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
                }
                obj.protocols.push(reader2.string());
                break;
              }
              case 8: {
                obj.signedPeerRecord = reader2.bytes();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Identify3.encode = (obj) => {
      return encodeMessage(obj, Identify3.codec());
    };
    Identify3.decode = (buf2, opts) => {
      return decodeMessage(buf2, Identify3.codec(), opts);
    };
  })(Identify || (Identify = {}));

  // node_modules/@libp2p/identify/dist/src/utils.js
  var defaultValues6 = {
    protocolPrefix: "ipfs",
    timeout: 5e3,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxObservedAddresses: 10,
    maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
    runOnConnectionOpen: true,
    runOnSelfUpdate: true,
    runOnLimitedConnection: true,
    concurrency: MAX_PUSH_CONCURRENCY
  };
  function getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr(addr);
      } catch {
      }
    }
  }
  async function consumeIdentifyMessage(peerStore, events, log18, connection, message2) {
    log18("received identify from %p", connection.remotePeer);
    if (message2 == null) {
      throw new InvalidMessageError("message was null or undefined");
    }
    const peer = {};
    if (message2.listenAddrs.length > 0) {
      peer.addresses = message2.listenAddrs.map((buf2) => ({
        isCertified: false,
        multiaddr: multiaddr(buf2)
      }));
    }
    if (message2.protocols.length > 0) {
      peer.protocols = message2.protocols;
    }
    if (message2.publicKey != null) {
      const publicKey2 = publicKeyFromProtobuf(message2.publicKey);
      const peerId = peerIdFromPublicKey(publicKey2);
      if (!peerId.equals(connection.remotePeer)) {
        throw new InvalidMessageError("public key did not match remote PeerId");
      }
      peer.publicKey = publicKey2;
    }
    let output;
    if (message2.signedPeerRecord != null) {
      log18.trace("received signedPeerRecord from %p", connection.remotePeer);
      let peerRecordEnvelope2 = message2.signedPeerRecord;
      const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope2, PeerRecord2.DOMAIN);
      let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
      const envelopePeer = peerIdFromCID(envelope.publicKey.toCID());
      if (!peerRecord.peerId.equals(envelopePeer)) {
        throw new InvalidMessageError("signing key does not match PeerId in the PeerRecord");
      }
      if (!connection.remotePeer.equals(peerRecord.peerId)) {
        throw new InvalidMessageError("signing key does not match remote PeerId");
      }
      let existingPeer;
      try {
        existingPeer = await peerStore.get(peerRecord.peerId);
      } catch (err2) {
        if (err2.name !== "NotFoundError") {
          throw err2;
        }
      }
      if (existingPeer != null) {
        peer.metadata = existingPeer.metadata;
        if (existingPeer.peerRecordEnvelope != null) {
          const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
          const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log18("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            peerRecord = storedRecord;
            peerRecordEnvelope2 = existingPeer.peerRecordEnvelope;
          }
        }
      }
      peer.peerRecordEnvelope = peerRecordEnvelope2;
      peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }));
      output = {
        seq: peerRecord.seqNumber,
        addresses: peerRecord.multiaddrs
      };
    } else {
      log18("%p did not send a signed peer record", connection.remotePeer);
    }
    log18.trace("patching %p with", connection.remotePeer, peer);
    await peerStore.patch(connection.remotePeer, peer);
    if (message2.agentVersion != null || message2.protocolVersion != null) {
      const metadata = {};
      if (message2.agentVersion != null) {
        metadata.AgentVersion = fromString2(message2.agentVersion);
      }
      if (message2.protocolVersion != null) {
        metadata.ProtocolVersion = fromString2(message2.protocolVersion);
      }
      log18.trace("merging %p metadata", connection.remotePeer, metadata);
      await peerStore.merge(connection.remotePeer, {
        metadata
      });
    }
    const result = {
      peerId: connection.remotePeer,
      protocolVersion: message2.protocolVersion,
      agentVersion: message2.agentVersion,
      publicKey: message2.publicKey,
      listenAddrs: message2.listenAddrs.map((buf2) => multiaddr(buf2)),
      observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
      protocols: message2.protocols,
      signedPeerRecord: output,
      connection
    };
    events.safeDispatchEvent("peer:identify", { detail: result });
    return result;
  }
  var AbstractIdentify = class {
    host;
    components;
    protocol;
    started;
    timeout;
    maxInboundStreams;
    maxOutboundStreams;
    maxMessageSize;
    maxObservedAddresses;
    runOnLimitedConnection;
    log;
    constructor(components, init) {
      this.protocol = init.protocol;
      this.started = false;
      this.components = components;
      this.log = init.log;
      this.timeout = init.timeout ?? defaultValues6.timeout;
      this.maxInboundStreams = init.maxInboundStreams ?? defaultValues6.maxInboundStreams;
      this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues6.maxOutboundStreams;
      this.maxMessageSize = init.maxMessageSize ?? defaultValues6.maxMessageSize;
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues6.maxObservedAddresses;
      this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues6.runOnLimitedConnection;
      this.host = {
        protocolVersion: `${init.protocolPrefix ?? defaultValues6.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
        agentVersion: components.nodeInfo.userAgent
      };
      this.handleProtocol = this.handleProtocol.bind(this);
    }
    isStarted() {
      return this.started;
    }
    async start() {
      if (this.started) {
        return;
      }
      await this.components.peerStore.merge(this.components.peerId, {
        metadata: {
          AgentVersion: fromString2(this.host.agentVersion),
          ProtocolVersion: fromString2(this.host.protocolVersion)
        }
      });
      await this.components.registrar.handle(this.protocol, this.handleProtocol, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      this.started = true;
    }
    async stop() {
      await this.components.registrar.unhandle(this.protocol);
      this.started = false;
    }
  };

  // node_modules/@libp2p/identify/dist/src/identify-push.js
  var IdentifyPush = class extends AbstractIdentify {
    connectionManager;
    concurrency;
    _push;
    constructor(components, init = {}) {
      super(components, {
        ...init,
        protocol: `/${init.protocolPrefix ?? defaultValues6.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,
        log: components.logger.forComponent("libp2p:identify-push")
      });
      this.connectionManager = components.connectionManager;
      this.concurrency = init.concurrency ?? defaultValues6.concurrency;
      this._push = debounce(this.sendPushMessage.bind(this), init.debounce ?? PUSH_DEBOUNCE_MS);
      if (init.runOnSelfUpdate ?? defaultValues6.runOnSelfUpdate) {
        components.events.addEventListener("self:peer:update", (evt) => {
          this.push().catch((err2) => {
            this.log.error("error pushing updates to peers - %e", err2);
          });
        });
      }
    }
    [serviceCapabilities] = [
      "@libp2p/identify-push"
    ];
    /**
     * Calls `push` on all peer connections
     */
    async push() {
      this._push();
    }
    async sendPushMessage() {
      if (!this.isStarted()) {
        return;
      }
      try {
        const listenAddresses = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P));
        const peerRecord = new PeerRecord2({
          peerId: this.components.peerId,
          multiaddrs: listenAddresses
        });
        const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.components.privateKey);
        const supportedProtocols = this.components.registrar.getProtocols();
        const peer = await this.components.peerStore.get(this.components.peerId);
        const agentVersion = toString2(peer.metadata.get("AgentVersion") ?? fromString2(this.host.agentVersion));
        const protocolVersion = toString2(peer.metadata.get("ProtocolVersion") ?? fromString2(this.host.protocolVersion));
        const self2 = this;
        async function* pushToConnections() {
          for (const connection of self2.connectionManager.getConnections()) {
            const peer2 = await self2.components.peerStore.get(connection.remotePeer);
            if (!peer2.protocols.includes(self2.protocol)) {
              continue;
            }
            yield async () => {
              let stream;
              const signal = AbortSignal.timeout(self2.timeout);
              setMaxListeners(Infinity, signal);
              try {
                stream = await connection.newStream(self2.protocol, {
                  signal,
                  runOnLimitedConnection: self2.runOnLimitedConnection
                });
                const pb = pbStream(stream, {
                  maxDataLength: self2.maxMessageSize
                }).pb(Identify);
                await pb.write({
                  listenAddrs: listenAddresses.map((ma) => ma.bytes),
                  signedPeerRecord: signedPeerRecord.marshal(),
                  protocols: supportedProtocols,
                  agentVersion,
                  protocolVersion
                }, {
                  signal
                });
                await stream.close({
                  signal
                });
              } catch (err2) {
                const log18 = stream?.log.newScope("identify-push");
                log18?.error("could not push identify update to peer", err2);
                stream?.abort(err2);
              }
            };
          }
        }
        await src_default3(parallel(pushToConnections(), {
          concurrency: this.concurrency
        }));
      } catch (err2) {
        this.log.error("error pushing updates to peers - %e", err2);
      }
    }
    /**
     * Reads the Identify Push message from the given `connection`
     */
    async handleProtocol(stream, connection) {
      const log18 = stream.log.newScope("identify-push");
      if (this.components.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options2);
      await stream.close(options2);
      await consumeIdentifyMessage(this.components.peerStore, this.components.events, log18, connection, message2);
      log18.trace("handled push from %p", connection.remotePeer);
    }
  };

  // node_modules/@libp2p/identify/dist/src/identify.js
  var Identify2 = class extends AbstractIdentify {
    constructor(components, init = {}) {
      super(components, {
        ...init,
        protocol: `/${init.protocolPrefix ?? defaultValues6.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
        log: components.logger.forComponent("libp2p:identify")
      });
      if (init.runOnConnectionOpen ?? defaultValues6.runOnConnectionOpen) {
        components.events.addEventListener("connection:open", (evt) => {
          const connection = evt.detail;
          this.identify(connection).catch(() => {
          });
        });
      }
    }
    [serviceCapabilities] = [
      "@libp2p/identify"
    ];
    async _identify(connection, options2 = {}) {
      let stream;
      let log18;
      if (options2.signal == null) {
        const signal = AbortSignal.timeout(this.timeout);
        setMaxListeners(Infinity, signal);
        options2 = {
          ...options2,
          signal
        };
      }
      this.log("run identify on new connection %a", connection.remoteAddr);
      try {
        stream = await connection.newStream(this.protocol, {
          ...options2,
          runOnLimitedConnection: this.runOnLimitedConnection
        });
        log18 = stream.log.newScope("identify");
        const pb = pbStream(stream, {
          maxDataLength: this.maxMessageSize
        }).pb(Identify);
        const message2 = await pb.read(options2);
        await pb.unwrap().unwrap().close(options2);
        return message2;
      } catch (err2) {
        log18?.error("identify failed - %e", err2);
        stream?.abort(err2);
        throw err2;
      }
    }
    async identify(connection, options2 = {}) {
      const message2 = await this._identify(connection, options2);
      const { publicKey: publicKey2, protocols, observedAddr } = message2;
      if (publicKey2 == null) {
        throw new InvalidMessageError("Public key was missing from identify message");
      }
      const key = publicKeyFromProtobuf(publicKey2);
      const id = peerIdFromCID(key.toCID());
      if (!connection.remotePeer.equals(id)) {
        throw new InvalidMessageError("Identified peer does not match the expected peer");
      }
      if (this.components.peerId.equals(id)) {
        throw new InvalidMessageError("Identified peer is our own peer id?");
      }
      this.maybeAddObservedAddress(observedAddr);
      this.log("completed for peer %p and protocols %o", id, protocols);
      return consumeIdentifyMessage(this.components.peerStore, this.components.events, this.log, connection, message2);
    }
    maybeAddObservedAddress(observedAddr) {
      const cleanObservedAddr = getCleanMultiaddr(observedAddr);
      if (cleanObservedAddr == null) {
        return;
      }
      this.log.trace("our observed address was %a", cleanObservedAddr);
      if (isPrivate(cleanObservedAddr)) {
        return;
      }
      const tuples = cleanObservedAddr.getComponents();
      if ((tuples[0].code === CODE_IP6 || tuples[0].code === CODE_IP6ZONE && tuples[1].code === CODE_IP6) && !isGlobalUnicast(cleanObservedAddr)) {
        this.log.trace("our observed address was IPv6 but not a global unicast address");
        return;
      }
      if (TCP.exactMatch(cleanObservedAddr)) {
        return;
      }
      this.log.trace("storing the observed address");
      this.components.addressManager.addObservedAddr(cleanObservedAddr);
    }
    /**
     * Sends the `Identify` response with the Signed Peer Record
     * to the requesting peer over the given `connection`
     */
    async handleProtocol(stream, connection) {
      const log18 = stream.log.newScope("identify");
      log18("responding to identify");
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      const peerData = await this.components.peerStore.get(this.components.peerId, {
        signal
      });
      const multiaddrs = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord2({
          peerId: this.components.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.components.privateKey, {
          signal
        });
        signedPeerRecord = envelope.marshal().subarray();
      }
      let observedAddr = connection.remoteAddr.bytes;
      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
        observedAddr = void 0;
      }
      const pb = pbStream(stream).pb(Identify);
      log18("send response");
      await pb.write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey: publicKeyToProtobuf(this.components.privateKey.publicKey),
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr,
        protocols: peerData.protocols
      }, {
        signal
      });
      log18("close write");
      await pb.unwrap().unwrap().close({
        signal
      });
    }
  };

  // node_modules/@libp2p/identify/dist/src/index.js
  function identify(init = {}) {
    return (components) => new Identify2(components, init);
  }
  function identifyPush(init = {}) {
    return (components) => new IdentifyPush(components, init);
  }

  // node_modules/@libp2p/kad-dht/dist/src/constants.js
  var second2 = 1e3;
  var minute2 = 60 * second2;
  var hour = 60 * minute2;
  var PROTOCOL = "/ipfs/kad/1.0.0";
  var PROVIDERS_VALIDITY = 48 * hour;
  var REPROVIDE_THRESHOLD = 24 * hour;
  var REPROVIDE_CONCURRENCY = 10;
  var REPROVIDE_MAX_QUEUE_SIZE = 16384;
  var REPROVIDE_INTERVAL = hour;
  var REPROVIDE_TIMEOUT = hour;
  var READ_MESSAGE_TIMEOUT = 10 * second2;
  var ON_PEER_CONNECT_TIMEOUT = 10 * second2;
  var K = 20;
  var ALPHA = 10;
  var QUERY_SELF_INTERVAL = 5 * minute2;
  var QUERY_SELF_INITIAL_INTERVAL = second2;
  var QUERY_SELF_TIMEOUT = 5 * second2;
  var TABLE_REFRESH_INTERVAL = 5 * minute2;
  var TABLE_REFRESH_QUERY_TIMEOUT = 30 * second2;
  var DEFAULT_QUERY_TIMEOUT = 180 * second2;
  var KEEP_ALIVE_TAG2 = `${KEEP_ALIVE}-kad-dht`;

  // node_modules/@libp2p/record/dist/src/record.js
  var Record;
  (function(Record3) {
    let _codec;
    Record3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (obj.timeReceived != null && obj.timeReceived !== "") {
            w.uint32(42);
            w.string(obj.timeReceived);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            key: alloc(0),
            value: alloc(0),
            timeReceived: ""
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader2.bytes();
                break;
              }
              case 2: {
                obj.value = reader2.bytes();
                break;
              }
              case 5: {
                obj.timeReceived = reader2.string();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Record3.encode = (obj) => {
      return encodeMessage(obj, Record3.codec());
    };
    Record3.decode = (buf2, opts) => {
      return decodeMessage(buf2, Record3.codec(), opts);
    };
  })(Record || (Record = {}));

  // node_modules/@libp2p/record/dist/src/utils.js
  function toRFC3339(time) {
    const year = time.getUTCFullYear();
    const month = String(time.getUTCMonth() + 1).padStart(2, "0");
    const day = String(time.getUTCDate()).padStart(2, "0");
    const hour2 = String(time.getUTCHours()).padStart(2, "0");
    const minute3 = String(time.getUTCMinutes()).padStart(2, "0");
    const seconds = String(time.getUTCSeconds()).padStart(2, "0");
    const milliseconds = time.getUTCMilliseconds();
    const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
    return `${year}-${month}-${day}T${hour2}:${minute3}:${seconds}.${nanoseconds}Z`;
  }
  function parseRFC3339(time) {
    const rfc3339Matcher = new RegExp(
      // 2006-01-02T
      "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
    );
    const m2 = String(time).trim().match(rfc3339Matcher);
    if (m2 == null) {
      throw new Error("Invalid format");
    }
    const year = parseInt(m2[1], 10);
    const month = parseInt(m2[2], 10) - 1;
    const date = parseInt(m2[3], 10);
    const hour2 = parseInt(m2[4], 10);
    const minute3 = parseInt(m2[5], 10);
    const second3 = parseInt(m2[6], 10);
    const millisecond = parseInt(m2[7].slice(0, -6), 10);
    return new Date(Date.UTC(year, month, date, hour2, minute3, second3, millisecond));
  }

  // node_modules/@libp2p/record/dist/src/index.js
  var Libp2pRecord = class _Libp2pRecord {
    key;
    value;
    timeReceived;
    constructor(key, value2, timeReceived) {
      if (!(key instanceof Uint8Array)) {
        throw new Error("key must be a Uint8Array");
      }
      if (!(value2 instanceof Uint8Array)) {
        throw new Error("value must be a Uint8Array");
      }
      this.key = key;
      this.value = value2;
      this.timeReceived = timeReceived;
    }
    serialize() {
      return Record.encode(this.prepareSerialize());
    }
    /**
     * Return the object format ready to be given to the protobuf library.
     */
    prepareSerialize() {
      return {
        key: this.key,
        value: this.value,
        timeReceived: toRFC3339(this.timeReceived)
      };
    }
    /**
     * Decode a protobuf encoded record
     */
    static deserialize(raw) {
      const rec = Record.decode(raw);
      return new _Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
    }
    /**
     * Create a record from the raw object returned from the protobuf library
     */
    static fromDeserialized(obj) {
      const receivedTime = parseRFC3339(obj.timeReceived);
      if (obj.key == null) {
        throw new Error("key missing from deserialized object");
      }
      if (obj.value == null) {
        throw new Error("value missing from deserialized object");
      }
      const rec = new _Libp2pRecord(obj.key, obj.value, receivedTime);
      return rec;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/errors.js
  var QueryError = class extends Error {
    constructor(message2 = "Query error") {
      super(message2);
      this.name = "QueryError";
    }
  };
  var InvalidRecordError = class extends Error {
    constructor(message2 = "Invalid record") {
      super(message2);
      this.name = "InvalidRecordError";
    }
  };
  var MissingSelectorError = class extends Error {
    constructor(message2 = "No selector function configured for prefix") {
      super(message2);
      this.name = "MissingSelectorError";
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/message/dht.js
  var Record2;
  (function(Record3) {
    let _codec;
    Record3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null) {
            w.uint32(10);
            w.bytes(obj.key);
          }
          if (obj.value != null) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (obj.author != null) {
            w.uint32(26);
            w.bytes(obj.author);
          }
          if (obj.signature != null) {
            w.uint32(34);
            w.bytes(obj.signature);
          }
          if (obj.timeReceived != null) {
            w.uint32(42);
            w.string(obj.timeReceived);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader2.bytes();
                break;
              }
              case 2: {
                obj.value = reader2.bytes();
                break;
              }
              case 3: {
                obj.author = reader2.bytes();
                break;
              }
              case 4: {
                obj.signature = reader2.bytes();
                break;
              }
              case 5: {
                obj.timeReceived = reader2.string();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Record3.encode = (obj) => {
      return encodeMessage(obj, Record3.codec());
    };
    Record3.decode = (buf2, opts) => {
      return decodeMessage(buf2, Record3.codec(), opts);
    };
  })(Record2 || (Record2 = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2["PUT_VALUE"] = "PUT_VALUE";
    MessageType2["GET_VALUE"] = "GET_VALUE";
    MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
    MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
    MessageType2["FIND_NODE"] = "FIND_NODE";
    MessageType2["PING"] = "PING";
  })(MessageType || (MessageType = {}));
  var __MessageTypeValues;
  (function(__MessageTypeValues2) {
    __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
    __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
  })(__MessageTypeValues || (__MessageTypeValues = {}));
  (function(MessageType2) {
    MessageType2.codec = () => {
      return enumeration(__MessageTypeValues);
    };
  })(MessageType || (MessageType = {}));
  var ConnectionType;
  (function(ConnectionType2) {
    ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
    ConnectionType2["CONNECTED"] = "CONNECTED";
    ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
    ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
  })(ConnectionType || (ConnectionType = {}));
  var __ConnectionTypeValues;
  (function(__ConnectionTypeValues2) {
    __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
  (function(ConnectionType2) {
    ConnectionType2.codec = () => {
      return enumeration(__ConnectionTypeValues);
    };
  })(ConnectionType || (ConnectionType = {}));
  var PeerInfo;
  (function(PeerInfo2) {
    let _codec;
    PeerInfo2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.id != null && obj.id.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.id);
          }
          if (obj.multiaddrs != null) {
            for (const value2 of obj.multiaddrs) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (obj.connection != null) {
            w.uint32(24);
            ConnectionType.codec().encode(obj.connection, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            id: alloc(0),
            multiaddrs: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.id = reader2.bytes();
                break;
              }
              case 2: {
                if (opts.limits?.multiaddrs != null && obj.multiaddrs.length === opts.limits.multiaddrs) {
                  throw new MaxLengthError('Decode error - map field "multiaddrs" had too many elements');
                }
                obj.multiaddrs.push(reader2.bytes());
                break;
              }
              case 3: {
                obj.connection = ConnectionType.codec().decode(reader2);
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerInfo2.encode = (obj) => {
      return encodeMessage(obj, PeerInfo2.codec());
    };
    PeerInfo2.decode = (buf2, opts) => {
      return decodeMessage(buf2, PeerInfo2.codec(), opts);
    };
  })(PeerInfo || (PeerInfo = {}));
  var Message2;
  (function(Message5) {
    let _codec;
    Message5.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.type != null && __MessageTypeValues[obj.type] !== 0) {
            w.uint32(8);
            MessageType.codec().encode(obj.type, w);
          }
          if (obj.clusterLevel != null) {
            w.uint32(80);
            w.int32(obj.clusterLevel);
          }
          if (obj.key != null) {
            w.uint32(18);
            w.bytes(obj.key);
          }
          if (obj.record != null) {
            w.uint32(26);
            w.bytes(obj.record);
          }
          if (obj.closer != null) {
            for (const value2 of obj.closer) {
              w.uint32(66);
              PeerInfo.codec().encode(value2, w);
            }
          }
          if (obj.providers != null) {
            for (const value2 of obj.providers) {
              w.uint32(74);
              PeerInfo.codec().encode(value2, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            type: MessageType.PUT_VALUE,
            closer: [],
            providers: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.type = MessageType.codec().decode(reader2);
                break;
              }
              case 10: {
                obj.clusterLevel = reader2.int32();
                break;
              }
              case 2: {
                obj.key = reader2.bytes();
                break;
              }
              case 3: {
                obj.record = reader2.bytes();
                break;
              }
              case 8: {
                if (opts.limits?.closer != null && obj.closer.length === opts.limits.closer) {
                  throw new MaxLengthError('Decode error - map field "closer" had too many elements');
                }
                obj.closer.push(PeerInfo.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.closer$
                }));
                break;
              }
              case 9: {
                if (opts.limits?.providers != null && obj.providers.length === opts.limits.providers) {
                  throw new MaxLengthError('Decode error - map field "providers" had too many elements');
                }
                obj.providers.push(PeerInfo.codec().decode(reader2, reader2.uint32(), {
                  limits: opts.limits?.providers$
                }));
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Message5.encode = (obj) => {
      return encodeMessage(obj, Message5.codec());
    };
    Message5.decode = (buf2, opts) => {
      return decodeMessage(buf2, Message5.codec(), opts);
    };
  })(Message2 || (Message2 = {}));

  // node_modules/@libp2p/kad-dht/dist/src/query/events.js
  function sendQueryEvent(fields, options2 = {}) {
    const event = {
      ...fields,
      name: "SEND_QUERY",
      type: 0,
      messageName: fields.type,
      messageType: fields.type
    };
    options2.onProgress?.(new CustomEvent("kad-dht:query:send-query", { detail: event }));
    return event;
  }
  function peerResponseEvent(fields, options2 = {}) {
    const event = {
      ...fields,
      name: "PEER_RESPONSE",
      type: 1,
      messageName: fields.messageType,
      closer: fields.closer ?? [],
      providers: fields.providers ?? []
    };
    options2.onProgress?.(new CustomEvent("kad-dht:query:peer-response", { detail: event }));
    return event;
  }
  function finalPeerEvent(fields, options2 = {}) {
    const event = {
      ...fields,
      name: "FINAL_PEER",
      type: 2
    };
    options2.onProgress?.(new CustomEvent("kad-dht:query:final-peer", { detail: event }));
    return event;
  }
  function queryErrorEvent(fields, options2 = {}) {
    const event = {
      ...fields,
      name: "QUERY_ERROR",
      type: 3
    };
    options2.onProgress?.(new CustomEvent("kad-dht:query:query-error", { detail: event }));
    return event;
  }
  function providerEvent(fields, options2 = {}) {
    const event = {
      ...fields,
      name: "PROVIDER",
      type: 4
    };
    options2.onProgress?.(new CustomEvent("kad-dht:query:provider", { detail: event }));
    return event;
  }
  function valueEvent(fields, options2 = {}) {
    const event = {
      ...fields,
      name: "VALUE",
      type: 5
    };
    options2.onProgress?.(new CustomEvent("kad-dht:query:value", { detail: event }));
    return event;
  }
  function dialPeerEvent(fields, options2 = {}) {
    const event = {
      ...fields,
      name: "DIAL_PEER",
      type: 7
    };
    options2.onProgress?.(new CustomEvent("kad-dht:query:dial-peer", { detail: event }));
    return event;
  }
  function pathEndedEvent(fields, options2 = {}) {
    const event = {
      ...fields,
      name: "PATH_ENDED",
      type: 8
    };
    options2.onProgress?.(new CustomEvent("kad-dht:query:path-ended", { detail: event }));
    return event;
  }

  // node_modules/@libp2p/kad-dht/dist/src/record/selectors.js
  function bestRecord(selectors2, k, records) {
    if (records.length === 0) {
      throw new InvalidParametersError("No records given");
    }
    const kStr = toString2(k);
    const parts = kStr.split("/");
    if (parts.length < 3) {
      throw new InvalidParametersError("Record key does not have a selector function");
    }
    const selector = selectors2[parts[1].toString()];
    if (selector == null) {
      throw new MissingSelectorError(`No selector function configured for key type "${parts[1]}"`);
    }
    if (records.length === 1) {
      return 0;
    }
    return selector(k, records);
  }
  function publicKey(k, records) {
    return 0;
  }
  var selectors = {
    pk: publicKey
  };

  // node_modules/@libp2p/kad-dht/dist/src/record/validators.js
  async function verifyRecord(validators2, record, options2) {
    const key = record.key;
    const keyString = toString2(key);
    const parts = keyString.split("/");
    if (parts.length < 3) {
      return;
    }
    const validator = validators2[parts[1].toString()];
    if (validator == null) {
      throw new InvalidParametersError(`No validator available for key type "${parts[1]}"`);
    }
    await validator(key, record.value, options2);
  }
  var validatePublicKeyRecord = async (key, publicKey2, options2) => {
    if (!(key instanceof Uint8Array)) {
      throw new InvalidParametersError('"key" must be a Uint8Array');
    }
    if (key.byteLength < 5) {
      throw new InvalidParametersError("Invalid public key record");
    }
    const prefix = toString2(key.subarray(0, 4));
    if (prefix !== "/pk/") {
      throw new InvalidParametersError("key was not prefixed with /pk/");
    }
    const pubKey = publicKeyFromProtobuf(publicKey2);
    const keyHash = key.slice(4);
    if (!equals3(keyHash, pubKey.toMultihash().bytes)) {
      throw new InvalidParametersError("public key does not match passed in key");
    }
  };
  var validators = {
    pk: validatePublicKeyRecord
  };

  // node_modules/@libp2p/kad-dht/dist/src/utils.js
  var PK_PREFIX = fromString2("/pk/");
  function removePrivateAddressesMapper(peer) {
    return {
      ...peer,
      multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
        return !isPrivate(multiaddr2);
      })
    };
  }
  async function convertBuffer(buf2, options2) {
    const multihash = await sha256.digest(buf2);
    options2?.signal?.throwIfAborted();
    return multihash.digest;
  }
  async function convertPeerId(peerId, options2) {
    return convertBuffer(peerId.toMultihash().bytes, options2);
  }
  function bufferToRecordKey(prefix, buf2) {
    return new Key(`${prefix}/${toString2(buf2, "base32")}`, false);
  }
  function keyForPublicKey(peerId) {
    return concat([
      PK_PREFIX,
      peerId.toMultihash().bytes
    ]);
  }
  function isPublicKeyKey(key) {
    return toString2(key.subarray(0, 4)) === "/pk/";
  }
  function fromPublicKeyKey(key) {
    const multihash = decode4(key.subarray(4));
    return peerIdFromMultihash(multihash);
  }
  function createPutRecord(key, value2) {
    const timeReceived = /* @__PURE__ */ new Date();
    const rec = new Libp2pRecord(key, value2, timeReceived);
    return rec.serialize();
  }
  function parseProviderKey(key) {
    const parts = key.toString().split("/");
    const peerIdStr = parts.pop();
    const cidStr = parts.pop();
    if (peerIdStr == null || cidStr == null) {
      throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
    }
    return {
      cid: CID.createV1(code3, decode4(fromString2(cidStr, "base32"))),
      peerId: peerIdFromString(peerIdStr)
    };
  }
  function toProviderKey(prefix, cid, peerId) {
    const cidStr = typeof cid === "string" ? cid : toString2(cid.multihash.bytes, "base32");
    const parts = [
      prefix,
      cidStr
    ];
    if (peerId != null) {
      parts.push(peerId.toString());
    }
    return new Key(parts.join("/"));
  }
  function readProviderTime(buf2) {
    return new Date(decode8(buf2));
  }
  function timeOperationGenerator(fn, operationMetrics, type) {
    return async function* (...args) {
      const stopSuccessTimer = operationMetrics.queryTime?.timer(type);
      const stopErrorTimer = operationMetrics.errorTime?.timer(type);
      let errored = false;
      try {
        operationMetrics.queries?.increment({ [type]: true });
        yield* fn(...args);
      } catch (err2) {
        errored = true;
        stopErrorTimer?.();
        operationMetrics.errors?.increment({ [type]: true });
        throw err2;
      } finally {
        operationMetrics.queries?.decrement({ [type]: true });
        if (!errored) {
          stopSuccessTimer?.();
        }
      }
    };
  }
  function timeOperationMethod(fn, operationMetrics, type) {
    return async function(...args) {
      const stopSuccessTimer = operationMetrics?.queryTime?.timer(type);
      const stopErrorTimer = operationMetrics?.errorTime?.timer(type);
      let errored = false;
      try {
        operationMetrics.queries?.increment({ [type]: true });
        return await fn(...args);
      } catch (err2) {
        errored = true;
        stopErrorTimer?.();
        operationMetrics.errors?.increment({ [type]: true });
        throw err2;
      } finally {
        operationMetrics.queries?.decrement({ [type]: true });
        if (!errored) {
          stopSuccessTimer?.();
        }
      }
    };
  }

  // node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
  var ContentFetching = class {
    log;
    components;
    validators;
    selectors;
    peerRouting;
    queryManager;
    network;
    datastorePrefix;
    constructor(components, init) {
      const { validators: validators2, selectors: selectors2, peerRouting, queryManager, network, logPrefix } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${logPrefix}:content-fetching`);
      this.datastorePrefix = `${init.datastorePrefix}/record`;
      this.validators = validators2;
      this.selectors = selectors2;
      this.peerRouting = peerRouting;
      this.queryManager = queryManager;
      this.network = network;
      this.get = components.metrics?.traceFunction("libp2p.kadDHT.get", this.get.bind(this), {
        optionsIndex: 1
      }) ?? this.get;
      this.put = components.metrics?.traceFunction("libp2p.kadDHT.put", this.put.bind(this), {
        optionsIndex: 2
      }) ?? this.put;
    }
    /**
     * Attempt to retrieve the value for the given key from
     * the local datastore
     */
    async getLocal(key, options2) {
      this.log("getLocal %b", key);
      const dsKey = bufferToRecordKey(this.datastorePrefix, key);
      this.log("fetching record for key %k", dsKey);
      const raw = await this.components.datastore.get(dsKey, options2);
      this.log("found %k in local datastore", dsKey);
      const rec = Libp2pRecord.deserialize(raw);
      await verifyRecord(this.validators, rec, options2);
      return rec;
    }
    /**
     * Send the best record found to any peers that have an out of date record
     */
    async *sendCorrectionRecord(key, vals, best, options2) {
      this.log("sendCorrection for %b", key);
      const fixupRec = createPutRecord(key, best);
      for (const { value: value2, from: from3 } of vals) {
        if (equals3(value2, best)) {
          this.log("record was ok");
          continue;
        }
        if (this.components.peerId.equals(from3)) {
          try {
            const dsKey = bufferToRecordKey(this.datastorePrefix, key);
            this.log(`Storing corrected record for key ${dsKey.toString()}`);
            await this.components.datastore.put(dsKey, fixupRec.subarray(), options2);
          } catch (err2) {
            this.log.error("failed error correcting self - %e", err2);
          }
          continue;
        }
        let sentCorrection = false;
        const request = {
          type: MessageType.PUT_VALUE,
          key,
          record: fixupRec
        };
        for await (const event of this.network.sendRequest(from3, request, options2)) {
          if (event.name === "PEER_RESPONSE" && event.record != null && equals3(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
            sentCorrection = true;
          }
          yield event;
        }
        if (!sentCorrection) {
          throw new QueryError("Could not send correction");
        }
        this.log.error("failed error correcting entry");
      }
    }
    /**
     * Store the given key/value pair in the DHT
     */
    async *put(key, value2, options2) {
      this.log("put key %b value %b", key, value2);
      const record = createPutRecord(key, value2);
      const dsKey = bufferToRecordKey(this.datastorePrefix, key);
      this.log(`storing record for key ${dsKey.toString()}`);
      await this.components.datastore.put(dsKey, record.subarray(), options2);
      yield* pipe(this.peerRouting.getClosestPeers(key, {
        ...options2,
        signal: options2.signal
      }), (source) => src_default5(source, (event) => {
        return async () => {
          if (event.name !== "FINAL_PEER") {
            return [event];
          }
          const events = [];
          const msg = {
            type: MessageType.PUT_VALUE,
            key,
            record
          };
          this.log("send put to %p", event.peer.id);
          for await (const putEvent of this.network.sendRequest(event.peer.id, msg, {
            ...options2,
            path: event.path
          })) {
            events.push(putEvent);
            if (putEvent.name !== "PEER_RESPONSE") {
              continue;
            }
            if (!(putEvent.record != null && equals3(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
              events.push(queryErrorEvent({
                from: event.peer.id,
                error: new QueryError("Value not put correctly"),
                path: putEvent.path
              }, options2));
            }
          }
          return events;
        };
      }), (source) => parallel(source, {
        ordered: false,
        concurrency: ALPHA
      }), async function* (source) {
        for await (const events of source) {
          yield* events;
        }
      });
    }
    /**
     * Get the value to the given key
     */
    async *get(key, options2) {
      this.log("get %b", key);
      const vals = [];
      for await (const event of this.getMany(key, options2)) {
        if (event.name === "VALUE") {
          vals.push(event);
          continue;
        }
        yield event;
      }
      if (vals.length === 0) {
        return;
      }
      const records = vals.map((v) => v.value);
      let i2 = 0;
      try {
        i2 = bestRecord(this.selectors, key, records);
      } catch (err2) {
        if (err2.name !== "InvalidParametersError") {
          throw err2;
        }
      }
      const best = records[i2];
      this.log("GetValue %b %b", key, best);
      if (best == null) {
        throw new NotFoundError("Best value was not found");
      }
      yield* this.sendCorrectionRecord(key, vals, best, {
        ...options2,
        path: {
          index: -1,
          queued: 0,
          running: 0,
          total: 0
        }
      });
      yield vals[i2];
    }
    /**
     * Get the `n` values to the given key without sorting
     */
    async *getMany(key, options2 = {}) {
      this.log("getMany values for %b", key);
      try {
        const localRec = await this.getLocal(key, options2);
        yield valueEvent({
          value: localRec.value,
          from: this.components.peerId,
          path: {
            index: -1,
            running: 0,
            queued: 0,
            total: 0
          }
        }, options2);
      } catch (err2) {
        this.log("error getting local value for %b", key, err2);
      }
      const self2 = this;
      const getValueQuery = async function* ({ peer, signal, path }) {
        for await (const event of self2.peerRouting.getValueOrPeers(peer.id, key, {
          ...options2,
          signal,
          path
        })) {
          yield event;
          if (event.name === "PEER_RESPONSE" && event.record != null) {
            yield valueEvent({
              from: peer.id,
              value: event.record.value,
              path
            }, options2);
          }
        }
      };
      yield* this.queryManager.run(key, getValueQuery, options2);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/message/utils.js
  function toPbPeerInfo(peer, connection) {
    const output = {
      id: peer.id.toMultihash().bytes,
      multiaddrs: (peer.multiaddrs ?? []).map((m2) => m2.bytes),
      connection
    };
    return output;
  }
  function fromPbPeerInfo(peer) {
    if (peer.id == null) {
      throw new Error("Invalid peer in message");
    }
    const multihash = decode4(peer.id);
    return {
      id: peerIdFromMultihash(multihash),
      multiaddrs: (peer.multiaddrs ?? []).map((a2) => multiaddr(a2))
    };
  }

  // node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
  var ContentRouting = class {
    log;
    components;
    network;
    peerRouting;
    queryManager;
    routingTable;
    providers;
    constructor(components, init) {
      const { network, peerRouting, queryManager, routingTable, providers, logPrefix } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${logPrefix}:content-routing`);
      this.network = network;
      this.peerRouting = peerRouting;
      this.queryManager = queryManager;
      this.routingTable = routingTable;
      this.providers = providers;
      this.findProviders = components.metrics?.traceFunction("libp2p.kadDHT.findProviders", this.findProviders.bind(this), {
        optionsIndex: 1,
        getAttributesFromYieldedValue: (event, attrs) => {
          if (event.name === "PROVIDER") {
            attrs.providers ??= [];
            attrs.providers.push(...event.providers.map((info) => info.id.toString()));
          }
          return attrs;
        }
      }) ?? this.findProviders;
      this.provide = components.metrics?.traceFunction("libp2p.kadDHT.provide", this.provide.bind(this), {
        optionsIndex: 1,
        getAttributesFromYieldedValue: (event, attrs) => {
          if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
            attrs.providers ??= [];
            attrs.providers.push(event.from.toString());
          }
          return attrs;
        }
      }) ?? this.provide;
    }
    /**
     * Announce to the network that we can provide the value for a given key and
     * are contactable on the given multiaddrs
     */
    async *provide(key, multiaddrs, options2 = {}) {
      this.log("provide %s", key);
      const target = key.multihash.bytes;
      await this.providers.addProvider(key, this.components.peerId, options2);
      const msg = {
        type: MessageType.ADD_PROVIDER,
        key: target,
        providers: [
          toPbPeerInfo({
            id: this.components.peerId,
            multiaddrs
          })
        ]
      };
      let sent = 0;
      const self2 = this;
      async function* publishProviderRecord(event) {
        try {
          self2.log("sending provider record for %s to %p", key, event.peer.id);
          for await (const addProviderEvent of self2.network.sendMessage(event.peer.id, msg, {
            ...options2,
            path: event.path
          })) {
            if (addProviderEvent.name === "PEER_RESPONSE") {
              self2.log("sent provider record for %s to %p", key, event.peer.id);
              sent++;
            }
            yield addProviderEvent;
          }
        } catch (err2) {
          self2.log.error("error sending provide record to peer %p - %e", event.peer.id, err2);
          yield queryErrorEvent({
            from: event.peer.id,
            error: err2,
            path: event.path
          }, options2);
        }
      }
      const events = pushable({
        objectMode: true
      });
      const queue = new Queue({
        concurrency: ALPHA
      });
      queue.addEventListener("idle", () => {
        events.end();
      });
      queue.addEventListener("failure", (event) => {
        this.log.error("error publishing provider record to peer - %e", event.detail.error);
      });
      queue.add(async () => {
        const finalPeerEvents = [];
        for await (const event of this.peerRouting.getClosestPeers(target, options2)) {
          events.push(event);
          if (event.name !== "FINAL_PEER") {
            continue;
          }
          finalPeerEvents.push(event);
        }
        finalPeerEvents.forEach((event) => {
          queue.add(async () => {
            for await (const notifyEvent of publishProviderRecord(event)) {
              events.push(notifyEvent);
            }
          }).catch((err2) => {
            this.log.error("error publishing provider record to peer - %e", err2);
          });
        });
      }).catch((err2) => {
        events.end(err2);
      });
      yield* events;
      this.log("sent provider records to %d peers", sent);
    }
    /**
     * Search the dht for up to `K` providers of the given CID.
     */
    async *findProviders(key, options2) {
      const toFind = this.routingTable.kBucketSize;
      let found = 0;
      const target = key.multihash.bytes;
      const self2 = this;
      this.log("findProviders %c", key);
      const provs = await this.providers.getProviders(key, options2);
      if (provs.length > 0) {
        const providers2 = [];
        for (const peerId of provs.slice(0, toFind)) {
          try {
            const peer = await this.components.peerStore.get(peerId, options2);
            providers2.push({
              id: peerId,
              multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
            });
          } catch (err2) {
            if (err2.name !== "NotFoundError") {
              throw err2;
            }
            this.log("no peer store entry for %p", peerId);
          }
        }
        yield peerResponseEvent({
          from: this.components.peerId,
          messageType: MessageType.GET_PROVIDERS,
          providers: providers2,
          path: {
            index: -1,
            queued: 0,
            running: 0,
            total: 0
          }
        }, options2);
        yield providerEvent({
          from: this.components.peerId,
          providers: providers2,
          path: {
            index: -1,
            queued: 0,
            running: 0,
            total: 0
          }
        }, options2);
        found += providers2.length;
        if (found >= toFind) {
          return;
        }
      }
      const findProvidersQuery = async function* ({ peer, signal, path }) {
        const request = {
          type: MessageType.GET_PROVIDERS,
          key: target
        };
        yield* self2.network.sendRequest(peer.id, request, {
          ...options2,
          signal,
          path
        });
      };
      const providers = new PeerSet(provs);
      for await (const event of this.queryManager.run(target, findProvidersQuery, options2)) {
        yield event;
        if (event.name === "PEER_RESPONSE") {
          this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
          const newProviders = [];
          for (const peer of event.providers) {
            if (providers.has(peer.id)) {
              continue;
            }
            providers.add(peer.id);
            newProviders.push(peer);
          }
          if (newProviders.length > 0) {
            yield providerEvent({
              from: event.from,
              providers: newProviders,
              path: event.path
            }, options2);
            found += newProviders.length;
            if (found >= toFind) {
              return;
            }
          }
        }
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/network.js
  var Network2 = class extends TypedEventEmitter {
    log;
    protocol;
    running;
    components;
    timeout;
    metrics;
    /**
     * Create a new network
     */
    constructor(components, init) {
      super();
      this.components = components;
      this.log = components.logger.forComponent(`${init.logPrefix}:network`);
      this.running = false;
      this.protocol = init.protocol;
      this.timeout = new AdaptiveTimeout({
        ...init.timeout ?? {},
        metrics: components.metrics,
        metricName: `${init.metricsPrefix}_network_message_send_times_milliseconds`
      });
      this.metrics = {
        operations: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_outbound_rpc_requests_total`),
        errors: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_outbound_rpc_errors_total`)
      };
      this.sendRequest = components.metrics?.traceFunction("libp2p.kadDHT.sendRequest", this.sendRequest.bind(this), {
        optionsIndex: 2,
        getAttributesFromArgs([to, message2], attrs) {
          return {
            ...attrs,
            to: to.toString(),
            "message type": `${message2.type}`
          };
        },
        getAttributesFromYieldedValue: (event, attrs) => {
          if (event.name === "PEER_RESPONSE") {
            if (event.providers.length > 0) {
              event.providers.forEach((value2, index) => {
                attrs[`providers-${index}`] = value2.id.toString();
              });
            }
            if (event.closer.length > 0) {
              event.closer.forEach((value2, index) => {
                attrs[`closer-${index}`] = value2.id.toString();
              });
            }
          }
          return attrs;
        }
      }) ?? this.sendRequest;
      this.sendMessage = components.metrics?.traceFunction("libp2p.kadDHT.sendMessage", this.sendMessage.bind(this), {
        optionsIndex: 2,
        getAttributesFromArgs([to, message2], attrs) {
          return {
            ...attrs,
            to: to.toString(),
            "message type": `${message2.type}`
          };
        },
        getAttributesFromYieldedValue: (event, attrs) => {
          if (event.name === "PEER_RESPONSE") {
            if (event.providers.length > 0) {
              event.providers.forEach((value2, index) => {
                attrs[`providers-${index}`] = value2.id.toString();
              });
            }
            if (event.closer.length > 0) {
              event.closer.forEach((value2, index) => {
                attrs[`closer-${index}`] = value2.id.toString();
              });
            }
          }
          return attrs;
        }
      }) ?? this.sendMessage;
    }
    /**
     * Start the network
     */
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
    }
    /**
     * Stop all network activity
     */
    async stop() {
      this.running = false;
    }
    /**
     * Is the network online?
     */
    isStarted() {
      return this.running;
    }
    /**
     * Send a request and read a response
     */
    async *sendRequest(to, msg, options2) {
      if (!this.running) {
        return;
      }
      const type = msg.type;
      if (type == null) {
        throw new InvalidParametersError("Message type was missing");
      }
      let stream;
      const signal = this.timeout.getTimeoutSignal(options2);
      options2 = {
        ...options2,
        signal
      };
      try {
        this.metrics.operations?.increment({ [type]: true });
        this.log("dialling %p", to);
        yield dialPeerEvent({ peer: to, path: options2.path }, options2);
        stream = await this.components.connectionManager.openStream(to, this.protocol, options2);
        this.log("sending %s to %p", msg.type, to);
        yield sendQueryEvent({ to, type, path: options2.path }, options2);
        const response = await this._writeReadMessage(stream, msg, options2);
        stream.close(options2).catch((err2) => {
          this.log.error("error closing stream to %p - %e", to, err2);
          stream?.abort(err2);
        });
        yield peerResponseEvent({
          from: to,
          messageType: response.type,
          closer: response.closer.map(fromPbPeerInfo),
          providers: response.providers.map(fromPbPeerInfo),
          record: response.record == null ? void 0 : Libp2pRecord.deserialize(response.record),
          path: options2.path
        }, options2);
      } catch (err2) {
        this.metrics.errors?.increment({ [type]: true });
        stream?.abort(err2);
        if (options2.signal?.aborted !== true) {
          this.log.error("could not send %s to %p - %e", msg.type, to, err2);
        }
        yield queryErrorEvent({ from: to, error: err2, path: options2.path }, options2);
      } finally {
        this.timeout.cleanUp(signal);
      }
    }
    /**
     * Sends a message without expecting an answer
     */
    async *sendMessage(to, msg, options2) {
      if (!this.running) {
        return;
      }
      const type = msg.type;
      if (type == null) {
        throw new InvalidParametersError("Message type was missing");
      }
      let stream;
      const signal = this.timeout.getTimeoutSignal(options2);
      options2 = {
        ...options2,
        signal
      };
      try {
        this.metrics.operations?.increment({ [type]: true });
        this.log("dialling %p", to);
        yield dialPeerEvent({ peer: to, path: options2.path }, options2);
        stream = await this.components.connectionManager.openStream(to, this.protocol, options2);
        this.log("sending %s to %p", msg.type, to);
        yield sendQueryEvent({ to, type, path: options2.path }, options2);
        await this._writeMessage(stream, msg, options2);
        stream.close(options2).catch((err2) => {
          this.log.error("error closing stream to %p - %e", to, err2);
          stream?.abort(err2);
        });
        yield peerResponseEvent({ from: to, messageType: type, path: options2.path }, options2);
      } catch (err2) {
        this.metrics.errors?.increment({ [type]: true });
        stream?.abort(err2);
        yield queryErrorEvent({ from: to, error: err2, path: options2.path }, options2);
      } finally {
        this.timeout.cleanUp(signal);
      }
    }
    /**
     * Write a message to the given stream
     */
    async _writeMessage(stream, msg, options2) {
      const pb = pbStream(stream);
      await pb.write(msg, Message2, options2);
    }
    /**
     * Write a message and read a response
     */
    async _writeReadMessage(stream, msg, options2) {
      const pb = pbStream(stream);
      await pb.write(msg, Message2, options2);
      const message2 = await pb.read(Message2, options2);
      message2.closer.forEach((peerData) => {
        this.safeDispatchEvent("peer", {
          detail: fromPbPeerInfo(peerData)
        });
      });
      message2.providers.forEach((peerData) => {
        this.safeDispatchEvent("peer", {
          detail: fromPbPeerInfo(peerData)
        });
      });
      return message2;
    }
  };

  // node_modules/uint8arrays/dist/src/xor-compare.js
  function xorCompare(a2, b) {
    if (a2.byteLength !== b.byteLength) {
      throw new Error("Inputs should have the same length");
    }
    for (let i2 = 0; i2 < a2.byteLength; i2++) {
      if (a2[i2] === b[i2]) {
        continue;
      }
      return a2[i2] < b[i2] ? -1 : 1;
    }
    return 0;
  }

  // node_modules/@libp2p/kad-dht/dist/src/peer-distance-list.js
  var PeerDistanceList = class {
    /**
     * The DHT key from which distance is calculated
     */
    originDhtKey;
    /**
     * The maximum size of the list
     */
    capacity;
    peerDistances;
    constructor(originDhtKey, capacity) {
      this.originDhtKey = originDhtKey;
      this.capacity = capacity;
      this.peerDistances = [];
    }
    /**
     * The length of the list
     */
    get length() {
      return this.peerDistances.length;
    }
    /**
     * The peers in the list, in order of distance from the origin key
     */
    get peers() {
      return [...this.peerDistances];
    }
    /**
     * Add a peerId to the list.
     */
    async add(peer, path = { index: -1, queued: 0, running: 0, total: 0 }, options2) {
      const dhtKey = await convertPeerId(peer.id, options2);
      this.addWithKadId(peer, dhtKey, path);
    }
    /**
     * Add a peerId to the list.
     */
    addWithKadId(peer, kadId, path = { index: -1, queued: 0, running: 0, total: 0 }) {
      if (this.peerDistances.find((pd) => pd.peer.id.equals(peer.id)) != null) {
        return;
      }
      const el = {
        peer,
        distance: xor(this.originDhtKey, kadId),
        path
      };
      if (this.peerDistances.length === this.capacity) {
        const lastPeer = this.peerDistances[this.peerDistances.length - 1];
        if (lastPeer != null && xorCompare(el.distance, lastPeer.distance) !== -1) {
          return;
        }
      }
      let added = false;
      for (let j = 0; j < this.peerDistances.length; j++) {
        const distance = xorCompare(this.peerDistances[j].distance, el.distance);
        if (distance === 0 || distance === 1) {
          added = true;
          this.peerDistances.splice(j, 0, el);
          break;
        }
      }
      if (!added) {
        this.peerDistances.push(el);
      }
      this.peerDistances = this.peerDistances.slice(0, this.capacity);
    }
    /**
     * Indicates whether any of the peerIds passed as a parameter are closer
     * to the origin key than the furthest peerId in the PeerDistanceList.
     */
    async isCloser(peerId, options2) {
      if (this.length === 0) {
        return true;
      }
      const dhtKey = await convertPeerId(peerId, options2);
      const dhtKeyXor = xor(dhtKey, this.originDhtKey);
      const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
      return xorCompare(dhtKeyXor, furthestDistance) === -1;
    }
    /**
     * Indicates whether any of the peerIds passed as a parameter are closer
     * to the origin key than the furthest peerId in the PeerDistanceList.
     */
    async anyCloser(peerIds, options2) {
      if (peerIds.length === 0) {
        return false;
      }
      return Promise.any(peerIds.map(async (peerId) => this.isCloser(peerId, options2)));
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
  var PeerRouting = class {
    log;
    routingTable;
    network;
    validators;
    queryManager;
    components;
    constructor(components, init) {
      this.routingTable = init.routingTable;
      this.network = init.network;
      this.validators = init.validators;
      this.queryManager = init.queryManager;
      this.components = components;
      this.log = components.logger.forComponent(`${init.logPrefix}:peer-routing`);
      this.findPeer = components.metrics?.traceFunction("libp2p.kadDHT.findPeer", this.findPeer.bind(this), {
        optionsIndex: 1
      }) ?? this.findPeer;
      this.getClosestPeers = components.metrics?.traceFunction("libp2p.kadDHT.getClosestPeers", this.getClosestPeers.bind(this), {
        optionsIndex: 1
      }) ?? this.getClosestPeers;
    }
    /**
     * Look if we are connected to a peer with the given id.
     * Returns its id and addresses, if found, otherwise `undefined`.
     */
    async findPeerLocal(peer, options2) {
      let peerData;
      const p2 = await this.routingTable.find(peer, options2);
      if (p2 != null) {
        this.log("findPeerLocal found %p in routing table", peer);
        try {
          peerData = await this.components.peerStore.get(p2, options2);
        } catch (err2) {
          if (err2.name !== "NotFoundError") {
            throw err2;
          }
        }
      }
      if (peerData == null) {
        try {
          peerData = await this.components.peerStore.get(peer, options2);
        } catch (err2) {
          if (err2.name !== "NotFoundError") {
            throw err2;
          }
        }
      }
      if (peerData != null) {
        this.log("findPeerLocal found %p in peer store", peer);
        return {
          id: peerData.id,
          multiaddrs: peerData.addresses.map((address) => address.multiaddr)
        };
      }
      return void 0;
    }
    /**
     * Get a value via rpc call for the given parameters
     */
    async *_getValueSingle(peer, key, options2) {
      const msg = {
        type: MessageType.GET_VALUE,
        key
      };
      yield* this.network.sendRequest(peer, msg, options2);
    }
    /**
     * Get the public key directly from a node
     */
    async *getPublicKeyFromNode(peer, options2 = {}) {
      const pkKey = keyForPublicKey(peer);
      const path = {
        index: -1,
        queued: 0,
        running: 0,
        total: 0
      };
      for await (const event of this._getValueSingle(peer, pkKey, {
        ...options2,
        path
      })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          const publicKey2 = publicKeyFromProtobuf(event.record.value);
          const recPeer = peerIdFromPublicKey(publicKey2);
          if (!recPeer.equals(peer)) {
            throw new InvalidPublicKeyError("public key does not match id");
          }
          if (recPeer.publicKey == null) {
            throw new InvalidPublicKeyError("public key missing");
          }
          yield valueEvent({
            from: peer,
            value: event.record.value,
            path
          }, options2);
        }
      }
      throw new QueryError(`Node not responding with its public key: ${peer.toString()}`);
    }
    /**
     * Search for a peer with the given ID
     */
    async *findPeer(id, options2 = {}) {
      this.log("findPeer %p", id);
      if (options2.useCache !== false) {
        const pi = await this.findPeerLocal(id, options2);
        if (pi != null) {
          this.log("found local");
          yield finalPeerEvent({
            from: this.components.peerId,
            peer: pi,
            path: {
              index: -1,
              queued: 0,
              running: 0,
              total: 0
            }
          }, options2);
          return;
        }
      }
      let foundPeer = false;
      if (options2.useNetwork !== false) {
        const self2 = this;
        const findPeerQuery = async function* ({ peer, signal, path }) {
          const request = {
            type: MessageType.FIND_NODE,
            key: id.toMultihash().bytes
          };
          for await (const event of self2.network.sendRequest(peer.id, request, {
            ...options2,
            signal,
            path
          })) {
            yield event;
            if (event.name === "PEER_RESPONSE") {
              const match = event.closer.find((p2) => p2.id.equals(id));
              if (match != null) {
                yield finalPeerEvent({
                  from: event.from,
                  peer: match,
                  path: event.path
                }, options2);
              }
            }
          }
        };
        for await (const event of this.queryManager.run(id.toMultihash().bytes, findPeerQuery, options2)) {
          if (event.name === "FINAL_PEER") {
            foundPeer = true;
          }
          yield event;
        }
      }
      if (!foundPeer) {
        throw new NotFoundError("Not found");
      }
    }
    /**
     * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from a
     * multihash or a peer ID
     */
    async *getClosestPeers(key, options2 = {}) {
      this.log("getClosestPeers to %b", key);
      const kadId = await convertBuffer(key, options2);
      const peers = new PeerDistanceList(kadId, this.routingTable.kBucketSize);
      const self2 = this;
      const getCloserPeersQuery = async function* ({ peer, path, peerKadId, signal }) {
        self2.log("getClosestPeers asking %p", peer.id);
        const request = {
          type: MessageType.FIND_NODE,
          key
        };
        yield* self2.network.sendRequest(peer.id, request, {
          ...options2,
          signal,
          path
        });
        peers.addWithKadId(peer, peerKadId, path);
      };
      yield* this.queryManager.run(key, getCloserPeersQuery, options2);
      this.log("found %d peers close to %b", peers.length, key);
      for (let { peer, path } of peers.peers) {
        try {
          if (peer.multiaddrs.length === 0) {
            peer = await self2.components.peerStore.getInfo(peer.id, options2);
          }
          if (peer.multiaddrs.length === 0) {
            continue;
          }
          yield finalPeerEvent({
            from: this.components.peerId,
            peer: await self2.components.peerStore.getInfo(peer.id, options2),
            path: {
              index: path.index,
              queued: 0,
              running: 0,
              total: 0
            }
          }, options2);
        } catch {
          continue;
        }
      }
    }
    /**
     * Query a particular peer for the value for the given key.
     * It will either return the value or a list of closer peers.
     *
     * Note: The peerStore is updated with new addresses found for the given peer.
     */
    async *getValueOrPeers(peer, key, options2) {
      for await (const event of this._getValueSingle(peer, key, options2)) {
        if (event.name === "PEER_RESPONSE") {
          if (event.record != null) {
            try {
              await this._verifyRecordOnline(event.record, options2);
            } catch (err2) {
              const errMsg = "invalid record received, discarded";
              this.log(errMsg);
              yield queryErrorEvent({
                from: event.from,
                error: new QueryError(errMsg),
                path: options2.path
              }, options2);
              continue;
            }
          }
        }
        yield event;
      }
    }
    /**
     * Verify a record, fetching missing public keys from the network.
     * Throws an error if the record is invalid.
     */
    async _verifyRecordOnline(record, options2) {
      if (record.timeReceived == null) {
        throw new InvalidRecordError("invalid record received");
      }
      await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived), options2);
    }
    /**
     * Get the peers in our routing table that are closest to the passed key
     */
    async getClosestPeersOffline(key, options2) {
      const output = [];
      try {
        const multihash = decode4(key);
        const targetPeerId = peerIdFromMultihash(multihash);
        const peer = await this.components.peerStore.get(targetPeerId, options2);
        output.push({
          id: peer.id,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        });
      } catch {
      }
      const keyKadId = await convertBuffer(key, options2);
      const ids = this.routingTable.closestPeers(keyKadId, options2);
      for (const peerId of ids) {
        try {
          output.push(await this.components.peerStore.getInfo(peerId, options2));
        } catch (err2) {
          if (err2.name !== "NotFoundError") {
            throw err2;
          }
        }
      }
      if (output.length > 0) {
        this.log("getClosestPeersOffline returning the %d closest peer(s) we know to %b", output.length, key);
      } else {
        this.log("getClosestPeersOffline could not any peers close to %b with %d peers in the routing table", key, this.routingTable.size);
      }
      return output;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/providers.js
  var Providers = class {
    log;
    datastore;
    datastorePrefix;
    constructor(components, init) {
      this.log = components.logger.forComponent(`${init.logPrefix}:providers`);
      this.datastorePrefix = `${init.datastorePrefix}/provider`;
      this.datastore = components.datastore;
    }
    /**
     * Add a new provider for the given CID
     */
    async addProvider(cid, provider, options2) {
      this.log.trace("%p provides %s", provider, cid);
      await this.writeProviderEntry(cid, provider, options2);
    }
    /**
     * Remove a provider for the given CID
     */
    async removeProvider(cid, provider, options2) {
      const key = toProviderKey(this.datastorePrefix, cid, provider);
      this.log.trace("%p no longer provides %s", provider, cid);
      await this.datastore.delete(key, options2);
    }
    /**
     * Get a list of providers for the given CID
     */
    async getProviders(cid, options2) {
      this.log.trace("get providers for %c", cid);
      const provs = await this.loadProviders(cid, options2);
      this.log.trace("got %d providers for %c", provs.size, cid);
      return [...provs.keys()];
    }
    /**
     * Write a provider into the given store
     */
    async writeProviderEntry(cid, peerId, options2) {
      const key = toProviderKey(this.datastorePrefix, cid, peerId);
      const buffer2 = encode7(options2?.time?.getTime() ?? Date.now());
      await this.datastore.put(key, buffer2, options2);
    }
    /**
     * Load providers for the given CID from the store
     */
    async loadProviders(cid, options2) {
      const providers = new PeerMap();
      const key = toProviderKey(this.datastorePrefix, cid);
      for await (const entry of this.datastore.query({ prefix: key.toString() }, options2)) {
        const { peerId } = parseProviderKey(entry.key);
        providers.set(peerId, readProviderTime(entry.value));
      }
      return providers;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
  async function* queryPath(options2) {
    const { key, startingPeers, ourPeerId, query, alpha, path, numPaths, log: log18, peersSeen, connectionManager, signal } = options2;
    const events = pushable({
      objectMode: true
    });
    const queue = new Queue({
      concurrency: alpha,
      sort: (a2, b) => xorCompare(a2.options.distance, b.options.distance)
    });
    queue.addEventListener("idle", () => {
      events.push(pathEndedEvent({
        path: {
          index: path,
          queued: queue.queued,
          running: queue.running,
          total: queue.size
        }
      }, options2));
      events.end();
    });
    queue.addEventListener("failure", (evt) => {
      log18.error("error during query - %e", evt.detail.error);
    });
    const onAbort = () => {
      queue.abort();
      events.end(new AbortError());
    };
    signal.addEventListener("abort", onAbort);
    try {
      let queryPeer = function(peer, peerKadId) {
        if (peer == null) {
          return;
        }
        peersSeen.add(peer.id.toMultihash().bytes);
        const peerXor = xor(peerKadId, kadId);
        queue.add(async () => {
          try {
            for await (const event of query({
              ...options2,
              key,
              peer,
              path: {
                index: path,
                queued: queue.queued,
                running: queue.running,
                total: queue.size
              },
              numPaths,
              peerKadId,
              signal
            })) {
              if (event.name === "PEER_RESPONSE") {
                for (const closerPeer of event.closer) {
                  if (peersSeen.has(closerPeer.id.toMultihash().bytes)) {
                    log18("already seen %p in query", closerPeer.id);
                    continue;
                  }
                  if (ourPeerId.equals(closerPeer.id)) {
                    log18("not querying ourselves");
                    continue;
                  }
                  if (!await connectionManager.isDialable(closerPeer.multiaddrs)) {
                    log18("not querying undialable peer");
                    continue;
                  }
                  const closerPeerKadId = await convertPeerId(closerPeer.id, {
                    signal
                  });
                  const closerPeerXor = xor(closerPeerKadId, kadId);
                  if (xorCompare(closerPeerXor, peerXor) !== -1) {
                    log18("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer.id);
                    continue;
                  }
                  log18("querying closer peer %p", closerPeer.id);
                  queryPeer(closerPeer, closerPeerKadId);
                }
              }
              events.push({
                ...event,
                path: {
                  index: path,
                  queued: queue.queued,
                  running: queue.running,
                  total: queue.size
                }
              });
            }
          } catch (err2) {
            events.push(queryErrorEvent({
              from: peer.id,
              error: err2,
              path: {
                index: path,
                queued: queue.queued,
                running: queue.running - 1,
                total: queue.size - 1
              }
            }, options2));
          }
        }, {
          distance: peerXor
        }).catch((err2) => {
          log18.error("error during query - %e", err2);
        });
      };
      const kadId = await convertBuffer(key, {
        signal
      });
      await Promise.all(startingPeers.map(async (startingPeer) => {
        queryPeer({ id: startingPeer, multiaddrs: [] }, await convertPeerId(startingPeer, {
          signal
        }));
      }));
      yield* events;
    } finally {
      signal.removeEventListener("abort", onAbort);
    }
  }

  // node_modules/@libp2p/kad-dht/dist/src/query/manager.js
  var QueryManager = class {
    disjointPaths;
    alpha;
    shutDownController;
    running;
    logger;
    peerId;
    connectionManager;
    routingTable;
    initialQuerySelfHasRun;
    logPrefix;
    allowQueryWithZeroPeers;
    constructor(components, init) {
      this.logPrefix = init.logPrefix;
      this.disjointPaths = init.disjointPaths ?? K;
      this.alpha = init.alpha ?? ALPHA;
      this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
      this.routingTable = init.routingTable;
      this.logger = components.logger;
      this.peerId = components.peerId;
      this.connectionManager = components.connectionManager;
      this.allowQueryWithZeroPeers = init.allowQueryWithZeroPeers ?? false;
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
      this.running = false;
    }
    isStarted() {
      return this.running;
    }
    /**
     * Starts the query manager
     */
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
    }
    /**
     * Stops all queries
     */
    async stop() {
      this.running = false;
      this.shutDownController.abort();
    }
    async *run(key, queryFunc, options2 = {}) {
      if (!this.running) {
        throw new Error("QueryManager not started");
      }
      if (options2.signal == null) {
        const signal2 = AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);
        setMaxListeners(Infinity, signal2);
        options2 = {
          ...options2,
          signal: signal2
        };
      }
      const queryEarlyExitController = new AbortController();
      const signal = anySignal([
        this.shutDownController.signal,
        queryEarlyExitController.signal,
        options2.signal
      ]);
      setMaxListeners(Infinity, signal, queryEarlyExitController.signal);
      const log18 = this.logger.forComponent(`${this.logPrefix}:query:` + toString2(key, "base58btc"));
      let queryFinished = false;
      try {
        if (this.routingTable.size === 0 && !this.allowQueryWithZeroPeers) {
          log18("routing table was empty, waiting for some peers before running%s query", options2.isSelfQuery === true ? " self" : "");
          await pEvent(this.routingTable, "peer:add", {
            signal,
            filter: (event) => !this.peerId.equals(event.detail)
          });
          log18("routing table has peers, continuing with%s query", options2.isSelfQuery === true ? " self" : "");
        }
        if (options2.isSelfQuery !== true && this.initialQuerySelfHasRun != null) {
          log18("waiting for initial self query before continuing");
          await raceSignal(this.initialQuerySelfHasRun.promise, signal);
          this.initialQuerySelfHasRun = void 0;
        }
        log18("query:start");
        const id = await convertBuffer(key, {
          signal
        });
        const peers = this.routingTable.closestPeers(id, {
          count: this.routingTable.kBucketSize
        });
        const peersToQuery = peers.sort(() => {
          if (Math.random() > 0.5) {
            return 1;
          }
          return -1;
        }).reduce((acc, curr, index) => {
          acc[index % this.disjointPaths].push(curr);
          return acc;
        }, new Array(this.disjointPaths).fill(0).map(() => [])).filter((peers2) => peers2.length > 0);
        if (peers.length === 0) {
          log18.error("running query with no peers");
          return;
        }
        const peersSeen = createScalableCuckooFilter(1024);
        const paths = peersToQuery.map((peer, index) => {
          return queryPath({
            ...options2,
            key,
            startingPeers: peer,
            ourPeerId: this.peerId,
            signal,
            query: queryFunc,
            path: index,
            numPaths: peersToQuery.length,
            alpha: this.alpha,
            log: log18,
            peersSeen,
            onProgress: options2.onProgress,
            connectionManager: this.connectionManager
          });
        });
        for await (const event of src_default(...paths)) {
          if (event.name === "QUERY_ERROR") {
            log18.error("query error - %e", event.error);
          }
          if (event.name === "PEER_RESPONSE") {
            for (const peer of [...event.closer, ...event.providers]) {
              if (!await this.connectionManager.isDialable(peer.multiaddrs, {
                signal
              })) {
                continue;
              }
              await this.routingTable.add(peer.id, {
                signal
              });
            }
          }
          signal.throwIfAborted();
          yield event;
        }
        queryFinished = true;
      } catch (err2) {
        if (this.running) {
          throw err2;
        }
      } finally {
        if (!queryFinished) {
          log18("query exited early");
          queryEarlyExitController.abort();
        }
        signal.clear();
        log18("query finished");
      }
    }
  };

  // node_modules/it-length/dist/src/index.js
  function isAsyncIterable13(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function length3(source) {
    if (isAsyncIterable13(source)) {
      return (async () => {
        let count = 0;
        for await (const _ of source) {
          count++;
        }
        return count;
      })();
    } else {
      let count = 0;
      for (const _ of source) {
        count++;
      }
      return count;
    }
  }
  var src_default13 = length3;

  // node_modules/@libp2p/kad-dht/dist/src/query-self.js
  var QuerySelf = class {
    log;
    peerId;
    peerRouting;
    events;
    count;
    interval;
    initialInterval;
    queryTimeout;
    running;
    timeoutId;
    controller;
    initialQuerySelfHasRun;
    querySelfPromise;
    constructor(components, init) {
      this.peerId = components.peerId;
      this.log = components.logger.forComponent(`${init.logPrefix}:query-self`);
      this.events = components.events;
      this.running = false;
      this.peerRouting = init.peerRouting;
      this.count = init.count ?? K;
      this.interval = init.interval ?? QUERY_SELF_INTERVAL;
      this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;
      this.queryTimeout = init.queryTimeout ?? QUERY_SELF_TIMEOUT;
      this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
      this.querySelf = timeOperationMethod(this.querySelf.bind(this), init.operationMetrics, "SELF_QUERY");
    }
    isStarted() {
      return this.running;
    }
    start() {
      if (this.running) {
        return;
      }
      this.running = true;
      clearTimeout(this.timeoutId);
      this.timeoutId = setTimeout(() => {
        this.querySelf().catch((err2) => {
          this.log.error("error running self-query - %e", err2);
        });
      }, this.initialInterval);
    }
    stop() {
      this.running = false;
      if (this.timeoutId != null) {
        clearTimeout(this.timeoutId);
      }
      if (this.controller != null) {
        this.controller.abort();
      }
    }
    async querySelf() {
      if (!this.running) {
        this.log("skip self-query because we are not started");
        return;
      }
      if (this.querySelfPromise != null) {
        this.log("joining existing self query");
        return this.querySelfPromise.promise;
      }
      this.querySelfPromise = pDefer();
      if (this.running) {
        this.controller = new AbortController();
        const signals = [this.controller.signal];
        if (this.initialQuerySelfHasRun == null) {
          const timeoutSignal = AbortSignal.timeout(this.queryTimeout);
          setMaxListeners(Infinity, timeoutSignal);
          signals.push(timeoutSignal);
        }
        const signal = anySignal(signals);
        setMaxListeners(Infinity, signal, this.controller.signal);
        try {
          this.log("run self-query, look for %d peers timing out after %dms", this.count, this.queryTimeout);
          const start2 = Date.now();
          const peers = await pipe(this.peerRouting.getClosestPeers(this.peerId.toMultihash().bytes, {
            signal,
            isSelfQuery: true
          }), (source) => src_default6(source, this.count), async (source) => src_default13(source));
          signal?.throwIfAborted();
          const duration = Date.now() - start2;
          this.log("self-query found %d peers in %dms", peers, duration);
          this.events.dispatchEvent(new CustomEvent("kad-dht:query:self", {
            detail: {
              peers,
              duration
            }
          }));
        } catch (err2) {
          this.log.error("self-query error - %e", err2);
        } finally {
          signal.clear();
          if (this.initialQuerySelfHasRun != null) {
            this.initialQuerySelfHasRun.resolve();
            this.initialQuerySelfHasRun = void 0;
          }
        }
      }
      this.querySelfPromise.resolve();
      this.querySelfPromise = void 0;
      if (!this.running) {
        return;
      }
      this.timeoutId = setTimeout(() => {
        this.querySelf().catch((err2) => {
          this.log.error("error running self-query - %e", err2);
        });
      }, this.interval);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/reprovider.js
  var Reprovider = class extends TypedEventEmitter {
    log;
    reprovideQueue;
    maxQueueSize;
    datastore;
    timeout;
    reprovideTimeout;
    running;
    shutdownController;
    reprovideThreshold;
    contentRouting;
    datastorePrefix;
    addressManager;
    validity;
    interval;
    peerId;
    constructor(components, init) {
      super();
      this.log = components.logger.forComponent(`${init.logPrefix}:reprovider`);
      this.peerId = components.peerId;
      this.reprovideQueue = new Queue({
        concurrency: init.concurrency ?? REPROVIDE_CONCURRENCY,
        metrics: components.metrics,
        metricName: `${init.metricsPrefix}_reprovide_queue`
      });
      this.reprovideTimeout = new AdaptiveTimeout({
        ...init.timeout ?? {},
        metrics: components.metrics,
        metricName: `${init.metricsPrefix}_reprovide_timeout_milliseconds`
      });
      this.datastore = components.datastore;
      this.addressManager = components.addressManager;
      this.datastorePrefix = `${init.datastorePrefix}/provider`;
      this.reprovideThreshold = init.threshold ?? REPROVIDE_THRESHOLD;
      this.maxQueueSize = init.maxQueueSize ?? REPROVIDE_MAX_QUEUE_SIZE;
      this.validity = init.validity ?? PROVIDERS_VALIDITY;
      this.interval = init.interval ?? REPROVIDE_INTERVAL;
      this.contentRouting = init.contentRouting;
      this.running = false;
      this.reprovide = timeOperationMethod(this.reprovide.bind(this), init.operationMetrics, "PROVIDE");
    }
    start() {
      if (this.running) {
        return;
      }
      this.running = true;
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
      this.timeout = setTimeout(() => {
        this.processRecords({
          signal: AbortSignal.timeout(REPROVIDE_TIMEOUT)
        }).catch((err2) => {
          this.log.error("error running process to reprovide/cleanup - %e", err2);
        });
      }, this.interval);
    }
    stop() {
      this.running = false;
      this.reprovideQueue.clear();
      clearTimeout(this.timeout);
      this.shutdownController?.abort();
    }
    /**
     * Check all provider records. Delete them if they have expired, reprovide
     * them if the provider is us and the expiry is within the reprovide window.
     */
    async processRecords(options2) {
      try {
        this.safeDispatchEvent("reprovide:start");
        this.log("starting reprovide/cleanup");
        for await (const entry of this.datastore.query({
          prefix: this.datastorePrefix
        }, options2)) {
          try {
            const { cid, peerId } = parseProviderKey(entry.key);
            const created = readProviderTime(entry.value).getTime();
            const expires = created + this.validity;
            const now = Date.now();
            const expired = now > expires;
            const isSelf = this.peerId.equals(peerId);
            this.log.trace("comparing: %d (now) < %d (expires) = %s %s", now, expires, expired, expired ? "(expired)" : "(valid)");
            if (expired && !isSelf) {
              await this.datastore.delete(entry.key, options2);
            }
            if (this.shouldReprovide(isSelf, expires)) {
              this.log("reproviding %c as it is within the reprovide threshold (%d)", cid, this.reprovideThreshold);
              this.queueReprovide(cid).catch((err2) => {
                this.log.error("could not reprovide %c - %e", cid, err2);
              });
            }
          } catch (err2) {
            this.log.error("error processing datastore key %s - %s", entry.key, err2.message);
          }
        }
        this.log("reprovide/cleanup successful");
      } finally {
        this.safeDispatchEvent("reprovide:end");
        if (this.running) {
          this.log("queuing next re-provide/cleanup run in %d ms", this.interval);
          this.timeout = setTimeout(() => {
            this.processRecords({
              signal: AbortSignal.timeout(REPROVIDE_TIMEOUT)
            }).catch((err2) => {
              this.log.error("error running re-provide - %e", err2);
            });
          }, this.interval);
        }
      }
    }
    /**
     * Determines if a record should be reprovided
     */
    shouldReprovide(isSelf, expires) {
      if (!isSelf) {
        return false;
      }
      const now = Date.now();
      if (expires < now) {
        return true;
      }
      return expires - now < this.reprovideThreshold;
    }
    async queueReprovide(cid, options2) {
      if (!this.running) {
        return;
      }
      this.log.trace("waiting for queue capacity before adding %c to re-provide queue", cid);
      await this.reprovideQueue.onSizeLessThan(this.maxQueueSize, options2);
      const existingJob = this.reprovideQueue.queue.find((job) => job.options.cid.equals(cid));
      if (existingJob != null) {
        this.log.trace("not adding %c to re-provide queue - already in queue", cid);
        return existingJob.join();
      }
      this.log.trace("adding %c to re-provide queue", cid);
      this.reprovideQueue.add(async (options3) => {
        options3.signal?.throwIfAborted();
        if (!this.running) {
          return;
        }
        this.log.trace("re-providing %c", cid);
        const signal = this.reprovideTimeout.getTimeoutSignal(options3);
        try {
          await this.reprovide(options3.cid, options3);
        } finally {
          this.reprovideTimeout.cleanUp(signal);
        }
        this.log.trace("re-provided %c", cid);
      }, {
        signal: this.shutdownController?.signal,
        cid
      }).catch((err2) => {
        this.log.error("could not re-provide key %c - %e", cid, err2);
      });
    }
    async reprovide(cid, options2) {
      await src_default3(this.contentRouting.provide(cid, this.addressManager.getAddresses(), options2));
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/closest-peers.js
  var PEER_SET_SIZE = 20;
  var REFRESH_INTERVAL = 5e3;
  var KAD_CLOSE_TAG_NAME = "kad-close";
  var KAD_CLOSE_TAG_VALUE = 50;
  var ClosestPeers = class {
    routingTable;
    components;
    closestPeers;
    newPeers;
    refreshInterval;
    peerSetSize;
    timeout;
    closeTagName;
    closeTagValue;
    log;
    running;
    constructor(components, init) {
      this.components = components;
      this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
      this.routingTable = init.routingTable;
      this.refreshInterval = init.refreshInterval ?? REFRESH_INTERVAL;
      this.peerSetSize = init.peerSetSize ?? PEER_SET_SIZE;
      this.closeTagName = init.closeTagName ?? KAD_CLOSE_TAG_NAME;
      this.closeTagValue = init.closeTagValue ?? KAD_CLOSE_TAG_VALUE;
      this.closestPeers = new PeerSet();
      this.onPeerPing = this.onPeerPing.bind(this);
      this.running = false;
    }
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
      const targetKadId = await convertPeerId(this.components.peerId);
      this.newPeers = new PeerDistanceList(targetKadId, this.peerSetSize);
      this.routingTable.addEventListener("peer:ping", this.onPeerPing);
      this.timeout = setInterval(() => {
        this.updatePeerTags().catch((err2) => {
          this.log.error("error updating peer tags - %e", err2);
        });
      }, this.refreshInterval);
    }
    stop() {
      this.running = false;
      this.routingTable.removeEventListener("peer:ping", this.onPeerPing);
      clearTimeout(this.timeout);
    }
    onPeerPing(event) {
      this.newPeers?.add({ id: event.detail, multiaddrs: [] }).catch((err2) => {
        this.log.error("error adding peer to distance list - %e", err2);
      });
    }
    async updatePeerTags() {
      const newClosest = new PeerSet(this.newPeers?.peers.map(({ peer }) => peer.id));
      const added = newClosest.difference(this.closestPeers);
      const removed = this.closestPeers.difference(newClosest);
      this.closestPeers = newClosest;
      await Promise.all([
        ...[...added].map(async (peerId) => {
          await this.components.peerStore.merge(peerId, {
            tags: {
              [this.closeTagName]: {
                value: this.closeTagValue
              },
              [KEEP_ALIVE_TAG2]: {
                value: 1
              }
            }
          });
        }),
        ...[...removed].map(async (peerId) => {
          await this.components.peerStore.merge(peerId, {
            tags: {
              [this.closeTagName]: void 0,
              [KEEP_ALIVE_TAG2]: void 0
            }
          });
        })
      ]);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/k-bucket.js
  function isLeafBucket(obj) {
    return Array.isArray(obj?.peers);
  }
  var KBucket = class {
    peerId;
    root;
    localPeer;
    prefixLength;
    splitThreshold;
    kBucketSize;
    numberOfNodesToPing;
    lastPingThreshold;
    ping;
    verify;
    onAdd;
    onRemove;
    onMove;
    addingPeerMap;
    constructor(components, options2) {
      this.peerId = components.peerId;
      this.prefixLength = options2.prefixLength ?? PREFIX_LENGTH;
      this.kBucketSize = options2.kBucketSize ?? KBUCKET_SIZE;
      this.splitThreshold = options2.splitThreshold ?? this.kBucketSize;
      this.numberOfNodesToPing = options2.numberOfOldContactsToPing ?? PING_OLD_CONTACT_COUNT;
      this.lastPingThreshold = options2.lastPingThreshold ?? LAST_PING_THRESHOLD;
      this.ping = options2.ping;
      this.verify = options2.verify;
      this.onAdd = options2.onAdd;
      this.onRemove = options2.onRemove;
      this.addingPeerMap = trackedPeerMap({
        name: `${options2.metricsPrefix}_adding_peer_map`,
        metrics: components.metrics
      });
      this.root = {
        prefix: "",
        depth: 0,
        peers: []
      };
    }
    async start() {
      await this.addSelfPeer(this.peerId);
    }
    stop() {
      this.addingPeerMap.clear();
      this.root = {
        prefix: "",
        depth: 0,
        peers: []
      };
    }
    async addSelfPeer(peerId, options2) {
      this.localPeer = {
        peerId,
        kadId: await convertPeerId(peerId, options2),
        lastPing: Date.now()
      };
    }
    /**
     * Adds a contact to the trie
     */
    async add(peerId, options2) {
      const peer = {
        peerId,
        kadId: await convertPeerId(peerId, options2),
        lastPing: 0
      };
      const existingPromise = this.addingPeerMap.get(peerId);
      if (existingPromise != null) {
        return existingPromise;
      }
      try {
        const p2 = this._add(peer, options2);
        this.addingPeerMap.set(peerId, p2);
        await p2;
      } finally {
        this.addingPeerMap.delete(peerId);
      }
    }
    async _add(peer, options2) {
      const bucket = this._determineBucket(peer.kadId);
      if (this._indexOf(bucket, peer.kadId) > -1) {
        return;
      }
      if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {
        await this._split(bucket, options2);
        await this._add(peer, options2);
        return;
      }
      if (bucket.peers.length < this.kBucketSize) {
        if (!needsPing(peer, this.lastPingThreshold)) {
          bucket.peers.push(peer);
          await this.onAdd?.(peer, bucket, options2);
          return;
        }
        const result = await this.verify(peer, options2);
        if (result) {
          peer.lastPing = Date.now();
          await this._add(peer, options2);
        }
        return;
      }
      const toPing = bucket.peers.filter((peer2) => {
        if (peer2.peerId.equals(this.localPeer?.peerId)) {
          return false;
        }
        if (peer2.lastPing > Date.now() - this.lastPingThreshold) {
          return false;
        }
        return true;
      }).sort((a2, b) => {
        if (a2.lastPing < b.lastPing) {
          return -1;
        }
        if (a2.lastPing > b.lastPing) {
          return 1;
        }
        return 0;
      }).slice(0, this.numberOfNodesToPing);
      let evicted = false;
      for await (const toEvict of this.ping(toPing, options2)) {
        evicted = true;
        await this.remove(toEvict.kadId, options2);
      }
      if (!evicted) {
        return;
      }
      await this._add(peer, options2);
    }
    /**
     * Get 0-n closest contacts to the provided node id. "Closest" here means:
     * closest according to the XOR metric of the contact node id.
     *
     * @param {Uint8Array} id - Contact node id
     * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
     */
    *closest(id, options2) {
      const list = new PeerDistanceList(id, options2?.count ?? this.kBucketSize);
      for (const peer of this.toIterable()) {
        if (options2?.exclude?.some((p2) => p2.equals(peer.peerId)) === true) {
          continue;
        }
        list.addWithKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);
      }
      yield* src_default5(list.peers, ({ peer }) => peer.id);
    }
    /**
     * Counts the total number of contacts in the tree.
     *
     * @returns {number} The number of contacts held in the tree
     */
    count() {
      function countBucket(bucket) {
        if (isLeafBucket(bucket)) {
          return bucket.peers.length;
        }
        let count = 0;
        if (bucket.left != null) {
          count += countBucket(bucket.left);
        }
        if (bucket.right != null) {
          count += countBucket(bucket.right);
        }
        return count;
      }
      return countBucket(this.root);
    }
    /**
     * Get a contact by its exact ID.
     * If this is a leaf, loop through the bucket contents and return the correct
     * contact if we have it or null if not. If this is an inner node, determine
     * which branch of the tree to traverse and repeat.
     *
     * @param {Uint8Array} kadId - The ID of the contact to fetch.
     * @returns {Peer | undefined} The contact if available, otherwise null
     */
    get(kadId) {
      const bucket = this._determineBucket(kadId);
      const index = this._indexOf(bucket, kadId);
      return bucket.peers[index];
    }
    /**
     * Removes contact with the provided id.
     *
     * @param {Uint8Array} kadId - The ID of the contact to remove
     */
    async remove(kadId, options2) {
      const bucket = this._determineBucket(kadId);
      const index = this._indexOf(bucket, kadId);
      if (index > -1) {
        const peer = bucket.peers.splice(index, 1)[0];
        await this.onRemove?.(peer, bucket, options2);
      }
    }
    /**
     * Similar to `toArray()` but instead of buffering everything up into an
     * array before returning it, yields contacts as they are encountered while
     * walking the tree.
     *
     * @returns {Iterable} All of the contacts in the tree, as an iterable
     */
    *toIterable() {
      function* iterate(bucket) {
        if (isLeafBucket(bucket)) {
          yield* bucket.peers;
          return;
        }
        yield* iterate(bucket.left);
        yield* iterate(bucket.right);
      }
      yield* iterate(this.root);
    }
    /**
     * Default distance function. Finds the XOR distance between firstId and
     * secondId.
     *
     * @param  {Uint8Array} firstId - Uint8Array containing first id.
     * @param  {Uint8Array} secondId - Uint8Array containing second id.
     * @returns {number} Integer The XOR distance between firstId and secondId.
     */
    distance(firstId, secondId) {
      return BigInt("0x" + toString2(xor(firstId, secondId), "base16"));
    }
    /**
     * Determines whether the id at the bitIndex is 0 or 1
     * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
     *
     * @param {Uint8Array} kadId - Id to compare localNodeId with
     * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
     */
    _determineBucket(kadId) {
      const bitString = toString2(kadId, "base2");
      function findBucket(bucket, bitIndex = 0) {
        if (isLeafBucket(bucket)) {
          return bucket;
        }
        const bit = bitString[bitIndex];
        if (bit === "0") {
          return findBucket(bucket.left, bitIndex + 1);
        }
        return findBucket(bucket.right, bitIndex + 1);
      }
      return findBucket(this.root);
    }
    /**
     * Returns the index of the contact with provided
     * id if it exists, returns -1 otherwise.
     *
     * @param {object} bucket - internal object that has 2 leafs: left and right
     * @param {Uint8Array} kadId - KadId of peer
     * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
     */
    _indexOf(bucket, kadId) {
      return bucket.peers.findIndex((peer) => equals3(peer.kadId, kadId));
    }
    /**
     * Modify the bucket, turn it from a leaf bucket to an internal bucket
     *
     * @param {any} bucket - bucket for splitting
     */
    async _split(bucket, options2) {
      const left = {
        prefix: "0",
        depth: bucket.depth + 1,
        peers: []
      };
      const right = {
        prefix: "1",
        depth: bucket.depth + 1,
        peers: []
      };
      for (const peer of bucket.peers) {
        const bitString = toString2(peer.kadId, "base2");
        if (bitString[bucket.depth] === "0") {
          left.peers.push(peer);
          await this.onMove?.(peer, bucket, left, options2);
        } else {
          right.peers.push(peer);
          await this.onMove?.(peer, bucket, right, options2);
        }
      }
      convertToInternalBucket(bucket, left, right);
    }
  };
  function convertToInternalBucket(bucket, left, right) {
    delete bucket.peers;
    bucket.left = left;
    bucket.right = right;
    if (bucket.prefix === "") {
      delete bucket.depth;
      delete bucket.prefix;
    }
    return true;
  }
  function needsPing(peer, threshold) {
    return peer.lastPing < Date.now() - threshold;
  }

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
  var KBUCKET_SIZE = 20;
  var PREFIX_LENGTH = 6;
  var PING_NEW_CONTACT_CONCURRENCY = 20;
  var PING_NEW_CONTACT_MAX_QUEUE_SIZE = 100;
  var PING_OLD_CONTACT_COUNT = 3;
  var PING_OLD_CONTACT_CONCURRENCY = 20;
  var PING_OLD_CONTACT_MAX_QUEUE_SIZE = 100;
  var KAD_PEER_TAG_NAME = "kad-peer";
  var KAD_PEER_TAG_VALUE = 1;
  var LAST_PING_THRESHOLD = 6e5;
  var POPULATE_FROM_DATASTORE_ON_START = true;
  var POPULATE_FROM_DATASTORE_LIMIT = 1e3;
  var RoutingTable = class extends TypedEventEmitter {
    kBucketSize;
    kb;
    network;
    closestPeerTagger;
    log;
    components;
    running;
    pingNewContactTimeout;
    pingNewContactQueue;
    pingOldContactTimeout;
    pingOldContactQueue;
    populateFromDatastoreOnStart;
    populateFromDatastoreLimit;
    protocol;
    peerTagName;
    peerTagValue;
    metrics;
    shutdownController;
    constructor(components, init) {
      super();
      this.components = components;
      this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
      this.kBucketSize = init.kBucketSize ?? KBUCKET_SIZE;
      this.running = false;
      this.protocol = init.protocol;
      this.network = init.network;
      this.peerTagName = init.peerTagName ?? KAD_PEER_TAG_NAME;
      this.peerTagValue = init.peerTagValue ?? KAD_PEER_TAG_VALUE;
      this.pingOldContacts = this.pingOldContacts.bind(this);
      this.verifyNewContact = this.verifyNewContact.bind(this);
      this.peerAdded = this.peerAdded.bind(this);
      this.peerRemoved = this.peerRemoved.bind(this);
      this.populateFromDatastoreOnStart = init.populateFromDatastoreOnStart ?? POPULATE_FROM_DATASTORE_ON_START;
      this.populateFromDatastoreLimit = init.populateFromDatastoreLimit ?? POPULATE_FROM_DATASTORE_LIMIT;
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
      this.pingOldContactQueue = new PeerQueue({
        concurrency: init.pingOldContactConcurrency ?? PING_OLD_CONTACT_CONCURRENCY,
        metricName: `${init.metricsPrefix}_ping_old_contact_queue`,
        metrics: this.components.metrics,
        maxSize: init.pingOldContactMaxQueueSize ?? PING_OLD_CONTACT_MAX_QUEUE_SIZE
      });
      this.pingOldContactTimeout = new AdaptiveTimeout({
        ...init.pingOldContactTimeout ?? {},
        metrics: this.components.metrics,
        metricName: `${init.metricsPrefix}_routing_table_ping_old_contact_time_milliseconds`
      });
      this.pingNewContactQueue = new PeerQueue({
        concurrency: init.pingNewContactConcurrency ?? PING_NEW_CONTACT_CONCURRENCY,
        metricName: `${init.metricsPrefix}_ping_new_contact_queue`,
        metrics: this.components.metrics,
        maxSize: init.pingNewContactMaxQueueSize ?? PING_NEW_CONTACT_MAX_QUEUE_SIZE
      });
      this.pingNewContactTimeout = new AdaptiveTimeout({
        ...init.pingNewContactTimeout ?? {},
        metrics: this.components.metrics,
        metricName: `${init.metricsPrefix}_routing_table_ping_new_contact_time_milliseconds`
      });
      this.kb = new KBucket(components, {
        kBucketSize: init.kBucketSize,
        prefixLength: init.prefixLength,
        splitThreshold: init.splitThreshold,
        numberOfOldContactsToPing: init.numberOfOldContactsToPing,
        lastPingThreshold: init.lastPingThreshold,
        ping: this.pingOldContacts,
        verify: this.verifyNewContact,
        onAdd: this.peerAdded,
        onRemove: this.peerRemoved,
        metricsPrefix: init.metricsPrefix
      });
      this.closestPeerTagger = new ClosestPeers(this.components, {
        logPrefix: init.logPrefix,
        routingTable: this,
        peerSetSize: init.closestPeerSetSize,
        refreshInterval: init.closestPeerSetRefreshInterval,
        closeTagName: init.closeTagName,
        closeTagValue: init.closeTagValue
      });
      if (this.components.metrics != null) {
        this.metrics = {
          routingTableSize: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_size`),
          routingTableKadBucketTotal: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_total`),
          routingTableKadBucketAverageOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_average_occupancy`),
          routingTableKadBucketMinOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_min_occupancy`),
          routingTableKadBucketMaxOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_max_occupancy`),
          routingTableKadBucketMaxDepth: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_max_depth`),
          kadBucketEvents: this.components.metrics.registerCounterGroup(`${init.metricsPrefix}_kad_bucket_events_total`)
        };
      }
    }
    isStarted() {
      return this.running;
    }
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
      await start(this.closestPeerTagger, this.kb);
    }
    async afterStart() {
      let peerStorePeers = 0;
      Promise.resolve().then(async () => {
        if (!this.populateFromDatastoreOnStart) {
          return;
        }
        const signal = anySignal([
          this.shutdownController.signal,
          AbortSignal.timeout(2e4)
        ]);
        setMaxListeners(Infinity, signal);
        try {
          for (const peer of await this.components.peerStore.all({
            filters: [(peer2) => {
              return peer2.protocols.includes(this.protocol) && peer2.tags.has(KAD_PEER_TAG_NAME);
            }],
            limit: this.populateFromDatastoreLimit,
            signal
          })) {
            if (!this.running) {
              return;
            }
            try {
              await this.add(peer.id, {
                signal
              });
              peerStorePeers++;
            } catch (err2) {
              this.log("failed to add peer %p to routing table, removing kad-dht peer tags - %e");
              await this.components.peerStore.merge(peer.id, {
                tags: {
                  [this.peerTagName]: void 0
                }
              });
            }
          }
        } finally {
          signal.clear();
        }
        this.log("added %d peer store peers to the routing table", peerStorePeers);
      }).catch((err2) => {
        this.log.error("error adding %d, peer store peers to the routing table - %e", peerStorePeers, err2);
      });
    }
    async stop() {
      this.running = false;
      await stop(this.closestPeerTagger, this.kb);
      this.pingOldContactQueue.abort();
      this.pingNewContactQueue.abort();
      this.shutdownController.abort();
    }
    async peerAdded(peer, bucket, options2) {
      if (!this.components.peerId.equals(peer.peerId)) {
        await this.components.peerStore.merge(peer.peerId, {
          tags: {
            [this.peerTagName]: {
              value: this.peerTagValue
            }
          }
        }, options2);
      }
      this.updateMetrics();
      this.metrics?.kadBucketEvents.increment({ peer_added: true });
      this.safeDispatchEvent("peer:add", { detail: peer.peerId });
    }
    async peerRemoved(peer, bucket, options2) {
      if (!this.components.peerId.equals(peer.peerId)) {
        await this.components.peerStore.merge(peer.peerId, {
          tags: {
            [this.peerTagName]: void 0
          }
        }, options2);
      }
      this.updateMetrics();
      this.metrics?.kadBucketEvents.increment({ peer_removed: true });
      this.safeDispatchEvent("peer:remove", { detail: peer.peerId });
    }
    /**
     * Called on the `ping` event from `k-bucket` when a bucket is full
     * and cannot split.
     *
     * `oldContacts.length` is defined by the `numberOfNodesToPing` param
     * passed to the `k-bucket` constructor.
     *
     * `oldContacts` will not be empty and is the list of contacts that
     * have not been contacted for the longest.
     */
    async *pingOldContacts(oldContacts, options2) {
      if (!this.running) {
        return;
      }
      const jobs = [];
      for (const oldContact of oldContacts) {
        if (this.kb.get(oldContact.kadId) == null) {
          this.log("asked to ping contact %p that was not in routing table", oldContact.peerId);
          continue;
        }
        this.metrics?.kadBucketEvents.increment({ ping_old_contact: true });
        jobs.push(async () => {
          const existingJob = this.pingOldContactQueue.find(oldContact.peerId);
          if (existingJob != null) {
            this.log("asked to ping contact %p was already being pinged", oldContact.peerId);
            const result2 = await existingJob.join(options2);
            if (!result2) {
              return oldContact;
            }
            return;
          }
          const result = await this.pingOldContactQueue.add(async (options3) => {
            const signal = this.pingOldContactTimeout.getTimeoutSignal();
            const signals = anySignal([
              signal,
              this.shutdownController.signal,
              options3?.signal
            ]);
            setMaxListeners(Infinity, signal, signals);
            try {
              return await this.pingContact(oldContact, options3);
            } catch {
              this.metrics?.kadBucketEvents.increment({ ping_old_contact_error: true });
              return true;
            } finally {
              this.pingOldContactTimeout.cleanUp(signal);
              signals.clear();
            }
          }, {
            peerId: oldContact.peerId,
            signal: options2?.signal
          });
          if (!result) {
            return oldContact;
          }
        });
      }
      for await (const peer of parallel(jobs)) {
        if (peer != null) {
          yield peer;
        }
      }
    }
    async verifyNewContact(contact, options2) {
      const signal = this.pingNewContactTimeout.getTimeoutSignal();
      const signals = anySignal([
        signal,
        this.shutdownController.signal,
        options2?.signal
      ]);
      setMaxListeners(Infinity, signal, signals);
      try {
        const job = this.pingNewContactQueue.find(contact.peerId);
        if (job != null) {
          this.log("joining existing ping to add new peer %p to routing table", contact.peerId);
          return await job.join({
            signal: signals
          });
        } else {
          return await this.pingNewContactQueue.add(async (options3) => {
            this.metrics?.kadBucketEvents.increment({ ping_new_contact: true });
            this.log("pinging new peer %p before adding to routing table", contact.peerId);
            return this.pingContact(contact, options3);
          }, {
            peerId: contact.peerId,
            signal: signals
          });
        }
      } catch (err2) {
        this.log.trace("tried to add peer %p but they were not online", contact.peerId);
        this.metrics?.kadBucketEvents.increment({ ping_new_contact_error: true });
        return false;
      } finally {
        this.pingNewContactTimeout.cleanUp(signal);
        signals.clear();
      }
    }
    async pingContact(contact, options2) {
      let stream;
      try {
        this.log("pinging contact %p", contact.peerId);
        await this.components.ping.ping(contact.peerId, options2);
        this.log("contact %p ping ok", contact.peerId);
        this.safeDispatchEvent("peer:ping", {
          detail: contact.peerId
        });
        return true;
      } catch (err2) {
        this.log("error pinging old contact %p - %e", contact.peerId, err2);
        stream?.abort(err2);
        return false;
      }
    }
    /**
     * Amount of currently stored peers
     */
    get size() {
      if (this.kb == null) {
        return 0;
      }
      return this.kb.count();
    }
    /**
     * Find a specific peer by id
     */
    async find(peer, options2) {
      const kadId = await convertPeerId(peer, options2);
      return this.kb.get(kadId)?.peerId;
    }
    /**
     * Retrieve the closest peers to the given kadId
     */
    closestPeer(kadId) {
      const res = this.closestPeers(kadId, {
        count: 1
      });
      if (res.length > 0) {
        return res[0];
      }
      return void 0;
    }
    /**
     * Retrieve the `count`-closest peers to the given kadId
     */
    closestPeers(kadId, options2) {
      if (this.kb == null) {
        return [];
      }
      return [...this.kb.closest(kadId, options2)];
    }
    /**
     * Add or update the routing table with the given peer
     */
    async add(peerId, options2) {
      if (this.kb == null) {
        throw new Error("RoutingTable is not started");
      }
      await this.kb.add(peerId, options2);
    }
    /**
     * Remove a given peer from the table
     */
    async remove(peer, options2) {
      if (this.kb == null) {
        throw new Error("RoutingTable is not started");
      }
      const kadId = await convertPeerId(peer, options2);
      await this.kb.remove(kadId, options2);
    }
    updateMetrics() {
      if (this.metrics == null || this.kb == null) {
        return;
      }
      let size = 0;
      let buckets = 0;
      let maxDepth = 0;
      let minOccupancy = 20;
      let maxOccupancy = 0;
      function count(bucket) {
        if (isLeafBucket(bucket)) {
          if (bucket.depth > maxDepth) {
            maxDepth = bucket.depth;
          }
          buckets++;
          size += bucket.peers.length;
          if (bucket.peers.length < minOccupancy) {
            minOccupancy = bucket.peers.length;
          }
          if (bucket.peers.length > maxOccupancy) {
            maxOccupancy = bucket.peers.length;
          }
          return;
        }
        count(bucket.left);
        count(bucket.right);
      }
      count(this.kb.root);
      this.metrics.routingTableSize.update(size);
      this.metrics.routingTableKadBucketTotal.update(buckets);
      this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(size / buckets));
      this.metrics.routingTableKadBucketMinOccupancy.update(minOccupancy);
      this.metrics.routingTableKadBucketMaxOccupancy.update(maxOccupancy);
      this.metrics.routingTableKadBucketMaxDepth.update(maxDepth);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
  var generated_prefix_list_browser_default = [
    77591,
    22417,
    43971,
    28421,
    740,
    29829,
    71467,
    228973,
    196661,
    78537,
    27689,
    36431,
    44415,
    14362,
    19456,
    106025,
    96308,
    2882,
    49509,
    21149,
    87173,
    131409,
    75844,
    23676,
    121838,
    30291,
    17492,
    2953,
    7564,
    110620,
    129477,
    127283,
    53113,
    72417,
    165166,
    109690,
    21200,
    102125,
    24049,
    71504,
    90342,
    25307,
    72039,
    26812,
    26715,
    32264,
    133800,
    71161,
    88956,
    171987,
    51779,
    24425,
    16671,
    30251,
    186294,
    247761,
    14202,
    2121,
    8465,
    35024,
    4876,
    85917,
    169730,
    3638,
    256836,
    96184,
    943,
    18678,
    6583,
    52907,
    35807,
    112254,
    214097,
    18796,
    11595,
    9243,
    23554,
    887,
    268203,
    382004,
    24590,
    111335,
    11625,
    16619,
    29039,
    102425,
    69006,
    97976,
    92362,
    32552,
    63717,
    41433,
    128974,
    137630,
    59943,
    10019,
    13986,
    35430,
    33665,
    108037,
    43799,
    43280,
    38195,
    29078,
    58629,
    18265,
    14425,
    46832,
    235538,
    40830,
    77881,
    110717,
    58937,
    3463,
    325358,
    51300,
    47623,
    117252,
    19007,
    10170,
    20540,
    91237,
    294813,
    4951,
    79841,
    56232,
    36270,
    128547,
    69209,
    66275,
    100156,
    32063,
    73531,
    34439,
    80937,
    28892,
    44466,
    88595,
    216307,
    32583,
    49620,
    16605,
    82127,
    45807,
    21630,
    78726,
    20235,
    40163,
    111007,
    96926,
    5567,
    72083,
    21665,
    58844,
    39419,
    179767,
    48328,
    42662,
    51550,
    5251,
    37811,
    49608,
    81056,
    50854,
    55513,
    20922,
    18891,
    197409,
    164656,
    32593,
    71449,
    220474,
    58919,
    85682,
    67854,
    13758,
    35066,
    3565,
    61905,
    214793,
    119572,
    141419,
    21504,
    10302,
    27354,
    67003,
    46131,
    32668,
    15165,
    64871,
    34450,
    17821,
    2757,
    11452,
    34189,
    5160,
    12257,
    85523,
    560,
    53385,
    65887,
    119549,
    135620,
    312353,
    115979,
    122356,
    10867,
    193231,
    124537,
    54783,
    90675,
    120791,
    4715,
    142253,
    50943,
    17271,
    43358,
    25331,
    4917,
    120566,
    34580,
    12878,
    33786,
    160528,
    32523,
    4869,
    301307,
    104817,
    81491,
    23276,
    8832,
    97911,
    31265,
    52065,
    7998,
    49622,
    9715,
    43998,
    34091,
    84587,
    20664,
    69041,
    29419,
    53205,
    10838,
    58288,
    116145,
    6185,
    5154,
    141795,
    35924,
    21307,
    144738,
    43730,
    12085,
    8279,
    10002,
    119,
    133779,
    199668,
    72938,
    31768,
    39176,
    67875,
    38453,
    9700,
    44144,
    4121,
    116048,
    41733,
    12868,
    82669,
    92308,
    128,
    34262,
    11332,
    7712,
    90764,
    36141,
    13553,
    71312,
    77470,
    117314,
    96549,
    49135,
    23602,
    54468,
    28605,
    6327,
    62308,
    17171,
    67531,
    21319,
    14105,
    894,
    107722,
    46157,
    8503,
    51069,
    100472,
    45138,
    15246,
    14577,
    35609,
    191464,
    1757,
    13364,
    161349,
    32067,
    91705,
    81144,
    52339,
    5408,
    91066,
    21983,
    14157,
    100545,
    4372,
    26630,
    129112,
    1423,
    29676,
    213626,
    4397,
    88436,
    99190,
    6877,
    49958,
    26122,
    114348,
    60661,
    29818,
    293118,
    50042,
    179738,
    16400,
    163423,
    89627,
    31040,
    43973,
    36638,
    45952,
    5153,
    1894,
    109322,
    1898,
    134021,
    12402,
    112077,
    68309,
    190269,
    69866,
    31938,
    107383,
    11522,
    105232,
    11248,
    14868,
    39852,
    71707,
    186525,
    16530,
    38162,
    106212,
    11700,
    5130,
    16608,
    26998,
    59586,
    108399,
    230033,
    43683,
    48135,
    82179,
    2073,
    5015,
    196684,
    189293,
    16378,
    23452,
    8301,
    35640,
    11632,
    214551,
    29240,
    57644,
    33137,
    91949,
    55157,
    52384,
    117313,
    5090,
    17717,
    89668,
    49363,
    82238,
    241035,
    66216,
    29066,
    184088,
    97206,
    62820,
    26595,
    4241,
    135635,
    173672,
    8202,
    459,
    71355,
    146294,
    29587,
    3008,
    135385,
    141203,
    14803,
    6634,
    45094,
    69362,
    50925,
    546,
    51884,
    62011,
    83296,
    234584,
    44515,
    56050,
    89476,
    87751,
    19373,
    12691,
    149923,
    19794,
    13833,
    35846,
    87557,
    58339,
    2884,
    19145,
    25647,
    12224,
    11024,
    77338,
    64608,
    122297,
    53025,
    7205,
    36189,
    36294,
    170779,
    21750,
    7739,
    173883,
    75192,
    35664,
    224240,
    113121,
    30181,
    26267,
    27036,
    117827,
    92015,
    106516,
    55628,
    203549,
    67949,
    60462,
    60844,
    35911,
    20457,
    1820,
    920,
    19773,
    8738,
    73173,
    181993,
    38521,
    98254,
    76257,
    46008,
    92796,
    5384,
    26868,
    151566,
    22124,
    2411,
    15919,
    186872,
    180021,
    28099,
    152961,
    78811,
    80237,
    62352,
    102653,
    74259,
    184890,
    16792,
    123702,
    224945,
    29940,
    19512,
    75283,
    14059,
    112691,
    92811,
    233329,
    20411,
    138569,
    53341,
    109802,
    50600,
    134528,
    66747,
    5529,
    166531,
    31578,
    64732,
    67189,
    1596,
    126357,
    967,
    167999,
    206598,
    109752,
    119431,
    207825,
    78791,
    91938,
    10301,
    27311,
    24233,
    252343,
    28831,
    32812,
    66002,
    112267,
    90895,
    8786,
    8095,
    16824,
    22866,
    21813,
    60507,
    174833,
    19549,
    130985,
    117051,
    52110,
    6938,
    81923,
    123864,
    38061,
    919,
    18680,
    53534,
    46739,
    112893,
    161529,
    85429,
    26761,
    11900,
    81121,
    91968,
    15390,
    217947,
    56524,
    1713,
    6654,
    37089,
    85630,
    138866,
    61850,
    16491,
    75577,
    16884,
    98296,
    73523,
    6140,
    44645,
    6062,
    36366,
    29844,
    57946,
    37932,
    42472,
    5266,
    20834,
    19309,
    33753,
    127182,
    134259,
    35810,
    41805,
    45878,
    312001,
    14881,
    47757,
    49251,
    120050,
    44252,
    3708,
    25856,
    107864,
    120347,
    1228,
    36550,
    41682,
    34496,
    47025,
    8393,
    173365,
    246526,
    12894,
    161607,
    35670,
    90785,
    126572,
    2095,
    124731,
    157033,
    58694,
    554,
    12786,
    9642,
    4817,
    16136,
    47864,
    174698,
    66992,
    4639,
    69284,
    10625,
    40710,
    27763,
    51738,
    30404,
    264105,
    137904,
    109882,
    52487,
    42824,
    57514,
    2740,
    10479,
    146799,
    107390,
    16586,
    88038,
    174951,
    9410,
    16185,
    44158,
    5568,
    40658,
    46108,
    12763,
    97385,
    26175,
    108859,
    664,
    230732,
    67470,
    46663,
    14395,
    50750,
    141320,
    93140,
    15361,
    47997,
    55784,
    6791,
    307840,
    118569,
    107326,
    18056,
    58281,
    260415,
    54691,
    8790,
    73332,
    45633,
    7511,
    45674,
    143373,
    14031,
    11799,
    94491,
    35646,
    96544,
    14560,
    26049,
    32983,
    25791,
    83814,
    42094,
    231370,
    63955,
    139212,
    2359,
    169908,
    3108,
    183486,
    105867,
    28197,
    32941,
    124968,
    26402,
    88267,
    149768,
    23053,
    3078,
    19091,
    52924,
    25383,
    19209,
    111548,
    97361,
    3959,
    24880,
    235061,
    9099,
    24921,
    161254,
    151405,
    20508,
    7159,
    34381,
    20133,
    11434,
    74036,
    19974,
    34769,
    36585,
    1076,
    22454,
    17354,
    38727,
    235160,
    111547,
    96454,
    117448,
    156940,
    91330,
    37299,
    7310,
    26915,
    117060,
    51369,
    22620,
    61861,
    322264,
    106850,
    111694,
    15091,
    2624,
    40345,
    300446,
    177064,
    1707,
    27389,
    54792,
    327783,
    132669,
    183543,
    59003,
    17744,
    20603,
    151134,
    106923,
    53084,
    71803,
    279424,
    319816,
    11579,
    21946,
    16728,
    38274,
    72711,
    5085,
    83391,
    88646,
    40159,
    25027,
    34680,
    10752,
    12988,
    54126,
    30365,
    18338,
    100445,
    230674,
    44874,
    84974,
    143877,
    123253,
    139372,
    28082,
    91477,
    144002,
    13096,
    219729,
    46016,
    50029,
    42377,
    14601,
    6660,
    58244,
    58978,
    23918,
    88206,
    113611,
    64452,
    17541,
    41032,
    10942,
    12021,
    49189,
    10978,
    40175,
    37156,
    10947,
    71709,
    106894,
    112538,
    57007,
    137486,
    150608,
    152719,
    40615,
    7746,
    279716,
    13101,
    19524,
    28708,
    40578,
    72320,
    1096,
    182051,
    94527,
    51275,
    22833,
    45164,
    81917,
    77519,
    48508,
    5421,
    140302,
    37845,
    149830,
    5587,
    27579,
    5357,
    428725,
    248187,
    6326,
    206760,
    39814,
    32585,
    89923,
    44341,
    288753,
    284443,
    96368,
    31201,
    94189,
    119504,
    20359,
    52073,
    103216,
    179,
    27934,
    32801,
    96035,
    34111,
    34309,
    101326,
    18198,
    20704,
    210266,
    37643,
    27880,
    141873,
    106e3,
    19414,
    56614,
    167714,
    66483,
    107885,
    86602,
    4379,
    20796,
    75467,
    4987,
    5017,
    118857,
    26003,
    34308,
    114428,
    29198,
    6686,
    29697,
    73632,
    3739,
    69795,
    16798,
    41504,
    7207,
    30722,
    21436,
    36735,
    28067,
    28545,
    3239,
    11221,
    36031,
    41889,
    100010,
    19247,
    317673,
    29495,
    174554,
    6424,
    129725,
    53845,
    94986,
    7955,
    59676,
    2604,
    191497,
    19735,
    102214,
    62954,
    23844,
    11872,
    179525,
    261436,
    34492,
    428,
    78404,
    142035,
    16747,
    17246,
    27578,
    37021,
    33672,
    57944,
    26056,
    135760,
    2369,
    61674,
    122066,
    31327,
    19374,
    157065,
    40553,
    130982,
    69619,
    71290,
    38855,
    72100,
    92903,
    95940,
    51422,
    165999,
    65713,
    57873,
    50726,
    7288,
    20272,
    2081,
    42326,
    22624,
    81120,
    57914,
    79352,
    19447,
    1684,
    72302,
    11774,
    302559,
    161481,
    96396,
    13692,
    414988,
    3721,
    79066,
    56627,
    46883,
    21150,
    11747,
    12184,
    5856,
    113458,
    176117,
    84416,
    52079,
    27933,
    3354,
    59765,
    141359,
    2212,
    216309,
    2555,
    23458,
    196722,
    142463,
    45701,
    44548,
    28798,
    19418,
    215,
    29916,
    9396,
    10574,
    114226,
    84475,
    13520,
    18694,
    34056,
    4524,
    90302,
    62930,
    13539,
    19407,
    77209,
    7728,
    38088,
    9535,
    2263,
    23875,
    183945,
    17750,
    26274,
    67172,
    10585,
    28042,
    22199,
    7478,
    51331,
    66030,
    26774,
    192929,
    31434,
    25850,
    50197,
    52926,
    178158,
    4679,
    181256,
    70184,
    229600,
    9959,
    105594,
    72158,
    73974,
    2726,
    35085,
    78087,
    23284,
    35568,
    51713,
    155676,
    5401,
    27254,
    11966,
    17569,
    223253,
    71993,
    103357,
    111477,
    55722,
    30504,
    26034,
    46774,
    35392,
    36285,
    214814,
    41143,
    163465,
    1051,
    16094,
    81044,
    6636,
    76489,
    179102,
    20712,
    39178,
    35683,
    125177,
    54219,
    30617,
    52994,
    25324,
    50123,
    2543,
    87529,
    58995,
    10688,
    125199,
    12388,
    60158,
    125481,
    131646,
    7642,
    133350,
    65874,
    3438,
    97277,
    101450,
    10075,
    56344,
    116821,
    50778,
    60547,
    98016,
    106135,
    13859,
    14255,
    16300,
    77373,
    173521,
    8285,
    45932,
    37426,
    4054,
    114295,
    55947,
    7703,
    39114,
    52,
    51119,
    128135,
    19714,
    60715,
    9554,
    50492,
    88180,
    2823,
    118271,
    52993,
    122625,
    97919,
    23859,
    37895,
    25040,
    33614,
    32102,
    20431,
    3577,
    9275,
    15686,
    43031,
    157741,
    110358,
    1884,
    40291,
    125391,
    13736,
    5008,
    64881,
    87336,
    77381,
    70711,
    43032,
    49155,
    118587,
    70494,
    4318,
    10168,
    30126,
    12580,
    10524,
    280104,
    104001,
    145413,
    2862,
    84140,
    6603,
    106005,
    13566,
    12780,
    11251,
    42830,
    571,
    179910,
    82443,
    13146,
    469,
    42714,
    32591,
    265217,
    424024,
    92553,
    54721,
    134100,
    6007,
    15242,
    114681,
    59030,
    16718,
    85465,
    200214,
    85982,
    55174,
    165013,
    23493,
    56964,
    82529,
    109150,
    32706,
    27568,
    82442,
    5350,
    14976,
    13165,
    44890,
    60021,
    21343,
    33978,
    17264,
    4655,
    22328,
    27819,
    75730,
    16567,
    55483,
    14510,
    17926,
    45827,
    150609,
    3704,
    7385,
    272531,
    161543,
    76904,
    122163,
    52405,
    2039,
    19165,
    41623,
    14423,
    228354,
    3369,
    176360,
    85491,
    7122,
    35789,
    303724,
    4465,
    13628,
    2233,
    55311,
    118771,
    20713,
    10006,
    221519,
    45115,
    71021,
    35650,
    29775,
    7337,
    10864,
    20665,
    21142,
    1746,
    15080,
    1624,
    32449,
    10905,
    105743,
    229797,
    7701,
    3940,
    22997,
    178467,
    57208,
    389057,
    39683,
    59403,
    63344,
    63125,
    54847,
    69691,
    18336,
    56448,
    3362,
    37202,
    18282,
    29648,
    138224,
    35867,
    10495,
    5911,
    28814,
    26653,
    31514,
    176702,
    26550,
    45621,
    11734,
    4525,
    40543,
    73944,
    121080,
    27858,
    155561,
    14887,
    44670,
    30742,
    8796,
    107455,
    113472,
    56369,
    75581,
    183777,
    240095,
    133699,
    153299,
    8768,
    160464,
    26058,
    49078,
    103971,
    21875,
    71486,
    44888,
    17156,
    9678,
    89541,
    123019,
    102337,
    3972,
    83930,
    21245,
    87852,
    109660,
    287918,
    183019,
    686,
    10100,
    39177,
    283941,
    11274,
    24736,
    26793,
    26214,
    25995,
    77011,
    141580,
    4070,
    23742,
    46285,
    46632,
    30700,
    26669,
    19056,
    35951,
    115575,
    174034,
    56097,
    35463,
    87425,
    24575,
    44245,
    38701,
    82317,
    85922,
    281616,
    100333,
    147697,
    61503,
    7730,
    84330,
    8530,
    59917,
    61597,
    17173,
    9092,
    32658,
    90288,
    193136,
    39023,
    20381,
    56654,
    31132,
    7779,
    1919,
    1375,
    117128,
    30819,
    11169,
    40938,
    23935,
    115201,
    101155,
    151034,
    4835,
    11231,
    74550,
    89388,
    59951,
    91704,
    107312,
    167882,
    115062,
    12732,
    72738,
    88703,
    464019,
    158267,
    57995,
    60496,
    737,
    14371,
    123867,
    4174,
    243339,
    159946,
    7568,
    16025,
    134556,
    110916,
    38103,
    191,
    80226,
    88794,
    29688,
    27230,
    10454,
    76308,
    57647,
    77409,
    113483,
    66864,
    14745,
    19808,
    12023,
    46583,
    84805,
    16015,
    17102,
    2231,
    20611,
    3547,
    95740,
    250131,
    34559,
    108894,
    8498,
    15853,
    159169,
    148920,
    20942,
    2813,
    93160,
    45188,
    210613,
    45531,
    52587,
    149062,
    39782,
    28194,
    57849,
    60965,
    84954,
    89766,
    84453,
    100927,
    16501,
    27658,
    165311,
    103841,
    54192,
    207341,
    19558,
    20084,
    319622,
    5672,
    205467,
    98462,
    61849,
    36279,
    13609,
    147177,
    24726,
    165015,
    209489,
    59591,
    31157,
    6551,
    117580,
    75060,
    141146,
    277310,
    21072,
    22023,
    106474,
    63041,
    137443,
    122965,
    68371,
    5383,
    42146,
    98961,
    113467,
    30863,
    23794,
    4843,
    99630,
    30392,
    82679,
    13699,
    241612,
    33601,
    93146,
    24319,
    18643,
    32155,
    95669,
    40440,
    15333,
    34089,
    67799,
    142144,
    58245,
    38633,
    114531,
    117400,
    77861,
    188726,
    5507,
    2568,
    8853,
    10987,
    107222,
    2663,
    2421,
    11530,
    13345,
    30075,
    41785,
    118661,
    104786,
    17459,
    12490,
    16281,
    71936,
    193555,
    17431,
    5944,
    71758,
    26485,
    77317,
    20803,
    367167,
    158,
    7362,
    93430,
    11735,
    172445,
    46002,
    11532,
    54482,
    930,
    62911,
    2235,
    23004,
    179236,
    4764,
    101859,
    208113,
    22477,
    55163,
    95579,
    14098,
    67320,
    162556,
    90709,
    156949,
    3826,
    57492,
    4025,
    34092,
    87442,
    104565,
    6718,
    186015,
    28214,
    14209,
    10039,
    107186,
    233912,
    58877,
    81637,
    55265,
    39828,
    6194,
    145813,
    50831,
    105849,
    4974,
    88319,
    122296,
    10272,
    197216,
    95714,
    51540,
    72418,
    23324,
    91555,
    8743,
    140452,
    250249,
    51666,
    34124,
    7229,
    38592,
    129641,
    78169,
    174242,
    22464,
    149964,
    51450,
    14034,
    10026,
    95376,
    26190,
    120062,
    14401,
    8700,
    265,
    31386,
    143573,
    7203,
    229889,
    61567,
    4227,
    140981,
    2466,
    72052,
    10787,
    10062,
    30958,
    6099,
    38471,
    30103,
    23202,
    208101,
    70847,
    467,
    58934,
    32271,
    32984,
    36637,
    24107,
    30771,
    17109,
    73353,
    13650,
    2098,
    157040,
    67366,
    66904,
    106018,
    265380,
    107238,
    18535,
    44025,
    32681,
    144983,
    62505,
    91295,
    56120,
    3082,
    77508,
    10322,
    63023,
    36700,
    81885,
    224127,
    16721,
    45023,
    239261,
    111272,
    13852,
    7866,
    149243,
    204199,
    32309,
    22084,
    42029,
    38316,
    126644,
    104973,
    14406,
    43454,
    67322,
    61310,
    15789,
    40285,
    24026,
    181047,
    6301,
    70927,
    23319,
    115823,
    27248,
    66693,
    115875,
    278566,
    63007,
    146844,
    56841,
    59007,
    87368,
    180001,
    22370,
    42114,
    80605,
    12022,
    10374,
    308,
    25079,
    14689,
    12618,
    63368,
    7936,
    264973,
    212291,
    136713,
    95999,
    105801,
    18965,
    32075,
    48700,
    52230,
    35119,
    96912,
    32992,
    8586,
    16606,
    101333,
    101812,
    14969,
    39930,
    759,
    193090,
    27387,
    42914,
    12937,
    5058,
    62646,
    64528,
    38624,
    25743,
    37502,
    3716,
    4435,
    30352,
    178687,
    26461,
    132611,
    42002,
    138442,
    35833,
    59582,
    16345,
    8048,
    60319,
    49349,
    309,
    47800,
    49739,
    90482,
    26405,
    34470,
    63786,
    32479,
    85028,
    39866,
    47846,
    11649,
    23934,
    29466,
    2816,
    42864,
    31828,
    7410,
    74885,
    49632,
    47629,
    111801,
    90749,
    19536,
    18767,
    105764,
    59606,
    21223,
    10746,
    76298,
    22220,
    39408,
    7190,
    79654,
    64856,
    11602,
    82156,
    272765,
    17079,
    70089,
    245473,
    51813,
    184407,
    384678,
    1576,
    122249,
    5064,
    27481,
    6188,
    25790,
    74361,
    27541,
    318284,
    45430,
    31488,
    620,
    93579,
    45723,
    192118,
    22670,
    51913,
    4162,
    70244,
    35966,
    26397,
    16199,
    50899,
    209613,
    121702,
    287507,
    2993,
    36101,
    132229,
    67345,
    33062,
    76295,
    118628,
    78705,
    52316,
    34375,
    107083,
    107454,
    44863,
    127561,
    33964,
    3073,
    154010,
    190914,
    55967,
    39074,
    6272,
    31047,
    5550,
    41123,
    26154,
    98638,
    47110,
    19998,
    148091,
    50229,
    31329,
    59900,
    195442,
    19106,
    61347,
    73497,
    70015,
    682,
    45850,
    25776,
    38022,
    148951,
    6288,
    37411,
    232526,
    109277,
    27286,
    32342,
    9262,
    5220,
    16651,
    23175,
    46740,
    129438,
    78614,
    121925,
    66914,
    88710,
    127952,
    5563,
    21500,
    34521,
    10739,
    14863,
    191006,
    62956,
    17359,
    16749,
    67027,
    56284,
    69134,
    43301,
    35039,
    58883,
    54466,
    60823,
    404451,
    75743,
    59856,
    86979,
    7923,
    34273,
    83785,
    32142,
    7693,
    268986,
    197428,
    282681,
    17049,
    22346,
    22990,
    92245,
    107180,
    3357,
    37104,
    96724,
    49153,
    7683,
    31197,
    43267,
    82231,
    164276,
    23696,
    20848,
    188364,
    22309,
    24821,
    158707,
    1018,
    22514,
    70922,
    27792,
    45589,
    59709,
    10765,
    736,
    35218,
    63479,
    51987,
    24275,
    63588,
    55361,
    92929,
    81964,
    4658,
    20122,
    12330,
    44058,
    13065,
    311456,
    72224,
    8337,
    211229,
    38979,
    22590,
    138478,
    52757,
    32595,
    133600,
    8838,
    31549,
    94412,
    43391,
    90056,
    1585,
    94802,
    127271,
    6223,
    31889,
    137038,
    132910,
    2165,
    57616,
    230152,
    6080,
    10748,
    36737,
    74579,
    134062,
    50525,
    180532,
    119270,
    34556,
    76155,
    82394,
    52595,
    29258,
    31435,
    87820,
    67996,
    26943,
    183878,
    38007,
    2410,
    13526,
    180297,
    69856,
    3503,
    187396,
    167700,
    7838,
    16701,
    9199,
    56267,
    3661,
    37407,
    65994,
    23767,
    5708,
    62508,
    221700,
    67088,
    86978,
    46776,
    84434,
    32088,
    5612,
    9149,
    88244,
    21685,
    95151,
    46750,
    189612,
    2979,
    506311,
    2594,
    3628,
    40074,
    105039,
    78243,
    28523,
    6651,
    38058,
    71999,
    30992,
    12764,
    68261,
    108991,
    6165,
    26450,
    61961,
    13400,
    22426,
    7490,
    60890,
    109623,
    2070,
    12958,
    50355,
    67979,
    257096,
    7213,
    42578,
    52121,
    35716,
    65461,
    7516,
    124758,
    39268,
    302,
    64712,
    14977,
    1467,
    219452,
    2840,
    34229,
    11121,
    21602,
    19270,
    63574,
    8024,
    1532,
    17331,
    79839,
    78885,
    52029,
    180767,
    57957,
    6069,
    91265,
    61380,
    55767,
    8927,
    32881,
    287603,
    22149,
    35029,
    68876,
    6428,
    199567,
    46926,
    13412,
    104132,
    21434,
    366616,
    45060,
    110046,
    81924,
    128910,
    45886,
    52821,
    130416,
    29416,
    77342,
    21762,
    67329,
    121432,
    79924,
    11724,
    38625,
    81006,
    102033,
    28338,
    13326,
    3250,
    82056,
    82526,
    38212,
    21112,
    12382,
    111495,
    3263,
    7414,
    86274,
    93490,
    40844,
    30224,
    45212,
    24019,
    48411,
    71367,
    24941,
    76729,
    57776,
    3769,
    38114,
    202019,
    197745,
    31953,
    237533,
    33270,
    201580,
    255648,
    100798,
    44741,
    32241,
    98468,
    106931,
    10085,
    15090,
    170358,
    33154,
    66787,
    18819,
    69760,
    25061,
    234005,
    82660,
    6295,
    131975,
    16874,
    9076,
    4094,
    25005,
    17740,
    40908,
    19533,
    220019,
    44330,
    99792,
    50040,
    19619,
    13950,
    55228,
    24423,
    31253,
    95308,
    103177,
    184795,
    28590,
    82285,
    5059,
    3210,
    75525,
    49894,
    70007,
    56178,
    10580,
    36051,
    139681,
    21617,
    98736,
    3555,
    106306,
    164189,
    37352,
    63915,
    47824,
    24883,
    145530,
    61904,
    28444,
    11483,
    19837,
    145446,
    30420,
    112972,
    85939,
    11835,
    191233,
    2262,
    20705,
    58630,
    1753,
    148334,
    1197,
    144714,
    6887,
    11223,
    107667,
    60879,
    77914,
    4151,
    57417,
    81594,
    96681,
    169430,
    1784,
    20444,
    95138,
    254041,
    27038,
    596,
    7117,
    72808,
    13759,
    3353,
    126776,
    21074,
    55322,
    27081,
    36942,
    39547,
    139830,
    179275,
    4453,
    713,
    8722,
    71399,
    19204,
    25785,
    22794,
    23923,
    104114,
    11291,
    25458,
    102309,
    88396,
    75288,
    230440,
    206396,
    104551,
    58447,
    130857,
    37247,
    94734,
    31548,
    176529,
    226077,
    65159,
    20104,
    10096,
    66881,
    94191,
    237909,
    27109,
    37404,
    1520,
    27421,
    25220,
    113003,
    23423,
    24884,
    50585,
    6286,
    231877,
    150800,
    11789,
    3226,
    90004,
    60642,
    5053,
    202400,
    61442,
    132531,
    175329,
    57138,
    30116,
    103847,
    9973,
    75367,
    16452,
    32360,
    59119,
    21246,
    10191,
    164804,
    23305,
    61051,
    37348,
    154530,
    13214,
    5468,
    50403,
    66754,
    130976,
    50559,
    80515,
    14436,
    155492,
    84017,
    5472,
    43107,
    41240,
    2890,
    90431,
    70188,
    382,
    76234,
    48040,
    50211,
    281038,
    237007,
    32115,
    142178,
    1536,
    22761,
    96429,
    1811,
    31243,
    1679,
    49143,
    55209,
    17402,
    235054,
    61494,
    7462,
    77030,
    34925,
    87609,
    78002,
    9499,
    9027,
    73289,
    201078,
    101379,
    63544,
    27666,
    5469,
    10642,
    30029,
    49816,
    132979,
    95620,
    58086,
    351930,
    116300,
    2110,
    2043,
    30845,
    6154,
    11279,
    16727,
    4122,
    2277,
    27281,
    4971,
    3650,
    39060,
    61970,
    65951,
    39674,
    75686,
    38151,
    11370,
    130809,
    177895,
    32665,
    63725,
    122267,
    7857,
    39618,
    118483,
    44792,
    157755,
    178624,
    136994,
    24260,
    41308,
    22471,
    12404,
    21707,
    12486,
    30473,
    52781,
    50246,
    20247,
    39065,
    909,
    56825,
    103158,
    128603,
    31542,
    1089,
    41935,
    32744,
    12428,
    37963,
    84420,
    33134,
    72921,
    208449,
    42622,
    168151,
    127335,
    147107,
    46699,
    38216,
    12591,
    94342,
    85814,
    31423,
    24944,
    2605,
    87542,
    67473,
    192551,
    4496,
    56321,
    91819,
    17630,
    6300,
    256183,
    114569,
    202090,
    33209,
    35289,
    34897,
    24967,
    40520,
    43470,
    5344,
    10199,
    34810,
    14283,
    10381,
    10017,
    62923,
    49924,
    23233,
    64539,
    13051,
    35686,
    19698,
    11570,
    135555,
    120868,
    44924,
    87065,
    52318,
    52335,
    47586,
    140906,
    245885,
    109834,
    78668,
    9065,
    46990,
    25258,
    72022,
    61243,
    40838,
    4545,
    146387,
    10537,
    11557,
    17470,
    36930,
    68104,
    46711,
    24264,
    79401,
    81043,
    18225,
    120488,
    24746,
    84338,
    81652,
    28266,
    13776,
    21878,
    46973,
    1047,
    230465,
    73357,
    95777,
    24973,
    210160,
    62210,
    58404,
    110633,
    169651,
    6937,
    41870,
    9909,
    26822,
    191062,
    76553,
    27519,
    96256,
    239070,
    2478,
    205678,
    67955,
    58532,
    20601,
    50120,
    19148,
    78501,
    195724,
    110740,
    8249,
    109665,
    27446,
    30568,
    57631,
    31425,
    49752,
    32820,
    65504,
    50079,
    3663,
    102256,
    219898,
    23849,
    211315,
    14645,
    4359,
    91767,
    9528,
    12449,
    49366,
    7941,
    49763,
    107848,
    8930,
    27086,
    50686,
    9744,
    10447,
    81935,
    39513,
    46514,
    1670,
    29229,
    6172,
    22312,
    137280,
    97759,
    9806,
    14445,
    22976,
    56458,
    73391,
    34983,
    93760,
    174219,
    52573,
    33149,
    59747,
    2429,
    136277,
    75123,
    165263,
    91040,
    7446,
    57632,
    48633,
    97140,
    246081,
    84766,
    151684,
    79918,
    93268,
    120346,
    54059,
    54875,
    77858,
    32996,
    103590,
    45276,
    11968,
    19600,
    25849,
    17159,
    132907,
    42828,
    16817,
    4913,
    99462,
    103303,
    27395,
    5737,
    74184,
    20749,
    21160,
    14377,
    77062,
    131403,
    158735,
    10999,
    27799,
    77785,
    9320,
    34366,
    51593,
    61070,
    33746,
    47048,
    29268,
    36675,
    30262,
    53297,
    9832,
    82e3,
    20188,
    122292,
    39917,
    7331,
    18160,
    68301,
    185935,
    134830,
    15031,
    4935,
    10004,
    165845,
    185534,
    46923,
    30109,
    44134,
    122631,
    18874,
    22903,
    112790,
    26561,
    18549,
    348902,
    82871,
    140345,
    255565,
    135390,
    63556,
    103747,
    145055,
    179600,
    145662,
    296111,
    61661,
    211987,
    23952,
    52342,
    126343,
    48450,
    32919,
    44277,
    82185,
    9591,
    62139,
    205363,
    376969,
    394874,
    108461,
    18040,
    120885,
    14798,
    39863,
    16571,
    16794,
    58271,
    81025,
    55206,
    14640,
    118656,
    6361,
    44092,
    85970,
    6262,
    153863,
    108244,
    180200,
    72264,
    79947,
    38044,
    10050,
    5735,
    61221,
    80712,
    5471,
    115689,
    11391,
    11661,
    184257,
    20010,
    60116,
    30320,
    19327,
    134598,
    45455,
    27542,
    18004,
    125092,
    452272,
    1549,
    91523,
    46567,
    180063,
    156026,
    2608,
    11174,
    58848,
    37788,
    65907,
    80194,
    30490,
    5786,
    40775,
    119519,
    106241,
    11323,
    156297,
    8425,
    61495,
    2617,
    29675,
    2425,
    59886,
    112582,
    49142,
    59618,
    4863,
    50597,
    86710,
    50650,
    168632,
    27693,
    85641,
    83643,
    18993,
    25768,
    84284,
    28090,
    93592,
    36627,
    312804,
    43381,
    9887,
    9402,
    100931,
    97165,
    3311,
    173330,
    66805,
    28935,
    4963,
    184460,
    3201,
    78102,
    19126,
    21607,
    37496,
    24938,
    22615,
    16153,
    32862,
    134792,
    153318,
    61120,
    6067,
    2812,
    12826,
    12792,
    23825,
    37559,
    64662,
    202250,
    102694,
    155488,
    85881,
    149193,
    46233,
    65383,
    15521,
    106982,
    11358,
    176786,
    25752,
    39717,
    34208,
    24510,
    32464,
    77742,
    39371,
    72028,
    138229,
    60688,
    71386,
    102834,
    132477,
    2208,
    11548,
    63670,
    271279,
    28351,
    30338,
    38620,
    32491,
    99845,
    143885,
    152266,
    13252,
    2825,
    178663,
    108097,
    1775,
    78201,
    14897,
    113573,
    163346,
    62292,
    171129,
    22183,
    96598,
    38733,
    64971,
    166776,
    117445,
    9968,
    146393,
    44677,
    74867,
    20908,
    97328,
    12761,
    25656,
    26785,
    9148,
    112344,
    26115,
    99176,
    110121,
    22437,
    49547,
    6180,
    79320,
    5835,
    31392,
    43328,
    33377,
    75870,
    119860,
    69497,
    80273,
    7325,
    155219,
    43167,
    111173,
    28347,
    20222,
    3763,
    71752,
    55041,
    47252,
    14618,
    28088,
    15012,
    97805,
    194698,
    54636,
    2036,
    41349,
    6173,
    96604,
    61530,
    51859,
    43782,
    13361,
    24334,
    22668,
    24792,
    7070,
    23441,
    16789,
    3209,
    36211,
    208475,
    26242,
    32880,
    122181,
    182407,
    21444,
    31060,
    88459,
    29929,
    77907,
    12716,
    10934,
    97005,
    20599,
    31690,
    8403,
    58445,
    30303,
    22700,
    10336,
    86731,
    103115,
    337709,
    72556,
    46788,
    112566,
    47684,
    67089,
    53548,
    36874,
    56487,
    41387,
    125985,
    26893,
    40071,
    106683,
    73712,
    18787,
    40105,
    72992,
    67246,
    137276,
    50802,
    36790,
    70328,
    138827,
    22466,
    39263,
    183295,
    29858,
    50975,
    9322,
    57397,
    10654,
    24364,
    30383,
    55799,
    41600,
    23584,
    127295,
    296610,
    129078,
    143558,
    244131,
    86397,
    36049,
    1085,
    80677,
    3820,
    108139,
    5476,
    34767,
    24683,
    7758,
    13060,
    7239,
    131671,
    250593,
    59556,
    103392,
    29810,
    4188,
    252323,
    39404,
    116877,
    7651,
    43600,
    40338,
    13554,
    157253,
    39196,
    25978,
    144387,
    61211,
    234,
    50104,
    6129,
    10449,
    93777,
    9240,
    356378,
    274148,
    4439,
    72970,
    3724,
    147770,
    78680,
    62570,
    115877,
    40027,
    40547,
    36817,
    224392,
    64609,
    34795,
    165027,
    67440,
    2477,
    37206,
    23431,
    50754,
    164797,
    46018,
    94995,
    170982,
    27051,
    7957,
    22767,
    3674,
    27900,
    56419,
    18930,
    60701,
    41302,
    2692,
    84749,
    339721,
    61996,
    111094,
    80221,
    50129,
    1045,
    8153,
    62945,
    19202,
    8250,
    37208,
    37418,
    32560,
    79477,
    41106,
    88569,
    33963,
    36693,
    5892,
    30570,
    1581,
    66471,
    49647,
    11922,
    160717,
    29442,
    5643,
    114865,
    82962,
    95982,
    132098,
    22633,
    22838,
    94726,
    54556,
    28566,
    205039,
    162340,
    33216,
    16849,
    35847,
    221339,
    94851,
    26533,
    71469,
    1805,
    3804,
    12935,
    45483,
    71020,
    36310,
    65381,
    192960,
    34240,
    35165,
    59773,
    1248,
    46954,
    155332,
    96864,
    4246,
    388800,
    16129,
    57133,
    74592,
    44807,
    442014,
    38203,
    42574,
    80818,
    91592,
    26377,
    36424,
    65760,
    977,
    77387,
    22628,
    147610,
    28018,
    30561,
    98454,
    6969,
    119628,
    63648,
    18170,
    36854,
    26601,
    64018,
    22027,
    37279,
    51395,
    152934,
    21153,
    9430,
    58760,
    194742,
    5330,
    55115,
    34158,
    28917,
    174111,
    13171,
    122326,
    1526,
    43896,
    66094,
    25325,
    4234,
    148354,
    11450,
    275,
    18999,
    112191,
    44365,
    22723,
    68409,
    8733,
    57746,
    96565,
    75007,
    14196,
    108844,
    29475,
    88599,
    177563,
    100792,
    106156,
    86323,
    93726,
    14248,
    135341,
    194131,
    40126,
    47099,
    14779,
    8272,
    39597,
    95983,
    171398,
    65882,
    28052,
    10393,
    47213,
    40689,
    22120,
    72212,
    106829,
    34964,
    109146,
    753,
    648,
    21660,
    30047,
    17527,
    181025,
    5619,
    145357,
    4085,
    216883,
    9359,
    186951,
    24779,
    53931,
    24545,
    36197,
    223296,
    62628,
    168101,
    4243,
    107313,
    30321,
    26642,
    13049,
    51059,
    31027,
    107912,
    807,
    73550,
    26551,
    84369,
    122422,
    165872,
    49754,
    74213,
    234264,
    33151,
    52014,
    33100,
    87183,
    22365,
    52500,
    40013,
    23302,
    5652,
    72723,
    21404,
    26107,
    48434,
    587,
    94049,
    168493,
    96418,
    32871,
    70860,
    31709,
    25128,
    443,
    71597,
    166253,
    15670,
    70994,
    26341,
    133675,
    28280,
    75491,
    54756,
    47955,
    56028,
    26182,
    11952,
    113272,
    472197,
    64640,
    110753,
    17919,
    337,
    50642,
    22576,
    142,
    87371,
    53391,
    93210,
    126694,
    15285,
    19642,
    85667,
    14148,
    1506,
    42092,
    52962,
    33243,
    11970,
    20734,
    135843,
    57044,
    58880,
    13002,
    219134,
    22876,
    64754,
    232519,
    4257,
    43120,
    321573,
    24799,
    64526,
    124728,
    52579,
    81472,
    70831,
    276848,
    17403,
    74359,
    23021,
    182101,
    74597,
    23744,
    148267,
    12055,
    7976,
    5349,
    11772,
    67540,
    167347,
    65318,
    18720,
    127832,
    108238,
    22828,
    90233,
    9987,
    259080,
    118185,
    73209,
    79270,
    13775,
    90100,
    137742,
    90799,
    70569,
    15699,
    19961,
    9087,
    67475,
    57872,
    39731,
    8810,
    134897,
    131868,
    146849,
    19898,
    3334,
    2281,
    167061,
    91073,
    60356,
    467742,
    74712,
    188,
    53179,
    137679,
    92769,
    29241,
    9537,
    132595,
    80119,
    1041,
    88962,
    5976,
    40171,
    44911,
    102859,
    139059,
    104558,
    98987,
    47761,
    19272,
    71472,
    113864,
    175377,
    73338,
    10857,
    23402,
    23758,
    1591,
    139864,
    5644,
    4076,
    118760,
    16427,
    134198,
    18853,
    20291,
    100849,
    37423,
    22038,
    36677,
    19071,
    195521,
    57445,
    11069,
    31869,
    55718,
    66882,
    148490,
    44,
    41296,
    75242,
    49704,
    166810,
    9906,
    20943,
    122258,
    49112,
    105667,
    15969,
    10344,
    6408,
    187694,
    21399,
    72742,
    58970,
    14867,
    14376,
    81889,
    41856,
    23225,
    15042,
    56993,
    16074,
    131389,
    74276,
    72407,
    53875,
    383108,
    53597,
    37363,
    68993,
    44854,
    122548,
    430927,
    198279,
    38430,
    80409,
    12245,
    2981,
    628,
    2818,
    17760,
    37437,
    238229,
    7968,
    46892,
    2200,
    3730,
    34190,
    65983,
    37959,
    112291,
    87850,
    70827,
    6522,
    20750,
    73913,
    111621,
    41652,
    19587,
    2780,
    58668,
    25916,
    85259,
    18200,
    168962,
    95781,
    42445,
    102050,
    7776,
    57662,
    103313,
    47742,
    96358,
    41964,
    66174,
    100396,
    29069,
    204735,
    19679,
    27978,
    7479,
    40264,
    22534,
    61183,
    36081,
    107436,
    58223,
    14680,
    23002,
    101311,
    24716,
    124108,
    12908,
    5646,
    31750,
    40380,
    14215,
    232799,
    102772,
    14122,
    96775,
    61398,
    50917,
    12096,
    149880,
    67833,
    598749,
    124194,
    155871,
    49216,
    790,
    14677,
    65319,
    56917,
    7440,
    145744,
    95701,
    12206,
    49405,
    129269,
    76199,
    45732,
    9767,
    11058,
    9047,
    210885,
    11051,
    7392,
    26307,
    2130,
    8132,
    147526,
    20802,
    232698,
    115660,
    50060,
    59789,
    57344,
    107623,
    80343,
    112676,
    23291,
    9866,
    160971,
    34032,
    118291,
    15719,
    59730,
    164911,
    28975,
    2659,
    58046,
    78480,
    21854,
    66209,
    53863,
    109085,
    116045,
    29021,
    46481,
    107552,
    22130,
    18764,
    70254,
    31272,
    11300,
    52460,
    43933,
    84738,
    20721,
    53869,
    190840,
    79673,
    105300,
    7561,
    321817,
    66924,
    13940,
    33281,
    101046,
    183181,
    32176,
    71878,
    5678,
    62924,
    79535,
    56646,
    40303,
    19559,
    27703,
    93042,
    73368,
    42187,
    3670,
    37376,
    46440,
    7023,
    36816,
    109628,
    20680,
    5940,
    276440,
    275233,
    170848,
    112093,
    136996,
    14984,
    20226,
    111441,
    77693,
    112960,
    48577,
    39370,
    55707,
    50314,
    123404,
    26570,
    54281,
    61372,
    123391,
    4857,
    35928,
    246740,
    132507,
    106646,
    44241,
    7196,
    92258,
    9825,
    37688,
    51197,
    303141,
    5590,
    15476,
    132986,
    10955,
    85782,
    34486,
    26696,
    7991,
    28813,
    18858,
    39546,
    11703,
    11365,
    38185,
    5716,
    93555,
    11925,
    40121,
    60002,
    6985,
    10976,
    171384,
    3887,
    43394,
    13337,
    56346,
    6381,
    252336,
    39573,
    75042,
    53711,
    1028,
    31781,
    44295,
    95925,
    131713,
    7214,
    68125,
    43571,
    70954,
    213234,
    1628,
    8760,
    13391,
    65485,
    17320,
    56038,
    1710,
    25248,
    60803,
    57399,
    19839,
    3870,
    326,
    281556,
    50945,
    72400,
    21460,
    316244,
    75619,
    56246,
    98775,
    481,
    13513,
    55765,
    50427,
    7388,
    123519,
    32929,
    57908,
    27124,
    61316,
    101097,
    57467,
    30228,
    48792,
    10788,
    20402,
    37318,
    50526,
    155730,
    34456,
    158065,
    145305,
    17832,
    43733,
    64052,
    4506,
    35072,
    205355,
    177028,
    184004,
    187081,
    68616,
    35938,
    83703,
    10367,
    36892,
    93186,
    260137,
    51934,
    89970,
    4985,
    23445,
    26755,
    21558,
    7948,
    78741,
    23376,
    124405,
    85594,
    68596,
    57536,
    49351,
    12619,
    56593,
    132668,
    99924,
    109728,
    71844,
    71935,
    196018,
    65464,
    17617,
    14987,
    89701,
    143773,
    33997,
    8687,
    22701,
    33258,
    2914,
    4436,
    72108,
    85610,
    9671,
    49067,
    2327,
    82988,
    1361,
    1672,
    44033,
    35777,
    30269,
    24057,
    10605,
    82236,
    616,
    15793,
    13919,
    47249,
    112086,
    116698,
    9484,
    80207,
    90574,
    33304,
    68624,
    93127,
    56101,
    42210,
    160929,
    4827,
    38995,
    38095,
    4701,
    125119,
    5027,
    33680,
    9236,
    231236,
    14135,
    87837,
    23318,
    70261,
    78893,
    30151,
    81482,
    14332,
    1084,
    74256,
    27532,
    46644,
    79185,
    3148,
    62615,
    6981,
    55672,
    31668,
    36825,
    1849,
    14536,
    37446,
    14738,
    23779,
    43058,
    162749,
    72199,
    1168,
    21346,
    5592,
    85932,
    85302,
    9668,
    18351,
    57135,
    150360,
    2080,
    228015,
    77953,
    34670,
    119302,
    151751,
    31009,
    106725,
    84265,
    45214,
    59289,
    74178,
    113071,
    263206,
    111009,
    4021,
    44449,
    188119,
    192629,
    123592,
    392506,
    292847,
    114487,
    12831,
    205858,
    9852,
    20780,
    79648,
    75767,
    357014,
    97721,
    18166,
    21005,
    67950,
    33226,
    204009,
    16536,
    2987,
    11335,
    66717,
    144910,
    47950,
    17262,
    55060,
    15063,
    2934,
    51038,
    26775,
    178497,
    66008,
    3427,
    49433,
    128592,
    20036,
    157553,
    63861,
    3089,
    23015,
    51210,
    28696,
    35933,
    49942,
    71135,
    231518,
    99620,
    17248,
    21835,
    176536,
    20676,
    16944,
    38700,
    165831,
    233253,
    295625,
    36723,
    13023,
    52745,
    10907,
    19423,
    67972,
    125868,
    95473,
    82875,
    1183,
    108455,
    52685,
    33417,
    64095,
    21433,
    52438,
    33191,
    127809,
    44505,
    211823,
    7810,
    2752,
    95548,
    162031,
    7185,
    91196,
    47563,
    61721,
    33359,
    17897,
    23682,
    42806,
    178101,
    22874,
    49707,
    199897,
    75419,
    82456,
    8618,
    11171,
    79712,
    116847,
    18783,
    44190,
    46564,
    5346,
    59046,
    95032,
    7893,
    14916,
    3214,
    26800,
    24172,
    121453,
    34362,
    10250,
    17408,
    18888,
    4840,
    68696,
    22831,
    13162,
    36005,
    32512,
    14800,
    62357,
    41723,
    45046,
    27247,
    37486,
    5372,
    2564,
    34261,
    298500,
    66509,
    133920,
    89138,
    31305,
    117697,
    19097,
    108304,
    81386,
    84106,
    23802,
    46411,
    63304,
    946,
    51417,
    41777,
    41041,
    19501,
    115864,
    60743,
    294354,
    37955,
    94165,
    18116,
    1156,
    17937,
    20645,
    57114,
    90804,
    58042,
    48643,
    92288,
    9861,
    2557,
    88546,
    61333,
    101008,
    12853,
    5148,
    87856,
    4152,
    144503,
    73841,
    18718,
    9789,
    147565,
    10846,
    42085,
    12789,
    30223,
    8993,
    56352,
    67203,
    2448,
    28215,
    6052,
    23540,
    126319,
    75933,
    36689,
    80235,
    23231,
    23561,
    21383,
    38800,
    77548,
    102798,
    21234,
    31468,
    158608,
    46188,
    63960,
    191679,
    8051,
    67014,
    11185,
    170078,
    42186,
    28827,
    34777,
    41930,
    212079,
    12421,
    34750,
    24111,
    110344,
    73918,
    45171,
    70826,
    141949,
    40063,
    23979,
    24254,
    37309,
    26724,
    27179,
    24718,
    83648,
    54938,
    14591,
    17425,
    29525,
    102675,
    48975,
    48654,
    12316,
    8929,
    60640,
    41709,
    50168,
    63264,
    89812,
    50716,
    48632,
    38755,
    138583,
    160123,
    55579,
    71829,
    24230,
    233277,
    46322,
    39650,
    166388,
    34718,
    24108,
    98252,
    7031,
    106695,
    62498,
    18258,
    35062,
    217827,
    78731,
    34824,
    33354,
    19520,
    60852,
    2432,
    60224,
    8587,
    2836,
    62955,
    702,
    20227,
    42285,
    40560,
    95592,
    62486,
    11094,
    53035,
    143291,
    18842,
    46177,
    77994,
    1770,
    9657,
    107422,
    172915,
    32655,
    128716,
    25886,
    25164,
    156740,
    119928,
    165875,
    85817,
    11007,
    89110,
    33956,
    12652,
    65156,
    180266,
    8494,
    36889,
    19958,
    20955,
    96,
    1264,
    118288,
    135769,
    44754,
    86671,
    5632,
    19026,
    168220,
    289120,
    33569,
    93821,
    66144,
    70635,
    7687,
    5642,
    2714,
    55445,
    56636,
    71545,
    184182,
    93133,
    7332,
    37389,
    12643,
    52315,
    22729,
    11014,
    158742,
    17050,
    152889,
    50178,
    34601,
    41945,
    52136,
    9948,
    26914,
    63548,
    95721,
    115951,
    40759,
    8960,
    158258,
    38938,
    49232,
    48325,
    42234,
    81523,
    253019,
    66128,
    40978,
    20048,
    238048,
    38760,
    62928,
    122560,
    118532,
    43687,
    137472,
    163689,
    26680,
    9878,
    17448,
    51035,
    16211,
    60834,
    36749,
    29178,
    14241,
    59868,
    150086,
    2305,
    26477,
    42422,
    34342,
    165341,
    83279,
    33894,
    14257,
    29928,
    12743,
    13957,
    125571,
    89134,
    66712,
    10952,
    16507,
    147839,
    30146,
    7249,
    16565,
    45399,
    39874,
    114565,
    215780,
    31990,
    230881,
    171477,
    102,
    196546,
    44538,
    10880,
    84948,
    281705,
    86651,
    10617,
    31395,
    2342,
    453658,
    43569,
    60561,
    132901,
    21845,
    17727,
    58556,
    258242,
    22262,
    58728,
    4008,
    77997,
    11806,
    37431,
    30599,
    81375,
    109137,
    185787,
    114085,
    217292,
    97453,
    169085,
    30593,
    60212,
    11544,
    102056,
    65580,
    2384,
    91655,
    4855,
    95725,
    7295,
    157994,
    16228,
    20669,
    53276,
    141590,
    105246,
    17334,
    25440,
    76067,
    17967,
    39321,
    38911,
    11362,
    28559,
    63807,
    21627,
    26468,
    85816,
    40120,
    1025,
    15234,
    58319,
    69516,
    66512,
    124548,
    75845,
    78873,
    22137,
    46681,
    51242,
    85683,
    32909,
    76747,
    35555,
    43396,
    101465,
    1765,
    73094,
    1077,
    2962,
    39028,
    66777,
    57831,
    42048,
    15828,
    13962,
    36041,
    63657,
    52412,
    5242,
    58846,
    2141,
    5506,
    219012,
    134451,
    3936,
    182230,
    17558,
    17153,
    152237,
    22621,
    49377,
    170216,
    35257,
    68233,
    65374,
    6510,
    11126,
    212151,
    7184,
    2480,
    22517,
    3437,
    33073,
    30156,
    16557,
    3768,
    55067,
    86829,
    91e3,
    12350,
    148650,
    66017,
    79424,
    70885,
    49066,
    28250,
    21369,
    51213,
    34533,
    11510,
    3258,
    18176,
    18465,
    84413,
    6315,
    36411,
    163765,
    4346,
    356,
    107618,
    598,
    13727,
    285026,
    162695,
    8749,
    14583,
    7132,
    63521,
    184253,
    32378,
    25991,
    5604,
    30961,
    53675,
    4874,
    84693,
    5086,
    34811,
    26978,
    56564,
    7904,
    33519,
    51221,
    113942,
    69253,
    6664,
    125563,
    22055,
    220680,
    102008,
    742,
    51930,
    19494,
    176108,
    44424,
    35123,
    13025,
    75685,
    11759,
    74335,
    22250,
    181453,
    131147,
    16984,
    132115,
    154311,
    11991,
    76452,
    52609,
    85351,
    196,
    30969,
    9198,
    74919,
    2529,
    56838,
    71779,
    29187,
    116304,
    3504,
    62330,
    41190,
    86153,
    28393,
    254926,
    104228,
    105189,
    13264,
    84359,
    3574,
    12415,
    8534,
    57147,
    10175,
    188174,
    59504,
    60932,
    66318,
    16407,
    107921,
    17638,
    99103,
    49278,
    28403,
    39786,
    145865,
    8462,
    3558,
    43406,
    142271,
    29139,
    21989,
    36552,
    93955,
    72365,
    7176,
    13556,
    106185,
    37957,
    321774,
    17782,
    129017,
    51154,
    27938,
    24952,
    1935,
    39366,
    2791,
    33489,
    41582,
    56078,
    24558,
    9311,
    5449,
    218786,
    27808,
    190429,
    68013,
    36020,
    86003,
    29735,
    3404,
    87348,
    119357,
    115714,
    2324,
    86796,
    81973,
    40992,
    43376,
    93621,
    28784,
    16808,
    36367,
    2517,
    2909,
    191926,
    24978,
    55303,
    53308,
    205724,
    60068,
    3098,
    21375,
    64784,
    23949,
    26579,
    63121,
    12319,
    80145,
    39967,
    97861,
    6757,
    70143,
    67642,
    37082,
    34698,
    69140,
    122883,
    46151,
    62187,
    80934,
    429,
    19437,
    135071,
    137885,
    222647,
    13331,
    154065,
    327,
    61778,
    74257,
    40116,
    37493,
    14855,
    85079,
    237641,
    42342,
    102164,
    199965,
    71204,
    4662,
    29368,
    5042,
    113914,
    122214,
    8955,
    13149,
    102503,
    43173,
    5659,
    163787,
    69003,
    307084,
    63392,
    171080,
    21390,
    81918,
    86666,
    36622,
    24126,
    28887,
    5736,
    28054,
    207170,
    163428,
    79891,
    346467,
    95363,
    38980,
    111806,
    80828,
    9200,
    19288,
    294896,
    114468,
    87405,
    111715,
    141705,
    7015,
    72754,
    68463,
    48738,
    243147,
    33397,
    101210,
    37051,
    98801,
    82847,
    20397,
    4940,
    185559,
    18716,
    54718,
    83491,
    11725,
    40803,
    1128,
    12128,
    23060,
    5174,
    7745,
    67007,
    46701,
    1571,
    27807,
    180186,
    256996,
    18975,
    16837,
    7877,
    212758,
    250379,
    15440,
    87954,
    57755,
    24719,
    124057,
    83461,
    258,
    50864,
    8874,
    29038,
    71289,
    31627,
    15429,
    9005,
    4061,
    113851,
    107716,
    82819,
    13651,
    79656,
    117851,
    17539,
    111446,
    12938,
    39724,
    190787,
    4352,
    15402,
    21070,
    62708,
    8539,
    23777,
    73853,
    13552,
    38810,
    86117,
    16285,
    56400,
    1718,
    75342,
    142863,
    29033,
    378,
    110113,
    180321,
    32586,
    23606,
    26393,
    160984,
    207987,
    23783,
    8406,
    16904,
    24596,
    47274,
    11693,
    46539,
    60524,
    78595,
    48423,
    31718,
    20170,
    9009,
    146268,
    15183,
    191060,
    172765,
    1349,
    138436,
    37365,
    10970,
    40509,
    225817,
    20021,
    70394,
    152138,
    21541,
    66559,
    66544,
    89352,
    2725,
    17258,
    91345,
    7313,
    3815,
    115868,
    8660,
    40362,
    4071,
    103524,
    39388,
    118275,
    21950,
    6549,
    38226,
    32754,
    209574,
    29201,
    43495,
    18028,
    20296,
    40597,
    18370,
    47520,
    202450,
    24134,
    2219,
    8195,
    69545,
    38041,
    136934,
    46374,
    19041,
    159811,
    84865,
    58620,
    846,
    98749,
    13569,
    30714,
    97246,
    32186,
    4479,
    27355,
    92973,
    35214,
    151491,
    75963,
    37631,
    1561,
    27200,
    238083,
    23182,
    60756,
    12291,
    25766,
    39355,
    102333,
    87362,
    65741,
    59906,
    19538,
    201575,
    48772,
    102938,
    24438,
    292580,
    39964,
    66366,
    9004,
    61379,
    50548,
    37622,
    38732,
    28379,
    68180,
    76622,
    17488,
    69849,
    5963,
    7219,
    48143,
    43413,
    55358,
    540,
    58691,
    29506,
    19245,
    52193,
    48621,
    5518,
    13048,
    118625,
    44755,
    191081,
    42061,
    89197,
    2259,
    60665,
    66994,
    71210,
    51232,
    3585,
    142096,
    55024,
    7892,
    8345,
    58653,
    463307,
    65658,
    64319,
    137941,
    136323,
    53499,
    12746,
    43492,
    6978,
    95163,
    29925,
    60175,
    5128,
    7352,
    41463,
    184756,
    121146,
    20473,
    18426,
    4598,
    5309,
    54580,
    14277,
    121151,
    10691,
    56711,
    43880,
    63409,
    76682,
    11830,
    172218,
    264898,
    32632,
    66536,
    81062,
    31649,
    25788,
    92774,
    60222,
    11100,
    63159,
    9432,
    224657,
    25240,
    53613,
    152,
    138620,
    163829,
    2397,
    85345,
    12501,
    37507,
    64932,
    38575,
    43522,
    65789,
    80198,
    78796,
    35226,
    3851,
    108891,
    73311,
    3060,
    28391,
    93671,
    39663,
    46142,
    30982,
    66041,
    37281,
    68157,
    26553,
    71872,
    81142,
    211527,
    39747,
    118119,
    22695,
    2859,
    11066,
    20232,
    168911,
    7933,
    197005,
    17066,
    111071,
    44434,
    133994,
    120798,
    12766,
    227798,
    45756,
    132852,
    29917,
    36076,
    55352,
    65281,
    129800,
    41958,
    18944,
    84678,
    18580,
    168093,
    132621,
    39997,
    54092,
    27740,
    32354,
    3770,
    114118,
    103242,
    43918,
    15899,
    18574,
    145944,
    3190,
    123469,
    219903,
    24169,
    100571,
    62403,
    16776,
    92779,
    14535,
    17168,
    16475,
    14304,
    37231,
    1712,
    28218,
    242754,
    61688,
    28980,
    1318,
    51359,
    222657,
    99200,
    67989,
    31772,
    23932,
    35351,
    201251,
    49041,
    27306,
    19128,
    40135,
    3986,
    77333,
    19649,
    120683,
    151927,
    21081,
    7076,
    78375,
    77501,
    101599,
    8011,
    89585,
    96715,
    58179,
    5378,
    102138,
    106793,
    26051,
    217276,
    4197,
    16297,
    27014,
    46721,
    13322,
    22806,
    5278,
    29629,
    70632,
    9647,
    71519,
    58818,
    40603,
    128530,
    8903,
    36770,
    56900,
    31483,
    26935,
    43845,
    34265,
    34920,
    87658,
    6114,
    84767,
    64250,
    47318,
    50720,
    19264,
    162514,
    33357,
    13117,
    6705,
    46696,
    75032,
    71054,
    87004,
    42035,
    69138,
    11903,
    99854,
    102328,
    19611,
    34525,
    69312,
    6431,
    49842,
    101600,
    133178,
    108751,
    41829,
    89939,
    225664,
    48916,
    99556,
    9195,
    130387,
    5960,
    36857,
    116724,
    53518,
    94002,
    39077,
    53996,
    6945,
    22261,
    64291,
    8314,
    152785,
    57588,
    16522,
    9091,
    5048,
    87671,
    35441,
    39509,
    1945,
    12423,
    158923,
    178413,
    37549,
    14095,
    1475,
    73188,
    62878,
    4819,
    24012,
    68534,
    42606,
    4010,
    120809,
    57497,
    59564,
    101758,
    103718,
    32701,
    80116,
    12345,
    95834,
    46918,
    21468,
    53213,
    15665,
    31200,
    3867,
    5140,
    96013,
    250744,
    21016,
    10069,
    13968,
    35449,
    180829,
    27683,
    39704,
    59956,
    22893,
    3115,
    26293,
    32785,
    75934,
    62445,
    141162,
    62720,
    2018,
    83638,
    19949,
    114012,
    95006,
    3330,
    99829,
    130935,
    309272,
    9565,
    55874,
    121727,
    37017,
    23586,
    319858,
    40970,
    27602,
    8625,
    112329,
    61060,
    100088,
    118525,
    25922,
    16232,
    1907,
    60671,
    51583,
    44553,
    80993,
    5262,
    94679,
    8676,
    940,
    20736,
    11823,
    3020,
    16476,
    12340,
    152600,
    97416,
    3703,
    25744,
    66826,
    16245,
    16876,
    46446,
    84798,
    74227,
    176020,
    45192,
    61955,
    75496,
    23946,
    23626,
    40372,
    26036,
    6149,
    11822,
    30582,
    16541,
    41914,
    82385,
    232823,
    40921,
    80773,
    14930,
    3631,
    7517,
    39619,
    4348,
    36180,
    126106,
    138939,
    62611,
    1477,
    113512,
    47321,
    25052,
    14546,
    118881,
    29060,
    23589,
    128322,
    36795,
    18401,
    137921,
    104699,
    267929,
    36194,
    172791,
    18113,
    4766,
    188215,
    30083,
    332586,
    94089,
    5805,
    77909,
    22194,
    68234,
    154976,
    43220,
    40660,
    70001,
    184893,
    138095,
    11128,
    103010,
    22663,
    5108,
    212615,
    8485,
    5565,
    49222,
    54614,
    26530,
    42639,
    16319,
    55062,
    152662,
    105595,
    21114,
    22216,
    10294,
    68158,
    10436,
    86950,
    7206,
    62115,
    3977,
    3657,
    59874,
    456,
    118617,
    18156,
    106663,
    112229,
    80992,
    17442,
    8217,
    55551,
    5133,
    34344,
    251927,
    51153,
    39364,
    201321,
    7816,
    66803,
    23057,
    156724,
    145664,
    14276,
    95705,
    979,
    2796,
    6875,
    13429,
    212525,
    50602,
    26276,
    28284,
    3424,
    19465,
    52397,
    46963,
    31420,
    51399,
    206476,
    92317,
    48851,
    637,
    100820,
    83349,
    10317,
    60227,
    21972,
    6908,
    282439,
    32857,
    224767,
    95629,
    83882,
    42106,
    87338,
    69757,
    29840,
    68709,
    37665,
    45244,
    114577,
    49188,
    175943,
    54009,
    186746,
    106158,
    70168,
    3358,
    234002,
    50555,
    9221,
    129338,
    9562,
    20118,
    32923,
    78479,
    118280,
    65752,
    4977,
    10474,
    102174,
    60947,
    129006,
    10570,
    83451,
    8598,
    8078,
    159367,
    123785,
    80438,
    16742,
    5905,
    5281,
    181513,
    42402,
    6977,
    163136,
    93179,
    42191,
    14968,
    50421,
    112401,
    105440,
    33456,
    57347,
    121611,
    4221,
    94954,
    36517,
    24046,
    27796,
    6255,
    33394,
    72990,
    135408,
    116627,
    1233,
    57874,
    25654,
    95419,
    68156,
    401399,
    313338,
    55208,
    45573,
    93124,
    119251,
    47200,
    38196,
    11909,
    130667,
    45391,
    73904,
    64964,
    167846,
    4137,
    115606,
    52036,
    62214,
    7969,
    160925,
    7187,
    1132,
    134835,
    40309,
    73195,
    64494,
    80472,
    444841,
    61111,
    26500,
    45323,
    40743,
    53625,
    52797,
    22659,
    15631,
    29739,
    36706,
    28841,
    39147,
    102836,
    26794,
    10536,
    14845,
    87305,
    45874,
    12241,
    127587,
    83833,
    57183,
    79722,
    30844,
    41304,
    84655,
    20825,
    92500,
    3722,
    25655,
    27811,
    10157,
    81634,
    31362,
    34088,
    92487,
    70123,
    22190,
    185100,
    72658,
    139035,
    192523,
    88241,
    2078,
    230490,
    44528,
    85638,
    100198,
    22088,
    29982,
    291233,
    241062,
    13865,
    4445,
    137791,
    37835,
    107218,
    31726,
    19718,
    38234,
    72528,
    23046,
    19177,
    66695,
    5109,
    17251,
    28077,
    5617,
    21554,
    47839,
    72425,
    133825,
    1486,
    73065,
    181275,
    141508,
    21768,
    62971,
    63082,
    2512,
    34200,
    9904,
    120309,
    6392,
    91243,
    68416,
    268253,
    41199,
    116757,
    138551,
    185526,
    41246,
    28986,
    4093,
    19057,
    17295,
    4148,
    245766,
    122360,
    35356,
    112075,
    20301,
    75441,
    10998,
    7977,
    19769,
    62922,
    937,
    63547,
    100196,
    26427,
    157820,
    20983,
    236696,
    22935,
    8140,
    90315,
    156004,
    47204,
    140973,
    7726,
    45097,
    52725,
    22636,
    23436,
    257282,
    105247,
    522,
    88389,
    216031,
    202204,
    46812,
    211666,
    19693,
    68828,
    81691,
    45925,
    11256,
    30292,
    372,
    5236,
    167826,
    88328,
    232776,
    151611,
    5360,
    82104,
    18841,
    80393,
    25465,
    18285,
    20320,
    72377,
    31730,
    33160,
    45803,
    38715,
    27705,
    37379,
    24163,
    18360,
    103586,
    4015,
    32305,
    269494,
    91252,
    20080,
    36567,
    54650,
    7797,
    57073,
    12650,
    31164,
    42209,
    6375,
    261663,
    105528,
    81661,
    106002,
    2800,
    5375,
    17247,
    43151,
    4442,
    15727,
    194619,
    100855,
    144898,
    62320,
    78465,
    39929,
    16454,
    1967,
    28311,
    61363,
    17219,
    9395,
    8745,
    121445,
    76939,
    80385,
    162380,
    22009,
    54191,
    44248,
    16299,
    122830,
    48151,
    74429,
    78291,
    64755,
    14238,
    44966,
    2511,
    17712,
    67954,
    93583,
    829,
    105899,
    49935,
    84750,
    11591,
    33185,
    85447,
    42717,
    27409,
    208542,
    28965,
    62052,
    52525,
    5597,
    25694,
    65594,
    16343,
    63224,
    276188,
    12475,
    9331,
    127507,
    38522,
    57287,
    24128,
    133161,
    79723,
    105548,
    133695,
    48917,
    27558,
    43278,
    46520,
    13778,
    141954,
    110785,
    83366,
    17715,
    46317,
    105763,
    66298,
    147013,
    41086,
    94180,
    16478,
    220447,
    44611,
    730,
    19722,
    78975,
    117889,
    125643,
    26254,
    16574,
    18480,
    65006,
    15806,
    38549,
    246418,
    46052,
    36056,
    8440,
    34984,
    30170,
    3163,
    59800,
    4458,
    115442,
    4283,
    41970,
    33507,
    104078,
    1653,
    22,
    121158,
    276486,
    3655,
    6338,
    24048,
    133421,
    23641,
    2161,
    24422,
    36006,
    8086,
    10675,
    181474,
    12307,
    29514,
    59143,
    14729,
    52509,
    87128,
    122470,
    19446,
    80852,
    33314,
    24573,
    119864,
    14237,
    9652,
    57779,
    6612,
    51851,
    15284,
    98871,
    90581,
    124466,
    156831,
    21190,
    22015,
    71380,
    161906,
    87247,
    69201,
    18392,
    17908,
    108470,
    72962,
    40719,
    14338,
    17911,
    95260,
    43339,
    20610,
    78916,
    20710,
    72451,
    11315,
    31448,
    17263,
    58853,
    178878,
    48111,
    116002,
    45497,
    80506,
    82605,
    85880,
    36300,
    121755,
    25215,
    36118,
    301929,
    88728,
    405223,
    276136,
    553,
    34704,
    212438,
    49970,
    78329,
    922,
    20711,
    25036,
    257130,
    38295,
    145369,
    18128,
    15385,
    30829,
    55656,
    48345,
    8012,
    3561,
    28004,
    122041,
    192900,
    58338,
    112508,
    41085,
    29976,
    87040,
    47117,
    23905,
    4336,
    92061,
    138880,
    97407,
    42083,
    172121,
    6256,
    25192,
    172671,
    5,
    93568,
    1420,
    12677,
    31605,
    56743,
    40620,
    6015,
    78415,
    231077,
    31298,
    80026,
    13902,
    19048,
    24924,
    170586,
    32955,
    176119,
    87859,
    36731,
    6773,
    27711,
    24658,
    26475,
    115216,
    133207,
    93250,
    95820,
    88522,
    8317,
    5714,
    124047,
    55219,
    86860,
    19677,
    23961,
    22928,
    162209,
    8904,
    225992,
    359835,
    56084,
    96201,
    29392,
    96558,
    86071,
    93643,
    55114,
    13347,
    8183,
    95129,
    82012,
    2017,
    123336,
    34219,
    115554,
    157159,
    47747,
    101684,
    41008,
    18735,
    193781,
    104151,
    226906,
    7552,
    179874,
    124113,
    31159,
    21162,
    44010,
    14771,
    51268,
    166128,
    31382,
    73124,
    77438,
    92830,
    205709,
    12113,
    1292,
    38937,
    13114,
    1334,
    2118,
    15597,
    69581,
    14449,
    21934,
    76618,
    48728,
    67038,
    14967,
    51495,
    24243,
    87736,
    147249,
    26720,
    11119,
    46063,
    43749,
    5843,
    44147,
    152629,
    133428,
    65703,
    14269,
    45604,
    57982,
    28672,
    55616,
    45957,
    8438,
    95433,
    37698,
    220862,
    132034,
    39456,
    61870,
    4161,
    26501,
    73560,
    56418,
    9845,
    4654,
    20916,
    10456,
    88920,
    119358,
    9015,
    65931,
    96507,
    48029,
    38534,
    21676,
    109081,
    43078,
    34943,
    25089,
    6131,
    28766,
    23665,
    5477,
    10255,
    16695,
    67,
    45778,
    42443,
    42770,
    29534,
    23733,
    100513,
    62617,
    42630,
    48746,
    14191,
    43753,
    50295,
    26007,
    8792,
    57243,
    43119,
    54725,
    164253,
    58250,
    112304,
    131796,
    25165,
    4651,
    3188,
    24831,
    47748,
    3705,
    19540,
    13211,
    102095,
    5593,
    18699,
    23666,
    32005,
    117571,
    33541,
    60584,
    74573,
    86311,
    99443,
    25172,
    27222,
    168938,
    7143,
    11853,
    53560,
    18834,
    19960,
    86522,
    28217,
    53266,
    117700,
    72989,
    34323,
    18721,
    66450,
    34346,
    74056,
    47217,
    202002,
    46269,
    9429,
    68582,
    75458,
    37823,
    82843,
    96652,
    32549,
    145144,
    27958,
    19820,
    158086,
    31955,
    201406,
    135379,
    31207,
    192545,
    12950,
    51704,
    9094,
    248263,
    76147,
    64028,
    110009,
    79407,
    89345,
    99284,
    223492,
    47966,
    26848,
    15359,
    201137,
    2861,
    110507,
    71231,
    72297,
    31851,
    118777,
    71039,
    151051,
    240855,
    16333,
    50766,
    14727,
    7939,
    4149,
    80908,
    418780,
    88378,
    59276,
    1327,
    7284,
    38576,
    79814,
    65820,
    42199,
    84860,
    49574,
    62596,
    12396,
    70598,
    40117,
    8648,
    7994,
    16836,
    7630,
    14047,
    359699,
    106878,
    525,
    29037,
    28064,
    13380,
    11675,
    50669,
    74216,
    103539,
    180314,
    27449,
    56299,
    172344,
    19274,
    7301,
    246099,
    32043,
    19422,
    36506,
    129317,
    6806,
    30140,
    4614,
    46639,
    66926,
    932,
    86600,
    6322,
    27847,
    233103,
    10541,
    39025,
    34887,
    3517,
    12972,
    26220,
    2031,
    66561,
    115015,
    48658,
    47596,
    12714,
    33845,
    3893,
    16165,
    35237,
    89983,
    14769,
    11962,
    147224,
    47018,
    29977,
    27979,
    5552,
    82338,
    86023,
    131368,
    1218,
    24853,
    237840,
    132193,
    15455,
    40873,
    3668,
    65351,
    53388,
    15229,
    59889,
    272245,
    47934,
    11858,
    34347,
    18038,
    90853,
    86981,
    300602,
    19343,
    114181,
    29362,
    84921,
    6095,
    106059,
    79472,
    38015,
    1206,
    48741,
    6208,
    8e4,
    21916,
    17423,
    6002,
    108083,
    24479,
    34931,
    56661,
    9511,
    26995,
    100694,
    163853,
    35997,
    81254,
    58321,
    18919,
    171890,
    86877,
    91341,
    74503,
    70477,
    53412,
    7027,
    59281,
    39892,
    131302,
    5864,
    15947,
    61301,
    67466,
    162369,
    47956,
    27874,
    35624,
    282324,
    21270,
    111847,
    102548,
    41482,
    30955,
    116737,
    28264,
    8592,
    55458,
    22301,
    75090,
    29821,
    30697,
    51709,
    3041,
    19208,
    8038,
    24634,
    30467,
    87509,
    126428,
    19389,
    18814,
    152686,
    20701,
    83474,
    45832,
    80891,
    105808,
    11378,
    153223,
    120770,
    98186,
    150633,
    49838,
    9141,
    12755,
    30962,
    5260,
    74490,
    21256,
    31678,
    65062,
    33326,
    289838,
    187831,
    20595,
    89768,
    2805,
    58535,
    10844,
    70085,
    12090,
    2451,
    138068,
    98544,
    24461,
    4511,
    6754,
    41684,
    28203,
    3383,
    65355,
    82833,
    30161,
    83924,
    234361,
    128424,
    28921,
    222594,
    33975,
    125491,
    34069,
    11508,
    67464,
    144226,
    41850,
    98703,
    34371,
    7901,
    21254,
    38398,
    65651,
    23549,
    53883,
    213340,
    123269,
    12028,
    71764,
    177701,
    28758,
    2623,
    68395,
    11549,
    15232,
    68603,
    9660,
    63116,
    36079,
    57093,
    31198,
    20475,
    48467,
    89984,
    35619,
    186847,
    107469,
    31389,
    43631,
    73867,
    41949,
    68841,
    114250,
    1605,
    30564,
    63403,
    17588,
    27680,
    99533,
    12641,
    70325,
    50428,
    73426,
    78379,
    11855,
    91651,
    72081,
    91720,
    60198,
    15743,
    12065,
    83398,
    140046,
    6761,
    46598,
    45900,
    5068,
    886,
    62448,
    148968,
    37347,
    19405,
    9680,
    15819,
    43496,
    63370,
    75667,
    163700,
    37639,
    3633,
    22774,
    34341,
    183131,
    134335,
    37200,
    23915,
    7054,
    14194,
    12970,
    26438,
    13350,
    285521,
    25594,
    8219,
    104410,
    91039,
    168804,
    138480,
    149734,
    15907,
    33818,
    61132,
    60082,
    4622,
    110187,
    56736,
    13551,
    73571,
    3945,
    73463,
    65498,
    17758,
    263266,
    17593,
    2710,
    27585,
    54469,
    38200,
    45367,
    63754,
    28881,
    3473,
    12791,
    98287,
    31895,
    65787,
    4463,
    94536,
    24951,
    36332,
    59901,
    28803,
    52130,
    86403,
    7668,
    181822,
    74831,
    18977,
    9850,
    177206,
    145485,
    109798,
    7292,
    31421,
    26280,
    77211,
    58511,
    12507,
    127004,
    11113,
    147,
    8729,
    56208,
    43066,
    79926,
    129937,
    31345,
    83947,
    39915,
    46146,
    98763,
    42566,
    1337,
    13192,
    18323,
    105163,
    80570,
    117753,
    16555,
    72883,
    11077,
    159438,
    40764,
    70933,
    83329,
    26066,
    12276,
    72059,
    21655,
    173836,
    126713,
    69454,
    153482,
    91585,
    70644,
    102558,
    110483,
    6764,
    127864,
    190133,
    3961,
    101798,
    20945,
    71138,
    82402,
    90884,
    69669,
    44753,
    923,
    16939,
    59700,
    164258,
    25969,
    27082,
    31399,
    43846,
    6306,
    246093,
    51342,
    6153,
    151581,
    202801,
    182731,
    56475,
    162188,
    89426,
    141356,
    14355,
    121815,
    27536,
    28023,
    65257,
    77523,
    106668,
    127314,
    24947,
    12790,
    38796,
    169698,
    23555,
    10725,
    44573,
    183083,
    42088,
    62716,
    43265,
    105958,
    32050,
    44067,
    50118,
    1668,
    3874,
    6243,
    318411,
    16599,
    1691,
    94999,
    52378,
    28671,
    216728,
    123258,
    2059,
    34969,
    69225,
    5913,
    136280,
    171443,
    141515,
    91662,
    22175,
    135282,
    80020,
    92270,
    1663,
    4808,
    4482,
    3495,
    34691,
    5226,
    109830,
    108512,
    17342,
    107488,
    11606,
    123190,
    100247,
    29666,
    146527,
    113014,
    15794,
    30894,
    13224,
    39585,
    243192,
    22351,
    9903,
    7836,
    47699,
    11078,
    25468,
    122291,
    48821,
    26780,
    122679,
    75521,
    81450,
    630,
    4895,
    92900,
    55074,
    74293,
    17441,
    3563,
    111657,
    103102,
    51613,
    12318,
    52370,
    36191,
    68245,
    34269,
    40445,
    41354,
    122901,
    168604,
    182500,
    62012,
    42557,
    11259,
    24428,
    115113,
    86345,
    12362,
    3909,
    78430,
    86852,
    134602,
    20459,
    47853,
    93879,
    22577,
    7659,
    3688,
    38555,
    13349,
    17381,
    56715,
    91639,
    12493,
    10895,
    92438,
    3142,
    37057,
    28928,
    2004,
    36427,
    32268,
    34222,
    209974,
    10432,
    67436,
    41989,
    173518,
    107930,
    27079,
    62729,
    30908,
    55558,
    5828,
    45031,
    14902,
    53546,
    8204,
    144263,
    60255,
    14520,
    88212,
    86582,
    109589,
    69356,
    8064,
    47449,
    8505,
    66558,
    16886,
    4844,
    52817,
    111260,
    215129,
    12941,
    91118,
    650,
    20770,
    6273,
    73089,
    40618,
    62790,
    2873,
    35002,
    14023,
    97208,
    19386,
    102646,
    36993,
    143736,
    135457,
    35385,
    113601,
    17893,
    32627,
    84439,
    100619,
    56016,
    6581,
    57264,
    172160,
    45452,
    111710,
    203627,
    70131,
    24100,
    322787,
    1996,
    35665,
    70078,
    22358,
    90922,
    83658,
    4097,
    63200,
    58499,
    14542,
    99153,
    52159,
    6615,
    12414,
    63415,
    31986,
    16823,
    1579,
    65405,
    137809,
    8841,
    16898,
    48082,
    259,
    33014,
    42375,
    12260,
    179850,
    73667,
    91389,
    98882,
    29532,
    17311,
    326251,
    41092,
    5928,
    20742,
    44964,
    48019,
    43505,
    9317,
    49265,
    6643,
    192712,
    48424,
    163487,
    19861,
    20113,
    70848,
    31928,
    105333,
    23685,
    78563,
    14638,
    54755,
    7158,
    24142,
    44018,
    20774,
    125255,
    20331,
    24280,
    10163,
    1285,
    2336,
    39851,
    4299,
    117269,
    46714,
    63816,
    87779,
    159624,
    11731,
    9971,
    990,
    137317,
    108831,
    50994,
    74554,
    162680,
    23640,
    131597,
    146962,
    170620,
    34829,
    91205,
    21184,
    1913,
    63616,
    18427,
    93136,
    156592,
    17519,
    67565,
    115882,
    138220,
    78622,
    88535,
    18115,
    2711,
    33554,
    109492,
    54298,
    971,
    24914,
    25863,
    36363,
    45715,
    27099,
    194995,
    14299,
    178181,
    111488,
    72395,
    322385,
    157719,
    130787,
    11897,
    81843,
    83999,
    11369,
    49280,
    118604,
    40922,
    61332,
    110343,
    53407,
    75639,
    40582,
    300440,
    54722,
    25637,
    13694,
    48248,
    48278,
    194521,
    56203,
    52779,
    48783,
    72627,
    10953,
    376,
    16733,
    280238,
    26351,
    230789,
    15132,
    25168,
    137270,
    3588,
    63704,
    73376,
    94031,
    74284,
    19443,
    159557,
    9697,
    39901,
    13351,
    119050,
    15406,
    146455,
    3460,
    29556,
    75195,
    37673,
    102524,
    92329,
    47289,
    98413,
    15311,
    100684,
    56345,
    7116,
    95480,
    11590,
    7200,
    167,
    23610,
    58426,
    17730,
    136656,
    27944,
    53151,
    2701,
    8824,
    103124,
    3017,
    90744,
    113588,
    53216,
    79736,
    65940,
    26931,
    498,
    29568,
    80540,
    143543,
    21292,
    1740,
    59268,
    16561,
    180816,
    42323,
    50174,
    40890,
    52866,
    10703,
    57169,
    4700,
    17191,
    4424,
    93511,
    49698,
    166650,
    26972,
    48631,
    165169,
    82879,
    69326,
    202970,
    4007,
    2376,
    231325,
    139592,
    22119,
    62851,
    37504,
    68816,
    58345,
    67398,
    186643,
    43331,
    277416,
    53749,
    15746,
    23102,
    17432,
    4793,
    151138,
    48822,
    54265,
    48203,
    198688,
    14305,
    54287,
    2291,
    18018,
    113378,
    123260,
    7180,
    97549,
    87027,
    120085,
    2920,
    76080,
    8190,
    102005,
    5641,
    64580,
    14955,
    59802,
    54028,
    58884,
    19367,
    81779,
    412567,
    85957,
    97053,
    103637,
    78871,
    29364,
    27637,
    141728,
    4767,
    30686,
    112738,
    130146,
    42745,
    12730,
    105040,
    14844,
    232,
    210944,
    36581,
    152317,
    135543,
    29744,
    3129,
    55647,
    58149,
    46319,
    27265,
    17499,
    28005,
    59948,
    7170,
    34138,
    5702,
    293047,
    110892,
    408,
    91760,
    218674,
    18469,
    46095,
    81403,
    14389,
    4610,
    35672,
    73060,
    11006,
    74848,
    104820,
    118143,
    190357,
    20043,
    105358,
    141735,
    5115,
    27093,
    45924,
    123073,
    52599,
    29433,
    9616,
    238350,
    78610,
    24851,
    58858,
    26769,
    31969,
    24613,
    18294,
    4982,
    32735,
    39639,
    143563,
    112073,
    202205,
    12567,
    4873,
    88601,
    44897,
    81503,
    101648,
    81362,
    34662,
    85277,
    17574,
    48173,
    21435,
    221188,
    40215,
    39576,
    80786,
    26544,
    64668,
    81841,
    10731,
    37733,
    247986,
    149188,
    127703,
    495,
    18382,
    54388,
    72446,
    43071,
    30974,
    198723,
    89608,
    41360,
    190,
    33045,
    8386,
    31658,
    19992,
    237838,
    119015,
    137622,
    50890,
    100913,
    6460,
    116233,
    267230,
    26621,
    104129,
    65114,
    14190,
    41542,
    14888,
    85962,
    23342,
    23041,
    26453,
    43725,
    71809,
    45186,
    4770,
    46452,
    53894,
    56616,
    221286,
    18973,
    9038,
    109299,
    55365,
    19366,
    26863,
    18808,
    60909,
    69353,
    41738,
    83463,
    12100,
    68561,
    72860,
    3980,
    13796,
    49340,
    12332,
    31311,
    27418,
    4255,
    53430,
    18976,
    45523,
    510,
    14224,
    30477,
    26581,
    4530,
    3651,
    101663,
    139840,
    22709,
    150861,
    31996,
    63923,
    120623,
    262522,
    3076,
    10528,
    2929,
    14672,
    130238,
    18087,
    9816,
    121894,
    100308,
    25085,
    55111,
    14565,
    18952,
    53293,
    2042,
    369988,
    23674,
    61789,
    133529,
    28783,
    108293,
    35477,
    47119,
    36448,
    71049,
    40015,
    33055,
    78598,
    198442,
    1833,
    159937,
    40654,
    77444,
    189245,
    113153,
    8621,
    18599,
    38553,
    35223,
    166072,
    2375,
    11659,
    21786,
    89523,
    6032,
    12116,
    63046,
    159398,
    18454,
    3678,
    32521,
    47626,
    11411,
    103527,
    38896,
    42946,
    15696,
    26370,
    10185,
    8413,
    37080,
    165583,
    4331,
    63555,
    14907,
    72220,
    50056,
    6623,
    62236,
    36565,
    49783,
    10049,
    17503,
    100581,
    55951,
    146244,
    24724,
    9626,
    17969,
    25524,
    109300,
    173965,
    99994,
    101056,
    46459,
    43647,
    53737,
    277968,
    8347,
    123521,
    74858,
    33829,
    44762,
    77574,
    877,
    81377,
    222525,
    123532,
    30602,
    43881,
    53145,
    2973,
    16284,
    81940,
    61281,
    127044,
    63620,
    9875,
    14756,
    114829,
    19032,
    9202,
    52759,
    119141,
    23928,
    120551,
    19607,
    3599,
    33401,
    76821,
    73233,
    117430,
    39968,
    36539,
    7071,
    5446,
    121735,
    194059,
    15206,
    45283,
    6706,
    15603,
    65615,
    1207,
    165723,
    92275,
    34773,
    104447,
    8396,
    32353,
    205240,
    164323,
    13600,
    60555,
    79205,
    25532,
    22907,
    33410,
    57480,
    107111,
    69630,
    32137,
    47832,
    70913,
    33161,
    20321,
    2371,
    117348,
    10714,
    86246,
    1625,
    11763,
    17900,
    268,
    78457,
    99175,
    97940,
    101092,
    86660,
    32221,
    14041,
    128504,
    125080,
    53744,
    124263,
    31017,
    13897,
    403,
    31859,
    21964,
    5633,
    111630,
    5547,
    77329,
    17961,
    18241,
    84995,
    25984,
    12983,
    67491,
    62168,
    47262,
    5241,
    297,
    51191,
    7351,
    8967,
    147212,
    82060,
    16821,
    782,
    11033,
    82431,
    62957,
    5026,
    43459,
    77963,
    203477,
    53528,
    6247,
    191852,
    87774,
    74164,
    215654,
    13467,
    1522,
    219964,
    28589,
    244104,
    16242,
    117821,
    67725,
    72570,
    156792,
    17186,
    15979,
    26990,
    44128,
    193014,
    35276,
    57125,
    16212,
    166451,
    68017,
    6905,
    77608,
    16364,
    53777,
    75921,
    76426,
    37975,
    26203,
    269296,
    64099,
    84122,
    12077,
    38533,
    830,
    4407,
    20139,
    963,
    43028,
    38902,
    42911,
    37503,
    83343,
    85045,
    16979,
    1165,
    60835,
    137387,
    58380,
    86990,
    110066,
    134540,
    56331,
    193845,
    81238,
    17922,
    163093,
    38744,
    110641,
    12502,
    56404,
    34862,
    26865,
    125964,
    12965,
    111648,
    25547,
    7771,
    27196,
    136980,
    9555,
    29551,
    107158,
    57885,
    18831,
    37705,
    35505,
    101742,
    13970,
    102109,
    62548,
    124657,
    23328,
    11124,
    89592,
    146376,
    248050,
    6241,
    22033,
    18337,
    80685,
    29898,
    11908,
    216623,
    67721,
    106162,
    146610,
    21377,
    15085,
    91552,
    42041,
    62560,
    122532,
    125336,
    102365,
    121537,
    142559,
    29693,
    223919,
    11515,
    110495,
    18776,
    22494,
    5895,
    185059,
    103592,
    229351,
    51220,
    100102,
    37027,
    257855,
    29359,
    54123,
    36066,
    106493,
    12244,
    79258,
    32002,
    432,
    56205,
    94836,
    90182,
    6726,
    14762,
    29391,
    48938,
    26864,
    38083,
    60364,
    3310,
    60192,
    14766,
    205567,
    57504,
    110760,
    22649,
    24666,
    46333,
    21517,
    3430,
    13135,
    28873,
    27052,
    158809,
    11597,
    20529,
    6695,
    23138,
    22960,
    37137,
    45574,
    6545,
    305877,
    43423,
    26153,
    24769,
    59844,
    14501,
    10430,
    134352,
    56169,
    13213,
    103432,
    49523,
    35181,
    13435,
    12408,
    129475,
    64620,
    230854,
    77390,
    51990,
    15653,
    83248,
    33466,
    44571,
    117828,
    51481,
    2187,
    10559,
    68019,
    18021,
    54895,
    48247,
    18354,
    33737,
    4554,
    108595,
    37288,
    39767,
    116707,
    9175,
    3726,
    108877,
    21616,
    83684,
    49862,
    1938,
    8543,
    276466,
    20134,
    108498,
    48770,
    102254,
    31914,
    131520,
    185291,
    100559,
    51890,
    209,
    19526,
    76471,
    50544,
    71814,
    99351,
    8172,
    198526,
    28816,
    20419,
    9109,
    98389,
    136777,
    76479,
    75596,
    30635,
    165417,
    48216,
    120220,
    25955,
    211071,
    39314,
    24308,
    32164,
    2559,
    146280,
    43403,
    9233,
    17947,
    90585,
    1786,
    86920,
    125662,
    2457,
    64741,
    32152,
    32918,
    122882,
    78538,
    44001,
    31723,
    56426,
    23375,
    103172,
    88177,
    145697,
    52506,
    49319,
    68016,
    31664,
    41488,
    18486,
    110400,
    7030,
    28241,
    986,
    109199,
    19900,
    42147,
    56864,
    65287,
    49183,
    7858,
    24e3,
    30453,
    840,
    16673,
    25907,
    68916,
    89927,
    6309,
    158335,
    36407,
    199737,
    130464,
    13137,
    59603,
    201778,
    195292,
    21015,
    42466,
    179062,
    172561,
    89492,
    11075,
    180407,
    31868,
    72493,
    20998,
    60217,
    9865,
    19530,
    39274,
    130266,
    54539,
    21623,
    12535,
    13505,
    40641,
    73375,
    4087,
    85633,
    2153,
    3117,
    70680,
    55788,
    92096,
    47509,
    98493,
    37490,
    271936,
    151475,
    3032,
    16171,
    96642,
    34106,
    78425,
    125761,
    19591,
    3366,
    19316,
    54508,
    24183,
    50786,
    194248,
    91528,
    33253,
    34622,
    108355,
    41741,
    705,
    3814,
    3883,
    108929,
    13203,
    67831,
    10142,
    59754,
    68208,
    29128,
    84820,
    56880,
    38794,
    24972,
    48571,
    40821,
    40476,
    18137,
    164254,
    24064,
    236309,
    79181,
    11282,
    395,
    39169,
    2013,
    51587,
    28551,
    9645,
    701,
    109513,
    115899,
    113566,
    12762,
    62045,
    58322,
    103726,
    41343,
    40866,
    244102,
    143816,
    2490,
    70346,
    40973,
    52618,
    15412,
    30720,
    104315,
    38917,
    42027,
    93676,
    17513,
    107418,
    20706,
    123890,
    13399,
    97727,
    24044,
    87962,
    65606,
    44250,
    98044,
    65276,
    74790,
    101473,
    19350,
    91570,
    1326,
    87790,
    172042,
    7577,
    100813,
    86896,
    85891,
    41512,
    108130,
    27794,
    14875,
    71431,
    12835,
    156250,
    58135,
    3759,
    22476,
    42176,
    115873,
    34686,
    56523,
    73643,
    108505,
    51491,
    20838,
    12721,
    32863,
    45700,
    29496,
    13700,
    34294,
    55360,
    29206,
    155942,
    123812,
    7706,
    163234,
    203,
    132720,
    49358,
    144431,
    8130,
    175788,
    35818,
    3270,
    76832,
    25710,
    54095,
    97274,
    28779,
    94621,
    74396,
    19092,
    128242,
    58067,
    20885,
    14670,
    93255,
    15107,
    63291,
    23654,
    126900,
    129421,
    59294,
    262659,
    9798,
    3251,
    67344,
    28600,
    44629,
    50672,
    29072,
    26999,
    31526,
    23183,
    49175,
    165843,
    175455,
    17282,
    175411,
    32022,
    45989,
    30298,
    90690,
    78118,
    83156,
    23749,
    35636,
    31317,
    7069,
    80381,
    94561,
    133756,
    14960,
    97404,
    6138,
    41065,
    78041,
    32843,
    16601,
    34123,
    9559,
    146529,
    123377,
    96395,
    54441,
    42012,
    84257,
    123541,
    10745,
    22139,
    106459,
    11720,
    150883,
    172651,
    154996,
    110538,
    4728,
    53447,
    25704,
    2009,
    71152,
    119354,
    21166,
    66604,
    1429,
    216162,
    8637,
    122250,
    63520,
    27180,
    29172,
    36124,
    276428,
    107787,
    77184,
    4680,
    14952,
    104903,
    24418,
    14793,
    51561,
    52931,
    8371,
    26342,
    48526,
    7118,
    92066,
    67280,
    40653,
    8847,
    34597,
    105438,
    14198,
    50163,
    61188,
    146286,
    50315,
    41205,
    170829,
    161496,
    585,
    197359,
    95056,
    1687,
    365794,
    91349,
    48507,
    5804,
    49263,
    5146,
    104902,
    96365,
    117343,
    132222,
    46084,
    96919,
    16875,
    8073,
    262381,
    79982,
    52663,
    13928,
    16056,
    153908,
    15145,
    109256,
    132308,
    18763,
    24904,
    167644,
    13618,
    40750,
    18686,
    147124,
    114709,
    150038,
    52849,
    2938,
    12568,
    48617,
    8778,
    5459,
    44202,
    44591,
    74914,
    17183,
    248689,
    13878,
    7822,
    80060,
    23116,
    194037,
    18487,
    2067,
    7798,
    43077,
    33678,
    244028,
    31320,
    74273,
    2794,
    19466,
    8218,
    36280,
    183997,
    48124,
    19416,
    29656,
    19280,
    98734,
    7715,
    18311,
    30701,
    133602,
    150307,
    126956,
    7378,
    2933,
    79903,
    13178,
    12593,
    86571,
    26604,
    92446,
    13574,
    44205,
    65699,
    427599,
    21118,
    8245,
    14407,
    27877,
    47936,
    33542,
    7916,
    26460,
    117762,
    21596,
    37818,
    2249,
    127359,
    209394,
    60044,
    47677,
    308089,
    36791,
    154971,
    31417,
    6998,
    150042,
    174360,
    12255,
    43009,
    29335,
    48739,
    3912,
    101398,
    53340,
    2580,
    146939,
    151295,
    45360,
    125275,
    15273,
    45383,
    27456,
    48761,
    23314,
    8750,
    60801,
    85823,
    104759,
    27894,
    123685,
    66968,
    39480,
    26917,
    55290,
    83305,
    2696,
    98390,
    57569,
    145853,
    340733,
    4919,
    20024,
    52268,
    30884,
    7413,
    203685,
    70989,
    112855,
    4129,
    50536,
    349518,
    68205,
    332641,
    159581,
    135361,
    236026,
    37563,
    176404,
    64899,
    6578,
    122033,
    63871,
    1850,
    85234,
    82089,
    66124,
    74145,
    121098,
    107351,
    12687,
    36881,
    117334,
    13136,
    14698,
    85933,
    93866,
    18047,
    32620,
    310,
    15094,
    46e3,
    88451,
    23632,
    36645,
    27940,
    87618,
    80520,
    58892,
    20976,
    27702,
    140090,
    96075,
    67841,
    103292,
    238964,
    87778,
    107338,
    17019,
    83427,
    67522,
    7302,
    8261,
    47570,
    116787,
    8730,
    80484,
    61772,
    174422,
    56005,
    131193,
    52875,
    14588,
    28471,
    59817,
    9586,
    15720,
    158155,
    51307,
    109734,
    15196,
    11025,
    59331,
    3884,
    52626,
    102602,
    84797,
    25158,
    27314,
    4437,
    20488,
    76214,
    189248,
    35023,
    114952,
    157376,
    2827,
    62439,
    102878,
    129749,
    36405,
    10329,
    109339,
    108633,
    36662,
    1254,
    13267,
    5470,
    87105,
    58004,
    15397,
    10434,
    159667,
    21864,
    52022,
    179464,
    3013,
    32147,
    31496,
    116832,
    18494,
    105502,
    129227,
    107267,
    50033,
    13481,
    9954,
    24267,
    22141,
    16257,
    116154,
    36185,
    950,
    115685,
    11305,
    176708,
    2048,
    178671,
    112573,
    287867,
    162328,
    497663,
    95170,
    50979,
    193861,
    50987,
    30368,
    136257,
    31830,
    46549,
    15119,
    169876,
    23788,
    17462,
    249887,
    57377,
    1949,
    35448,
    14791,
    43769,
    210091,
    3783,
    34612,
    282103,
    88380,
    245190,
    5457,
    20491,
    98908,
    11402,
    86899,
    117916,
    16028,
    162584,
    60644,
    320177,
    156096,
    31065,
    55876,
    22e3,
    77655,
    9992,
    23397,
    13757,
    317623,
    63978,
    215255,
    2443,
    17648,
    93231,
    27388,
    104529,
    93807,
    55505,
    140477,
    12046,
    112040,
    70887,
    40152,
    94365,
    112353,
    25063,
    114679,
    266061,
    71248,
    119555,
    15589,
    2244,
    617,
    14129,
    211431,
    70110,
    100652,
    7777,
    4383,
    85911,
    89221,
    21010,
    120615,
    58357,
    86405,
    37554,
    41647,
    18,
    15143,
    69662,
    60491,
    14714,
    186134,
    148344,
    42347,
    5410,
    168175,
    44535,
    42449,
    343894,
    129417,
    99682,
    20659,
    27272,
    140483,
    63455,
    222159,
    17536,
    13722,
    42637,
    62324,
    11976,
    114691,
    148109,
    2283,
    32057,
    182393,
    4295,
    147364,
    33705,
    2075,
    44303,
    30274,
    28331,
    63740,
    69740,
    29148,
    10346,
    44862,
    33716,
    73937,
    153333,
    12930,
    38784,
    247159,
    2515,
    41053,
    20256,
    83368,
    256189,
    54639,
    115240,
    5096,
    24661,
    175419,
    153552,
    26516,
    141,
    138176,
    63885,
    34115,
    47222,
    55709,
    2765,
    28479,
    38875,
    236608,
    12229,
    22921,
    77291,
    54426,
    45388,
    2860,
    57787,
    114579,
    295139,
    105782,
    17826,
    71066,
    19119,
    54364,
    69385,
    16568,
    12323,
    28057,
    33346,
    34919,
    124763,
    155533,
    101386,
    31644,
    8627,
    49001,
    303600,
    29868,
    63213,
    9103,
    77280,
    71333,
    9696,
    138789,
    37059,
    24823,
    5057,
    21352,
    32368,
    114208,
    56803,
    19424,
    10445,
    58514,
    8661,
    209508,
    26187,
    171838,
    10460,
    63454,
    14016,
    122504,
    41328,
    21329,
    46618,
    32493,
    38225,
    7855,
    31763,
    7945,
    29876,
    8734,
    6438,
    24205,
    97490,
    139977,
    130740,
    47323,
    33195,
    85390,
    57194,
    13813,
    60600,
    21313,
    96251,
    7699,
    27584,
    170521,
    139271,
    1363,
    4402,
    336738,
    129223,
    84983,
    69150,
    13147,
    3590,
    163929,
    207225,
    155260,
    55916,
    20288,
    4503,
    8398,
    98490,
    11773,
    27512,
    37113,
    84976,
    86558,
    28365,
    11756,
    116005,
    182148,
    13733,
    115313,
    47644,
    67208,
    85069,
    9347,
    14995,
    226141,
    14704,
    101835,
    41159,
    35314,
    13113,
    63526,
    214039,
    29978,
    50446,
    83339,
    17440,
    129441,
    72522,
    118641,
    97816,
    24907,
    73844,
    15717,
    118884,
    167255,
    96509,
    162793,
    30847,
    36849,
    51297,
    78974,
    77793,
    10427,
    1873,
    2972,
    9999,
    35074,
    28190,
    64297,
    146836,
    46298,
    60038,
    163007,
    108919,
    61219,
    2403,
    75022,
    127339,
    4233,
    110389,
    69022,
    9833,
    128097,
    88016,
    79390,
    222936,
    22570,
    94657,
    28462,
    56956,
    38803,
    81536,
    30474,
    152794,
    19566,
    16481,
    147408,
    74574,
    81895,
    20731,
    1918,
    1366,
    76367,
    187321,
    54494,
    24366,
    21690,
    61696,
    33283,
    107477,
    77499,
    31112,
    414383,
    74362,
    18463,
    218441,
    120929,
    59848,
    258629,
    201924,
    69269,
    454,
    19989,
    13054,
    59894,
    3623,
    58908,
    20681,
    35723,
    78523,
    102680,
    38988,
    184112,
    108087,
    50944,
    132704,
    52966,
    21699,
    18860,
    96349,
    201411,
    82697,
    85395,
    95658,
    5093,
    6427,
    177894,
    44191,
    32755,
    26961,
    155739,
    6249,
    31310,
    81030,
    26574,
    84311,
    120155,
    86730,
    113535,
    7424,
    48888,
    13516,
    45747,
    98098,
    20077,
    183995,
    81945,
    43210,
    26704,
    40420,
    75831,
    45648,
    11180,
    6855,
    57927,
    65528,
    124096,
    34851,
    2598,
    156633,
    107572,
    127352,
    38169,
    123845,
    60142,
    62722,
    105584,
    232364,
    23211,
    68120,
    1601,
    22169,
    89299,
    747,
    258039,
    80572,
    7258,
    152249,
    11862,
    101204,
    8834,
    121434,
    33761,
    19175,
    133142,
    46343,
    40178,
    48723,
    3589,
    41977,
    30210,
    38868,
    62257,
    10087,
    82658,
    87827,
    90646,
    16415,
    47552,
    351723,
    28298,
    72225,
    91146,
    272760,
    1701,
    11295,
    1652,
    109651,
    300747,
    51863,
    198800,
    29446,
    11794,
    32345,
    37538,
    22356,
    33102,
    37590,
    113544,
    37970,
    11478,
    179743,
    25454,
    103417,
    59905,
    221970,
    105196,
    145604,
    7817,
    164809,
    102360,
    16974,
    75840,
    255333,
    56902,
    6659,
    1954,
    645,
    59400,
    67769,
    7689,
    18675,
    5215,
    13793,
    20536,
    27852,
    3387,
    29523,
    259718,
    16860,
    94625,
    43143,
    29245,
    15848,
    233581,
    22685,
    63631,
    78557,
    22836,
    133302,
    84513,
    1348,
    51826,
    47129,
    98836,
    58284,
    1830,
    1749,
    94642,
    10933,
    6145,
    12506,
    10975,
    13879,
    103781,
    144434,
    10268,
    28409,
    32346,
    52968,
    121567,
    107374,
    77268,
    23686,
    35097,
    10501,
    155275,
    15303,
    47136,
    21102,
    168741,
    55332,
    90385,
    15996,
    84817,
    681,
    137803,
    25054,
    142275,
    6163,
    38175,
    8056,
    124296,
    240642,
    65621,
    4934,
    178205,
    16101,
    62803,
    60964,
    18230,
    100622,
    76465,
    44689,
    14545,
    9543,
    47514,
    16852,
    93380,
    28048,
    12047,
    107106,
    37575,
    101485,
    77047,
    57326,
    34819,
    96137,
    76916,
    6469,
    46264,
    115983,
    75768,
    87668,
    69942,
    13027,
    165,
    8373,
    114231,
    26434,
    52844,
    42799,
    182044,
    23580,
    146254,
    38081,
    43236,
    33883,
    146220,
    382894,
    14606,
    46035,
    36481,
    166621,
    35417,
    95382,
    2957,
    59384,
    60428,
    36358,
    66343,
    75378,
    22267,
    22950,
    83528,
    17577,
    56474,
    25285,
    4619,
    179691,
    75355,
    95836,
    53295,
    34588,
    171410,
    4487,
    14679,
    84208,
    44015,
    18562,
    109133,
    54101,
    11531,
    86052,
    174479,
    303157,
    28095,
    9953,
    35642,
    14564,
    39802,
    16145,
    77606,
    117406,
    53038,
    121117,
    53624,
    22062,
    1212,
    7632,
    127157,
    237292,
    189087,
    10478,
    127345,
    102515,
    181997,
    86752,
    87623,
    10966,
    121602,
    68783,
    68681,
    83042,
    114380,
    138349,
    191305,
    67176,
    50085,
    39016,
    1427,
    42384,
    1412,
    67118,
    122616,
    72389,
    25260,
    2237,
    13576,
    137346,
    19938,
    20304,
    2191,
    68759,
    5373,
    61364,
    238507,
    75814,
    23931,
    69565,
    38993,
    131741,
    38364,
    12528,
    87762,
    5679,
    129853,
    5310,
    186831,
    32653,
    90338,
    260176,
    389531,
    108118,
    26843,
    43985,
    50175,
    30563,
    25106,
    56965,
    18130,
    140428,
    4542,
    165503,
    117991,
    24219,
    229605,
    1819,
    129663,
    1240,
    3797,
    76093,
    18398,
    71339,
    51919,
    93043,
    27175,
    47060,
    216257,
    6483,
    35051,
    1217,
    16512,
    80798,
    129064,
    13225,
    69339,
    8548,
    237079,
    72298,
    2575,
    34280,
    51379,
    117910,
    55671,
    53345,
    247552,
    29486,
    39328,
    140821,
    34681,
    57045,
    60177,
    5004,
    90269,
    78522,
    2479,
    322607,
    48474,
    61296,
    13057,
    31558,
    4678,
    59271,
    6699,
    27044,
    31988,
    35944,
    12503,
    83480,
    4389,
    136508,
    3781,
    114121,
    70279,
    4488,
    155829,
    42214,
    2898,
    68191,
    75695,
    305850,
    45041,
    74344,
    106509,
    30087,
    17429,
    93292,
    12477,
    290,
    23080,
    114802,
    35714,
    18751,
    26554,
    105424,
    17775,
    2144,
    2412,
    100610,
    65192,
    113975,
    52975,
    180272,
    135050,
    129815,
    76238,
    106483,
    21440,
    63186,
    4260,
    46189,
    9711,
    28249,
    4169,
    23429,
    23390,
    8324,
    141585,
    63809,
    67668,
    38457,
    38063,
    39226,
    59972,
    1189,
    203916,
    62368,
    14403,
    16949,
    61767,
    85801,
    1739,
    40147,
    35049,
    76757,
    33124,
    62102,
    15780,
    103593,
    103009,
    53484,
    22952,
    67973,
    114645,
    6566,
    5245,
    50462,
    7601,
    8288,
    3513,
    194571,
    80276,
    1908,
    54592,
    5124,
    58571,
    2513,
    6800,
    273997,
    193904,
    1119,
    17991,
    117245,
    2508,
    129156,
    82366,
    26278,
    71465,
    63341,
    56943,
    39662,
    106116,
    94966,
    156875,
    9736,
    2204,
    122308,
    94418,
    27134,
    1280,
    24539,
    49022,
    45314,
    3764,
    50904,
    46424,
    30699,
    28087,
    293839,
    9400,
    33646,
    40165,
    822,
    147499,
    50263,
    116179,
    29085,
    11863,
    31314,
    5578,
    17797,
    5104,
    12454,
    1604,
    15342,
    219206,
    10232,
    67800,
    94261,
    25872,
    13565,
    90339,
    78971,
    75377,
    26649,
    41184,
    47695,
    11514,
    35369,
    20767,
    14227,
    41953,
    309396,
    148270,
    147938,
    33074,
    14453,
    27499,
    109019,
    39018,
    25738,
    240196,
    158931,
    52820,
    8612,
    95853,
    21524,
    137010,
    84901,
    70869,
    70021,
    116794,
    48404,
    38771,
    6732,
    1070,
    70990,
    187297,
    49140,
    5238,
    576,
    3564,
    253975,
    16027,
    16483,
    2811,
    37775,
    19034,
    25259,
    4053,
    2e3,
    70083,
    95774,
    19713,
    33431,
    92703,
    91314,
    42381,
    288770,
    48194,
    95985,
    3991,
    77418,
    13406,
    241328,
    245086,
    56533,
    35275,
    62725,
    9246,
    51924,
    70181,
    95331,
    16163,
    31410,
    79016,
    39312,
    120878,
    119371,
    275987,
    80124,
    27712,
    9186,
    220,
    23598,
    146167,
    85209,
    68238,
    282190,
    57048,
    31273,
    30555,
    80913,
    17594,
    75779,
    59160,
    135002,
    101219,
    189377,
    29225,
    96735,
    60126,
    62522,
    104e3,
    27620,
    86814,
    17240,
    147533,
    11001,
    5425,
    43682,
    410,
    49460,
    87270,
    69480,
    46315,
    59448,
    1816,
    76201,
    9431,
    11788,
    87960,
    29063,
    65539,
    47347,
    11678,
    33846,
    7008,
    196704,
    9895,
    6753,
    8633,
    120892,
    59970,
    572824,
    115934,
    6646,
    202559,
    892,
    48351,
    37611,
    251282,
    57823,
    67263,
    57750,
    26527,
    34485,
    90747,
    7685,
    88370,
    6144,
    64182,
    1709,
    41969,
    21458,
    62327,
    181657,
    49247,
    225330,
    122600,
    114574,
    107124,
    85361,
    111833,
    63243,
    71420,
    15655,
    191178,
    72430,
    18063,
    51425,
    54002,
    12364,
    53225,
    86557,
    18193,
    97580,
    41232,
    138398,
    67821,
    128724,
    8944,
    233212,
    101353,
    52099,
    42127,
    14006,
    120107,
    32789,
    32132,
    3498,
    18123,
    33758,
    56058,
    5779,
    128760,
    59888,
    98869,
    18445,
    84702,
    51911,
    13234,
    218379,
    20093,
    39031,
    8074,
    70195,
    20708,
    23462,
    24355,
    131384,
    60189,
    26390,
    10403,
    41060,
    7140,
    10781,
    49410,
    42261,
    87202,
    82566,
    41663,
    43105,
    60276,
    2768,
    5733,
    74176,
    28329,
    2297,
    145430,
    131632,
    83615,
    122915,
    105441,
    655,
    224102,
    5284,
    136426,
    67763,
    16294,
    188511,
    32538,
    61049,
    27893,
    3394,
    13951,
    159099,
    28542,
    17930,
    145360,
    9492,
    190122,
    32285,
    78855,
    26440,
    13570,
    58648,
    73908,
    4239,
    124561,
    2444,
    74172,
    53131,
    11468,
    10794,
    73566,
    11623,
    35343,
    64710,
    30481,
    4163,
    10328,
    38309,
    29901,
    10538,
    154377,
    76132,
    92405,
    24839,
    11679,
    3465,
    13449,
    11637,
    7824,
    2337,
    57754,
    1260,
    14458,
    41118,
    19878,
    38661,
    13416,
    159180,
    37074,
    163164,
    54137,
    28627,
    52134,
    184900,
    8520,
    40385,
    29546,
    30502,
    22386,
    66527,
    107458,
    6850,
    24022,
    47983,
    30603,
    35083,
    8934,
    304066,
    39500,
    9,
    28261,
    33026,
    77251,
    9374,
    44833,
    116312,
    34990,
    29236,
    63563,
    125639,
    135405,
    165398,
    159055,
    55690,
    88141,
    69643,
    236964,
    31983,
    25572,
    20436,
    36746,
    60896,
    31850,
    16179,
    11828,
    5888,
    3043,
    66368,
    9750,
    31167,
    7915,
    53111,
    36430,
    1333,
    64344,
    93659,
    20061,
    60596,
    180191,
    51630,
    6792,
    30244,
    43509,
    101058,
    22409,
    420,
    44210,
    109783,
    43223,
    27030,
    72477,
    72831,
    32679,
    29235,
    7675,
    47556,
    12258,
    39907,
    149412,
    84926,
    118247,
    24692,
    71717,
    105038,
    86009,
    45941,
    41189,
    89453,
    29856,
    52543,
    30627,
    226798,
    67303,
    59230,
    67415,
    34408,
    1367,
    99685,
    16867,
    128419,
    52147,
    4111,
    125381,
    117881,
    16173,
    44093,
    102224,
    31575,
    23234,
    24870,
    83790,
    127407,
    239098,
    3200,
    994,
    1255,
    100903,
    242275,
    117266,
    55116,
    38205,
    16140,
    29662,
    11307,
    40414,
    208793,
    123355,
    56470,
    4862,
    75600,
    30119,
    58218,
    70828,
    24075,
    26974,
    7802,
    192353,
    4851,
    5475,
    78720,
    66596,
    3409,
    28573,
    64396,
    30381,
    30690,
    59859,
    88256,
    5406,
    99945,
    103064,
    34463,
    37727,
    24238,
    86643,
    60088,
    4057,
    23741,
    5967,
    162904,
    38240,
    28356,
    93858,
    25510,
    122879,
    6897,
    3278,
    7057,
    11971,
    4400,
    35461,
    211413,
    21395,
    59615,
    39471,
    87233,
    55795,
    128426,
    3051,
    22470,
    41950,
    14705,
    3974,
    180108,
    80476,
    78442,
    204996,
    91987,
    15634,
    67610,
    139015,
    142373,
    35611,
    51134,
    10387,
    4353,
    153456,
    57749,
    181039,
    14183,
    68447,
    151532,
    21107,
    36452,
    20551,
    3186,
    46247,
    46383,
    129666,
    88736,
    140662,
    146243,
    2066,
    8360,
    7978,
    64818,
    106963,
    17896,
    47801,
    10723,
    114821,
    223295,
    74192,
    3293,
    3393,
    16987,
    74064,
    11277,
    91622,
    4270,
    29828,
    27951,
    387869,
    103235,
    1374,
    61988,
    120083,
    477,
    145892,
    128378,
    11779,
    211263,
    61354,
    18221,
    17869,
    46530,
    83061,
    108538,
    157981,
    90608,
    67199,
    95080,
    49064,
    195814,
    12302,
    66307,
    10348,
    231346,
    160732,
    112859,
    63633,
    146558,
    21271,
    31037,
    198802,
    47622,
    12862,
    95710,
    3910,
    77850,
    73961,
    85585,
    34752,
    61e3,
    4082,
    24595,
    103679,
    71107,
    8208,
    79568,
    150019,
    16615,
    24961,
    139857,
    32664,
    197366,
    4559,
    54735,
    32696,
    4126,
    162019,
    75698,
    13916,
    70108,
    159638,
    19834,
    9349,
    24675,
    175560,
    49643,
    18206,
    52459,
    27992,
    10809,
    88865,
    401975,
    133172,
    29e3,
    34558,
    30915,
    3658,
    25834,
    42430,
    36562,
    125265,
    18182,
    10155,
    40149,
    97082,
    208980,
    19575,
    60853,
    90529,
    66545,
    9600,
    789,
    46420,
    2317,
    88593,
    55595,
    98980,
    115302,
    5742,
    169155,
    1073,
    177901,
    3472,
    11189,
    63711,
    78643,
    65472,
    50459,
    127979,
    93,
    42202,
    67053,
    21720,
    157650,
    11145,
    141378,
    42033,
    22824,
    85705,
    79114,
    35584,
    15974,
    1510,
    54172,
    28562,
    12451,
    104226,
    19190,
    97151,
    73024,
    20948,
    5151,
    81741,
    21499,
    29006,
    84183,
    198074,
    54003,
    45120,
    170125,
    26240,
    35177,
    28389,
    64863,
    79974,
    60778,
    176915,
    232183,
    45342,
    2038,
    80253,
    41564,
    40703,
    32689,
    5430,
    100689,
    5366,
    23007,
    134279,
    14266,
    26712,
    73993,
    24934,
    64242,
    52113,
    102887,
    61801,
    46415,
    201049,
    54251,
    62133,
    122757,
    164883,
    30815,
    139966,
    2319,
    30842,
    766,
    13362,
    10287,
    134518,
    86111,
    81665,
    82440,
    28333,
    43019,
    18963,
    8804,
    161944,
    23439,
    102144,
    101145,
    80029,
    39052,
    248708,
    30350,
    117340,
    11878,
    128467,
    974,
    138625,
    63961,
    5237,
    74778,
    61834,
    67040,
    43814,
    13690,
    65947,
    33809,
    232476,
    115258,
    181745,
    28824,
    94013,
    9510,
    10246,
    93722,
    81976,
    7217,
    114383,
    3493,
    16014,
    69045,
    72692,
    12145,
    80981,
    9507,
    6692,
    1620,
    60820,
    330444,
    35474,
    33962,
    4797,
    7053,
    295463,
    46445,
    27026,
    12491,
    77988,
    49524,
    35675,
    90947,
    29114,
    166705,
    101385,
    133782,
    32704,
    6186,
    84595,
    176031,
    185623,
    45966,
    151302,
    63069,
    1699,
    107491,
    947,
    15458,
    74452,
    196212,
    6046,
    10498,
    12163,
    10239,
    35191,
    243951,
    9277,
    9090,
    29539,
    54460,
    22820,
    26514,
    112549,
    60372,
    51753,
    48756,
    21812,
    70861,
    260326,
    41,
    44222,
    10441,
    16961,
    48148,
    138771,
    216194,
    5914,
    52153,
    53400,
    212036,
    56519,
    26245,
    10117,
    45888,
    15294,
    138019,
    90913,
    26368,
    43842,
    42111,
    23348,
    6082,
    194845,
    161089,
    156206,
    51546,
    11647,
    30759,
    302912,
    262094,
    8635,
    78876,
    26535,
    35283,
    54183,
    31183,
    85484,
    147873,
    12989,
    5197,
    6356,
    72894,
    65347,
    20150,
    27370,
    73787,
    1493,
    45918,
    12366,
    190217,
    20724,
    13858,
    10981,
    67449,
    81213,
    7553,
    14115,
    72242,
    271517,
    11842,
    48310,
    88743,
    143726,
    22177,
    3290,
    243231,
    58452,
    62937,
    12592,
    1654,
    40066,
    33477,
    13751,
    9921,
    128442,
    15868,
    7106,
    75236,
    83773,
    10775,
    36938,
    10482,
    170465,
    17368,
    17469,
    161508,
    32752,
    98340,
    800,
    19824,
    264456,
    3901,
    87319,
    2867,
    26782,
    9630,
    113102,
    185815,
    24197,
    44584,
    86366,
    40224,
    3636,
    140916,
    31731,
    267731,
    9567,
    53678,
    72984,
    29389,
    27963,
    17106,
    50282,
    284911,
    60170,
    8322,
    12608,
    23374,
    89652,
    5268,
    39044,
    229766,
    8869,
    151350,
    31436,
    177342,
    12269,
    183212,
    120418,
    116270,
    2843,
    78888,
    69192,
    7865,
    184099,
    1086,
    129897,
    18383,
    70508,
    20242,
    18508,
    229924,
    124569,
    35749,
    50589,
    55626,
    9884,
    83115,
    40971,
    30671,
    18135,
    14452,
    38861,
    17844,
    201826,
    5549,
    26413,
    17189,
    13561,
    38539,
    10679,
    143331,
    3314,
    36785,
    171194,
    49685,
    187713,
    67506,
    4618,
    104039,
    17060,
    195080,
    50648,
    33159,
    19238,
    67559,
    134840,
    28599,
    157523,
    17130,
    38064,
    117398,
    94355,
    31918,
    13575,
    34538,
    40326,
    13997,
    3494,
    348283,
    62481,
    26862,
    3603,
    104426,
    244363,
    153709,
    112487,
    304612,
    199674,
    41239,
    35545,
    54869,
    293005,
    28223,
    26277,
    26899,
    4533,
    18518,
    15492,
    38587,
    80488,
    70485,
    160395,
    263,
    60162,
    11382,
    222152,
    4696,
    250751,
    51921,
    182609,
    10707,
    48463,
    46243,
    1227,
    49111,
    111564,
    46502,
    33342,
    56846,
    68541,
    63559,
    858,
    139927,
    16654,
    229375,
    76759,
    26478,
    33205,
    95828,
    23399,
    92945,
    2637,
    35630,
    28470,
    143992,
    50214,
    14174,
    21456,
    166191,
    65665,
    1711,
    21594,
    78019,
    97599,
    111701,
    36,
    147151,
    110246,
    189022,
    43021,
    30397,
    40757,
    131935,
    42065,
    73335,
    48039,
    26596,
    28984,
    15102,
    2361,
    7421,
    202167,
    69744,
    43766,
    52826,
    3642,
    83304,
    33873,
    75140,
    63169,
    192389,
    36551,
    92748,
    13039,
    123959,
    233220,
    21738,
    84447,
    77230,
    20228,
    187852,
    19095,
    25799,
    92136,
    108774,
    29237,
    53947,
    2299,
    118106,
    2687,
    8830,
    42331,
    202924,
    33667,
    2023,
    73763,
    30704,
    19363,
    19779,
    16737,
    35629,
    48081,
    24068,
    101013,
    162338,
    291912,
    13749,
    24745,
    328289,
    167679,
    70086,
    48299,
    23306,
    16732,
    17801,
    43322,
    54589,
    3586,
    63653,
    43624,
    53474,
    925,
    109177,
    251316,
    43805,
    13082,
    19511,
    86565,
    142182,
    92461,
    17117,
    101033,
    103319,
    64589,
    4022,
    4351,
    235897,
    5352,
    82705,
    107142,
    46391,
    156084,
    5860,
    61365,
    10558,
    13045,
    7717,
    18357,
    33922,
    12590,
    33065,
    6928,
    46993,
    783,
    46937,
    67846,
    8952,
    26295,
    6107,
    119656,
    18799,
    17458,
    50747,
    4229,
    179559,
    112727,
    118080,
    20683,
    41464,
    125468,
    51560,
    49749,
    44231,
    7359,
    35339,
    62988,
    136487,
    67015,
    5208,
    29150,
    24956,
    105186,
    48858,
    6143,
    18097,
    6972,
    16404,
    73489,
    58742,
    97196,
    36357,
    164616,
    5834,
    32267,
    13746,
    147733,
    15113,
    132091,
    34127,
    106298,
    39729,
    106426,
    22294,
    9780,
    15602,
    36213,
    71502,
    42808,
    66802,
    599,
    60755,
    5851,
    39120,
    67363,
    108623,
    126368,
    72770,
    91263,
    32486,
    30596,
    151717,
    7951,
    52002,
    43103,
    11768,
    68942,
    40901,
    39344,
    24037,
    127500,
    116890,
    48403,
    16926,
    86750,
    17745,
    48648,
    159545,
    34460,
    58419,
    5634,
    114317,
    67865,
    31462,
    23352,
    24010,
    98185,
    125708,
    69686,
    68337,
    13610,
    26271,
    70691,
    2980,
    4768,
    27225,
    102402,
    75453,
    28106,
    8104,
    6931,
    1176,
    6274,
    6475,
    112635,
    22498,
    6176,
    238686,
    26832,
    28893,
    90319,
    14441,
    15682,
    15087,
    39517,
    45270,
    109134,
    104440,
    45965,
    47645,
    81772,
    7876,
    52683,
    87720,
    12898,
    4505,
    185665,
    2769,
    113401,
    15664,
    57592,
    105229,
    137381,
    97059,
    119268,
    6876,
    43309,
    33886,
    128363,
    35476,
    144249,
    67013,
    143587,
    83367,
    25703,
    91436,
    59347,
    53236,
    2289,
    16519,
    19844,
    46309,
    58558,
    99834,
    23313,
    218816,
    231303,
    36388,
    51333,
    183535,
    109792,
    139277,
    54306,
    90139,
    18235,
    8275,
    32710,
    37677,
    82464,
    86025,
    92204,
    88842,
    117723,
    37570,
    128723,
    234242,
    76350,
    73795,
    34896,
    148247,
    58424,
    11105,
    11744,
    45746,
    63372,
    17118,
    49772,
    199520,
    81902,
    38004,
    22911,
    33752,
    3125,
    1995,
    53792,
    4689,
    26909,
    108150,
    146062,
    69674,
    41811,
    161444,
    84855,
    8999,
    28561,
    16731,
    93937,
    3189,
    21967,
    24890,
    22943,
    1356,
    145300,
    51569,
    28802,
    517,
    118679,
    31703,
    40607,
    48098,
    108854,
    25003,
    10233,
    73969,
    177495,
    5248,
    24516,
    215347,
    146192,
    48712,
    60626,
    69188,
    40735,
    5866,
    586,
    101541,
    6509,
    47590,
    52129,
    5969,
    222045,
    110933,
    25733,
    24223,
    65339,
    62812,
    2414,
    155418,
    35819,
    16022,
    78423,
    43138,
    20995,
    128255,
    240673,
    46745,
    236093,
    72176,
    57085,
    97841,
    61248,
    107,
    36068,
    193177,
    105427,
    55726,
    215229,
    20446,
    47228,
    100420,
    87091,
    14429,
    121708,
    23605,
    21157,
    187721,
    21880,
    2997,
    203976,
    99166,
    95068,
    25877,
    7724,
    98925,
    83401,
    4829,
    13182,
    18229,
    13718,
    239662,
    38653,
    116505,
    153497,
    30589,
    89029,
    38962,
    181302,
    43853,
    78872,
    180301,
    4786,
    248240,
    7401,
    106136,
    112590,
    77745,
    19731,
    60880,
    77789,
    125748,
    135487,
    5975,
    48627,
    34084,
    12419,
    215770,
    47557,
    254582,
    10364,
    106495,
    21856,
    67539,
    88981,
    38805,
    21428,
    48732,
    42316,
    12149,
    16078,
    52808,
    25327,
    51322,
    33850,
    51147,
    12253,
    122354,
    46077,
    56483,
    254553,
    115417,
    81834,
    150991,
    94662,
    86668,
    7381,
    12841,
    100650,
    18218,
    15741,
    22372,
    68294,
    50705,
    15535,
    84660,
    61887,
    22553,
    72299,
    31361,
    24824,
    17743,
    46820,
    64288,
    31582,
    77006,
    111674,
    116384,
    30760,
    80920,
    86149,
    77192,
    51979,
    79691,
    60342,
    122805,
    103800,
    240873,
    160744,
    233114,
    78962,
    54920,
    8608,
    3484,
    316104,
    72548,
    24337,
    5088,
    230040,
    21926,
    10172,
    36838,
    26,
    86221,
    83458,
    102176,
    12062,
    17571,
    41929,
    41170,
    28428,
    68239,
    41750,
    103930,
    2634,
    18313,
    53019,
    34825,
    97837,
    63115,
    24606,
    73157,
    152474,
    14715,
    91439,
    37033,
    109806,
    140259,
    30668,
    174760,
    380,
    135597,
    95673,
    136073,
    65073,
    134249,
    13829,
    17279,
    122305,
    4420,
    46444,
    10237,
    64848,
    203623,
    70728,
    10349,
    182885,
    65075,
    24519,
    25783,
    40318,
    34139,
    22222,
    63394,
    55266,
    102764,
    41422,
    20126,
    65100,
    90408,
    53640,
    35128,
    48932,
    11192,
    38935,
    96839,
    34782,
    39492,
    19396,
    41332,
    6250,
    5511,
    19492,
    51304,
    25936,
    104466,
    54099,
    73771,
    86115,
    5080,
    7669,
    30891,
    111700,
    13931,
    25276,
    72289,
    135447,
    14820,
    258641,
    25265,
    31005,
    281179,
    75286,
    393,
    95359,
    14623,
    13584,
    6680,
    101227,
    80173,
    44933,
    76666,
    54542,
    13244,
    39348,
    458,
    25379,
    109451,
    134348,
    81143,
    6959,
    65554,
    12027,
    51311,
    8716,
    57589,
    140731,
    28467,
    23316,
    17272,
    30458,
    25980,
    55229,
    77197,
    83798,
    28302,
    114784,
    7428,
    34548,
    26241,
    14712,
    39336,
    103304,
    18928,
    54080,
    12870,
    334,
    87722,
    15208,
    16895,
    142098,
    114262,
    39820,
    83913,
    57817,
    28682,
    7721,
    14900,
    108672,
    11250,
    62246,
    42849,
    415188,
    1724,
    26555,
    24549,
    25505,
    26443,
    107450,
    145899,
    61035,
    43528,
    6901,
    60726,
    65906,
    267741,
    21338,
    147590,
    42079,
    18924,
    73017,
    135236,
    15393,
    5206,
    4026,
    84185,
    1531,
    5988,
    113890,
    82647,
    303391,
    7386,
    69844,
    71611,
    189865,
    76523,
    31877,
    13315,
    19314,
    198575,
    32821,
    1928,
    67641,
    25913,
    104475,
    103489,
    3297,
    70391,
    18406,
    15446,
    113347,
    19295,
    93790,
    27856,
    1792,
    167471,
    116449,
    8541,
    4408,
    41757,
    63233,
    25765,
    86680,
    64501,
    27034,
    24816,
    34975,
    6079,
    4486,
    49693,
    36229,
    16917,
    21581,
    62426,
    27862,
    11612,
    54284,
    35702,
    194034,
    355,
    24277,
    48262,
    87411,
    70504,
    310164,
    118018,
    12516,
    47559,
    43502,
    57433,
    107139,
    9290,
    66533,
    80863,
    14634,
    34312,
    91725,
    28606,
    21342,
    67241,
    72355,
    43244,
    375789,
    37402,
    174015,
    105070,
    8342,
    44167,
    67494,
    1890,
    16365,
    11723,
    271002,
    1865,
    47918,
    8350,
    45564,
    27742,
    25110,
    125803,
    8553,
    49504,
    81925,
    62211,
    4534,
    15491,
    19011,
    80373,
    206920,
    667,
    102405,
    128623,
    245524,
    5553,
    113309,
    192739,
    65766,
    19567,
    22832,
    261958,
    29679,
    21293,
    71134,
    20962,
    105123,
    24721,
    860,
    21752,
    33448,
    18372,
    157167,
    94822,
    35770,
    173224,
    232737,
    75729,
    28937,
    46828,
    28062,
    25453,
    5207,
    140366,
    36665,
    30652,
    6169,
    67920,
    150458,
    92040,
    23186,
    184604,
    92330,
    20891,
    176492,
    49427,
    27828,
    38305,
    42495,
    143982,
    49560,
    25503,
    90043,
    29747,
    65328,
    47830,
    12932,
    11068,
    77721,
    9003,
    25213,
    94205,
    140426,
    46090,
    89945,
    138173,
    192691,
    33329,
    112232,
    129905,
    35709,
    27514,
    1841,
    19957,
    31411,
    127476,
    53572,
    17497,
    173549,
    55063,
    175135,
    19841,
    69314,
    5192,
    237921,
    117660,
    150697,
    4060,
    273045,
    50414,
    98940,
    65348,
    153665,
    164423,
    58804,
    156695,
    48994,
    213928,
    86036,
    28608,
    8355,
    39574,
    34540,
    16927,
    135680,
    18374,
    151587,
    10830,
    53805,
    16878,
    16623,
    4282,
    48030,
    8537,
    14986,
    46102,
    13062,
    72897,
    72,
    33050,
    108227,
    39451,
    45935,
    651,
    113320,
    40535,
    95176,
    57450,
    48843,
    5003,
    19019,
    10407,
    211163,
    3848,
    1068,
    4988,
    32091,
    30095,
    41692,
    15099,
    43602,
    107434,
    50744,
    7627,
    171349,
    16313,
    150832,
    352665,
    207750,
    33937,
    38256,
    51091,
    156e3,
    87889,
    90663,
    84175,
    24908,
    114900,
    50365,
    31494,
    83829,
    5398,
    169342,
    47521,
    54818,
    18935,
    8356,
    43094,
    41212,
    174536,
    10082,
    92550,
    6678,
    60614,
    23355,
    69721,
    14796,
    34149,
    128830,
    58187,
    3179,
    208,
    40325,
    28399,
    225029,
    401412,
    51150,
    31580,
    207268,
    6657,
    10993,
    69818,
    64282,
    289845,
    23308,
    12961,
    38447,
    6681,
    52944,
    31855,
    2572,
    47646,
    120728,
    179148,
    37240,
    45196,
    218274,
    4816,
    3695,
    21961,
    50084,
    35209,
    18073,
    51452,
    27004,
    6100,
    33941,
    1377,
    84831,
    171214,
    85,
    141510,
    9078,
    99227,
    32610,
    6417,
    11718,
    49868,
    65579,
    87902,
    73018,
    49062,
    46280,
    61742,
    21512,
    40862,
    107733,
    15941,
    29168,
    157765,
    144919,
    14487,
    5767,
    158014,
    140070,
    7241,
    573,
    71584,
    16921,
    223566,
    40331,
    179473,
    35081,
    47926,
    140885,
    41508,
    52104,
    59180,
    42310,
    32811,
    29048,
    123517,
    102413,
    80208,
    10104,
    14746,
    12649,
    153641,
    126022,
    37965,
    113017,
    4171,
    83,
    142592,
    2809,
    6362,
    50416,
    71323,
    116894,
    260776,
    16204,
    1524,
    5760,
    30351,
    12658,
    20703,
    54403,
    36083,
    45408,
    74772,
    4946,
    14485,
    50759,
    111222,
    10890,
    2195,
    167147,
    92962,
    130534,
    16283,
    177256,
    35016,
    15472,
    210156,
    151187,
    73922,
    117691,
    43250,
    52051,
    37392,
    24811,
    24358,
    30830,
    5775,
    818,
    21969,
    1476,
    127322,
    151783,
    58392,
    31021,
    106913,
    65215,
    89407,
    90802,
    28531,
    11690,
    20234,
    95249,
    44602,
    37256,
    18707,
    11928,
    5161,
    4410,
    26571,
    51903,
    49768,
    22008,
    25252,
    65780,
    209499,
    68769,
    203726,
    13249,
    137363,
    48845,
    86823,
    6658,
    5674,
    31881,
    1083,
    1823,
    108676,
    34518,
    166752,
    13791,
    14287,
    91576,
    91429,
    8665,
    11529,
    26401,
    16191,
    91972,
    30964,
    5254,
    28486,
    54697,
    79613,
    66520,
    18447,
    22870,
    45203,
    194466,
    22822,
    51703,
    12278,
    76716,
    44595,
    73455,
    33546,
    12235,
    144843,
    36154,
    51247,
    11116,
    33040,
    3180,
    225753,
    60864,
    1972,
    28469,
    12891,
    28879,
    10338,
    144157,
    56294,
    353058,
    38302,
    41447,
    87532,
    110616,
    27065,
    168438,
    6557,
    1213,
    50804,
    144643,
    24817,
    2390,
    136531,
    38174,
    247513,
    16190,
    4059,
    122791,
    131994,
    137430,
    39506,
    57650,
    16305,
    5188,
    54309,
    106128,
    20628,
    88071,
    67394,
    395446,
    250285,
    66176,
    91254,
    1399,
    114196,
    43915,
    60230,
    44853,
    27206,
    106353,
    43013,
    18733,
    345105,
    226453,
    51202,
    16607,
    57106,
    117175,
    35492,
    10476,
    89598,
    127439,
    15187,
    39624,
    13688,
    61570,
    10615,
    31111,
    59370,
    6238,
    175252,
    32143,
    224492,
    41388,
    95408,
    34384,
    148238,
    78307,
    38959,
    9340,
    160091,
    61443,
    15737,
    11216,
    41244,
    170,
    38299,
    102443,
    113097,
    26382,
    14027,
    33707,
    3957,
    76300,
    66160,
    19431,
    18900,
    6952,
    1717,
    108656,
    82206,
    188021,
    257335,
    27295,
    43999,
    41210,
    31777,
    46956,
    57457,
    12657,
    11489,
    15697,
    48060,
    204748,
    53583,
    82422,
    284790,
    30503,
    137341,
    8120,
    19615,
    220311,
    15991,
    10217,
    63424,
    9808,
    67431,
    70976,
    98221,
    4491,
    15177,
    28535,
    144789,
    751,
    13230,
    2394,
    1504,
    33977,
    132104,
    30316,
    22230,
    931,
    97193,
    185240,
    24826,
    22687,
    174322,
    15307,
    22988,
    1390,
    188745,
    180325,
    29580,
    59068,
    74903,
    18994,
    29195,
    79,
    15436,
    7622,
    38462,
    11566,
    138710,
    44828,
    45774,
    37768,
    99236,
    68137,
    84083,
    19282,
    22698,
    17134,
    74807,
    126662,
    173497,
    46248,
    16938,
    119735,
    3212,
    28292,
    213652,
    49013,
    9975,
    32180,
    45660,
    86250,
    4801,
    68788,
    95490,
    77482,
    113751,
    11994,
    44624,
    94452,
    46839,
    128497,
    100316,
    5798,
    58588,
    73184,
    202987,
    65417,
    37790,
    88524,
    1606,
    43156,
    97964,
    105717,
    34947,
    11203,
    100060,
    37742,
    130074,
    93653,
    107799,
    94311,
    196106,
    41347,
    8035,
    10780,
    16390,
    27883,
    118236,
    167395,
    1979,
    25006,
    19375,
    31628,
    18916,
    144723,
    78502,
    114047,
    103107,
    86492,
    107686,
    5844,
    20934,
    206963,
    23556,
    22591,
    16562,
    146333,
    20167,
    10471,
    117434,
    33085,
    2863,
    9740,
    36669,
    41849,
    37271,
    22790,
    18209,
    28979,
    8231,
    12952,
    54408,
    21731,
    25130,
    45208,
    55748,
    138120,
    75826,
    414,
    29593,
    9925,
    292865,
    25999,
    683,
    123149,
    7036,
    92159,
    86055,
    61827,
    103680,
    23176,
    54918,
    58466,
    57578,
    13305,
    5709,
    86479,
    16697,
    31064,
    17660,
    200919,
    10770,
    49793,
    33423,
    32370,
    52047,
    16488,
    62555,
    6459,
    8426,
    83493,
    7763,
    59725,
    82812,
    18628,
    67760,
    79405,
    68557,
    9612,
    7673,
    28102,
    56517,
    69620,
    171797,
    32458,
    29541,
    15870,
    81109,
    32080,
    207644,
    71495,
    21202,
    11039,
    91036,
    61230,
    2810,
    130800,
    32260,
    4613,
    60590,
    37112,
    75214,
    33979,
    126402,
    155062,
    30642,
    63875,
    12810,
    194463,
    82799,
    47664,
    16725,
    36685,
    43367,
    61099,
    449,
    172150,
    102867,
    21691,
    301838,
    36745,
    7130,
    18671,
    57316,
    34852,
    38034,
    54182,
    35578,
    65900,
    99486,
    19771,
    3456,
    2658,
    16914,
    99866,
    28390,
    28109,
    8262,
    21147,
    34353,
    20006,
    4228,
    137085,
    1675,
    203023,
    283196,
    198286,
    214375,
    163329,
    290603,
    152574,
    40471,
    83506,
    30068,
    14730,
    23177,
    131539,
    34759,
    27668,
    32178,
    71896,
    104799,
    116305,
    85430,
    119262,
    42860,
    25160,
    8911,
    23428,
    49437,
    105322,
    6519,
    16203,
    6349,
    74711,
    1230,
    38045,
    8540,
    75165,
    44736,
    25909,
    51026,
    317034,
    4984,
    32281,
    91312,
    27060,
    44431,
    17817,
    45363,
    155937,
    239085,
    35697,
    59784,
    91993,
    29531,
    126740,
    213757,
    76560,
    167776,
    285273,
    24262,
    8237,
    65030,
    41160,
    74437,
    48804,
    118916,
    13159,
    37842,
    1031,
    75349,
    1478,
    11655,
    108777,
    23435,
    277425,
    101734,
    67469,
    70231,
    124711,
    43532,
    28514,
    65526,
    54956,
    1e3,
    21882,
    17728,
    25302,
    40952,
    52214,
    149632,
    1999,
    2111,
    3259,
    63362,
    89961,
    220561,
    39777,
    26335,
    9063,
    10572,
    12416,
    34551,
    34623,
    38604,
    24723,
    5947,
    15588,
    69927,
    66252,
    119177,
    69173,
    46629,
    28714,
    70715,
    212408,
    20521,
    406913,
    74380,
    11716,
    50659,
    50862,
    37009,
    88460,
    130101,
    7210,
    53853,
    538,
    65120,
    151950,
    55806,
    163748,
    52837,
    13153,
    21100,
    16674,
    64536,
    6091,
    138201,
    44837,
    58547,
    3723,
    163,
    2177,
    32288,
    85454,
    34033,
    8497,
    14282,
    25742,
    10535,
    10741,
    79559,
    117493,
    243787,
    49337,
    100718,
    79495,
    40139,
    42956,
    7551,
    55433,
    15421,
    31509,
    23034,
    45081,
    547,
    61176,
    53434,
    328001,
    8470,
    36263,
    30145,
    4519,
    74173,
    53935,
    11845,
    73774,
    60211,
    78025,
    3,
    4102,
    73782,
    109293,
    315332,
    48412,
    26683,
    13714,
    6865,
    20128,
    18490,
    104141,
    325,
    39470,
    171970,
    115860,
    15707,
    7268,
    73301,
    74336,
    31370,
    2368,
    111827,
    107757,
    136231,
    142844,
    97138,
    96638,
    84053,
    38691,
    23801,
    1588,
    10573,
    122098,
    77039,
    240,
    186135,
    146101,
    11996,
    18143,
    112963,
    46171,
    155836,
    348769,
    47795,
    121213,
    116266,
    132515,
    3344,
    144804,
    31286,
    99187,
    255838,
    129694,
    35894,
    48779,
    55235,
    148582,
    71967,
    65282,
    15174,
    13920,
    47080,
    6147,
    108242,
    157593,
    125025,
    7136,
    1286,
    28957,
    127956,
    28402,
    98813,
    20805,
    7532,
    109417,
    40610,
    5041,
    32958,
    15142,
    18408,
    108596,
    33543,
    50517,
    27748,
    80114,
    233434,
    91447,
    487,
    37094,
    100048,
    30541,
    43477,
    10639,
    89862,
    155868,
    37667,
    8726,
    60684,
    237903,
    73408,
    99589,
    12190,
    38739,
    97348,
    3914,
    13594,
    2680,
    149016,
    13907,
    30171,
    28343,
    23530,
    115225,
    61104,
    35821,
    147679,
    14337,
    4297,
    244282,
    24085,
    326976,
    56428,
    7851,
    21303,
    131620,
    71446,
    83253,
    68692,
    111870,
    5224,
    15813,
    38197,
    49026,
    45057,
    13660,
    3306,
    76345,
    40671,
    27905,
    91072,
    996,
    68527,
    62085,
    91351,
    122634,
    55109,
    168209,
    2024,
    27560,
    112707,
    17352,
    8306,
    167115,
    169921,
    166958,
    5031,
    46020,
    11844,
    67284,
    19130,
    76185,
    6920,
    32849,
    5450,
    14610,
    22451,
    21002,
    17392,
    31872,
    66682,
    84796,
    13709,
    40210,
    59898,
    12029,
    8719,
    53564,
    21462,
    91884,
    21647,
    88379,
    194428,
    12754,
    37797,
    132826,
    160016,
    22567,
    54383,
    53186,
    77611,
    31107,
    8339,
    4694,
    19185,
    90355,
    23597,
    17222,
    140675,
    28442,
    23668,
    55977,
    9128,
    61555,
    28774,
    155229,
    17658,
    9390,
    24379,
    69357,
    15752,
    127381,
    239631,
    62460,
    93181,
    55913,
    45133,
    140155,
    18676,
    25249,
    33164,
    29581,
    82837,
    67223,
    22362,
    29975,
    7317,
    52813,
    1943,
    29613,
    20012,
    207130,
    49617,
    49651,
    5636,
    15334,
    36313,
    29226,
    28084,
    95247,
    72072,
    19e3,
    224932,
    15811,
    114,
    32127,
    38097,
    37508,
    88507,
    37225,
    27359,
    91626,
    12193,
    69279,
    20608,
    11055,
    88156,
    92808,
    2152,
    57259,
    55275,
    72789,
    24475,
    104414,
    1708,
    9882,
    3818,
    48661,
    66897,
    1631,
    34806,
    227930,
    85815,
    87753,
    18321,
    250664,
    72733,
    25107,
    206797,
    50891,
    8082,
    196411,
    92596,
    96764,
    152823,
    65514,
    22819,
    387277,
    62176,
    51225,
    40329,
    15563,
    189,
    3659,
    73670,
    64357,
    51793,
    275136,
    33482,
    86653,
    74615,
    67058,
    11318,
    125720,
    15388,
    22388,
    8267,
    1730,
    102663,
    170910,
    40784,
    7144,
    85373,
    13040,
    7088,
    94309,
    583,
    44224,
    140424,
    77439,
    18496,
    164026,
    36578,
    4722,
    9151,
    5824,
    63365,
    26510,
    35199,
    40500,
    79277,
    32495,
    44614,
    35233,
    9566,
    203293,
    152144,
    7097,
    2330,
    183480,
    98629,
    13423,
    330887,
    44130,
    68600,
    30939,
    97829,
    31012,
    345465,
    56747,
    94879,
    4939,
    160027,
    149761,
    99423,
    46099,
    32251,
    15332,
    8761,
    96094,
    128555,
    5763,
    235318,
    222223,
    55729,
    30241,
    55420,
    201746,
    3987,
    81382,
    8259,
    49325,
    23287,
    7719,
    24633,
    251100,
    92311,
    18591,
    110533,
    64759,
    170260,
    393860,
    7175,
    21144,
    132887,
    3593,
    75346,
    101277,
    91109,
    16387,
    259187,
    11627,
    57459,
    173829,
    44694,
    55780,
    49797,
    89192,
    120443,
    62622,
    3904,
    14814,
    23887,
    1027,
    112258,
    64955,
    99800,
    11132,
    66353,
    36202,
    48624,
    18158,
    88481,
    96882,
    43059,
    11040,
    2455,
    7077,
    21651,
    181159,
    99126,
    100434,
    61388,
    68186,
    19161,
    110468,
    120052,
    8819,
    55324,
    41494,
    7014,
    37689,
    3618,
    87729,
    92615,
    207943,
    9823,
    128657,
    12587,
    15857,
    6379,
    67628,
    51216,
    71775,
    157617,
    63244,
    1503,
    3864,
    218754,
    110864,
    5769,
    21492,
    7243,
    1192,
    87921,
    85529,
    31512,
    18537,
    42698,
    35350,
    73510,
    84474,
    34301,
    8991,
    21013,
    35034,
    566,
    38832,
    19838,
    35586,
    37216,
    39413,
    55006,
    12178,
    59742,
    856,
    84563,
    6900,
    25632,
    17437,
    49786,
    30723,
    13847,
    70845,
    4044,
    7843,
    23944,
    235976,
    55530,
    48942,
    6518,
    20939,
    73769,
    192653,
    52936,
    95207,
    23895,
    132542,
    142982,
    22632,
    87452,
    48042,
    54018,
    178468,
    10728,
    26230,
    23559,
    363,
    81269,
    142012,
    5718,
    346258,
    31456,
    84333,
    246476,
    51018,
    66692,
    101804,
    120570,
    39962,
    30373,
    70593,
    2864,
    60541,
    19425,
    54209,
    104092,
    7201,
    31545,
    48018,
    25865,
    15442,
    46257,
    40443,
    8328,
    6451,
    111782,
    47527,
    97754,
    33046,
    470,
    245116,
    31095,
    39,
    91934,
    87208,
    73470,
    36708,
    36521,
    12801,
    70624,
    36272,
    8892,
    79768,
    12427,
    55454,
    103756,
    5908,
    52390,
    62962,
    22720,
    141138,
    94634,
    41689,
    128402,
    126390,
    6628,
    106394,
    35527,
    134394,
    82727,
    254651,
    194502,
    148064,
    89549,
    3202,
    28359,
    957,
    21954,
    27906,
    49840,
    142747,
    8307,
    24206,
    48978,
    1186,
    71728,
    133038,
    71474,
    91306,
    6333,
    110959,
    74600,
    70387,
    18983,
    62609,
    56057,
    22970,
    1147,
    135850,
    1321,
    28834,
    3578,
    59715,
    102227,
    32827,
    81415,
    99952,
    55636,
    257598,
    390,
    22702,
    35701,
    85872,
    402916,
    39216,
    189795,
    14929,
    19467,
    10112,
    144422,
    61514,
    5279,
    63421,
    134686,
    41436,
    8424,
    51925,
    10598,
    132295,
    124416,
    4604,
    194739,
    210929,
    57866,
    31829,
    51626,
    50007,
    9976,
    91878,
    61906,
    56168,
    81906,
    60918,
    61859,
    40017,
    23059,
    16887,
    40927,
    62064,
    12785,
    32893,
    32913,
    21782,
    93965,
    20169,
    44387,
    79084,
    38463,
    11457,
    93950,
    27127,
    157050,
    2697,
    337088,
    5116,
    54128,
    48255,
    33279,
    8821,
    27352,
    25515,
    124022,
    65710,
    28906,
    38557,
    33390,
    1722,
    104435,
    72215,
    38551,
    12094,
    30978,
    25113,
    6671,
    37355,
    175109,
    42862,
    98024,
    65406,
    221276,
    59624,
    118012,
    64637,
    78760,
    86697,
    21426,
    1639,
    40350,
    12584,
    67193,
    84144,
    31396,
    7863,
    143011,
    69629,
    63112,
    9454,
    28666,
    65798,
    46372,
    134721,
    6314,
    51402,
    30837,
    151922,
    2847,
    38676,
    38008,
    92823,
    136245,
    17540,
    5504,
    109295,
    205242,
    37606,
    5211,
    214892,
    1586,
    20670,
    208711,
    137743,
    19328,
    40652,
    16995,
    20023,
    14657,
    154919,
    34422,
    12996,
    13918,
    38221,
    47690,
    16398,
    2959,
    37680,
    89122,
    6721,
    198469,
    91876,
    172043,
    83898,
    101992,
    26084,
    94570,
    3635,
    76958,
    22853,
    76497,
    38266,
    176590,
    168403,
    44464,
    142840,
    79180,
    184594,
    1984,
    41806,
    83147,
    11985,
    6546,
    366068,
    59732,
    24533,
    271505,
    8736,
    39084,
    222992,
    93429,
    28962,
    58985,
    86665,
    8432,
    30028,
    14548,
    32439,
    54424,
    165029,
    55175,
    27458,
    69046,
    121277,
    46168,
    33732,
    20661,
    24581,
    135574,
    123110,
    37556,
    79260,
    72611,
    16957,
    12939,
    46162,
    58238,
    44907,
    72936,
    253758,
    41324,
    32518,
    96480,
    11949,
    124438,
    65280,
    43256,
    34107,
    53533,
    43531,
    37037,
    28366,
    45970,
    32741,
    173438,
    6121,
    194202,
    62969,
    26355,
    30314,
    58370,
    28455,
    1848,
    50519,
    82830,
    90393,
    21761,
    295490,
    10936,
    256940,
    133568,
    44050,
    20269,
    4089,
    27457,
    21610,
    219460,
    36743,
    14821,
    101388,
    52005,
    13124,
    30979,
    140816,
    167362,
    26054,
    18458,
    60789,
    34917,
    40447,
    26606,
    33422,
    9066,
    3452,
    83614,
    5761,
    20263,
    137238,
    25038,
    91310,
    101,
    52322,
    74548,
    42572,
    38084,
    214054,
    186568,
    31802,
    17665,
    30620,
    141936,
    37730,
    14420,
    4265,
    187218,
    49640,
    188208,
    51441,
    55388,
    96452,
    66659,
    40869,
    42039,
    60967,
    221027,
    19234,
    178581,
    29105,
    96050,
    9165,
    196118,
    157335,
    3738,
    40354,
    117436,
    2965,
    34136,
    59659,
    15570,
    50843,
    230035,
    31444,
    71260,
    43886,
    18316,
    5387,
    38500,
    168508,
    17406,
    32174,
    8828,
    103373,
    143806,
    90367,
    3560,
    18719,
    122310,
    16508,
    26719,
    2541,
    105429,
    6645,
    37998,
    73190,
    10591,
    235916,
    49737,
    87112,
    233941,
    53188,
    32193,
    79154,
    4544,
    52905,
    126477,
    7580,
    63501,
    57314,
    3216,
    31337,
    6541,
    103083,
    60846,
    49,
    9756,
    15481,
    1355,
    43840,
    14319,
    13743,
    27486,
    10222,
    73114,
    230718,
    418644,
    16706,
    6674,
    279748,
    23058,
    45273,
    295831,
    86306,
    2743,
    5535,
    88773,
    21829,
    35253,
    120938,
    31153,
    3169,
    16839,
    42847,
    8751,
    80974,
    33942,
    36867,
    35514,
    16485,
    26474,
    77775,
    56877,
    5391,
    48346,
    3882,
    108713,
    31403,
    27804,
    55248,
    26235,
    43821,
    136104,
    40118,
    175507,
    28034,
    203908,
    18732,
    1788,
    34030,
    106427,
    36958,
    54359,
    7251,
    44936,
    15356,
    69139,
    455,
    157915,
    22173,
    140291,
    50348,
    43275,
    82066,
    49621,
    54952,
    15216,
    36226,
    96695,
    66855,
    6936,
    1987,
    8227,
    196087,
    4631,
    68827,
    99004,
    47541,
    110265,
    17953,
    147605,
    110242,
    58520,
    31312,
    38724,
    329975,
    642,
    3155,
    34497,
    75937,
    6207,
    73843,
    6120,
    17249,
    51429,
    117746,
    3218,
    910,
    68961,
    319671,
    14938,
    29555,
    34700,
    1649,
    66673,
    72268,
    9655,
    76800,
    153087,
    6941,
    210168,
    27130,
    35398,
    1780,
    73242,
    3135,
    56689,
    19556,
    165307,
    8765,
    35967,
    121458,
    13333,
    70453,
    17350,
    117253,
    22265,
    13340,
    44265,
    39869,
    441,
    3742,
    135025,
    23581,
    33309,
    16543,
    17731,
    13291,
    157637,
    283005,
    21408,
    101360,
    63887,
    52312,
    83873,
    5338,
    233779,
    23759,
    186949,
    34531,
    177320,
    38069,
    156465,
    91004,
    19353,
    59852,
    68160,
    14891,
    1338,
    1072,
    29823,
    1950,
    28901,
    81407,
    313445,
    73038,
    84807,
    162348,
    240257,
    37162,
    138934,
    16111,
    58013,
    41253,
    102951,
    16457,
    96056,
    19541,
    56402,
    67217,
    41638,
    94381,
    89674,
    29481,
    37456,
    80815,
    151579,
    13937,
    13683,
    132537,
    19699,
    134545,
    67020,
    29816,
    222341,
    141235,
    427578,
    48868,
    129557,
    233342,
    23077,
    87871,
    16213,
    18728,
    16184,
    9469,
    37913,
    19680,
    2798,
    171356,
    178328,
    13216,
    50049,
    72690,
    71904,
    124644,
    55455,
    7504,
    29052,
    41036,
    266546,
    19899,
    30391,
    188755,
    8659,
    59469,
    16,
    104298,
    112943,
    53865,
    76203,
    138226,
    68857,
    139953,
    14125,
    107625,
    119795,
    173133,
    4398,
    50273,
    48808,
    54390,
    16466,
    122086,
    31835,
    67035,
    50971,
    48859,
    7508,
    46427,
    66477,
    73021,
    84615,
    39985,
    83076,
    46779,
    201569,
    53336,
    36443,
    60865,
    168164,
    143810,
    51393,
    25548,
    169307,
    32896,
    24485,
    38424,
    21837,
    29087,
    275813,
    51674,
    6714,
    64883,
    46169,
    187369,
    55186,
    76192,
    12852,
    12018,
    62134,
    31067,
    118303,
    16542,
    12125,
    10579,
    4928,
    26291,
    43854,
    7091,
    10946,
    253716,
    109062,
    39283,
    17261,
    113012,
    258512,
    47764,
    125126,
    32646,
    55892,
    80279,
    201623,
    149872,
    3192,
    385,
    1208,
    48750,
    5376,
    58738,
    22335,
    5427,
    82416,
    47811,
    32435,
    143086,
    38930,
    94128,
    59975,
    156037,
    37977,
    38224,
    62485,
    7698,
    50405,
    71027,
    16462,
    21559,
    136153,
    34131,
    107506,
    162069,
    63703,
    3101,
    215029,
    40407,
    4178,
    3774,
    9187,
    80019,
    17880,
    97926,
    67579,
    2600,
    18405,
    8351,
    47924,
    86638,
    70820,
    92206,
    86453,
    29610,
    42241,
    119200,
    3198,
    15466,
    67813,
    57863,
    35454,
    4779,
    99518,
    4649,
    104641,
    144269,
    33730,
    38073,
    65864,
    6838,
    109456,
    193298,
    154007,
    5623,
    45741,
    30846,
    182578,
    25573,
    157224,
    1543,
    58575,
    138703,
    146140,
    44971,
    49356,
    18275,
    59064,
    20300,
    13122,
    11848,
    24453,
    11973,
    9797,
    86843,
    2919,
    25530,
    49210,
    1130,
    161220,
    76788,
    75373,
    85604,
    34926,
    36014,
    17777,
    17255,
    51533,
    11676,
    92226,
    51845,
    119859,
    21525,
    5936,
    18507,
    28050,
    1140,
    31418,
    14857,
    34207,
    47859,
    10750,
    36382,
    32079,
    106909,
    59426,
    87757,
    38393,
    110042,
    15965,
    97104,
    33757,
    35344,
    97993,
    53979,
    33651,
    45407,
    41884,
    82515,
    173089,
    7177,
    58371,
    35365,
    47543,
    51927,
    35587,
    10670,
    23544,
    29306,
    84233,
    39976,
    76076,
    62097,
    9007,
    8668,
    28119,
    78281,
    120790,
    19835,
    143020,
    54968,
    18670,
    64959,
    20649,
    34469,
    42570,
    33001,
    136570,
    87796,
    120044,
    1106,
    58700,
    63951,
    127623,
    12805,
    83057,
    40212,
    31773,
    49850,
    7361,
    54336,
    347524,
    101314,
    23751,
    19569,
    48791,
    29174,
    49369,
    20467,
    7465,
    75842,
    38281,
    623,
    112457,
    60210,
    28849,
    51003,
    94720,
    6426,
    90047,
    85560,
    43761,
    3579,
    85105,
    34607,
    90410,
    118528,
    7224,
    42907,
    111163,
    18168,
    6960,
    161135,
    191298,
    5247,
    100584,
    127552,
    171568,
    20121,
    91173,
    12636,
    54615,
    20199,
    63730,
    98105,
    2396,
    40387,
    14438,
    125012,
    4765,
    33235,
    12865,
    45299,
    37728,
    82098,
    77872,
    114037,
    59253,
    19675,
    24838,
    398016,
    102561,
    11446,
    17069,
    57508,
    178277,
    65836,
    99941,
    26114,
    2585,
    271882,
    136866,
    50126,
    11027,
    155648,
    118367,
    14585,
    8910,
    123015,
    335383,
    40434,
    41016,
    53021,
    14439,
    87098,
    176860,
    201543,
    121888,
    2358,
    9286,
    5739,
    22666,
    54270,
    37884,
    169381,
    33984,
    93859,
    16124,
    89364,
    72207,
    51639,
    76366,
    99029,
    65812,
    2198,
    12147,
    174891,
    194289,
    6986,
    30252,
    88822,
    21284,
    11445,
    288337,
    160821,
    33034,
    100869,
    43852,
    25761,
    52882,
    1144,
    103809,
    1924,
    84458,
    86079,
    43411,
    13542,
    139276,
    18141,
    34978,
    41298,
    7276,
    26481,
    173800,
    33210,
    17951,
    142652,
    33616,
    33677,
    2210,
    19941,
    98568,
    2486,
    192414,
    80136,
    12058,
    235883,
    50963,
    249638,
    29572,
    27221,
    47034,
    6124,
    72107,
    63346,
    97620,
    158513,
    299699,
    40388,
    23235,
    37176,
    224244,
    198386,
    121323,
    67992,
    23827,
    63170,
    17838,
    106622,
    158590,
    26807,
    5345,
    23489,
    91891,
    55474,
    74834,
    37981,
    13058,
    5977,
    72552,
    34706,
    26828,
    145172,
    19904,
    21367,
    34043,
    960,
    77092,
    91381,
    4733,
    47446,
    7680,
    41697,
    5170,
    16960,
    14741,
    46101,
    13656,
    473,
    51842,
    37433,
    11103,
    11551,
    121951,
    13191,
    97536,
    165932,
    50397,
    51628,
    129028,
    9069,
    44885,
    6590,
    59195,
    47045,
    32940,
    225472,
    90345,
    21833,
    13303,
    29407,
    96615,
    141951,
    5198,
    6028,
    18395,
    7181,
    3861,
    14966,
    156358,
    167182,
    36529,
    55253,
    25942,
    173153,
    30959,
    27261,
    50691,
    150176,
    162201,
    38467,
    48462,
    80602,
    42163,
    118482,
    168,
    108756,
    26011,
    17166,
    54149,
    456538,
    22512,
    91374,
    13816,
    90358,
    131615,
    18132,
    226707,
    1824,
    28139,
    26860,
    42253,
    93877,
    77351,
    65575,
    8980,
    80574,
    22020,
    27948,
    40422,
    91324,
    76376,
    13528,
    39281,
    91685,
    82215,
    122541,
    144066,
    1983,
    193851,
    17283,
    26320,
    2739,
    194978,
    4790,
    26845,
    42627,
    61300,
    65815,
    174612,
    55133,
    4200,
    191130,
    79771,
    158321,
    52280,
    166796,
    221620,
    62461,
    11278,
    4067,
    88152,
    83409,
    31717,
    121367,
    13522,
    47325,
    37945,
    10406,
    174348,
    249321,
    154101,
    64912,
    29938,
    51775,
    17220,
    15776,
    166138,
    78890,
    84425,
    54121,
    42861,
    16368,
    24572,
    291647,
    10197,
    32073,
    22651,
    11677,
    97509,
    26952,
    35787,
    18424,
    41910,
    71614,
    94977,
    72318,
    41594,
    70024,
    275419,
    37702,
    60199,
    7335,
    39107,
    61315,
    18271,
    18394,
    33768,
    87884,
    104277,
    123724,
    7277,
    56288,
    71981,
    189803,
    49320,
    3352,
    6798,
    14240,
    8954,
    69220,
    94433,
    57372,
    28620,
    68863,
    193727,
    85575,
    42309,
    41667,
    67689,
    42081,
    22543,
    44824,
    12719,
    28540,
    114236,
    101553,
    27638,
    27296,
    4300,
    5353,
    4663,
    19379,
    94098,
    3758,
    95888,
    95144,
    80344,
    87320,
    28447,
    259518,
    12718,
    71391,
    152731,
    37063,
    24132,
    31911,
    104896,
    15672,
    103782,
    1521,
    4945,
    72541,
    23717,
    122632,
    15619,
    87175,
    206120,
    29428,
    189780,
    61416,
    28350,
    44457,
    972,
    1175,
    47233,
    198738,
    95789,
    41907,
    21953,
    97034,
    59341,
    22864,
    53713,
    16873,
    32971,
    20693,
    20954,
    31336,
    21477,
    16169,
    38370,
    16412,
    9019,
    3841,
    24599,
    21938,
    17085,
    6484,
    81198,
    76413,
    5849,
    72514,
    12320,
    65247,
    276175,
    37234,
    59796,
    52642,
    16312,
    57349,
    198507,
    94148,
    46134,
    18958,
    125552,
    1747,
    18725,
    151873,
    14901,
    5490,
    68287,
    29470,
    3689,
    64794,
    40814,
    26018,
    25692,
    54450,
    2703,
    88278,
    124886,
    173087,
    174e3,
    24159,
    179477,
    24276,
    46004,
    201876,
    209202,
    445,
    52876,
    31948,
    30206,
    157610,
    39180,
    18439,
    44124,
    50469,
    5774,
    96278,
    222758,
    200216,
    50290,
    45486,
    20435,
    46986,
    46276,
    140133,
    142326,
    15569,
    13363,
    47522,
    92583,
    2182,
    7135,
    16853,
    22998,
    30272,
    4952,
    63263,
    35623,
    39096,
    53789,
    44864,
    20053,
    110392,
    124213,
    4630,
    16087,
    28221,
    127787,
    25839,
    77481,
    44693,
    13464,
    113146,
    6983,
    27069,
    55717,
    50102,
    4760,
    7107,
    26186,
    66507,
    59145,
    36032,
    104182,
    71328,
    29425,
    64317,
    50781,
    47465,
    94298,
    69706,
    74899,
    22754,
    120756,
    25108,
    93077,
    56834,
    73286,
    39928,
    16218,
    41699,
    176763,
    7555,
    70819,
    50083,
    26895,
    23315,
    26014,
    16773,
    123079,
    41712,
    5719,
    31516,
    90427,
    158540,
    85051,
    183128,
    40864,
    27505,
    55392,
    9058,
    45224,
    96857,
    30901,
    136622,
    96557,
    56304,
    120061,
    11501,
    151448,
    5773,
    89743,
    7769,
    86069,
    2935,
    18471,
    41628,
    10114,
    33660,
    110170,
    49479,
    26745,
    92846,
    33221,
    26731,
    18795,
    87076,
    8550,
    2100,
    29972,
    120289,
    3077,
    72490,
    33784,
    2630,
    208722,
    50861,
    63483,
    79029,
    6419,
    39467,
    14302,
    45286,
    64207,
    9686,
    67513,
    44170,
    1050,
    77246,
    59266,
    17055,
    53801,
    7150,
    11111,
    42432,
    4278,
    94579,
    362117,
    36175,
    42902,
    41933,
    39002,
    98489,
    22913,
    74161,
    84773,
    57036,
    17556,
    162288,
    74485,
    178760,
    93867,
    73635,
    128860,
    50362,
    261,
    67455,
    80001,
    46080,
    35662,
    4368,
    25247,
    19230,
    74393,
    22588,
    1822,
    27682,
    235324,
    13798,
    85998,
    13194,
    235067,
    23514,
    71669,
    147632,
    23191,
    134748,
    214683,
    105101,
    1518,
    25489,
    247114,
    7380,
    54842,
    26922,
    3971,
    26361,
    20844,
    68642,
    170517,
    77339,
    123255,
    8963,
    77818,
    150998,
    48466,
    36806,
    2732,
    23261,
    11741,
    236162,
    18243,
    126216,
    28690,
    50546,
    16385,
    92760,
    197383,
    246558,
    201295,
    88255,
    67588,
    71687,
    176076,
    172653,
    169058,
    33906,
    63747,
    24835,
    157621,
    43338,
    30050,
    46152,
    132741,
    2770,
    51371,
    94835,
    6614,
    15112,
    11749,
    56936,
    1250,
    19027,
    399017,
    58036,
    100215,
    23388,
    55815,
    308768,
    124152,
    94803,
    9521,
    64186,
    8971,
    28,
    30427,
    62163,
    7616,
    103838,
    35079,
    29203,
    131235,
    7743,
    17389,
    10882,
    37420,
    61460,
    228512,
    85363,
    41581,
    131077,
    62822,
    119647,
    10130,
    54445,
    26925,
    19968,
    29016,
    24446,
    74028,
    24176,
    61448,
    67185,
    9254,
    8563,
    119129,
    9771,
    99184,
    37716,
    39514,
    10532,
    221512,
    258753,
    218630,
    55980,
    23394,
    32141,
    61924,
    66749,
    32411,
    3741,
    36475,
    26678,
    77010,
    44946,
    91203,
    128749,
    116953,
    20476,
    49625,
    53116,
    13735,
    102335,
    29376,
    51946,
    83407,
    67892,
    59212,
    34685,
    21083,
    1546,
    112982,
    32972,
    74397,
    1078,
    190545,
    16082,
    86140,
    58591,
    89611,
    101531,
    10061,
    105104,
    76319,
    20035,
    17551,
    52611,
    169061,
    190842,
    100780,
    23907,
    90413,
    115619,
    9675,
    34710,
    193435,
    49443,
    129734,
    11183,
    258877,
    16318,
    136182,
    126808,
    44635,
    27304,
    192375,
    2599,
    125648,
    47051,
    12091,
    23814,
    721,
    58800,
    40137,
    66726,
    97930,
    60877,
    74487,
    7942,
    54326,
    9841,
    41428,
    13762,
    8211,
    85383,
    6950,
    99177,
    79806,
    201786,
    296464,
    124087,
    13144,
    29741,
    41721,
    47634,
    55088,
    254286,
    106408,
    17041,
    99064,
    12942,
    64086,
    45233,
    14005,
    2612,
    55827,
    255,
    7984,
    13980,
    38574,
    12776,
    46654,
    73499,
    249951,
    2101,
    26676,
    25996,
    132326,
    116415,
    119062,
    50449,
    31033,
    23038,
    11589,
    179252,
    20007,
    14860,
    129270,
    21143,
    17796,
    144715,
    60106,
    70758,
    69842,
    34674,
    282133,
    44014,
    16774,
    57268,
    38528,
    24053,
    46373,
    201667,
    28327,
    471023,
    51889,
    102667,
    21193,
    114909,
    84132,
    69317,
    96723,
    67969,
    16134,
    68145,
    15058,
    28765,
    32035,
    2524,
    101089,
    98664,
    25045,
    76571,
    14957,
    86040,
    118506,
    262428,
    154764,
    81573,
    39681,
    283900,
    73287,
    127825,
    544,
    80448,
    52347,
    38512,
    175971,
    15180,
    45467,
    33086,
    46552,
    48894,
    81107,
    43213,
    36672,
    54025,
    76703,
    8053,
    7608,
    13299,
    56619,
    20752,
    238099,
    54164,
    105133,
    1444,
    32942,
    953,
    37564,
    8e3,
    66316,
    119463,
    106817,
    404,
    13667,
    149108,
    128597,
    31267,
    10269,
    49836,
    106150,
    1484,
    52330,
    76965,
    160486,
    171648,
    38456,
    31263,
    22424,
    37738,
    66245,
    67467,
    143369,
    60471,
    75610,
    20895,
    115528,
    86070,
    60854,
    40796,
    49347,
    18989,
    15030,
    11371,
    37578,
    15779,
    79867,
    10187,
    86462,
    46402,
    155626,
    93200,
    40229,
    7090,
    57547,
    108053,
    99598,
    11088,
    47505,
    41218,
    206017,
    2173,
    20988,
    30219,
    22919,
    80563,
    57566,
    42369,
    93141,
    41675,
    2407,
    182519,
    120495,
    27154,
    16702,
    29456,
    14349,
    7958,
    16688,
    117177,
    140375,
    42467,
    261919,
    74916,
    153569,
    10836,
    34742,
    49526,
    7621,
    105997,
    12212,
    2270,
    392377,
    7755,
    17959,
    25086,
    232152,
    138791,
    33847,
    13860,
    35316,
    5811,
    1344,
    71259,
    50452,
    207539,
    92635,
    50359,
    5821,
    33674,
    30255,
    2086,
    2587,
    96264,
    17543,
    42,
    6029,
    9580,
    43007,
    139248,
    82831,
    12917,
    29607,
    25786,
    51467,
    42137,
    85161,
    100698,
    31561,
    88989,
    121990,
    278500,
    3602,
    109344,
    37982,
    15279,
    116442,
    28936,
    30880,
    87894,
    58079,
    128661,
    126731,
    67392,
    28051,
    146885,
    4861,
    16216,
    97344,
    42827,
    147561,
    153948,
    22684,
    21335,
    47685,
    1853,
    43349,
    15185,
    59642,
    10229,
    25520,
    187921,
    108972,
    5579,
    98037,
    24945,
    6697,
    19193,
    63734,
    137934,
    75056,
    89740,
    19767,
    224268,
    56138,
    63643,
    151661,
    39313,
    70618,
    84031,
    89723,
    84074,
    13703,
    85626,
    35460,
    8867,
    64845,
    3439,
    57906,
    99776,
    63968,
    49270,
    81130,
    34356,
    16210,
    23547,
    36446,
    34090,
    140028,
    72439,
    2221,
    22163,
    57058,
    363492,
    113754,
    18913,
    95451,
    48663,
    54464,
    54037,
    176097,
    68425,
    3023,
    34906,
    29482,
    117389,
    341780,
    80431,
    58330,
    16753,
    92616,
    60907,
    94846,
    147486,
    4498,
    48646,
    7773,
    46801,
    7778,
    18946,
    464978,
    47558,
    33223,
    177444,
    7328,
    15626,
    63337,
    94700,
    11743,
    9351,
    255024,
    39098,
    16447,
    42647,
    96230,
    39769,
    58840,
    10068,
    63439,
    35800,
    65843,
    58823,
    413844,
    9156,
    51258,
    7434,
    61791,
    85018,
    6872,
    3692,
    28096,
    7121,
    33024,
    6009,
    75532,
    31997,
    192535,
    9661,
    3304,
    9547,
    14753,
    31987,
    25314,
    55689,
    15896,
    20430,
    39472,
    31340,
    99744,
    25398,
    115569,
    54883,
    28719,
    205423,
    23071,
    57855,
    64638,
    149867,
    25671,
    82403,
    37616,
    20668,
    39989,
    77996,
    74948,
    140555,
    175248,
    64810,
    36515,
    46595,
    4958,
    248773,
    24045,
    28728,
    136673,
    168704,
    20804,
    114833,
    100325,
    27135,
    21205,
    96151,
    153134,
    45992,
    7093,
    13992,
    76047,
    1980,
    19432,
    145001,
    75159,
    87462,
    17710,
    1013,
    45556,
    34297,
    144882,
    20648,
    26061,
    11319,
    129567,
    108555,
    18872,
    464580,
    33386,
    22717,
    65948,
    167189,
    5603,
    135042,
    79542,
    8801,
    202632,
    18114,
    91882,
    5973,
    5239,
    67315,
    4431,
    60916,
    47819,
    71693,
    32597,
    32606,
    18183,
    45072,
    80329,
    76385,
    24749,
    51305,
    40314,
    156514,
    14693,
    130345,
    13168,
    66214,
    18029,
    12858,
    34801,
    27628,
    14544,
    10823,
    40522,
    40185,
    33739,
    148694,
    23548,
    9923,
    61012,
    28859,
    17933,
    19442,
    34364,
    99849,
    164107,
    141167,
    30629,
    21054,
    6744,
    36491,
    8096,
    42474,
    41706,
    155060,
    30650,
    10600,
    163442,
    1143,
    96655,
    61390,
    52359,
    7559,
    51568,
    64256,
    203854,
    4467,
    22453,
    14504,
    436398,
    7878,
    6980,
    8293,
    63610,
    293747,
    16167,
    35763,
    19627,
    147603,
    15419,
    18032,
    110744,
    51346,
    33681,
    54571,
    40472,
    48615,
    39073,
    21604,
    13754,
    173027,
    92560,
    11083,
    47299,
    63062,
    11813,
    52007,
    29883,
    9734,
    139722,
    15953,
    1550,
    20651,
    13616,
    49306,
    16113,
    90089,
    92326,
    7584,
    30712,
    72424,
    164858,
    6831,
    152871,
    55746,
    197721,
    34167,
    196442,
    6022,
    112107,
    55215,
    7538,
    123381,
    4920,
    43539,
    77165,
    8939,
    50392,
    34192,
    20225,
    79762,
    22505,
    58667,
    40770,
    29788,
    97180,
    82835,
    4568,
    8579,
    13273,
    363569,
    35898,
    49983,
    436,
    36598,
    3237,
    131691,
    62418,
    35591,
    8101,
    4073,
    379438,
    65218,
    76072,
    33887,
    2968,
    27573,
    212619,
    288680,
    68278,
    72851,
    150504,
    217896,
    6913,
    121339,
    22017,
    35340,
    51072,
    43616,
    75043,
    31437,
    10833,
    81487,
    4364,
    22968,
    41454,
    106687,
    85446,
    19863,
    109625,
    149241,
    524,
    141850,
    214404,
    54376,
    657,
    237023,
    9401,
    108137,
    53800,
    32474,
    49712,
    53334,
    126876,
    27337,
    45552,
    177696,
    8269,
    15036,
    12097,
    42240,
    2328,
    125374,
    119295,
    99715,
    2500,
    19624,
    39441,
    27220,
    102691,
    60957,
    94543,
    39101,
    18566,
    67362,
    13975,
    78230,
    25017,
    34017,
    239007,
    90027,
    39351,
    41681,
    35354,
    43822,
    1043,
    916,
    58587,
    141983,
    94818,
    38799,
    75459,
    41114,
    67432,
    16195,
    36606,
    59568,
    22272,
    126769,
    31424,
    68659,
    12287,
    134302,
    257977,
    5756,
    207285,
    95637,
    47248,
    117689,
    19583,
    77451,
    22373,
    12200,
    54993,
    117118,
    34244,
    29386,
    34562,
    53819,
    71267,
    64172,
    77665,
    49368,
    7716,
    59301,
    25749,
    45426,
    194789,
    17297,
    2650,
    1766,
    32501,
    45198,
    20403,
    20984,
    6600,
    14171,
    94604,
    19037,
    5402,
    29896,
    9938,
    59935,
    109708,
    88081,
    145182,
    44844,
    39167,
    352626,
    164173,
    35374,
    45982,
    6122,
    154,
    73419,
    220487,
    53834,
    53601,
    17992,
    8609,
    229321,
    5610,
    68098,
    66815,
    71012,
    95069,
    140968,
    27396,
    8957,
    134489,
    24656,
    86659,
    56598,
    134852,
    17316,
    123838,
    255436,
    6613,
    41610,
    138033,
    81452,
    32023,
    32396,
    123687,
    63398,
    8693,
    29712,
    30407,
    19296,
    121188,
    3551,
    36099,
    20032,
    111948,
    56624,
    16547,
    27453,
    35916,
    15378,
    52039,
    56849,
    13489,
    22214,
    73177,
    53097,
    277349,
    2157,
    14029,
    187886,
    10260,
    141743,
    246460,
    91880,
    50869,
    3788,
    49486,
    133566,
    54950,
    33120,
    129337,
    53768,
    18333,
    9525,
    26902,
    312251,
    10297,
    9020,
    70759,
    16647,
    112432,
    59260,
    84609,
    9818,
    82766,
    73569,
    468,
    46001,
    75780,
    55028,
    52106,
    11498,
    43645,
    108069,
    17150,
    17753,
    29417,
    16705,
    31799,
    9606,
    289,
    122254,
    115975,
    8620,
    6133,
    255357,
    56908,
    14456,
    133464,
    43554,
    79224,
    11247,
    29630,
    160,
    12756,
    25464,
    65960,
    350428,
    62521,
    321796,
    100359,
    67358,
    35169,
    46172,
    113128,
    48988,
    88868,
    31094,
    33266,
    6847,
    60887,
    98188,
    49659,
    69117,
    92977,
    220228,
    13947,
    80181,
    35103,
    62170,
    97351,
    13475,
    2440,
    199768,
    19498,
    36597,
    46971,
    25234,
    67806,
    62881,
    84717,
    73648,
    181966,
    10488,
    94149,
    21550,
    26655,
    63436,
    48375,
    14405,
    165650,
    9621,
    24439,
    28043,
    42735,
    4490,
    29963,
    56674,
    45373,
    1934,
    262446,
    50855,
    67098,
    26898,
    5261,
    52696,
    40644,
    33900,
    9440,
    180286,
    87162,
    22940,
    19704,
    26936,
    69769,
    10254,
    101759,
    27406,
    12243,
    48e3,
    73926,
    113215,
    54935,
    5726,
    192787,
    4312,
    106216,
    9366,
    11550,
    52949,
    23457,
    212271,
    277152,
    133895,
    108374,
    6191,
    96477,
    29980,
    218916,
    58024,
    54696,
    40853,
    91124,
    65894,
    91170,
    65908,
    252552,
    6793,
    29212,
    15389,
    44516,
    122515,
    52617,
    35058,
    9017,
    103536,
    39510,
    49136,
    19242,
    130652,
    662077,
    74699,
    47024,
    31422,
    8517,
    73351,
    24399,
    13867,
    128360,
    4810,
    4434,
    61779,
    111983,
    61036,
    17798,
    110240,
    59722,
    102960,
    39688,
    10001,
    23803,
    23039,
    176498,
    56659,
    44814,
    134295,
    17188,
    77577,
    74466,
    226175,
    102472,
    154333,
    63900,
    111747,
    18062,
    41171,
    79669,
    32773,
    408933,
    42562,
    28931,
    30907,
    107388,
    43487,
    2946,
    240310,
    23938,
    24354,
    319,
    184983,
    7927,
    6488,
    1422,
    10790,
    68809,
    68209,
    64775,
    4361,
    202,
    17123,
    59634,
    51200,
    44391,
    18188,
    17843,
    2619,
    74278,
    3230,
    9540,
    47187,
    21702,
    36274,
    56894,
    43907,
    16310,
    34790,
    16866,
    6150,
    5561,
    13587,
    107545,
    108873,
    126867,
    86986,
    28640,
    33427,
    19017,
    5762,
    80637,
    17430,
    46903,
    2047,
    131055,
    25958,
    13558,
    5444,
    47152,
    13900,
    44563,
    122857,
    45348,
    70863,
    39593,
    54332,
    38068,
    33637,
    318,
    40310,
    143467,
    18502,
    24520,
    11377,
    62013,
    28942,
    27246,
    28269,
    83545,
    17999,
    59015,
    90707,
    30065,
    15161,
    34720,
    1263,
    37008,
    2012,
    6060,
    98575,
    92933,
    5721,
    299,
    199555,
    24578,
    29223,
    2985,
    743,
    115825,
    109523,
    136657,
    47454,
    26378,
    53586,
    3733,
    174945,
    93340,
    244456,
    5693,
    37386,
    28782,
    89767,
    27545,
    23573,
    18798,
    136425,
    34320,
    84778,
    20041,
    48453,
    38215,
    7477,
    71958,
    40621,
    8773,
    5874,
    187927,
    105965,
    51100,
    43533,
    18083,
    8443,
    10180,
    43597,
    2003,
    183999,
    69689,
    12216,
    129696,
    146188,
    62389,
    34044,
    68410,
    12765,
    43273,
    26949,
    266807,
    3345,
    34477,
    79197,
    5688,
    47539,
    213110,
    21634,
    22257,
    50092,
    32222,
    42346,
    39530,
    63668,
    98,
    134978,
    74022,
    5152,
    59088,
    174145,
    37220,
    9934,
    9545,
    118937,
    5724,
    87240,
    19875,
    15784,
    40143,
    23263,
    87513,
    181654,
    285152,
    37881,
    263241,
    4966,
    43934,
    10433,
    186657,
    6470,
    74416,
    225854,
    25908,
    142677,
    246262,
    32280,
    6192,
    75890,
    45546,
    143264,
    135305,
    29742,
    47013,
    77787,
    11732,
    126658,
    8763,
    37950,
    21806,
    57557,
    113464,
    89465,
    108995,
    164574,
    23894,
    22996,
    23169,
    15369,
    23117,
    17642,
    130607,
    40503,
    36239,
    280990,
    44666,
    9981,
    40427,
    147487,
    26869,
    168452,
    32886,
    32991,
    46798,
    240839,
    15111,
    70502,
    65697,
    88548,
    44145,
    28701,
    48767,
    31139,
    206777,
    35659,
    181164,
    166262,
    14554,
    171445,
    31786,
    66523,
    76607,
    17956,
    6507,
    31279,
    90476,
    116611,
    167918,
    6560,
    1243,
    115324,
    80128,
    41867,
    55897,
    187323,
    37069,
    32596,
    189444,
    145931,
    13390,
    105530,
    65709,
    26805,
    6999,
    55714,
    41300,
    22915,
    68951,
    22138,
    21120,
    22264,
    10058,
    19945,
    33635,
    56123,
    99085,
    10032,
    5818,
    6016,
    46649,
    57476,
    35264,
    94413,
    112522,
    262288,
    93686,
    83038,
    14341,
    23204,
    28807,
    66084,
    77987,
    6101,
    126673,
    7133,
    38126,
    5923,
    122091,
    170240,
    97772,
    46874,
    215746,
    43948,
    41622,
    3272,
    55596,
    8332,
    146411,
    251315,
    13533,
    8561,
    81521,
    115449,
    48616,
    175175,
    2063,
    186556,
    3036,
    134537,
    75772,
    29728,
    82360,
    22973,
    186559,
    86348,
    89100,
    38388,
    82297,
    45610,
    2613,
    87082,
    9986,
    177812,
    57884,
    23591,
    47485,
    42543,
    33582,
    44713,
    74439,
    257444,
    252451,
    31825,
    35631,
    38540,
    33066,
    5147,
    13973,
    4343,
    51830,
    70378,
    22827,
    26448,
    95560,
    36896,
    241741,
    48067,
    203953,
    298860,
    61620,
    20450,
    3220,
    67272,
    6586,
    107662,
    100160,
    108684,
    6929,
    57226,
    4762,
    7457,
    1320,
    40404,
    77204,
    99309,
    62750,
    208653,
    59977,
    44e3,
    74315,
    34332,
    5819,
    172217,
    64904,
    114077,
    18147,
    84012,
    1791,
    98456,
    90930,
    21446,
    116669,
    103938,
    7422,
    85140,
    59713,
    5768,
    326211,
    16239,
    75411,
    13229,
    29398,
    10758,
    236107,
    1539,
    112472,
    95979,
    152154,
    151294,
    306,
    21196,
    38146,
    10700,
    6891,
    84282,
    109646,
    56492,
    40539,
    6589,
    119491,
    51354,
    30685,
    140209,
    136906,
    29622,
    73617,
    49553,
    70525,
    51671,
    166869,
    139616,
    74395,
    37439,
    49595,
    45678,
    11959,
    33211,
    86560,
    52434,
    9282,
    62690,
    112155,
    130810,
    5243,
    108261,
    99970,
    265613,
    72551,
    80049,
    6391,
    33365,
    90721,
    66737,
    69872,
    87011,
    1860,
    9032,
    112544,
    60905,
    37371,
    89015,
    140351,
    19076,
    850,
    373531,
    2802,
    36725,
    218795,
    72062,
    28990,
    16550,
    24614,
    7815,
    6187,
    26336,
    33373,
    32162,
    42791,
    73555,
    32062,
    23386,
    10244,
    56392,
    49442,
    27076,
    136262,
    12412,
    14883,
    1134,
    33675,
    97153,
    199281,
    15608,
    100152,
    74072,
    47942,
    254301,
    36451,
    16026,
    10687,
    65067,
    56708,
    254030,
    30290,
    50490,
    13864,
    57941,
    259331,
    35588,
    23485,
    43486,
    24869,
    21620,
    92971,
    22072,
    88645,
    1048,
    182050,
    13343,
    32452,
    14825,
    19509,
    3325,
    216938,
    45740,
    99716,
    189082,
    53740,
    78245,
    25609,
    24311,
    176777,
    47340,
    308354,
    40669,
    66085,
    14102,
    125339,
    9225,
    128709,
    97207,
    1271,
    200933,
    78439,
    113451,
    88975,
    18324,
    46521,
    11819,
    18570,
    141756,
    72512,
    170020,
    52754,
    63550,
    118515,
    103073,
    93330,
    32736,
    50499,
    14722,
    31600,
    68452,
    398867,
    29316,
    172786,
    18417,
    104924,
    2606,
    5670,
    84818,
    16288,
    67106,
    59580,
    82929,
    607401,
    291,
    85829,
    359,
    15897,
    35830,
    50696,
    65630,
    52672,
    22115,
    356968,
    29895,
    40837,
    231192,
    34024,
    38957,
    26722,
    406,
    23335,
    124952,
    72068,
    68804,
    13268,
    147101,
    164740,
    276569,
    162596,
    66943,
    11569,
    26654,
    66358,
    4777,
    23229,
    102127,
    5848,
    978,
    2921,
    59666,
    5371,
    28212,
    90108,
    42938,
    39320,
    2499,
    4271,
    108792,
    33510,
    125072,
    71653,
    65239,
    38250,
    66357,
    38577,
    13964,
    86251,
    35708,
    50755,
    36010,
    29448,
    12209,
    3844,
    38222,
    206337,
    100876,
    67827,
    137088,
    14167,
    252225,
    84163,
    195270,
    1306,
    5703,
    54198,
    779,
    46802,
    22028,
    51124,
    86759,
    70560,
    113164,
    35685,
    162145,
    45471,
    34561,
    422,
    2611,
    6464,
    47486,
    19223,
    38246,
    9191,
    18331,
    89942,
    243642,
    212364,
    15893,
    17518,
    22617,
    6409,
    30046,
    126182,
    59716,
    36560,
    104428,
    18846,
    26592,
    19458,
    50793,
    147333,
    30826,
    1388,
    27647,
    10922,
    14495,
    33545,
    19269,
    135828,
    39727,
    41601,
    46931,
    233379,
    49169,
    131130,
    182112,
    16276,
    82381,
    118209,
    142445,
    128310,
    19672,
    28740,
    82907,
    33436,
    3118,
    102206,
    28723,
    24819,
    41937,
    38854,
    5157,
    3881,
    111491,
    1142,
    9776,
    421673,
    152241,
    29309,
    14961,
    87854,
    6054,
    15424,
    3796,
    82656,
    54996,
    2108,
    55367,
    239450,
    154525,
    9643,
    118103,
    106041,
    64601,
    68549,
    48707,
    30266,
    25772,
    18740,
    9462,
    229669,
    91798,
    112152,
    191327,
    14493,
    72828,
    8175,
    66636,
    236474,
    25817,
    87351,
    129027,
    76653,
    20422,
    22983,
    71240,
    27846,
    44661,
    12399,
    46158,
    77704,
    53101,
    35032,
    11072,
    17300,
    109294,
    33638,
    24408,
    1895,
    11241,
    760,
    17584,
    82479,
    125877,
    63150,
    141075,
    34259,
    23274,
    81698,
    15732,
    43577,
    48340,
    91584,
    14688,
    16379,
    24481,
    150280,
    96420,
    262050,
    48635,
    43727,
    61819,
    56268,
    72003,
    88178,
    17281,
    79912,
    13218,
    122519,
    125295,
    166396,
    11811,
    2171,
    118930,
    67746,
    17636,
    178278,
    174656,
    95661,
    173039,
    83845,
    79689,
    17473,
    98555,
    127696,
    203415,
    54730,
    22925,
    232239,
    9309,
    12136,
    175026,
    20740,
    180188,
    10747,
    39816,
    314017,
    266131,
    10040,
    175732,
    112550,
    220651,
    31974,
    37393,
    888,
    23008,
    86799,
    4303,
    64905,
    148467,
    75337,
    251,
    3284,
    370102,
    50264,
    9835,
    5438,
    23655,
    4481,
    29851,
    329,
    12855,
    7162,
    64931,
    78141,
    12804,
    42372,
    296771,
    83547,
    18624,
    34874,
    86271,
    3360,
    48665,
    77735,
    88767,
    11463,
    63527,
    28889,
    22258,
    29140,
    194315,
    113924,
    25499,
    6406,
    31334,
    1845,
    4802,
    49184,
    43455,
    35469,
    127594,
    92970,
    61038,
    115005,
    38840,
    87761,
    106838,
    8811,
    20572,
    55637,
    11162,
    96721,
    132425,
    108925,
    2948,
    125457,
    36356,
    3502,
    75270,
    27622,
    127192,
    2561,
    123095,
    49394,
    61155,
    16897,
    110064,
    9699,
    89448,
    53356,
    19628,
    220310,
    21622,
    83036,
    9885,
    112214,
    6087,
    26713,
    17901,
    161912,
    91492,
    3440,
    68594,
    9266,
    92238,
    8087,
    6866,
    150194,
    72175,
    80701,
    13459,
    31836,
    43243,
    239700,
    95846,
    44749,
    50647,
    21945,
    230538,
    120612,
    132371,
    244604,
    5193,
    105637,
    34661,
    41341,
    68775,
    85393,
    1874,
    8771,
    33718,
    49672,
    77403,
    595452,
    99507,
    6490,
    58895,
    128742,
    7704,
    39239,
    73217,
    43816,
    62824,
    37804,
    199976,
    22361,
    80005,
    87514,
    94832,
    14089,
    4574,
    139975,
    59142,
    75523,
    100268,
    43906,
    53442,
    15152,
    2547,
    186002,
    17011,
    19513,
    204282,
    3343,
    60568,
    128318,
    119250,
    4298,
    51871,
    41336,
    71759,
    21921,
    45074,
    98169,
    145889,
    99427,
    11350,
    1237,
    5520,
    28799,
    7803,
    53702,
    21026,
    136352,
    38293,
    128690,
    12158,
    90132,
    44600,
    10184,
    26957,
    39459,
    126025,
    78904,
    82999,
    59373,
    39301,
    150198,
    120529,
    153042,
    20177,
    50089,
    14764,
    271571,
    30530,
    123161,
    38975,
    101562,
    22941,
    5648,
    124654,
    109243,
    69817,
    71675,
    49162,
    106884,
    21241,
    107795,
    30258,
    16572,
    188262,
    141456,
    7688,
    60718,
    8271,
    11044,
    32440,
    104608,
    103419,
    236109,
    93156,
    43293,
    128929,
    42107,
    67180,
    25201,
    115254,
    185488,
    130954,
    72813,
    167547,
    20537,
    39969,
    38432,
    22582,
    184022,
    1139,
    27199,
    5655,
    17767,
    97412,
    122606,
    209377,
    27070,
    35871,
    326617,
    188954,
    42680,
    73512,
    80911,
    22629,
    3011,
    95021,
    315242,
    157737,
    383,
    41821,
    41808,
    19335,
    27950,
    15674,
    25677,
    110950,
    35375,
    76835,
    59108,
    57370,
    35262,
    16569,
    160415,
    37706,
    78086,
    32041,
    49691,
    137143,
    9782,
    172080,
    50148,
    77917,
    6323,
    10110,
    69172,
    17711,
    21795,
    59511,
    76184,
    135114,
    31046,
    132319,
    59105,
    157578,
    20549,
    80778,
    57649,
    158421,
    65143,
    4575,
    72235,
    21899,
    10797,
    92745,
    34035,
    106079,
    80159,
    4508,
    78304,
    25350,
    75457,
    46458,
    32937,
    25623,
    47,
    8531,
    104751,
    84953,
    8138,
    36508,
    187199,
    66310,
    115274,
    13253,
    32461,
    38536,
    1916,
    42007,
    187160,
    35055,
    26325,
    84394,
    35963,
    94216,
    45590,
    97782
  ];

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
  var MAX_COMMON_PREFIX_LENGTH = 15;
  var RoutingTableRefresh = class {
    log;
    peerRouting;
    routingTable;
    refreshInterval;
    refreshQueryTimeout;
    commonPrefixLengthRefreshedAt;
    refreshTimeoutId;
    constructor(components, init) {
      const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, logPrefix } = init;
      this.log = components.logger.forComponent(`${logPrefix}:routing-table:refresh`);
      this.peerRouting = peerRouting;
      this.routingTable = routingTable;
      this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
      this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
      this.commonPrefixLengthRefreshedAt = [];
      this.refreshTable = this.refreshTable.bind(this);
    }
    async afterStart() {
      this.log(`refreshing routing table every ${this.refreshInterval}ms`);
      this.refreshTable(true);
    }
    async stop() {
      if (this.refreshTimeoutId != null) {
        clearTimeout(this.refreshTimeoutId);
      }
    }
    /**
     * To speed lookups, we seed the table with random PeerIds. This means
     * when we are asked to locate a peer on the network, we can find a KadId
     * that is close to the requested peer ID and query that, then network
     * peers will tell us who they know who is close to the fake ID
     */
    refreshTable(force = false, options2) {
      this.log("refreshing routing table");
      const prefixLength = this._maxCommonPrefix();
      const refreshCommonPrefixLengths = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
      this.log(`max common prefix length ${prefixLength}`);
      this.log(`tracked CPLs [ ${refreshCommonPrefixLengths.map((date) => date.toISOString()).join(", ")} ]`);
      Promise.all(refreshCommonPrefixLengths.map(async (lastRefresh, index) => {
        try {
          await this._refreshCommonPrefixLength(index, lastRefresh, force, options2);
          if (this._numPeersForCpl(prefixLength) === 0) {
            const lastCpl = Math.min(2 * (index + 1), refreshCommonPrefixLengths.length - 1);
            for (let n2 = index + 1; n2 < lastCpl + 1; n2++) {
              try {
                await this._refreshCommonPrefixLength(n2, lastRefresh, force, options2);
              } catch (err2) {
                this.log.error("failed to refresh entries with common prefix length %d - %e", n2, err2);
              }
            }
          }
        } catch (err2) {
          this.log.error("failed to refresh entries with common prefix length - %e", err2);
        }
      })).catch((err2) => {
        this.log.error("failed to refresh table - %e", err2);
      }).then(() => {
        this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
        if (this.refreshTimeoutId.unref != null) {
          this.refreshTimeoutId.unref();
        }
      }).catch((err2) => {
        this.log.error("failed to set refresh timeout - %e", err2);
      });
    }
    async _refreshCommonPrefixLength(cpl, lastRefresh, force, options2) {
      if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
        this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
        return;
      }
      const peerId = this._generateRandomPeerId(cpl);
      this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this.routingTable.size);
      const signal = anySignal([options2?.signal, AbortSignal.timeout(this.refreshQueryTimeout)]);
      setMaxListeners(Infinity, signal);
      try {
        const peers = await src_default13(this.peerRouting.getClosestPeers(peerId.toMultihash().bytes, {
          signal
        }));
        this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
        this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this.routingTable.size);
      } finally {
        signal.clear();
      }
    }
    _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
      if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
        maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
      }
      const dates = [];
      for (let i2 = 0; i2 <= maxCommonPrefix; i2++) {
        dates[i2] = this.commonPrefixLengthRefreshedAt[i2] ?? /* @__PURE__ */ new Date();
      }
      return dates;
    }
    _generateRandomPeerId(targetCommonPrefixLength) {
      if (this.routingTable.kb == null) {
        throw new Error("Routing table not started");
      }
      if (this.routingTable.kb.localPeer == null) {
        throw new Error("Local peer not set");
      }
      const randomData = randomBytes2(2);
      const randomUint16 = (randomData[1] << 8) + randomData[0];
      const key = this._makePeerId(this.routingTable.kb.localPeer.kadId, randomUint16, targetCommonPrefixLength);
      const multihash = decode4(key);
      return peerIdFromMultihash(multihash);
    }
    _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
      if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
        throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
      }
      const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
      const localPrefix = view.getUint16(0, false);
      const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
      const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
      const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
      const keyPrefix2 = generated_prefix_list_browser_default[targetPrefix];
      const keyBuffer = new ArrayBuffer(34);
      const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
      keyView.setUint8(0, sha256.code);
      keyView.setUint8(1, 32);
      keyView.setUint32(2, keyPrefix2, false);
      return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
    }
    /**
     * returns the maximum common prefix length between any peer in the table
     * and the current peer
     */
    _maxCommonPrefix() {
      let prefixLength = 0;
      for (const length4 of this._prefixLengths()) {
        if (length4 > prefixLength) {
          prefixLength = length4;
        }
      }
      return prefixLength;
    }
    /**
     * Returns the number of peers in the table with a given prefix length
     */
    _numPeersForCpl(prefixLength) {
      let count = 0;
      for (const length4 of this._prefixLengths()) {
        if (length4 === prefixLength) {
          count++;
        }
      }
      return count;
    }
    /**
     * Yields the common prefix length of every peer in the table
     */
    *_prefixLengths() {
      if (this.routingTable.kb?.localPeer == null) {
        return;
      }
      for (const { kadId } of this.routingTable.kb.toIterable()) {
        const distance = xor(this.routingTable.kb.localPeer.kadId, kadId);
        let leadingZeros = 0;
        for (const byte of distance) {
          if (byte === 0) {
            leadingZeros++;
          } else {
            break;
          }
        }
        yield leadingZeros;
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
  var AddProviderHandler = class {
    peerId;
    providers;
    peerStore;
    log;
    constructor(components, init) {
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:add-provider`);
      this.peerId = components.peerId;
      this.providers = init.providers;
      this.peerStore = components.peerStore;
    }
    async handle(peerId, msg) {
      if (msg.key == null || msg.key.length === 0) {
        throw new InvalidMessageError("Missing key");
      }
      let cid;
      try {
        cid = CID.decode(msg.key);
      } catch (err2) {
        throw new InvalidMessageError("Invalid CID");
      }
      if (msg.providers == null || msg.providers.length === 0) {
        this.log.error("no providers found in message");
      }
      this.log("%p asked us, %p to store provider record for for %c", peerId, this.peerId, cid);
      await Promise.all(msg.providers.map(async (pi) => {
        const digest2 = decode4(pi.id);
        const providerId = peerIdFromMultihash(digest2);
        const providerMultiaddrs = pi.multiaddrs.map((buf2) => multiaddr(buf2));
        if (!peerId.equals(providerId)) {
          this.log("invalid provider peer %p from %p", pi.id, peerId);
          return;
        }
        if (pi.multiaddrs.length < 1) {
          this.log("no valid addresses for provider %p. Ignore", peerId);
          return;
        }
        this.log.trace("received provider %p for %s (addrs %s)", peerId, cid, providerMultiaddrs);
        await this.providers.addProvider(cid, providerId);
        await this.peerStore.merge(providerId, {
          multiaddrs: providerMultiaddrs
        });
      }));
      return void 0;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
  var FindNodeHandler = class {
    peerRouting;
    peerInfoMapper;
    peerId;
    addressManager;
    log;
    constructor(components, init) {
      const { peerRouting, logPrefix } = init;
      this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);
      this.peerId = components.peerId;
      this.addressManager = components.addressManager;
      this.peerRouting = peerRouting;
      this.peerInfoMapper = init.peerInfoMapper;
    }
    /**
     * Process `FindNode` DHT messages
     */
    async handle(peerId, msg) {
      this.log("incoming request from %p for peers close to %b", peerId, msg.key);
      try {
        if (msg.key == null) {
          throw new InvalidMessageError("Invalid FIND_NODE message received - key was missing");
        }
        const closer = await this.peerRouting.getClosestPeersOffline(msg.key, {
          exclude: [
            // never tell a peer about itself
            peerId,
            // do not include the server in the results
            this.peerId
          ]
        });
        if (equals3(this.peerId.toMultihash().bytes, msg.key)) {
          closer.push({
            id: this.peerId,
            multiaddrs: this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P))
          });
        }
        const response = {
          type: MessageType.FIND_NODE,
          clusterLevel: msg.clusterLevel,
          closer: closer.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
            id: peerInfo.id.toMultihash().bytes,
            multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
          })),
          providers: []
        };
        if (response.closer.length === 0) {
          this.log("could not find any peers closer to %b for %p", msg.key, peerId);
        } else {
          this.log("found %d peers close to %b for %p", response.closer.length, msg.key, peerId);
        }
        return response;
      } catch (err2) {
        this.log("error during finding peers closer to %b for %p - %e", msg.key, peerId, err2);
        throw err2;
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
  var GetProvidersHandler = class {
    peerId;
    peerRouting;
    providers;
    peerStore;
    peerInfoMapper;
    log;
    constructor(components, init) {
      const { peerRouting, providers, logPrefix } = init;
      this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:get-providers`);
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.peerRouting = peerRouting;
      this.providers = providers;
      this.peerInfoMapper = init.peerInfoMapper;
    }
    async handle(peerId, msg) {
      if (msg.key == null) {
        throw new InvalidMessageError("Invalid GET_PROVIDERS message received - key was missing");
      }
      let cid;
      try {
        cid = CID.decode(msg.key);
      } catch (err2) {
        throw new InvalidMessageError("Invalid CID");
      }
      this.log("%p asking for providers for %s", peerId, cid);
      const [providerPeers, closerPeers] = await Promise.all([
        src_default11(src_default5(await this.providers.getProviders(cid), async (peerId2) => {
          const peer = await this.peerStore.get(peerId2);
          const info = {
            id: peer.id,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
          };
          return info;
        })),
        this.peerRouting.getClosestPeersOffline(msg.key)
      ]);
      const response = {
        type: MessageType.GET_PROVIDERS,
        key: msg.key,
        clusterLevel: msg.clusterLevel,
        closer: closerPeers.map(this.peerInfoMapper).filter(({ id, multiaddrs }) => multiaddrs.length > 0).map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        })),
        providers: providerPeers.map(this.peerInfoMapper).filter(({ id, multiaddrs }) => multiaddrs.length > 0).map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        }))
      };
      this.log("got %s providers %s closerPeers", response.providers.length, response.closer.length);
      return response;
    }
    async _getAddresses(peerId) {
      return [];
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
  var GetValueHandler = class {
    peerStore;
    datastore;
    peerRouting;
    log;
    datastorePrefix;
    constructor(components, init) {
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:get-value`);
      this.datastorePrefix = `${init.datastorePrefix}/record`;
      this.peerStore = components.peerStore;
      this.datastore = components.datastore;
      this.peerRouting = init.peerRouting;
    }
    async handle(peerId, msg) {
      const key = msg.key;
      this.log("%p asked for key %b", peerId, key);
      if (key == null || key.length === 0) {
        throw new InvalidMessageError("Invalid key");
      }
      const response = {
        type: MessageType.GET_VALUE,
        key,
        clusterLevel: msg.clusterLevel,
        closer: [],
        providers: []
      };
      if (isPublicKeyKey(key)) {
        this.log("is public key");
        const idFromKey = fromPublicKeyKey(key);
        let pubKey;
        try {
          const peer = await this.peerStore.get(idFromKey);
          if (peer.id.publicKey == null) {
            throw new NotFoundError("No public key found in key book");
          }
          pubKey = publicKeyToProtobuf(peer.id.publicKey);
        } catch (err2) {
          if (err2.name !== "NotFoundError") {
            throw err2;
          }
        }
        if (pubKey != null) {
          this.log("returning found public key");
          response.record = new Libp2pRecord(key, pubKey, /* @__PURE__ */ new Date()).serialize();
          return response;
        }
      }
      const [record, closer] = await Promise.all([
        this._checkLocalDatastore(key),
        this.peerRouting.getClosestPeersOffline(key)
      ]);
      if (record != null) {
        this.log("had record for %b in local datastore", key);
        response.record = record.serialize();
      }
      if (closer.length > 0) {
        this.log("had %s closer peers in routing table", closer.length);
        response.closer = closer.map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        }));
      }
      return response;
    }
    /**
     * Try to fetch a given record by from the local datastore.
     * Returns the record if it is still valid, meaning
     * - it was either authored by this node, or
     * - it was received less than `PROVIDERS_VALIDITY` ago.
     */
    async _checkLocalDatastore(key) {
      this.log("checkLocalDatastore looking for %b", key);
      const dsKey = bufferToRecordKey(this.datastorePrefix, key);
      let rawRecord;
      try {
        rawRecord = await this.datastore.get(dsKey);
      } catch (err2) {
        if (err2.name === "NotFoundError") {
          return void 0;
        }
        throw err2;
      }
      const record = Libp2pRecord.deserialize(rawRecord);
      if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > PROVIDERS_VALIDITY) {
        await this.datastore.delete(dsKey);
        return void 0;
      }
      return record;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
  var PingHandler = class {
    log;
    constructor(components, init) {
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:ping`);
    }
    async handle(peerId, msg) {
      this.log("ping from %p", peerId);
      return msg;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
  var PutValueHandler = class {
    components;
    validators;
    log;
    datastorePrefix;
    constructor(components, init) {
      const { validators: validators2 } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:put-value`);
      this.datastorePrefix = `${init.datastorePrefix}/record`;
      this.validators = validators2;
    }
    async handle(peerId, msg) {
      const key = msg.key;
      this.log("%p asked us to store value for key %b", peerId, key);
      if (msg.record == null) {
        this.log.error("empty record from %p", peerId);
        throw new InvalidMessageError(`Empty record from: ${peerId}`);
      }
      try {
        const deserializedRecord = Libp2pRecord.deserialize(msg.record);
        await verifyRecord(this.validators, deserializedRecord);
        deserializedRecord.timeReceived = /* @__PURE__ */ new Date();
        const recordKey = bufferToRecordKey(this.datastorePrefix, deserializedRecord.key);
        await this.components.datastore.put(recordKey, deserializedRecord.serialize().subarray());
        this.log("put record for %b into datastore under key %k", key, recordKey);
      } catch (err2) {
        this.log("did not put record for key %b into datastore %o", key, err2);
      }
      return msg;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
  var RPC = class {
    handlers;
    log;
    metrics;
    incomingMessageTimeout;
    constructor(components, init) {
      this.metrics = {
        operations: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_inbound_rpc_requests_total`),
        errors: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_inbound_rpc_errors_total`),
        rpcTime: components.metrics?.registerMetricGroup(`${init.metricsPrefix}_inbound_rpc_time_seconds`, { label: "operation" })
      };
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc`);
      this.incomingMessageTimeout = init.incomingMessageTimeout ?? 1e4;
      this.handlers = {
        [MessageType.GET_VALUE.toString()]: new GetValueHandler(components, init),
        [MessageType.PUT_VALUE.toString()]: new PutValueHandler(components, init),
        [MessageType.FIND_NODE.toString()]: new FindNodeHandler(components, init),
        [MessageType.ADD_PROVIDER.toString()]: new AddProviderHandler(components, init),
        [MessageType.GET_PROVIDERS.toString()]: new GetProvidersHandler(components, init),
        [MessageType.PING.toString()]: new PingHandler(components, init)
      };
    }
    /**
     * Process incoming DHT messages
     */
    async handleMessage(peerId, msg) {
      const handler = this.handlers[msg.type];
      if (handler == null) {
        this.log.error(`no handler found for message type: ${msg.type}`);
        return;
      }
      try {
        this.metrics.operations?.increment({
          [msg.type]: true
        });
        return await handler.handle(peerId, msg);
      } catch {
        this.metrics.errors?.increment({
          [msg.type]: true
        });
      }
    }
    /**
     * Handle incoming streams on the dht protocol
     */
    async onIncomingStream(stream, connection) {
      const abortListener = () => {
        stream.abort(new TimeoutError());
      };
      let signal = AbortSignal.timeout(this.incomingMessageTimeout);
      signal.addEventListener("abort", abortListener);
      const messages2 = pbStream(stream).pb(Message2);
      while (true) {
        if (stream.readStatus !== "readable") {
          await stream.close({
            signal
          });
          break;
        }
        const message2 = await messages2.read({
          signal
        });
        const stopSuccessTimer = this.metrics?.rpcTime?.timer(message2.type.toString());
        const stopErrorTimer = this.metrics?.rpcTime?.timer(message2.type.toString());
        let errored = false;
        try {
          this.log("incoming %s from %p", message2.type, connection.remotePeer);
          const res = await this.handleMessage(connection.remotePeer, message2);
          if (res != null) {
            await messages2.write(res, {
              signal
            });
          }
        } catch (err2) {
          errored = true;
          stopErrorTimer?.();
          throw err2;
        } finally {
          if (!errored) {
            stopSuccessTimer?.();
          }
        }
        signal.removeEventListener("abort", abortListener);
        signal = AbortSignal.timeout(this.incomingMessageTimeout);
        signal.addEventListener("abort", abortListener);
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
  var TopologyListener = class extends TypedEventEmitter {
    log;
    components;
    protocol;
    running;
    registrarId;
    constructor(components, init) {
      super();
      const { protocol, logPrefix } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${logPrefix}:topology-listener`);
      this.running = false;
      this.protocol = protocol;
    }
    isStarted() {
      return this.running;
    }
    /**
     * Start the network
     */
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
      this.registrarId = await this.components.registrar.register(this.protocol, {
        onConnect: (peerId) => {
          this.log("observed peer %p with protocol %s", peerId, this.protocol);
          this.dispatchEvent(new CustomEvent("peer", {
            detail: peerId
          }));
        }
      });
    }
    /**
     * Stop all network activity
     */
    async stop() {
      this.running = false;
      if (this.registrarId != null) {
        this.components.registrar.unregister(this.registrarId);
        this.registrarId = void 0;
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
  var DHTContentRouting = class {
    dht;
    constructor(dht) {
      this.dht = dht;
    }
    async provide(cid, options2 = {}) {
      await src_default3(this.dht.provide(cid, options2));
    }
    async cancelReprovide(key) {
      await this.dht.cancelReprovide(key);
    }
    async *findProviders(cid, options2 = {}) {
      for await (const event of this.dht.findProviders(cid, options2)) {
        if (event.name === "PROVIDER") {
          yield* event.providers.map((peer) => ({
            ...peer,
            routing: "kad-dht"
          }));
        }
      }
    }
    async put(key, value2, options2) {
      await src_default3(this.dht.put(key, value2, options2));
    }
    async get(key, options2) {
      for await (const event of this.dht.get(key, options2)) {
        if (event.name === "VALUE") {
          return event.value;
        }
      }
      throw new NotFoundError("Could not find value for key");
    }
  };
  var DHTPeerRouting = class {
    dht;
    constructor(dht) {
      this.dht = dht;
    }
    async findPeer(peerId, options2 = {}) {
      for await (const event of this.dht.findPeer(peerId, options2)) {
        if (event.name === "FINAL_PEER") {
          return event.peer;
        }
      }
      throw new NotFoundError("Peer not found");
    }
    async *getClosestPeers(key, options2 = {}) {
      for await (const event of this.dht.getClosestPeers(key, options2)) {
        if (event.name === "FINAL_PEER") {
          yield event.peer;
        }
      }
    }
  };
  var DEFAULT_MAX_INBOUND_STREAMS3 = 32;
  var DEFAULT_MAX_OUTBOUND_STREAMS3 = 64;
  var KadDHT = class extends TypedEventEmitter {
    k;
    a;
    d;
    protocol;
    routingTable;
    providers;
    network;
    peerRouting;
    components;
    log;
    running;
    clientMode;
    validators;
    selectors;
    queryManager;
    contentFetching;
    contentRouting;
    routingTableRefresh;
    rpc;
    topologyListener;
    querySelf;
    maxInboundStreams;
    maxOutboundStreams;
    dhtContentRouting;
    dhtPeerRouting;
    peerInfoMapper;
    reprovider;
    onPeerConnectTimeout;
    /**
     * Create a new KadDHT
     */
    constructor(components, init = {}) {
      super();
      const logPrefix = init.logPrefix ?? "libp2p:kad-dht";
      const datastorePrefix = init.datastorePrefix ?? "/dht";
      const metricsPrefix = init.metricsPrefix ?? "libp2p_kad_dht";
      const operationMetrics = {
        queries: components.metrics?.registerMetricGroup(`${metricsPrefix}_operations_total`, { label: "operation" }),
        errors: components.metrics?.registerCounterGroup(`${metricsPrefix}_operation_errors_total`, { label: "operation" }),
        queryTime: components.metrics?.registerMetricGroup(`${metricsPrefix}_operation_time_seconds`, { label: "operation" }),
        errorTime: components.metrics?.registerMetricGroup(`${metricsPrefix}_operation_error_time_seconds`, { label: "operation" })
      };
      this.running = false;
      this.components = components;
      this.log = components.logger.forComponent(logPrefix);
      this.k = init.kBucketSize ?? KBUCKET_SIZE;
      this.a = init.alpha ?? ALPHA;
      this.d = init.disjointPaths ?? this.a;
      this.protocol = init.protocol ?? PROTOCOL;
      this.clientMode = init.clientMode ?? true;
      this.maxInboundStreams = init.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS3;
      this.maxOutboundStreams = init.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS3;
      this.peerInfoMapper = init.peerInfoMapper ?? removePrivateAddressesMapper;
      this.onPeerConnectTimeout = init.onPeerConnectTimeout ?? ON_PEER_CONNECT_TIMEOUT;
      this.providers = new Providers(components, {
        ...init.providers,
        logPrefix,
        datastorePrefix
      });
      this.validators = {
        ...validators,
        ...init.validators
      };
      this.selectors = {
        ...selectors,
        ...init.selectors
      };
      this.network = new Network2(components, {
        protocol: this.protocol,
        logPrefix,
        metricsPrefix
      });
      this.routingTable = new RoutingTable(components, {
        kBucketSize: this.k,
        pingOldContactTimeout: init.pingOldContactTimeout,
        pingOldContactConcurrency: init.pingOldContactConcurrency,
        pingOldContactMaxQueueSize: init.pingOldContactMaxQueueSize,
        pingNewContactTimeout: init.pingNewContactTimeout,
        pingNewContactConcurrency: init.pingNewContactConcurrency,
        pingNewContactMaxQueueSize: init.pingNewContactMaxQueueSize,
        protocol: this.protocol,
        logPrefix,
        metricsPrefix,
        prefixLength: init.prefixLength,
        splitThreshold: init.kBucketSplitThreshold,
        network: this.network
      });
      const initialQuerySelfHasRun = pDefer();
      if (init.allowQueryWithZeroPeers === true) {
        initialQuerySelfHasRun.resolve();
      }
      this.queryManager = new QueryManager(components, {
        disjointPaths: this.d,
        alpha: this.a,
        logPrefix,
        metricsPrefix,
        initialQuerySelfHasRun,
        routingTable: this.routingTable,
        allowQueryWithZeroPeers: init.allowQueryWithZeroPeers
      });
      this.peerRouting = new PeerRouting(components, {
        routingTable: this.routingTable,
        network: this.network,
        validators: this.validators,
        queryManager: this.queryManager,
        logPrefix
      });
      this.contentFetching = new ContentFetching(components, {
        validators: this.validators,
        selectors: this.selectors,
        peerRouting: this.peerRouting,
        queryManager: this.queryManager,
        network: this.network,
        logPrefix,
        datastorePrefix
      });
      this.contentRouting = new ContentRouting(components, {
        network: this.network,
        peerRouting: this.peerRouting,
        queryManager: this.queryManager,
        routingTable: this.routingTable,
        providers: this.providers,
        logPrefix
      });
      this.routingTableRefresh = new RoutingTableRefresh(components, {
        peerRouting: this.peerRouting,
        routingTable: this.routingTable,
        logPrefix
      });
      this.rpc = new RPC(components, {
        routingTable: this.routingTable,
        providers: this.providers,
        peerRouting: this.peerRouting,
        validators: this.validators,
        logPrefix,
        metricsPrefix,
        datastorePrefix,
        peerInfoMapper: this.peerInfoMapper
      });
      this.topologyListener = new TopologyListener(components, {
        protocol: this.protocol,
        logPrefix
      });
      this.querySelf = new QuerySelf(components, {
        peerRouting: this.peerRouting,
        interval: init.querySelfInterval,
        initialInterval: init.initialQuerySelfInterval,
        logPrefix,
        initialQuerySelfHasRun,
        operationMetrics
      });
      this.reprovider = new Reprovider(components, {
        ...init.reprovide,
        logPrefix,
        metricsPrefix,
        datastorePrefix,
        contentRouting: this.contentRouting,
        operationMetrics
      });
      this.network.addEventListener("peer", (evt) => {
        const peerData = evt.detail;
        this.onPeerConnect(peerData).catch((err2) => {
          this.log.error("could not add %p to routing table - %e", peerData.id, err2);
        });
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerData
        }));
      });
      this.topologyListener.addEventListener("peer", (evt) => {
        const peerId = evt.detail;
        Promise.resolve().then(async () => {
          const peer = await this.components.peerStore.get(peerId);
          const peerData = {
            id: peerId,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
            protocols: peer.protocols
          };
          await this.onPeerConnect(peerData);
        }).catch((err2) => {
          this.log.error("could not add %p to routing table - %e", peerId, err2);
        });
      });
      this.dhtPeerRouting = new DHTPeerRouting(this);
      this.dhtContentRouting = new DHTContentRouting(this);
      if (init.clientMode == null) {
        components.events.addEventListener("self:peer:update", (evt) => {
          this.log("received update of self-peer info");
          void Promise.resolve().then(async () => {
            const hasPublicAddress = evt.detail.peer.addresses.some(({ multiaddr: multiaddr2 }) => {
              return !isPrivate(multiaddr2) && !Circuit.exactMatch(multiaddr2);
            });
            const mode = this.getMode();
            if (hasPublicAddress && mode === "client") {
              await this.setMode("server");
            } else if (mode === "server" && !hasPublicAddress) {
              await this.setMode("client");
            }
          }).catch((err2) => {
            this.log.error("error setting dht server mode - %e", err2);
          });
        });
      }
      this.get = timeOperationGenerator(this.get.bind(this), operationMetrics, "GET_VALUE");
      this.findProviders = timeOperationGenerator(this.findProviders.bind(this), operationMetrics, "FIND_PROVIDERS");
      this.findPeer = timeOperationGenerator(this.findPeer.bind(this), operationMetrics, "FIND_PEER");
      this.getClosestPeers = timeOperationGenerator(this.getClosestPeers.bind(this), operationMetrics, "GET_CLOSEST_PEERS");
      this.provide = timeOperationGenerator(this.provide.bind(this), operationMetrics, "PROVIDE");
      this.put = timeOperationGenerator(this.put.bind(this), operationMetrics, "PUT_VALUE");
    }
    [Symbol.toStringTag] = "@libp2p/kad-dht";
    [serviceCapabilities] = [
      "@libp2p/content-routing",
      "@libp2p/peer-routing",
      "@libp2p/peer-discovery",
      "@libp2p/kad-dht"
    ];
    [serviceDependencies] = [
      "@libp2p/identify",
      "@libp2p/ping"
    ];
    get [contentRoutingSymbol]() {
      return this.dhtContentRouting;
    }
    get [peerRoutingSymbol]() {
      return this.dhtPeerRouting;
    }
    get [peerDiscoverySymbol]() {
      return this;
    }
    async onPeerConnect(peerData) {
      this.log.trace("peer %p connected", peerData.id, peerData.multiaddrs);
      peerData = this.peerInfoMapper(peerData);
      if (peerData.multiaddrs.length === 0) {
        this.log.trace("ignoring %p as there were no valid addresses in %s after filtering", peerData.id, peerData.multiaddrs.map((addr) => addr.toString()));
        return;
      }
      const signal = AbortSignal.timeout(this.onPeerConnectTimeout);
      setMaxListeners(Infinity, signal);
      try {
        await this.routingTable.add(peerData.id, {
          signal
        });
      } catch (err2) {
        this.log.error("could not add %p to routing table - %e", peerData.id, err2);
      }
    }
    /**
     * Is this DHT running.
     */
    isStarted() {
      return this.running;
    }
    /**
     * If 'server' this node will respond to DHT queries, if 'client' this node will not
     */
    getMode() {
      return this.clientMode ? "client" : "server";
    }
    /**
     * If 'server' this node will respond to DHT queries, if 'client' this node will not
     */
    async setMode(mode, options2) {
      if (mode === this.getMode() && options2?.force !== true) {
        this.log("already in %s mode", mode);
        return;
      }
      await this.components.registrar.unhandle(this.protocol, options2);
      if (mode === this.getMode() && options2?.force !== true) {
        this.log("already in %s mode", mode);
        return;
      }
      if (mode === "client") {
        this.log("enabling client mode while in %s mode", this.getMode());
        this.clientMode = true;
      } else {
        this.log("enabling server mode while in %s mode", this.getMode());
        this.clientMode = false;
        await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
          signal: options2?.signal,
          maxInboundStreams: this.maxInboundStreams,
          maxOutboundStreams: this.maxOutboundStreams
        });
      }
    }
    /**
     * Start listening to incoming connections.
     */
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
      await this.setMode(this.clientMode ? "client" : "server", {
        force: true
      });
      await start(this.routingTable, this.queryManager, this.network, this.topologyListener, this.routingTableRefresh, this.reprovider);
      await start(this.querySelf);
    }
    /**
     * Stop accepting incoming connections and sending outgoing
     * messages.
     */
    async stop() {
      this.running = false;
      await stop(this.querySelf, this.queryManager, this.network, this.routingTable, this.routingTableRefresh, this.topologyListener, this.reprovider);
    }
    /**
     * Store the given key/value pair in the DHT
     */
    async *put(key, value2, options2 = {}) {
      yield* this.contentFetching.put(key, value2, options2);
    }
    /**
     * Get the value that corresponds to the passed key
     */
    async *get(key, options2 = {}) {
      yield* this.contentFetching.get(key, options2);
    }
    // ----------- Content Routing
    /**
     * Announce to the network that we can provide given key's value
     */
    async *provide(key, options2 = {}) {
      yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options2);
    }
    /**
     * Provider records must be re-published every 24 hours - pass a previously
     * provided CID here to not re-publish a record for it any more
     */
    async cancelReprovide(key, options2) {
      await this.providers.removeProvider(key, this.components.peerId, options2);
    }
    /**
     * Search the dht for providers of the given CID
     */
    async *findProviders(key, options2 = {}) {
      yield* this.contentRouting.findProviders(key, options2);
    }
    // ----------- Peer Routing -----------
    /**
     * Search for a peer with the given ID
     */
    async *findPeer(id, options2 = {}) {
      yield* this.peerRouting.findPeer(id, options2);
    }
    /**
     * Kademlia 'node lookup' operation
     */
    async *getClosestPeers(key, options2 = {}) {
      yield* this.peerRouting.getClosestPeers(key, options2);
    }
    async refreshRoutingTable(options2) {
      this.routingTableRefresh.refreshTable(true, options2);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/index.js
  var EventTypes;
  (function(EventTypes2) {
    EventTypes2[EventTypes2["SEND_QUERY"] = 0] = "SEND_QUERY";
    EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
    EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
    EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
    EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
    EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
    EventTypes2[EventTypes2["ADD_PEER"] = 6] = "ADD_PEER";
    EventTypes2[EventTypes2["DIAL_PEER"] = 7] = "DIAL_PEER";
    EventTypes2[EventTypes2["PATH_ENDED"] = 8] = "PATH_ENDED";
  })(EventTypes || (EventTypes = {}));
  function kadDHT(init = {}) {
    return (components) => new KadDHT(components, init);
  }

  // node_modules/@libp2p/mplex/dist/src/message-types.js
  var MessageTypes;
  (function(MessageTypes2) {
    MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
    MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
    MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
    MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
    MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
    MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
    MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
  })(MessageTypes || (MessageTypes = {}));
  var MessageTypeNames = Object.freeze({
    0: "NEW_STREAM",
    1: "MESSAGE_RECEIVER",
    2: "MESSAGE_INITIATOR",
    3: "CLOSE_RECEIVER",
    4: "CLOSE_INITIATOR",
    5: "RESET_RECEIVER",
    6: "RESET_INITIATOR"
  });
  var InitiatorMessageTypes = Object.freeze({
    NEW_STREAM: MessageTypes.NEW_STREAM,
    MESSAGE: MessageTypes.MESSAGE_INITIATOR,
    CLOSE: MessageTypes.CLOSE_INITIATOR,
    RESET: MessageTypes.RESET_INITIATOR
  });
  var ReceiverMessageTypes = Object.freeze({
    MESSAGE: MessageTypes.MESSAGE_RECEIVER,
    CLOSE: MessageTypes.CLOSE_RECEIVER,
    RESET: MessageTypes.RESET_RECEIVER
  });

  // node_modules/@libp2p/mplex/dist/src/decode.js
  var MAX_MSG_SIZE = 1 << 20;
  var MAX_MSG_QUEUE_SIZE = 4 << 20;
  var Decoder3 = class {
    _buffer;
    _headerInfo;
    _maxMessageSize;
    _maxUnprocessedMessageQueueSize;
    constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
      this._buffer = new Uint8ArrayList();
      this._headerInfo = null;
      this._maxMessageSize = maxMessageSize;
      this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
    }
    write(chunk) {
      if (chunk == null || chunk.length === 0) {
        return [];
      }
      this._buffer.append(chunk);
      if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
        throw new InvalidMessageError("Unprocessed message queue size too large!");
      }
      const msgs = [];
      while (this._buffer.length !== 0) {
        if (this._headerInfo == null) {
          try {
            this._headerInfo = this._decodeHeader(this._buffer);
          } catch (err2) {
            if (err2.name === "InvalidMessageError") {
              throw err2;
            }
            break;
          }
        }
        const { id, type, length: length4, offset } = this._headerInfo;
        const bufferedDataLength = this._buffer.length - offset;
        if (bufferedDataLength < length4) {
          break;
        }
        const msg = {
          id,
          type
        };
        if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
          msg.data = this._buffer.sublist(offset, offset + length4);
        }
        msgs.push(msg);
        this._buffer.consume(offset + length4);
        this._headerInfo = null;
      }
      return msgs;
    }
    /**
     * Attempts to decode the message header from the buffer
     */
    _decodeHeader(data) {
      const { value: h, offset } = readVarInt(data);
      const { value: length4, offset: end } = readVarInt(data, offset);
      const type = h & 7;
      if (MessageTypeNames[type] == null) {
        throw new Error(`Invalid type received: ${type}`);
      }
      if (length4 > this._maxMessageSize) {
        throw new InvalidMessageError("Message size too large");
      }
      return { id: h >> 3, type, offset: offset + end, length: length4 };
    }
  };
  var MSB3 = 128;
  var REST3 = 127;
  function readVarInt(buf2, offset = 0) {
    let res = 0;
    let shift = 0;
    let counter = offset;
    let b;
    const l2 = buf2.length;
    do {
      if (counter >= l2 || shift > 49) {
        offset = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf2.get(counter++);
      res += shift < 28 ? (b & REST3) << shift : (b & REST3) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB3);
    offset = counter - offset;
    return {
      value: res,
      offset
    };
  }

  // node_modules/@libp2p/mplex/dist/src/encode.js
  var POOL_SIZE = 10 * 1024;
  var Encoder2 = class {
    _pool;
    _poolOffset;
    constructor() {
      this._pool = allocUnsafe(POOL_SIZE);
      this._poolOffset = 0;
    }
    /**
     * Encodes the given message and adds it to the passed list
     */
    write(msg, list) {
      const pool2 = this._pool;
      let offset = this._poolOffset;
      encode7(msg.id << 3 | msg.type, pool2, offset);
      offset += encodingLength2(msg.id << 3 | msg.type);
      if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
        encode7(msg.data.length, pool2, offset);
        offset += encodingLength2(msg.data.length);
      } else {
        encode7(0, pool2, offset);
        offset += encodingLength2(0);
      }
      const header = pool2.subarray(this._poolOffset, offset);
      if (POOL_SIZE - offset < 100) {
        this._pool = allocUnsafe(POOL_SIZE);
        this._poolOffset = 0;
      } else {
        this._poolOffset = offset;
      }
      list.append(header);
      if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
        list.append(msg.data);
      }
    }
  };
  var encoder = new Encoder2();
  function encode14(message2) {
    const list = new Uint8ArrayList();
    encoder.write(message2, list);
    return list;
  }

  // node_modules/@libp2p/mplex/dist/src/stream.js
  var MplexStream = class extends AbstractStream {
    streamId;
    types;
    maxDataSize;
    muxer;
    constructor(init) {
      super(init);
      this.types = init.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
      this.maxDataSize = init.maxDataSize;
      this.muxer = init.muxer;
      this.streamId = parseInt(this.id.substring(1));
      if (init.direction === "outbound") {
        queueMicrotask(() => {
          this.muxer.send(encode14({
            id: this.streamId,
            type: InitiatorMessageTypes.NEW_STREAM,
            data: new Uint8ArrayList(fromString2(this.id))
          }));
        });
      }
    }
    sendData(data) {
      const list = new Uint8ArrayList();
      const sentBytes = data.byteLength;
      while (data.byteLength > 0) {
        const toSend = Math.min(data.byteLength, this.maxDataSize);
        const slice2 = data.sublist(0, toSend);
        data = data.sublist(toSend);
        list.append(encode14({
          id: this.streamId,
          type: this.types.MESSAGE,
          data: slice2
        }));
      }
      return {
        sentBytes,
        canSendMore: this.muxer.send(list)
      };
    }
    sendReset() {
      return this.muxer.send(encode14({
        id: this.streamId,
        type: this.types.RESET
      }));
    }
    async sendCloseWrite(options2) {
      this.muxer.send(encode14({
        id: this.streamId,
        type: this.types.CLOSE
      }));
      options2?.signal?.throwIfAborted();
    }
    async sendCloseRead(options2) {
      options2?.signal?.throwIfAborted();
    }
    sendPause() {
    }
    sendResume() {
    }
  };
  function createStream(options2) {
    const { id, muxer, direction, maxMsgSize = MAX_MSG_SIZE } = options2;
    return new MplexStream({
      ...options2,
      id: direction === "outbound" ? `i${id}` : `r${id}`,
      direction,
      maxDataSize: maxMsgSize,
      muxer,
      log: options2.log.newScope(`${direction}:${id}`),
      protocol: ""
    });
  }

  // node_modules/@libp2p/mplex/dist/src/mplex.js
  var DISCONNECT_THRESHOLD = 5;
  function printMessage(msg) {
    const output = {
      ...msg,
      type: `${MessageTypeNames[msg.type]} (${msg.type})`
    };
    if (msg.type === MessageTypes.NEW_STREAM) {
      output.data = toString2(msg.data.subarray());
    }
    if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
      output.data = toString2(msg.data.subarray(), "base16");
    }
    return output;
  }
  var MplexStreamMuxer = class extends AbstractStreamMuxer {
    _streamId;
    rateLimiter;
    maxMessageSize;
    maxUnprocessedMessageQueueSize;
    decoder;
    constructor(maConn, init) {
      super(maConn, {
        ...init,
        protocol: "/mplex/6.7.0",
        name: "mplex"
      });
      this._streamId = 0;
      this.maxMessageSize = init.maxMessageSize ?? MAX_MSG_SIZE;
      this.maxUnprocessedMessageQueueSize = init.maxUnprocessedMessageQueueSize ?? MAX_MSG_QUEUE_SIZE;
      this.decoder = new Decoder3(this.maxMessageSize, this.maxUnprocessedMessageQueueSize);
      this.rateLimiter = new RateLimiter({
        points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
        duration: 1
      });
    }
    onData(data) {
      for (const msg of this.decoder.write(data)) {
        this.handleMessage(msg);
      }
    }
    /**
     * Initiate a new stream with the given name. If no name is
     * provided, the id of the stream will be used.
     */
    onCreateStream(options2) {
      if (this.status !== "open") {
        throw new MuxerClosedError("Muxer already closed");
      }
      const id = this._streamId++;
      return this._newStream(id, "outbound", options2);
    }
    _newStream(id, direction, options2) {
      this.log("new %s stream %s", direction, id);
      const stream = createStream({
        ...options2,
        id,
        direction,
        maxMsgSize: this.maxMessageSize,
        log: this.log,
        muxer: this
      });
      return stream;
    }
    handleMessage(message2) {
      if (this.log.enabled) {
        this.log.trace("incoming message", printMessage(message2));
      }
      if (message2.type === MessageTypes.NEW_STREAM) {
        try {
          this.rateLimiter.consume("new-stream", 1);
        } catch {
          this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this.abort(new Error("Too many open streams"));
          return;
        }
        const stream2 = this._newStream(message2.id, "inbound", this.streamOptions);
        this.onRemoteStream(stream2);
        return;
      }
      const id = `${(message2.type & 1) === 1 ? "i" : "r"}${message2.id}`;
      const stream = this.streams.find((s2) => s2.id === id);
      if (stream == null) {
        this.log("missing stream %s for message type %s", id, MessageTypeNames[message2.type]);
        try {
          this.rateLimiter.consume("missing-stream", 1);
        } catch {
          this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection");
          this.abort(new Error("Too many messages for missing streams"));
          return;
        }
        return;
      }
      try {
        switch (message2.type) {
          case MessageTypes.MESSAGE_INITIATOR:
          case MessageTypes.MESSAGE_RECEIVER:
            stream.onData(message2.data);
            break;
          case MessageTypes.CLOSE_INITIATOR:
          case MessageTypes.CLOSE_RECEIVER:
            stream.onRemoteCloseWrite();
            break;
          case MessageTypes.RESET_INITIATOR:
          case MessageTypes.RESET_RECEIVER:
            stream.onRemoteReset();
            break;
          default:
            this.log("unknown message type");
        }
      } catch (err2) {
        this.log.error("error while processing message - %e", err2);
        stream.abort(err2);
      }
    }
  };

  // node_modules/@libp2p/mplex/dist/src/index.js
  var Mplex = class {
    protocol = "/mplex/6.7.0";
    _init;
    constructor(init = {}) {
      this._init = init;
    }
    [Symbol.toStringTag] = "@libp2p/mplex";
    [serviceCapabilities] = [
      "@libp2p/stream-multiplexing"
    ];
    createStreamMuxer(maConn) {
      return new MplexStreamMuxer(maConn, {
        ...this._init
      });
    }
  };
  function mplex(init = {}) {
    return () => new Mplex(init);
  }

  // node_modules/@libp2p/ping/dist/src/constants.js
  var PING_LENGTH2 = 32;
  var PROTOCOL_VERSION3 = "1.0.0";
  var PROTOCOL_NAME3 = "ping";
  var PROTOCOL_PREFIX3 = "ipfs";
  var TIMEOUT2 = 1e4;
  var MAX_INBOUND_STREAMS2 = 2;
  var MAX_OUTBOUND_STREAMS2 = 1;

  // node_modules/@libp2p/ping/dist/src/ping.js
  var Ping = class {
    protocol;
    components;
    started;
    timeout;
    maxInboundStreams;
    maxOutboundStreams;
    runOnLimitedConnection;
    constructor(components, init = {}) {
      this.components = components;
      this.started = false;
      this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX3}/${PROTOCOL_NAME3}/${PROTOCOL_VERSION3}`;
      this.timeout = init.timeout ?? TIMEOUT2;
      this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS2;
      this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS2;
      this.runOnLimitedConnection = init.runOnLimitedConnection ?? true;
      this.handlePing = this.handlePing.bind(this);
    }
    [Symbol.toStringTag] = "@libp2p/ping";
    [serviceCapabilities] = [
      "@libp2p/ping"
    ];
    async start() {
      await this.components.registrar.handle(this.protocol, this.handlePing, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      this.started = true;
    }
    async stop() {
      await this.components.registrar.unhandle(this.protocol);
      this.started = false;
    }
    isStarted() {
      return this.started;
    }
    /**
     * A handler to register with Libp2p to process ping messages
     */
    async handlePing(stream, connection) {
      const log18 = stream.log.newScope("ping");
      log18.trace("ping from %p", connection.remotePeer);
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      signal.addEventListener("abort", () => {
        stream.abort(new TimeoutError("Ping timed out"));
      });
      const start2 = Date.now();
      for await (const buf2 of stream) {
        if (stream.status !== "open") {
          log18("stream status changed to %s", stream.status);
          break;
        }
        if (!stream.send(buf2)) {
          log18("waiting for stream to drain");
          await pEvent(stream, "drain", {
            rejectionEvents: [
              "close"
            ],
            signal
          });
          log18("stream drained");
        }
      }
      log18("ping from %p complete in %dms", connection.remotePeer, Date.now() - start2);
      await stream.close({
        signal
      });
    }
    /**
     * Ping a given peer and wait for its response, getting the operation latency.
     */
    async ping(peer, options2 = {}) {
      const data = randomBytes2(PING_LENGTH2);
      const stream = await this.components.connectionManager.openStream(peer, this.protocol, {
        runOnLimitedConnection: this.runOnLimitedConnection,
        ...options2
      });
      const log18 = stream.log.newScope("ping");
      try {
        const start2 = Date.now();
        const finished = Promise.withResolvers();
        const received = new Uint8ArrayList();
        const onPong = (evt) => {
          received.append(evt.data);
          if (received.byteLength === PING_LENGTH2) {
            stream.removeEventListener("message", onPong);
            const rtt = Date.now() - start2;
            Promise.all([
              stream.closeRead(options2)
            ]).then(() => {
              if (!equals3(data, received.subarray())) {
                throw new ProtocolError(`Received wrong ping ack after ${rtt}ms`);
              } else {
                finished.resolve(rtt);
              }
            }).catch((err2) => {
              stream.abort(err2);
              finished.reject(err2);
            });
          }
        };
        stream.addEventListener("message", onPong);
        stream.send(data);
        await stream.close(options2);
        return await raceSignal(finished.promise, options2.signal);
      } catch (err2) {
        log18.error("error while pinging %o - %e", peer, err2);
        stream?.abort(err2);
        throw err2;
      } finally {
        stream?.close();
      }
    }
  };

  // node_modules/@libp2p/ping/dist/src/index.js
  function ping(init = {}) {
    return (components) => new Ping(components, init);
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/pb/message.js
  var Message3;
  (function(Message5) {
    let Flag2;
    (function(Flag3) {
      Flag3["FIN"] = "FIN";
      Flag3["STOP_SENDING"] = "STOP_SENDING";
      Flag3["RESET"] = "RESET";
      Flag3["FIN_ACK"] = "FIN_ACK";
    })(Flag2 = Message5.Flag || (Message5.Flag = {}));
    let __FlagValues;
    (function(__FlagValues2) {
      __FlagValues2[__FlagValues2["FIN"] = 0] = "FIN";
      __FlagValues2[__FlagValues2["STOP_SENDING"] = 1] = "STOP_SENDING";
      __FlagValues2[__FlagValues2["RESET"] = 2] = "RESET";
      __FlagValues2[__FlagValues2["FIN_ACK"] = 3] = "FIN_ACK";
    })(__FlagValues || (__FlagValues = {}));
    (function(Flag3) {
      Flag3.codec = () => {
        return enumeration(__FlagValues);
      };
    })(Flag2 = Message5.Flag || (Message5.Flag = {}));
    let _codec;
    Message5.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.flag != null) {
            w.uint32(8);
            Message5.Flag.codec().encode(obj.flag, w);
          }
          if (obj.message != null) {
            w.uint32(18);
            w.bytes(obj.message);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.flag = Message5.Flag.codec().decode(reader2);
                break;
              }
              case 2: {
                obj.message = reader2.bytes();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Message5.encode = (obj) => {
      return encodeMessage(obj, Message5.codec());
    };
    Message5.decode = (buf2, opts) => {
      return decodeMessage(buf2, Message5.codec(), opts);
    };
  })(Message3 || (Message3 = {}));

  // node_modules/@libp2p/webrtc/dist/src/constants.js
  var DEFAULT_ICE_SERVERS = [
    "stun:stun.l.google.com:19302",
    "stun:global.stun.twilio.com:3478",
    "stun:stun.cloudflare.com:3478",
    "stun:stun.services.mozilla.com:3478"
  ];
  var UFRAG_ALPHABET = Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
  var UFRAG_PREFIX = "libp2p+webrtc+v1/";
  var MAX_BUFFERED_AMOUNT = 2 * 1024 * 1024;
  var MAX_MESSAGE_SIZE3 = 16 * 1024;
  function calculateProtobufOverhead(maxMessageSize = MAX_MESSAGE_SIZE3) {
    const messageLength = encodingLength2(maxMessageSize - encodingLength2(maxMessageSize));
    const flagField = 1 + encodingLength2(Object.keys(Message3.Flag).length - 1);
    const messageFieldIdType = 1;
    const available = maxMessageSize - messageLength - flagField - messageFieldIdType;
    const messageFieldLengthLength = encodingLength2(available);
    return messageLength + flagField + messageFieldIdType + messageFieldLengthLength;
  }
  var PROTOBUF_OVERHEAD = calculateProtobufOverhead();
  var DEFAULT_FIN_ACK_TIMEOUT = 1e4;
  var MUXER_PROTOCOL = "/webrtc";
  var SIGNALING_PROTOCOL = "/webrtc-signaling/0.0.1";
  var DEFAULT_CERTIFICATE_DATASTORE_KEY = "/libp2p/webrtc-direct/certificate";
  var DEFAULT_CERTIFICATE_PRIVATE_KEY_NAME = "webrtc-direct-certificate-private-key";
  var DEFAULT_CERTIFICATE_LIFESPAN = 12096e5;
  var DEFAULT_CERTIFICATE_RENEWAL_THRESHOLD = 864e5;

  // node_modules/detect-browser/es/index.js
  var __spreadArray = function(to, from3, pack2) {
    if (pack2 || arguments.length === 2) for (var i2 = 0, l2 = from3.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from3)) {
        if (!ar) ar = Array.prototype.slice.call(from3, 0, i2);
        ar[i2] = from3[i2];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from3));
  };
  var BrowserInfo = (
    /** @class */
    /* @__PURE__ */ (function() {
      function BrowserInfo2(name9, version3, os) {
        this.name = name9;
        this.version = version3;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo2;
    })()
  );
  var NodeInfo = (
    /** @class */
    /* @__PURE__ */ (function() {
      function NodeInfo2(version3) {
        this.version = version3;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    })()
  );
  var SearchBotDeviceInfo = (
    /** @class */
    /* @__PURE__ */ (function() {
      function SearchBotDeviceInfo2(name9, version3, os, bot) {
        this.name = name9;
        this.version = version3;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    })()
  );
  var BotInfo = (
    /** @class */
    /* @__PURE__ */ (function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    })()
  );
  var ReactNativeInfo = (
    /** @class */
    /* @__PURE__ */ (function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    })()
  );
  var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS = 3;
  var userAgentRules = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", SEARCHBOX_UA_REGEX]
  ];
  var operatingSystemRules = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/]
  ];
  function detect(userAgent2) {
    if (!!userAgent2) {
      return parseUserAgent(userAgent2);
    }
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
      return new ReactNativeInfo();
    }
    if (typeof navigator !== "undefined") {
      return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
  }
  function matchUserAgent(ua) {
    return ua !== "" && userAgentRules.reduce(function(matched, _a4) {
      var browser2 = _a4[0], regex = _a4[1];
      if (matched) {
        return matched;
      }
      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser2, uaMatch];
    }, false);
  }
  function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
      return null;
    }
    var name9 = matchedRule[0], match = matchedRule[1];
    if (name9 === "searchbot") {
      return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
      }
    } else {
      versionParts = [];
    }
    var version3 = versionParts.join(".");
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name9, version3, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name9, version3, os);
  }
  function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
      var _a4 = operatingSystemRules[ii], os = _a4[0], regex = _a4[1];
      var match = regex.exec(ua);
      if (match) {
        return os;
      }
    }
    return null;
  }
  function getNodeVersion() {
    var isNode = typeof process !== "undefined" && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
  }
  function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
      output.push("0");
    }
    return output;
  }

  // node_modules/@libp2p/webrtc/dist/src/util.js
  var browser = detect();
  var isFirefox = browser != null && browser.name === "firefox";
  async function getRtcConfiguration(config) {
    config = config ?? {};
    if (typeof config === "function") {
      config = await config();
    }
    config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map((url) => ({
      urls: [
        url
      ]
    }));
    return config;
  }
  var genUfrag = (len = 32) => {
    return UFRAG_PREFIX + [...Array(len)].map(() => UFRAG_ALPHABET.at(Math.floor(Math.random() * UFRAG_ALPHABET.length))).join("");
  };

  // node_modules/@libp2p/webrtc/dist/src/stream.js
  var WebRTCStream = class extends AbstractStream {
    /**
     * The data channel used to send and receive data
     */
    channel;
    /**
     * push data from the underlying datachannel to the length prefix decoder
     * and then the protobuf decoder.
     */
    incomingData;
    maxBufferedAmount;
    receivedFinAck;
    finAckTimeout;
    constructor(init) {
      super({
        ...init,
        maxMessageSize: (init.maxMessageSize ?? MAX_MESSAGE_SIZE3) - PROTOBUF_OVERHEAD
      });
      this.channel = init.channel;
      this.channel.binaryType = "arraybuffer";
      this.incomingData = pushable();
      this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
      this.finAckTimeout = init.finAckTimeout ?? DEFAULT_FIN_ACK_TIMEOUT;
      this.channel.onclose = () => {
        this.log.trace("received datachannel close event");
        this.onRemoteCloseWrite();
        this.onTransportClosed();
      };
      this.channel.onerror = (evt) => {
        const err2 = evt.error;
        this.log.trace("received datachannel error event - %e", err2);
        this.abort(err2);
      };
      this.channel.onmessage = async (event) => {
        this.log("incoming message %d bytes", event.data.byteLength);
        const { data } = event;
        if (data === null || data.byteLength === 0) {
          return;
        }
        this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
      };
      this.channel.bufferedAmountLowThreshold = 0;
      this.channel.onbufferedamountlow = () => {
        if (this.writableNeedsDrain) {
          this.safeDispatchEvent("drain");
        }
      };
      Promise.resolve().then(async () => {
        for await (const buf2 of decode10(this.incomingData)) {
          this.processIncomingProtobuf(buf2);
        }
      }).catch((err2) => {
        this.log.error("error processing incoming data channel messages - %e", err2);
      });
      const cleanUpDatachannelOnClose = () => {
        if (this.channel.readyState === "open") {
          this.log.trace("stream closed, closing underlying datachannel");
          this.channel.close();
        }
      };
      this.addEventListener("close", cleanUpDatachannelOnClose);
      if (this.channel.readyState !== "open") {
        this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState);
        pEvent(this.channel, "open", {
          rejectionEvents: [
            "close",
            "error"
          ]
        }).then(() => {
          this.log('channel ready state is now "%s", dispatching drain', this.channel.readyState);
          this.safeDispatchEvent("drain");
        }).catch((err2) => {
          this.abort(err2.error ?? err2);
        });
      }
    }
    sendNewStream() {
    }
    _sendMessage(data) {
      if (this.channel.readyState !== "open") {
        throw new StreamStateError(`Invalid datachannel state - ${this.channel.readyState}`);
      }
      this.log.trace('sending message, channel state "%s"', this.channel.readyState);
      if (isFirefox) {
        this.channel.send(data.subarray());
        return;
      }
      for (const buf2 of data) {
        this.channel.send(buf2);
      }
    }
    sendData(data) {
      if (this.channel.readyState !== "open") {
        return {
          sentBytes: 0,
          canSendMore: false
        };
      }
      this._sendMessage(encode9.single(Message3.encode({
        message: data.subarray()
      })));
      return {
        sentBytes: data.byteLength,
        canSendMore: this.channel.bufferedAmount < this.maxBufferedAmount
      };
    }
    sendReset(err2) {
      try {
        this.log.error("sending reset - %e", err2);
        this._sendFlag(Message3.Flag.RESET);
        this.receivedFinAck?.reject(err2);
      } catch (err3) {
        this.log.error("failed to send reset - %e", err3);
      }
    }
    async sendCloseWrite(options2) {
      this._sendFlag(Message3.Flag.FIN);
      options2?.signal?.throwIfAborted();
      this.receivedFinAck = Promise.withResolvers();
      const signal = options2?.signal ?? AbortSignal.timeout(this.finAckTimeout);
      const eventPromises = [
        pEvent(this.channel, "close", {
          signal
        }),
        pEvent(this.channel, "error", {
          signal
        })
      ];
      await Promise.any([
        raceSignal(this.receivedFinAck.promise, signal),
        ...eventPromises
      ]).finally(() => {
        eventPromises.forEach((p2) => p2.cancel());
      });
    }
    async sendCloseRead(options2) {
      this._sendFlag(Message3.Flag.STOP_SENDING);
      options2?.signal?.throwIfAborted();
    }
    /**
     * Handle incoming
     */
    processIncomingProtobuf(buffer2) {
      const message2 = Message3.decode(buffer2);
      if (message2.message != null && (this.readStatus === "readable" || this.readStatus === "paused")) {
        this.onData(new Uint8ArrayList(message2.message));
      }
      if (message2.flag !== void 0) {
        this.log.trace('incoming flag %s, write status "%s", read status "%s"', message2.flag, this.writeStatus, this.readStatus);
        if (message2.flag === Message3.Flag.FIN) {
          this._sendFlag(Message3.Flag.FIN_ACK);
          this.onRemoteCloseWrite();
        }
        if (message2.flag === Message3.Flag.RESET) {
          this.receivedFinAck?.reject(new StreamResetError("The stream was reset"));
          this.onRemoteReset();
        }
        if (message2.flag === Message3.Flag.STOP_SENDING) {
          this.onRemoteCloseRead();
        }
        if (message2.flag === Message3.Flag.FIN_ACK) {
          this.receivedFinAck?.resolve();
        }
      }
    }
    _sendFlag(flag) {
      if (this.channel.readyState !== "open") {
        this.log.trace('not sending flag %s because channel is "%s" and not "open"', flag.toString(), this.channel.readyState);
        return false;
      }
      this.log.trace("sending flag %s", flag.toString());
      const messageBuf = Message3.encode({ flag });
      const prefixedBuf = encode9.single(messageBuf);
      try {
        this._sendMessage(prefixedBuf);
        return true;
      } catch (err2) {
        this.log.error("could not send flag %s - %e", flag.toString(), err2);
      }
      return false;
    }
    sendPause() {
    }
    sendResume() {
    }
  };
  function createStream2(options2) {
    const { channel, direction, isHandshake } = options2;
    return new WebRTCStream({
      ...options2,
      id: `${channel.id}`,
      log: options2.log.newScope(`${isHandshake === true ? "handshake" : direction}:${channel.id}`),
      protocol: ""
    });
  }

  // node_modules/@libp2p/webrtc/dist/src/muxer.js
  var DataChannelMuxerFactory = class {
    protocol;
    /**
     * WebRTC Peer Connection
     */
    peerConnection;
    metrics;
    dataChannelOptions;
    earlyDataChannels;
    constructor(init) {
      this.onEarlyDataChannel = this.onEarlyDataChannel.bind(this);
      this.peerConnection = init.peerConnection;
      this.metrics = init.metrics;
      this.protocol = init.protocol ?? MUXER_PROTOCOL;
      this.dataChannelOptions = init.dataChannelOptions ?? {};
      this.peerConnection.addEventListener("datachannel", this.onEarlyDataChannel);
      this.earlyDataChannels = [];
    }
    onEarlyDataChannel(evt) {
      this.earlyDataChannels.push(evt.channel);
    }
    createStreamMuxer(maConn) {
      this.peerConnection.removeEventListener("datachannel", this.onEarlyDataChannel);
      return new DataChannelMuxer(maConn, {
        peerConnection: this.peerConnection,
        dataChannelOptions: this.dataChannelOptions,
        metrics: this.metrics,
        protocol: this.protocol,
        earlyDataChannels: this.earlyDataChannels
      });
    }
  };
  var DataChannelMuxer = class extends AbstractStreamMuxer {
    peerConnection;
    dataChannelOptions;
    constructor(maConn, init) {
      super(maConn, {
        ...init,
        name: "muxer"
      });
      this.peerConnection = init.peerConnection;
      this.protocol = init.protocol ?? MUXER_PROTOCOL;
      this.dataChannelOptions = init.dataChannelOptions ?? {};
      this.peerConnection.ondatachannel = ({ channel }) => {
        this.onDataChannel(channel);
      };
      queueMicrotask(() => {
        if (this.status !== "open") {
          init.earlyDataChannels.forEach((channel) => {
            channel.close();
          });
          return;
        }
        init.earlyDataChannels.forEach((channel) => {
          this.onDataChannel(channel);
        });
      });
    }
    onDataChannel(channel) {
      this.log("incoming datachannel with channel id %d, protocol %s and status %s", channel.id, channel.protocol, channel.readyState);
      if (channel.label === "init") {
        this.log.trace("closing init channel %d", channel.id);
        channel.close();
        return;
      }
      const stream = createStream2({
        ...this.streamOptions,
        ...this.dataChannelOptions,
        channel,
        direction: "inbound",
        log: this.log
      });
      this.onRemoteStream(stream);
    }
    async onCreateStream(options2) {
      const channel = this.peerConnection.createDataChannel("", {
        // TODO: pre-negotiate stream protocol
        // protocol: options?.protocol
      });
      this.log("open channel %d for protocol %s", channel.id, options2?.protocol);
      const stream = createStream2({
        ...options2,
        ...this.dataChannelOptions,
        channel,
        direction: "outbound",
        log: this.log
      });
      return stream;
    }
    onData() {
    }
  };

  // node_modules/@libp2p/webrtc/dist/src/rtcpeerconnection-to-conn.js
  var RTCPeerConnectionMultiaddrConnection = class extends AbstractMultiaddrConnection {
    peerConnection;
    constructor(init) {
      super(init);
      this.peerConnection = init.peerConnection;
      const initialState = init.peerConnection.connectionState;
      this.peerConnection.onconnectionstatechange = () => {
        this.log.trace("peer connection state change %s initial state %s", this.peerConnection.connectionState, initialState);
        if (this.peerConnection.connectionState === "disconnected" || this.peerConnection.connectionState === "failed" || this.peerConnection.connectionState === "closed") {
          this.onTransportClosed();
          this.peerConnection.close();
        }
      };
    }
    sendData(data) {
      return {
        sentBytes: data.byteLength,
        canSendMore: true
      };
    }
    async sendClose(options2) {
      this.peerConnection.close();
      options2?.signal?.throwIfAborted();
    }
    sendReset() {
      this.peerConnection.close();
    }
    sendPause() {
    }
    sendResume() {
    }
  };
  var toMultiaddrConnection = (init) => {
    return new RTCPeerConnectionMultiaddrConnection(init);
  };

  // node_modules/@libp2p/webrtc/dist/src/webrtc/index.browser.js
  var RTCPeerConnection2 = globalThis.RTCPeerConnection;
  var RTCSessionDescription = globalThis.RTCSessionDescription;
  var RTCIceCandidate = globalThis.RTCIceCandidate;

  // node_modules/@libp2p/webrtc/dist/src/error.js
  var WebRTCTransportError = class extends Error {
    constructor(msg) {
      super(`WebRTC transport error: ${msg}`);
      this.name = "WebRTCTransportError";
    }
  };
  var SDPHandshakeFailedError = class extends WebRTCTransportError {
    constructor(message2 = "SDP handshake failed") {
      super(message2);
      this.name = "SDPHandshakeFailedError";
    }
  };
  var InvalidFingerprintError = class extends WebRTCTransportError {
    constructor(fingerprint, source) {
      super(`Invalid fingerprint "${fingerprint}" within ${source}`);
      this.name = "WebRTC/InvalidFingerprintError";
    }
  };
  var UnimplementedError = class extends WebRTCTransportError {
    constructor(methodName) {
      super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`);
      this.name = "WebRTC/UnimplementedError";
    }
  };
  var UnsupportedHashAlgorithmError = class extends WebRTCTransportError {
    constructor(algo) {
      super(`unsupported hash algorithm code: ${algo} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `);
      this.name = "WebRTC/UnsupportedHashAlgorithmError";
    }
  };

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/pb/message.js
  var Message4;
  (function(Message5) {
    let Type2;
    (function(Type3) {
      Type3["SDP_OFFER"] = "SDP_OFFER";
      Type3["SDP_ANSWER"] = "SDP_ANSWER";
      Type3["ICE_CANDIDATE"] = "ICE_CANDIDATE";
    })(Type2 = Message5.Type || (Message5.Type = {}));
    let __TypeValues;
    (function(__TypeValues2) {
      __TypeValues2[__TypeValues2["SDP_OFFER"] = 0] = "SDP_OFFER";
      __TypeValues2[__TypeValues2["SDP_ANSWER"] = 1] = "SDP_ANSWER";
      __TypeValues2[__TypeValues2["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
    })(__TypeValues || (__TypeValues = {}));
    (function(Type3) {
      Type3.codec = () => {
        return enumeration(__TypeValues);
      };
    })(Type2 = Message5.Type || (Message5.Type = {}));
    let _codec;
    Message5.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.type != null) {
            w.uint32(8);
            Message5.Type.codec().encode(obj.type, w);
          }
          if (obj.data != null) {
            w.uint32(18);
            w.string(obj.data);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.type = Message5.Type.codec().decode(reader2);
                break;
              }
              case 2: {
                obj.data = reader2.string();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Message5.encode = (obj) => {
      return encodeMessage(obj, Message5.codec());
    };
    Message5.decode = (buf2, opts) => {
      return decodeMessage(buf2, Message5.codec(), opts);
    };
  })(Message4 || (Message4 = {}));

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/util.js
  var readCandidatesUntilConnected = async (pc, stream, options2) => {
    try {
      const connectedPromise = Promise.withResolvers();
      resolveOnConnected(pc, connectedPromise);
      while (true) {
        const message2 = await Promise.race([
          connectedPromise.promise,
          stream.read({
            signal: options2.signal
          })
        ]);
        if (message2 == null) {
          options2.signal?.throwIfAborted();
          break;
        }
        if (message2.type !== Message4.Type.ICE_CANDIDATE) {
          throw new InvalidMessageError("ICE candidate message expected");
        }
        const candidateInit = JSON.parse(message2.data ?? "null");
        if (candidateInit === "" || candidateInit === null) {
          options2.onProgress?.(new CustomProgressEvent("webrtc:end-of-ice-candidates"));
          options2.log.trace("end-of-candidates received");
          continue;
        }
        const candidate = new RTCIceCandidate(candidateInit);
        options2.log.trace("%s received new ICE candidate %o", options2.direction, candidateInit);
        try {
          options2.onProgress?.(new CustomProgressEvent("webrtc:add-ice-candidate", candidate.candidate));
          await pc.addIceCandidate(candidate);
        } catch (err2) {
          options2.log.error("%s bad candidate received %o - %e", options2.direction, candidateInit, err2);
        }
      }
    } catch (err2) {
      options2.log.error("%s error parsing ICE candidate - %e", options2.direction, err2);
      if (options2.signal?.aborted === true && pc.connectionState !== "connected") {
        throw err2;
      }
    }
  };
  function resolveOnConnected(pc, promise) {
    if (pc.connectionState === "connected") {
      promise.resolve();
      return;
    }
    pc.onconnectionstatechange = (_) => {
      switch (pc.connectionState) {
        case "connected":
          promise.resolve();
          break;
        case "failed":
        case "disconnected":
        case "closed":
          promise.reject(new ConnectionFailedError(`RTCPeerConnection connection state became "${pc.connectionState}"`));
          break;
        default:
          break;
      }
    };
  }
  function getRemotePeer(ma) {
    let remotePeer;
    for (const component of ma.getComponents()) {
      if (component.name === "p2p") {
        remotePeer = peerIdFromString(component.value ?? "");
      }
    }
    if (remotePeer == null) {
      throw new InvalidMultiaddrError("Remote peerId must be present in multiaddr");
    }
    return remotePeer;
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/initiate-connection.js
  async function initiateConnection({ rtcConfiguration, dataChannel, signal, metrics, multiaddr: ma, connectionManager, transportManager, log: log18, logger: logger2, onProgress }) {
    const { circuitAddress, targetPeer } = splitAddr(ma);
    metrics?.dialerEvents.increment({ open: true });
    log18.trace("dialing circuit address: %a", circuitAddress);
    const connections = connectionManager.getConnections(targetPeer);
    let connection;
    if (connections.length === 0) {
      onProgress?.(new CustomProgressEvent("webrtc:dial-relay"));
      connection = await transportManager.dial(circuitAddress, {
        signal,
        onProgress
      });
    } else {
      onProgress?.(new CustomProgressEvent("webrtc:reuse-relay-connection"));
      connection = connections[0];
    }
    onProgress?.(new CustomProgressEvent("webrtc:open-signaling-stream"));
    const stream = await connection.newStream(SIGNALING_PROTOCOL, {
      signal,
      runOnLimitedConnection: true
    });
    const messageStream = pbStream(stream).pb(Message4);
    const peerConnection = new RTCPeerConnection2(rtcConfiguration);
    peerConnection.addEventListener("connectionstatechange", () => {
      switch (peerConnection.connectionState) {
        case "closed":
          peerConnection.close();
          break;
        default:
          break;
      }
    });
    const muxerFactory = new DataChannelMuxerFactory({
      // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
      peerConnection,
      dataChannelOptions: dataChannel
    });
    try {
      const channel = peerConnection.createDataChannel("init");
      peerConnection.onicecandidate = ({ candidate }) => {
        if (peerConnection.connectionState === "connected") {
          log18.trace("ignore new ice candidate as peer connection is already connected");
          return;
        }
        if (candidate == null || candidate?.candidate === "") {
          log18.trace("initiator detected end of ICE candidates");
          return;
        }
        const data = JSON.stringify(candidate?.toJSON() ?? null);
        log18.trace("initiator sending ICE candidate %o", candidate);
        void messageStream.write({
          type: Message4.Type.ICE_CANDIDATE,
          data
        }, {
          signal
        }).catch((err2) => {
          log18.error("error sending ICE candidate - %e", err2);
        });
      };
      peerConnection.onicecandidateerror = (event) => {
        log18.error("initiator ICE candidate error", event);
      };
      const offerSdp = await peerConnection.createOffer().catch((err2) => {
        log18.error("could not execute createOffer - %e", err2);
        throw new SDPHandshakeFailedError("Failed to set createOffer");
      });
      log18.trace("initiator send SDP offer %s", offerSdp.sdp);
      onProgress?.(new CustomProgressEvent("webrtc:send-sdp-offer"));
      await messageStream.write({ type: Message4.Type.SDP_OFFER, data: offerSdp.sdp }, {
        signal
      });
      await peerConnection.setLocalDescription(offerSdp).catch((err2) => {
        log18.error("could not execute setLocalDescription - %e", err2);
        throw new SDPHandshakeFailedError("Failed to set localDescription");
      });
      onProgress?.(new CustomProgressEvent("webrtc:read-sdp-answer"));
      log18.trace("initiator read SDP answer");
      const answerMessage = await messageStream.read({
        signal
      });
      if (answerMessage.type !== Message4.Type.SDP_ANSWER) {
        throw new SDPHandshakeFailedError("Remote should send an SDP answer");
      }
      log18.trace("initiator received SDP answer %s", answerMessage.data);
      const answerSdp = new RTCSessionDescription({ type: "answer", sdp: answerMessage.data });
      await peerConnection.setRemoteDescription(answerSdp).catch((err2) => {
        log18.error("could not execute setRemoteDescription - %e", err2);
        throw new SDPHandshakeFailedError("Failed to set remoteDescription");
      });
      log18.trace("initiator read candidates until connected");
      onProgress?.(new CustomProgressEvent("webrtc:read-ice-candidates"));
      await readCandidatesUntilConnected(peerConnection, messageStream, {
        direction: "initiator",
        signal,
        log: log18,
        onProgress
      });
      log18.trace("initiator connected");
      if (channel.readyState !== "open") {
        log18.trace("wait for init channel to open");
        await pEvent(channel, "open", {
          signal
        });
      }
      log18.trace("closing init channel");
      channel.close();
      log18.trace("waiting for init channel to close");
      await pEvent(channel, "close", {
        signal
      });
      onProgress?.(new CustomProgressEvent("webrtc:close-signaling-stream"));
      log18.trace("closing signaling channel");
      await stream.close({
        signal
      });
      log18.trace("initiator connected to remote address %s", ma);
      return {
        remoteAddress: ma,
        // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
        peerConnection,
        muxerFactory
      };
    } catch (err2) {
      log18.error("outgoing signaling error - %e", err2);
      peerConnection.close();
      stream.abort(err2);
      throw err2;
    } finally {
      peerConnection.onicecandidate = null;
      peerConnection.onicecandidateerror = null;
    }
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/listener.js
  var Circuit2 = fmt(P2P.matchers[0], code7(CODE_P2P_CIRCUIT));
  var WebRTCPeerListener = class _WebRTCPeerListener extends TypedEventEmitter {
    transportManager;
    shutdownController;
    events;
    constructor(components, init) {
      super();
      this.transportManager = components.transportManager;
      this.events = components.events;
      this.shutdownController = init.shutdownController;
      this.onTransportListening = this.onTransportListening.bind(this);
    }
    async listen() {
      this.events.addEventListener("transport:listening", this.onTransportListening);
    }
    onTransportListening(event) {
      const circuitAddresses = event.detail.getAddrs().filter((ma) => Circuit2.exactMatch(ma)).map((ma) => {
        return ma.encapsulate("/webrtc");
      });
      if (circuitAddresses.length > 0) {
        this.safeDispatchEvent("listening");
      }
    }
    getAddrs() {
      return this.transportManager.getListeners().filter((l2) => !(l2 instanceof _WebRTCPeerListener)).map((l2) => l2.getAddrs().filter((ma) => Circuit2.exactMatch(ma)).map((ma) => {
        return ma.encapsulate("/webrtc");
      })).flat();
    }
    updateAnnounceAddrs() {
    }
    async close() {
      this.events.removeEventListener("transport:listening", this.onTransportListening);
      this.shutdownController.abort();
      queueMicrotask(() => {
        this.safeDispatchEvent("close");
      });
    }
  };

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/signaling-stream-handler.js
  async function handleIncomingStream(stream, connection, { peerConnection, signal, log: log18 }) {
    log18.trace("new inbound signaling stream");
    const messageStream = pbStream(stream).pb(Message4);
    try {
      peerConnection.onicecandidate = ({ candidate }) => {
        if (peerConnection.connectionState === "connected") {
          log18.trace("ignore new ice candidate as peer connection is already connected");
          return;
        }
        if (candidate == null || candidate?.candidate === "") {
          log18.trace("recipient detected end of ICE candidates");
          return;
        }
        const data = JSON.stringify(candidate?.toJSON() ?? null);
        log18.trace("recipient sending ICE candidate %s", data);
        messageStream.write({
          type: Message4.Type.ICE_CANDIDATE,
          data
        }, {
          signal
        }).catch((err2) => {
          log18.error("error sending ICE candidate - %e", err2);
        });
      };
      log18.trace("recipient read SDP offer");
      const pbOffer = await messageStream.read({
        signal
      });
      if (pbOffer.type !== Message4.Type.SDP_OFFER) {
        throw new SDPHandshakeFailedError(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `);
      }
      log18.trace("recipient received SDP offer %s", pbOffer.data);
      const offer = new RTCSessionDescription({
        type: "offer",
        sdp: pbOffer.data
      });
      await peerConnection.setRemoteDescription(offer).catch((err2) => {
        log18.error("could not execute setRemoteDescription - %e", err2);
        throw new SDPHandshakeFailedError("Failed to set remoteDescription");
      });
      const answer = await peerConnection.createAnswer().catch((err2) => {
        log18.error("could not execute createAnswer - %e", err2);
        throw new SDPHandshakeFailedError("Failed to create answer");
      });
      log18.trace("recipient send SDP answer %s", answer.sdp);
      await messageStream.write({ type: Message4.Type.SDP_ANSWER, data: answer.sdp }, {
        signal
      });
      await peerConnection.setLocalDescription(answer).catch((err2) => {
        log18.error("could not execute setLocalDescription - %e", err2);
        throw new SDPHandshakeFailedError("Failed to set localDescription");
      });
      log18.trace("recipient read candidates until connected");
      await readCandidatesUntilConnected(peerConnection, messageStream, {
        direction: "recipient",
        signal,
        log: log18
      });
    } catch (err2) {
      if (peerConnection.connectionState !== "connected") {
        log18.error("error while handling signaling stream from peer %a - %e", connection.remoteAddr, err2);
        peerConnection.close();
        throw err2;
      } else {
        log18("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", connection.remoteAddr, err2);
      }
    }
    const remotePeer = getRemotePeer(connection.remoteAddr);
    const remoteAddress = multiaddr(`/webrtc/p2p/${remotePeer}`);
    log18.trace("recipient connected to remote address %s", remoteAddress);
    return {
      remoteAddress,
      remotePeer
    };
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js
  var WebRTCTransport = class {
    components;
    init;
    log;
    _started = false;
    metrics;
    shutdownController;
    constructor(components, init = {}) {
      this.components = components;
      this.init = init;
      this.log = components.logger.forComponent("libp2p:webrtc");
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
      if (components.metrics != null) {
        this.metrics = {
          dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
            label: "event",
            help: "Total count of WebRTC dialer events by type"
          }),
          listenerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
            label: "event",
            help: "Total count of WebRTC listener events by type"
          })
        };
      }
    }
    [transportSymbol] = true;
    [Symbol.toStringTag] = "@libp2p/webrtc";
    [serviceCapabilities] = [
      "@libp2p/transport"
    ];
    [serviceDependencies] = [
      "@libp2p/identify",
      "@libp2p/circuit-relay-v2-transport"
    ];
    isStarted() {
      return this._started;
    }
    async start() {
      await this.components.registrar.handle(SIGNALING_PROTOCOL, (stream, connection) => {
        const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
        this._onProtocol(stream, connection, signal).catch((err2) => {
          this.log.error("failed to handle incoming connect from %p - %e", connection.remotePeer, err2);
        }).finally(() => {
          signal.clear();
        });
      }, {
        runOnLimitedConnection: true
      });
      this._started = true;
    }
    async stop() {
      await this.components.registrar.unhandle(SIGNALING_PROTOCOL);
      this._started = false;
    }
    createListener(options2) {
      return new WebRTCPeerListener(this.components, {
        shutdownController: this.shutdownController
      });
    }
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs) {
      return multiaddrs.filter(WebRTC.exactMatch);
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs) {
      return this.listenFilter(multiaddrs);
    }
    /*
     * dial connects to a remote via the circuit relay or any other protocol
     * and proceeds to upgrade to a webrtc connection.
     * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
     * For a circuit relay, this will be of the form
     * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
    */
    async dial(ma, options2) {
      this.log.trace("dialing address: %a", ma);
      const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({
        rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),
        dataChannel: this.init.dataChannel,
        multiaddr: ma,
        dataChannelOptions: this.init.dataChannel,
        signal: options2.signal,
        connectionManager: this.components.connectionManager,
        transportManager: this.components.transportManager,
        log: this.log,
        logger: this.components.logger,
        onProgress: options2.onProgress
      });
      const webRTCConn = toMultiaddrConnection({
        peerConnection,
        remoteAddr: remoteAddress,
        metrics: this.metrics?.dialerEvents,
        direction: "outbound",
        log: this.components.logger.forComponent("libp2p:webrtc:connection")
      });
      const connection = await options2.upgrader.upgradeOutbound(webRTCConn, {
        skipProtection: true,
        skipEncryption: true,
        remotePeer: getRemotePeer(ma),
        muxerFactory,
        onProgress: options2.onProgress,
        signal: options2.signal
      });
      this._closeOnShutdown(peerConnection, webRTCConn);
      return connection;
    }
    async _onProtocol(stream, connection, signal) {
      const peerConnection = new RTCPeerConnection2(await getRtcConfiguration(this.init.rtcConfiguration));
      peerConnection.addEventListener("connectionstatechange", () => {
        switch (peerConnection.connectionState) {
          case "closed":
            peerConnection.close();
            break;
          default:
            break;
        }
      });
      const muxerFactory = new DataChannelMuxerFactory({
        // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
        peerConnection,
        dataChannelOptions: this.init.dataChannel
      });
      try {
        const { remoteAddress, remotePeer } = await handleIncomingStream(stream, connection, {
          peerConnection,
          signal,
          log: this.log
        });
        await stream.close({
          signal
        });
        const webRTCConn = toMultiaddrConnection({
          // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
          peerConnection,
          remoteAddr: remoteAddress,
          metrics: this.metrics?.listenerEvents,
          direction: "inbound",
          log: this.components.logger.forComponent("libp2p:webrtc:connection")
        });
        await this.components.upgrader.upgradeInbound(webRTCConn, {
          skipEncryption: true,
          skipProtection: true,
          remotePeer,
          muxerFactory,
          signal
        });
        this._closeOnShutdown(peerConnection, webRTCConn);
      } catch (err2) {
        this.log.error("incoming signaling error - %e", err2);
        peerConnection.close();
        stream.abort(err2);
        throw err2;
      }
    }
    _closeOnShutdown(pc, webRTCConn) {
      const shutDownListener = () => {
        webRTCConn.close().catch((err2) => {
          this.log.error("could not close WebRTCMultiaddrConnection - %e", err2);
        });
      };
      this.shutdownController.signal.addEventListener("abort", shutDownListener);
      pc.addEventListener("close", () => {
        this.shutdownController.signal.removeEventListener("abort", shutDownListener);
      });
    }
  };
  function splitAddr(ma) {
    const target = ma.getComponents().filter(({ name: name9 }) => name9 === "p2p").map(({ value: value2 }) => value2).pop();
    if (target == null) {
      throw new InvalidParametersError("Destination peer id was missing");
    }
    const circuitAddress = multiaddr(ma.getComponents().filter(({ name: name9 }) => name9 !== "webrtc"));
    return { circuitAddress, targetPeer: peerIdFromString(target) };
  }

  // node_modules/@peculiar/x509/build/x509.es.js
  var import_reflect_metadata = __toESM(require_Reflect());

  // node_modules/@peculiar/asn1-schema/build/es2015/enums.js
  var AsnTypeTypes;
  (function(AsnTypeTypes2) {
    AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";
    AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";
    AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";
  })(AsnTypeTypes || (AsnTypeTypes = {}));
  var AsnPropTypes;
  (function(AsnPropTypes2) {
    AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";
    AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";
    AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";
    AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";
    AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";
    AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";
    AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";
    AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";
    AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";
    AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";
    AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";
    AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";
    AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";
    AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";
    AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";
    AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";
    AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";
    AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";
    AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";
    AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";
    AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";
    AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";
    AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";
    AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";
    AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";
    AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";
    AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";
  })(AsnPropTypes || (AsnPropTypes = {}));

  // node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
  var import_pvtsutils = __toESM(require_build());
  var BitString2 = class {
    constructor(params, unusedBits = 0) {
      this.unusedBits = 0;
      this.value = new ArrayBuffer(0);
      if (params) {
        if (typeof params === "number") {
          this.fromNumber(params);
        } else if (import_pvtsutils.BufferSourceConverter.isBufferSource(params)) {
          this.unusedBits = unusedBits;
          this.value = import_pvtsutils.BufferSourceConverter.toArrayBuffer(params);
        } else {
          throw TypeError("Unsupported type of 'params' argument for BitString");
        }
      }
    }
    fromASN(asn) {
      if (!(asn instanceof BitString)) {
        throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
      }
      this.unusedBits = asn.valueBlock.unusedBits;
      this.value = asn.valueBlock.valueHex;
      return this;
    }
    toASN() {
      return new BitString({ unusedBits: this.unusedBits, valueHex: this.value });
    }
    toSchema(name9) {
      return new BitString({ name: name9 });
    }
    toNumber() {
      let res = "";
      const uintArray = new Uint8Array(this.value);
      for (const octet of uintArray) {
        res += octet.toString(2).padStart(8, "0");
      }
      res = res.split("").reverse().join("");
      if (this.unusedBits) {
        res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
      }
      return parseInt(res, 2);
    }
    fromNumber(value2) {
      let bits2 = value2.toString(2);
      const octetSize = bits2.length + 7 >> 3;
      this.unusedBits = (octetSize << 3) - bits2.length;
      const octets = new Uint8Array(octetSize);
      bits2 = bits2.padStart(octetSize << 3, "0").split("").reverse().join("");
      let index = 0;
      while (index < octetSize) {
        octets[index] = parseInt(bits2.slice(index << 3, (index << 3) + 8), 2);
        index++;
      }
      this.value = octets.buffer;
    }
  };

  // node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
  var import_pvtsutils2 = __toESM(require_build());
  var OctetString2 = class {
    get byteLength() {
      return this.buffer.byteLength;
    }
    get byteOffset() {
      return 0;
    }
    constructor(param) {
      if (typeof param === "number") {
        this.buffer = new ArrayBuffer(param);
      } else {
        if (import_pvtsutils2.BufferSourceConverter.isBufferSource(param)) {
          this.buffer = import_pvtsutils2.BufferSourceConverter.toArrayBuffer(param);
        } else if (Array.isArray(param)) {
          this.buffer = new Uint8Array(param);
        } else {
          this.buffer = new ArrayBuffer(0);
        }
      }
    }
    fromASN(asn) {
      if (!(asn instanceof OctetString)) {
        throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
      }
      this.buffer = asn.valueBlock.valueHex;
      return this;
    }
    toASN() {
      return new OctetString({ valueHex: this.buffer });
    }
    toSchema(name9) {
      return new OctetString({ name: name9 });
    }
  };

  // node_modules/@peculiar/asn1-schema/build/es2015/converters.js
  var AsnAnyConverter = {
    fromASN: (value2) => value2 instanceof Null ? null : value2.valueBeforeDecodeView,
    toASN: (value2) => {
      if (value2 === null) {
        return new Null();
      }
      const schema = fromBER(value2);
      if (schema.result.error) {
        throw new Error(schema.result.error);
      }
      return schema.result;
    }
  };
  var AsnIntegerConverter = {
    fromASN: (value2) => value2.valueBlock.valueHexView.byteLength >= 4 ? value2.valueBlock.toString() : value2.valueBlock.valueDec,
    toASN: (value2) => new Integer({ value: +value2 })
  };
  var AsnEnumeratedConverter = {
    fromASN: (value2) => value2.valueBlock.valueDec,
    toASN: (value2) => new Enumerated({ value: value2 })
  };
  var AsnIntegerArrayBufferConverter = {
    fromASN: (value2) => value2.valueBlock.valueHexView,
    toASN: (value2) => new Integer({ valueHex: value2 })
  };
  var AsnBitStringConverter = {
    fromASN: (value2) => value2.valueBlock.valueHexView,
    toASN: (value2) => new BitString({ valueHex: value2 })
  };
  var AsnObjectIdentifierConverter = {
    fromASN: (value2) => value2.valueBlock.toString(),
    toASN: (value2) => new ObjectIdentifier({ value: value2 })
  };
  var AsnBooleanConverter = {
    fromASN: (value2) => value2.valueBlock.value,
    toASN: (value2) => new Boolean2({ value: value2 })
  };
  var AsnOctetStringConverter = {
    fromASN: (value2) => value2.valueBlock.valueHexView,
    toASN: (value2) => new OctetString({ valueHex: value2 })
  };
  var AsnConstructedOctetStringConverter = {
    fromASN: (value2) => new OctetString2(value2.getValue()),
    toASN: (value2) => value2.toASN()
  };
  function createStringConverter(Asn1Type) {
    return {
      fromASN: (value2) => value2.valueBlock.value,
      toASN: (value2) => new Asn1Type({ value: value2 })
    };
  }
  var AsnUtf8StringConverter = createStringConverter(Utf8String);
  var AsnBmpStringConverter = createStringConverter(BmpString);
  var AsnUniversalStringConverter = createStringConverter(UniversalString);
  var AsnNumericStringConverter = createStringConverter(NumericString);
  var AsnPrintableStringConverter = createStringConverter(PrintableString);
  var AsnTeletexStringConverter = createStringConverter(TeletexString);
  var AsnVideotexStringConverter = createStringConverter(VideotexString);
  var AsnIA5StringConverter = createStringConverter(IA5String);
  var AsnGraphicStringConverter = createStringConverter(GraphicString);
  var AsnVisibleStringConverter = createStringConverter(VisibleString);
  var AsnGeneralStringConverter = createStringConverter(GeneralString);
  var AsnCharacterStringConverter = createStringConverter(CharacterString);
  var AsnUTCTimeConverter = {
    fromASN: (value2) => value2.toDate(),
    toASN: (value2) => new UTCTime({ valueDate: value2 })
  };
  var AsnGeneralizedTimeConverter = {
    fromASN: (value2) => value2.toDate(),
    toASN: (value2) => new GeneralizedTime({ valueDate: value2 })
  };
  var AsnNullConverter = {
    fromASN: () => null,
    toASN: () => {
      return new Null();
    }
  };
  function defaultConverter(type) {
    switch (type) {
      case AsnPropTypes.Any:
        return AsnAnyConverter;
      case AsnPropTypes.BitString:
        return AsnBitStringConverter;
      case AsnPropTypes.BmpString:
        return AsnBmpStringConverter;
      case AsnPropTypes.Boolean:
        return AsnBooleanConverter;
      case AsnPropTypes.CharacterString:
        return AsnCharacterStringConverter;
      case AsnPropTypes.Enumerated:
        return AsnEnumeratedConverter;
      case AsnPropTypes.GeneralString:
        return AsnGeneralStringConverter;
      case AsnPropTypes.GeneralizedTime:
        return AsnGeneralizedTimeConverter;
      case AsnPropTypes.GraphicString:
        return AsnGraphicStringConverter;
      case AsnPropTypes.IA5String:
        return AsnIA5StringConverter;
      case AsnPropTypes.Integer:
        return AsnIntegerConverter;
      case AsnPropTypes.Null:
        return AsnNullConverter;
      case AsnPropTypes.NumericString:
        return AsnNumericStringConverter;
      case AsnPropTypes.ObjectIdentifier:
        return AsnObjectIdentifierConverter;
      case AsnPropTypes.OctetString:
        return AsnOctetStringConverter;
      case AsnPropTypes.PrintableString:
        return AsnPrintableStringConverter;
      case AsnPropTypes.TeletexString:
        return AsnTeletexStringConverter;
      case AsnPropTypes.UTCTime:
        return AsnUTCTimeConverter;
      case AsnPropTypes.UniversalString:
        return AsnUniversalStringConverter;
      case AsnPropTypes.Utf8String:
        return AsnUtf8StringConverter;
      case AsnPropTypes.VideotexString:
        return AsnVideotexStringConverter;
      case AsnPropTypes.VisibleString:
        return AsnVisibleStringConverter;
      default:
        return null;
    }
  }

  // node_modules/@peculiar/asn1-schema/build/es2015/helper.js
  function isConvertible(target) {
    if (typeof target === "function" && target.prototype) {
      if (target.prototype.toASN && target.prototype.fromASN) {
        return true;
      } else {
        return isConvertible(target.prototype);
      }
    } else {
      return !!(target && typeof target === "object" && "toASN" in target && "fromASN" in target);
    }
  }
  function isTypeOfArray(target) {
    var _a4;
    if (target) {
      const proto = Object.getPrototypeOf(target);
      if (((_a4 = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a4 === void 0 ? void 0 : _a4.constructor) === Array) {
        return true;
      }
      return isTypeOfArray(proto);
    }
    return false;
  }
  function isArrayEqual(bytes1, bytes2) {
    if (!(bytes1 && bytes2)) {
      return false;
    }
    if (bytes1.byteLength !== bytes2.byteLength) {
      return false;
    }
    const b1 = new Uint8Array(bytes1);
    const b2 = new Uint8Array(bytes2);
    for (let i2 = 0; i2 < bytes1.byteLength; i2++) {
      if (b1[i2] !== b2[i2]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@peculiar/asn1-schema/build/es2015/schema.js
  var AsnSchemaStorage = class {
    constructor() {
      this.items = /* @__PURE__ */ new WeakMap();
    }
    has(target) {
      return this.items.has(target);
    }
    get(target, checkSchema = false) {
      const schema = this.items.get(target);
      if (!schema) {
        throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
      }
      if (checkSchema && !schema.schema) {
        throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
      }
      return schema;
    }
    cache(target) {
      const schema = this.get(target);
      if (!schema.schema) {
        schema.schema = this.create(target, true);
      }
    }
    createDefault(target) {
      const schema = { type: AsnTypeTypes.Sequence, items: {} };
      const parentSchema = this.findParentSchema(target);
      if (parentSchema) {
        Object.assign(schema, parentSchema);
        schema.items = Object.assign({}, schema.items, parentSchema.items);
      }
      return schema;
    }
    create(target, useNames) {
      const schema = this.items.get(target) || this.createDefault(target);
      const asn1Value = [];
      for (const key in schema.items) {
        const item = schema.items[key];
        const name9 = useNames ? key : "";
        let asn1Item;
        if (typeof item.type === "number") {
          const Asn1TypeName = AsnPropTypes[item.type];
          const Asn1Type = index_es_exports[Asn1TypeName];
          if (!Asn1Type) {
            throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
          }
          asn1Item = new Asn1Type({ name: name9 });
        } else if (isConvertible(item.type)) {
          const instance2 = new item.type();
          asn1Item = instance2.toSchema(name9);
        } else if (item.optional) {
          const itemSchema = this.get(item.type);
          if (itemSchema.type === AsnTypeTypes.Choice) {
            asn1Item = new Any({ name: name9 });
          } else {
            asn1Item = this.create(item.type, false);
            asn1Item.name = name9;
          }
        } else {
          asn1Item = new Any({ name: name9 });
        }
        const optional2 = !!item.optional || item.defaultValue !== void 0;
        if (item.repeated) {
          asn1Item.name = "";
          const Container = item.repeated === "set" ? Set2 : Sequence;
          asn1Item = new Container({
            name: "",
            value: [new Repeated({ name: name9, value: asn1Item })]
          });
        }
        if (item.context !== null && item.context !== void 0) {
          if (item.implicit) {
            if (typeof item.type === "number" || isConvertible(item.type)) {
              const Container = item.repeated ? Constructed : Primitive;
              asn1Value.push(new Container({ name: name9, optional: optional2, idBlock: { tagClass: 3, tagNumber: item.context } }));
            } else {
              this.cache(item.type);
              const isRepeated = !!item.repeated;
              let value2 = !isRepeated ? this.get(item.type, true).schema : asn1Item;
              value2 = "valueBlock" in value2 ? value2.valueBlock.value : value2.value;
              asn1Value.push(new Constructed({
                name: !isRepeated ? name9 : "",
                optional: optional2,
                idBlock: { tagClass: 3, tagNumber: item.context },
                value: value2
              }));
            }
          } else {
            asn1Value.push(new Constructed({
              optional: optional2,
              idBlock: { tagClass: 3, tagNumber: item.context },
              value: [asn1Item]
            }));
          }
        } else {
          asn1Item.optional = optional2;
          asn1Value.push(asn1Item);
        }
      }
      switch (schema.type) {
        case AsnTypeTypes.Sequence:
          return new Sequence({ value: asn1Value, name: "" });
        case AsnTypeTypes.Set:
          return new Set2({ value: asn1Value, name: "" });
        case AsnTypeTypes.Choice:
          return new Choice({ value: asn1Value, name: "" });
        default:
          throw new Error(`Unsupported ASN1 type in use`);
      }
    }
    set(target, schema) {
      this.items.set(target, schema);
      return this;
    }
    findParentSchema(target) {
      const parent = Object.getPrototypeOf(target);
      if (parent) {
        const schema = this.items.get(parent);
        return schema || this.findParentSchema(parent);
      }
      return null;
    }
  };

  // node_modules/@peculiar/asn1-schema/build/es2015/storage.js
  var schemaStorage = new AsnSchemaStorage();

  // node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
  var AsnType = (options2) => (target) => {
    let schema;
    if (!schemaStorage.has(target)) {
      schema = schemaStorage.createDefault(target);
      schemaStorage.set(target, schema);
    } else {
      schema = schemaStorage.get(target);
    }
    Object.assign(schema, options2);
  };
  var AsnProp = (options2) => (target, propertyKey) => {
    let schema;
    if (!schemaStorage.has(target.constructor)) {
      schema = schemaStorage.createDefault(target.constructor);
      schemaStorage.set(target.constructor, schema);
    } else {
      schema = schemaStorage.get(target.constructor);
    }
    const copyOptions = Object.assign({}, options2);
    if (typeof copyOptions.type === "number" && !copyOptions.converter) {
      const defaultConverter2 = defaultConverter(options2.type);
      if (!defaultConverter2) {
        throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
      }
      copyOptions.converter = defaultConverter2;
    }
    copyOptions.raw = options2.raw;
    schema.items[propertyKey] = copyOptions;
  };

  // node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js
  var AsnSchemaValidationError = class extends Error {
    constructor() {
      super(...arguments);
      this.schemas = [];
    }
  };

  // node_modules/@peculiar/asn1-schema/build/es2015/parser.js
  var AsnParser = class {
    static parse(data, target) {
      const asn1Parsed = fromBER(data);
      if (asn1Parsed.result.error) {
        throw new Error(asn1Parsed.result.error);
      }
      const res = this.fromASN(asn1Parsed.result, target);
      return res;
    }
    static fromASN(asn1Schema, target) {
      try {
        if (isConvertible(target)) {
          const value2 = new target();
          return value2.fromASN(asn1Schema);
        }
        const schema = schemaStorage.get(target);
        schemaStorage.cache(target);
        let targetSchema = schema.schema;
        const choiceResult = this.handleChoiceTypes(asn1Schema, schema, target, targetSchema);
        if (choiceResult === null || choiceResult === void 0 ? void 0 : choiceResult.result) {
          return choiceResult.result;
        }
        if (choiceResult === null || choiceResult === void 0 ? void 0 : choiceResult.targetSchema) {
          targetSchema = choiceResult.targetSchema;
        }
        const sequenceResult = this.handleSequenceTypes(asn1Schema, schema, target, targetSchema);
        if (sequenceResult && "isManualMapping" in sequenceResult) {
          return sequenceResult.result;
        }
        const asn1ComparedSchema = sequenceResult;
        const res = new target();
        if (isTypeOfArray(target)) {
          return this.handleArrayTypes(asn1Schema, schema, target);
        }
        this.processSchemaItems(schema, asn1ComparedSchema, res);
        return res;
      } catch (error) {
        if (error instanceof AsnSchemaValidationError) {
          error.schemas.push(target.name);
        }
        throw error;
      }
    }
    static handleChoiceTypes(asn1Schema, schema, target, targetSchema) {
      if (asn1Schema.constructor === Constructed && schema.type === AsnTypeTypes.Choice && asn1Schema.idBlock.tagClass === 3) {
        for (const key in schema.items) {
          const schemaItem = schema.items[key];
          if (schemaItem.context === asn1Schema.idBlock.tagNumber && schemaItem.implicit) {
            if (typeof schemaItem.type === "function" && schemaStorage.has(schemaItem.type)) {
              const fieldSchema = schemaStorage.get(schemaItem.type);
              if (fieldSchema && fieldSchema.type === AsnTypeTypes.Sequence) {
                const newSeq = new Sequence();
                if ("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value) && "value" in newSeq.valueBlock) {
                  newSeq.valueBlock.value = asn1Schema.valueBlock.value;
                  const fieldValue = this.fromASN(newSeq, schemaItem.type);
                  const res = new target();
                  res[key] = fieldValue;
                  return { result: res };
                }
              }
            }
          }
        }
      } else if (asn1Schema.constructor === Constructed && schema.type !== AsnTypeTypes.Choice) {
        const newTargetSchema = new Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: asn1Schema.idBlock.tagNumber
          },
          value: schema.schema.valueBlock.value
        });
        for (const key in schema.items) {
          delete asn1Schema[key];
        }
        return { targetSchema: newTargetSchema };
      }
      return null;
    }
    static handleSequenceTypes(asn1Schema, schema, target, targetSchema) {
      if (schema.type === AsnTypeTypes.Sequence) {
        const optionalChoiceFields = Object.keys(schema.items).filter((key) => {
          const item = schema.items[key];
          return item.optional && typeof item.type === "function" && schemaStorage.has(item.type) && schemaStorage.get(item.type).type === AsnTypeTypes.Choice;
        });
        if (optionalChoiceFields.length > 0 && "value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value) && target.name === "CertReqMsg") {
          return this.handleManualMapping(asn1Schema, schema, target);
        }
        const asn1ComparedSchema = compareSchema({}, asn1Schema, targetSchema);
        if (!asn1ComparedSchema.verified) {
          throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema.${asn1ComparedSchema.result.error ? ` ${asn1ComparedSchema.result.error}` : ""}`);
        }
        return asn1ComparedSchema;
      } else {
        const asn1ComparedSchema = compareSchema({}, asn1Schema, targetSchema);
        if (!asn1ComparedSchema.verified) {
          throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema.${asn1ComparedSchema.result.error ? ` ${asn1ComparedSchema.result.error}` : ""}`);
        }
        return asn1ComparedSchema;
      }
    }
    static handleManualMapping(asn1Schema, schema, target) {
      const res = new target();
      const asn1Elements = asn1Schema.valueBlock.value;
      const schemaKeys = Object.keys(schema.items);
      let asn1Index = 0;
      for (let i2 = 0; i2 < schemaKeys.length; i2++) {
        const key = schemaKeys[i2];
        const schemaItem = schema.items[key];
        if (asn1Index >= asn1Elements.length)
          break;
        if (schemaItem.repeated) {
          res[key] = this.processRepeatedField(asn1Elements, asn1Index, schemaItem);
          break;
        } else if (typeof schemaItem.type === "number") {
          res[key] = this.processPrimitiveField(asn1Elements[asn1Index], schemaItem);
          asn1Index++;
        } else if (this.isOptionalChoiceField(schemaItem)) {
          const result = this.processOptionalChoiceField(asn1Elements[asn1Index], schemaItem);
          if (result.processed) {
            res[key] = result.value;
            asn1Index++;
          }
        } else {
          res[key] = this.fromASN(asn1Elements[asn1Index], schemaItem.type);
          asn1Index++;
        }
      }
      return { result: res, verified: true, isManualMapping: true };
    }
    static processRepeatedField(asn1Elements, asn1Index, schemaItem) {
      let elementsToProcess = asn1Elements.slice(asn1Index);
      if (elementsToProcess.length === 1 && elementsToProcess[0].constructor.name === "Sequence") {
        const seq = elementsToProcess[0];
        if (seq.valueBlock && seq.valueBlock.value && Array.isArray(seq.valueBlock.value)) {
          elementsToProcess = seq.valueBlock.value;
        }
      }
      if (typeof schemaItem.type === "number") {
        const converter = defaultConverter(schemaItem.type);
        if (!converter)
          throw new Error(`No converter for ASN.1 type ${schemaItem.type}`);
        return elementsToProcess.filter((el) => el && el.valueBlock).map((el) => {
          try {
            return converter.fromASN(el);
          } catch {
            return void 0;
          }
        }).filter((v) => v !== void 0);
      } else {
        return elementsToProcess.filter((el) => el && el.valueBlock).map((el) => {
          try {
            return this.fromASN(el, schemaItem.type);
          } catch {
            return void 0;
          }
        }).filter((v) => v !== void 0);
      }
    }
    static processPrimitiveField(asn1Element, schemaItem) {
      const converter = defaultConverter(schemaItem.type);
      if (!converter)
        throw new Error(`No converter for ASN.1 type ${schemaItem.type}`);
      return converter.fromASN(asn1Element);
    }
    static isOptionalChoiceField(schemaItem) {
      return schemaItem.optional && typeof schemaItem.type === "function" && schemaStorage.has(schemaItem.type) && schemaStorage.get(schemaItem.type).type === AsnTypeTypes.Choice;
    }
    static processOptionalChoiceField(asn1Element, schemaItem) {
      try {
        const value2 = this.fromASN(asn1Element, schemaItem.type);
        return { processed: true, value: value2 };
      } catch (err2) {
        if (err2 instanceof AsnSchemaValidationError && /Wrong values for Choice type/.test(err2.message)) {
          return { processed: false };
        }
        throw err2;
      }
    }
    static handleArrayTypes(asn1Schema, schema, target) {
      if (!("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {
        throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
      }
      const itemType = schema.itemType;
      if (typeof itemType === "number") {
        const converter = defaultConverter(itemType);
        if (!converter) {
          throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
        }
        return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
      } else {
        return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
      }
    }
    static processSchemaItems(schema, asn1ComparedSchema, res) {
      for (const key in schema.items) {
        const asn1SchemaValue = asn1ComparedSchema.result[key];
        if (!asn1SchemaValue) {
          continue;
        }
        const schemaItem = schema.items[key];
        const schemaItemType = schemaItem.type;
        let parsedValue;
        if (typeof schemaItemType === "number" || isConvertible(schemaItemType)) {
          parsedValue = this.processPrimitiveSchemaItem(asn1SchemaValue, schemaItem, schemaItemType);
        } else {
          parsedValue = this.processComplexSchemaItem(asn1SchemaValue, schemaItem, schemaItemType);
        }
        if (parsedValue && typeof parsedValue === "object" && "value" in parsedValue && "raw" in parsedValue) {
          res[key] = parsedValue.value;
          res[`${key}Raw`] = parsedValue.raw;
        } else {
          res[key] = parsedValue;
        }
      }
    }
    static processPrimitiveSchemaItem(asn1SchemaValue, schemaItem, schemaItemType) {
      var _a4;
      const converter = (_a4 = schemaItem.converter) !== null && _a4 !== void 0 ? _a4 : isConvertible(schemaItemType) ? new schemaItemType() : null;
      if (!converter) {
        throw new Error("Converter is empty");
      }
      if (schemaItem.repeated) {
        return this.processRepeatedPrimitiveItem(asn1SchemaValue, schemaItem, converter);
      } else {
        return this.processSinglePrimitiveItem(asn1SchemaValue, schemaItem, schemaItemType, converter);
      }
    }
    static processRepeatedPrimitiveItem(asn1SchemaValue, schemaItem, converter) {
      if (schemaItem.implicit) {
        const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
        const newItem = new Container();
        newItem.valueBlock = asn1SchemaValue.valueBlock;
        const newItemAsn = fromBER(newItem.toBER(false));
        if (newItemAsn.offset === -1) {
          throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
        }
        if (!("value" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {
          throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
        }
        const value2 = newItemAsn.result.valueBlock.value;
        return Array.from(value2, (element) => converter.fromASN(element));
      } else {
        return Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
      }
    }
    static processSinglePrimitiveItem(asn1SchemaValue, schemaItem, schemaItemType, converter) {
      let value2 = asn1SchemaValue;
      if (schemaItem.implicit) {
        let newItem;
        if (isConvertible(schemaItemType)) {
          newItem = new schemaItemType().toSchema("");
        } else {
          const Asn1TypeName = AsnPropTypes[schemaItemType];
          const Asn1Type = index_es_exports[Asn1TypeName];
          if (!Asn1Type) {
            throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
          }
          newItem = new Asn1Type();
        }
        newItem.valueBlock = value2.valueBlock;
        value2 = fromBER(newItem.toBER(false)).result;
      }
      return converter.fromASN(value2);
    }
    static processComplexSchemaItem(asn1SchemaValue, schemaItem, schemaItemType) {
      if (schemaItem.repeated) {
        if (!Array.isArray(asn1SchemaValue)) {
          throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
        }
        return Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
      } else {
        const valueToProcess = this.handleImplicitTagging(asn1SchemaValue, schemaItem, schemaItemType);
        if (this.isOptionalChoiceField(schemaItem)) {
          try {
            return this.fromASN(valueToProcess, schemaItemType);
          } catch (err2) {
            if (err2 instanceof AsnSchemaValidationError && /Wrong values for Choice type/.test(err2.message)) {
              return void 0;
            }
            throw err2;
          }
        } else {
          const parsedValue = this.fromASN(valueToProcess, schemaItemType);
          if (schemaItem.raw) {
            return {
              value: parsedValue,
              raw: asn1SchemaValue.valueBeforeDecodeView
            };
          }
          return parsedValue;
        }
      }
    }
    static handleImplicitTagging(asn1SchemaValue, schemaItem, schemaItemType) {
      if (schemaItem.implicit && typeof schemaItem.context === "number") {
        const schema = schemaStorage.get(schemaItemType);
        if (schema.type === AsnTypeTypes.Sequence) {
          const newSeq = new Sequence();
          if ("value" in asn1SchemaValue.valueBlock && Array.isArray(asn1SchemaValue.valueBlock.value) && "value" in newSeq.valueBlock) {
            newSeq.valueBlock.value = asn1SchemaValue.valueBlock.value;
            return newSeq;
          }
        } else if (schema.type === AsnTypeTypes.Set) {
          const newSet = new Set2();
          if ("value" in asn1SchemaValue.valueBlock && Array.isArray(asn1SchemaValue.valueBlock.value) && "value" in newSet.valueBlock) {
            newSet.valueBlock.value = asn1SchemaValue.valueBlock.value;
            return newSet;
          }
        }
      }
      return asn1SchemaValue;
    }
  };

  // node_modules/@peculiar/asn1-schema/build/es2015/serializer.js
  var AsnSerializer = class _AsnSerializer {
    static serialize(obj) {
      if (obj instanceof BaseBlock) {
        return obj.toBER(false);
      }
      return this.toASN(obj).toBER(false);
    }
    static toASN(obj) {
      if (obj && typeof obj === "object" && isConvertible(obj)) {
        return obj.toASN();
      }
      if (!(obj && typeof obj === "object")) {
        throw new TypeError("Parameter 1 should be type of Object.");
      }
      const target = obj.constructor;
      const schema = schemaStorage.get(target);
      schemaStorage.cache(target);
      let asn1Value = [];
      if (schema.itemType) {
        if (!Array.isArray(obj)) {
          throw new TypeError("Parameter 1 should be type of Array.");
        }
        if (typeof schema.itemType === "number") {
          const converter = defaultConverter(schema.itemType);
          if (!converter) {
            throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
          }
          asn1Value = obj.map((o2) => converter.toASN(o2));
        } else {
          asn1Value = obj.map((o2) => this.toAsnItem({ type: schema.itemType }, "[]", target, o2));
        }
      } else {
        for (const key in schema.items) {
          const schemaItem = schema.items[key];
          const objProp = obj[key];
          if (objProp === void 0 || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
            continue;
          }
          const asn1Item = _AsnSerializer.toAsnItem(schemaItem, key, target, objProp);
          if (typeof schemaItem.context === "number") {
            if (schemaItem.implicit) {
              if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible(schemaItem.type))) {
                const value2 = {};
                value2.valueHex = asn1Item instanceof Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
                asn1Value.push(new Primitive({
                  optional: schemaItem.optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: schemaItem.context
                  },
                  ...value2
                }));
              } else {
                asn1Value.push(new Constructed({
                  optional: schemaItem.optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: schemaItem.context
                  },
                  value: asn1Item.valueBlock.value
                }));
              }
            } else {
              asn1Value.push(new Constructed({
                optional: schemaItem.optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: schemaItem.context
                },
                value: [asn1Item]
              }));
            }
          } else if (schemaItem.repeated) {
            asn1Value = asn1Value.concat(asn1Item);
          } else {
            asn1Value.push(asn1Item);
          }
        }
      }
      let asnSchema;
      switch (schema.type) {
        case AsnTypeTypes.Sequence:
          asnSchema = new Sequence({ value: asn1Value });
          break;
        case AsnTypeTypes.Set:
          asnSchema = new Set2({ value: asn1Value });
          break;
        case AsnTypeTypes.Choice:
          if (!asn1Value[0]) {
            throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
          }
          asnSchema = asn1Value[0];
          break;
      }
      return asnSchema;
    }
    static toAsnItem(schemaItem, key, target, objProp) {
      let asn1Item;
      if (typeof schemaItem.type === "number") {
        const converter = schemaItem.converter;
        if (!converter) {
          throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
        }
        if (schemaItem.repeated) {
          if (!Array.isArray(objProp)) {
            throw new TypeError("Parameter 'objProp' should be type of Array.");
          }
          const items = Array.from(objProp, (element) => converter.toASN(element));
          const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
          asn1Item = new Container({
            value: items
          });
        } else {
          asn1Item = converter.toASN(objProp);
        }
      } else {
        if (schemaItem.repeated) {
          if (!Array.isArray(objProp)) {
            throw new TypeError("Parameter 'objProp' should be type of Array.");
          }
          const items = Array.from(objProp, (element) => this.toASN(element));
          const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
          asn1Item = new Container({
            value: items
          });
        } else {
          asn1Item = this.toASN(objProp);
        }
      }
      return asn1Item;
    }
  };

  // node_modules/@peculiar/asn1-schema/build/es2015/objects.js
  var AsnArray = class extends Array {
    constructor(items = []) {
      if (typeof items === "number") {
        super(items);
      } else {
        super();
        for (const item of items) {
          this.push(item);
        }
      }
    }
  };

  // node_modules/@peculiar/asn1-schema/build/es2015/convert.js
  var import_pvtsutils3 = __toESM(require_build());
  var AsnConvert = class _AsnConvert {
    static serialize(obj) {
      return AsnSerializer.serialize(obj);
    }
    static parse(data, target) {
      return AsnParser.parse(data, target);
    }
    static toString(data) {
      const buf2 = import_pvtsutils3.BufferSourceConverter.isBufferSource(data) ? import_pvtsutils3.BufferSourceConverter.toArrayBuffer(data) : _AsnConvert.serialize(data);
      const asn = fromBER(buf2);
      if (asn.offset === -1) {
        throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
      }
      return asn.result.toString();
    }
  };

  // node_modules/tslib/tslib.es6.mjs
  function __decorate(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
    else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  }
  function __classPrivateFieldGet(receiver, state, kind, f2) {
    if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value2, kind, f2) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state.set(receiver, value2), value2;
  }

  // node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js
  var import_pvtsutils4 = __toESM(require_build());
  var IpConverter = class {
    static isIPv4(ip) {
      return /^(\d{1,3}\.){3}\d{1,3}$/.test(ip);
    }
    static parseIPv4(ip) {
      const parts = ip.split(".");
      if (parts.length !== 4) {
        throw new Error("Invalid IPv4 address");
      }
      return parts.map((part) => {
        const num = parseInt(part, 10);
        if (isNaN(num) || num < 0 || num > 255) {
          throw new Error("Invalid IPv4 address part");
        }
        return num;
      });
    }
    static parseIPv6(ip) {
      const expandedIP = this.expandIPv6(ip);
      const parts = expandedIP.split(":");
      if (parts.length !== 8) {
        throw new Error("Invalid IPv6 address");
      }
      return parts.reduce((bytes, part) => {
        const num = parseInt(part, 16);
        if (isNaN(num) || num < 0 || num > 65535) {
          throw new Error("Invalid IPv6 address part");
        }
        bytes.push(num >> 8 & 255);
        bytes.push(num & 255);
        return bytes;
      }, []);
    }
    static expandIPv6(ip) {
      if (!ip.includes("::")) {
        return ip;
      }
      const parts = ip.split("::");
      if (parts.length > 2) {
        throw new Error("Invalid IPv6 address");
      }
      const left = parts[0] ? parts[0].split(":") : [];
      const right = parts[1] ? parts[1].split(":") : [];
      const missing = 8 - (left.length + right.length);
      if (missing < 0) {
        throw new Error("Invalid IPv6 address");
      }
      return [...left, ...Array(missing).fill("0"), ...right].join(":");
    }
    static formatIPv6(bytes) {
      const parts = [];
      for (let i2 = 0; i2 < 16; i2 += 2) {
        parts.push((bytes[i2] << 8 | bytes[i2 + 1]).toString(16));
      }
      return this.compressIPv6(parts.join(":"));
    }
    static compressIPv6(ip) {
      const parts = ip.split(":");
      let longestZeroStart = -1;
      let longestZeroLength = 0;
      let currentZeroStart = -1;
      let currentZeroLength = 0;
      for (let i2 = 0; i2 < parts.length; i2++) {
        if (parts[i2] === "0") {
          if (currentZeroStart === -1) {
            currentZeroStart = i2;
          }
          currentZeroLength++;
        } else {
          if (currentZeroLength > longestZeroLength) {
            longestZeroStart = currentZeroStart;
            longestZeroLength = currentZeroLength;
          }
          currentZeroStart = -1;
          currentZeroLength = 0;
        }
      }
      if (currentZeroLength > longestZeroLength) {
        longestZeroStart = currentZeroStart;
        longestZeroLength = currentZeroLength;
      }
      if (longestZeroLength > 1) {
        const before = parts.slice(0, longestZeroStart).join(":");
        const after = parts.slice(longestZeroStart + longestZeroLength).join(":");
        return `${before}::${after}`;
      }
      return ip;
    }
    static parseCIDR(text) {
      const [addr, prefixStr] = text.split("/");
      const prefix = parseInt(prefixStr, 10);
      if (this.isIPv4(addr)) {
        if (prefix < 0 || prefix > 32) {
          throw new Error("Invalid IPv4 prefix length");
        }
        return [this.parseIPv4(addr), prefix];
      } else {
        if (prefix < 0 || prefix > 128) {
          throw new Error("Invalid IPv6 prefix length");
        }
        return [this.parseIPv6(addr), prefix];
      }
    }
    static decodeIP(value2) {
      if (value2.length === 64 && parseInt(value2, 16) === 0) {
        return "::/0";
      }
      if (value2.length !== 16) {
        return value2;
      }
      const mask = parseInt(value2.slice(8), 16).toString(2).split("").reduce((a2, k) => a2 + +k, 0);
      let ip = value2.slice(0, 8).replace(/(.{2})/g, (match) => `${parseInt(match, 16)}.`);
      ip = ip.slice(0, -1);
      return `${ip}/${mask}`;
    }
    static toString(buf2) {
      const uint8 = new Uint8Array(buf2);
      if (uint8.length === 4) {
        return Array.from(uint8).join(".");
      }
      if (uint8.length === 16) {
        return this.formatIPv6(uint8);
      }
      if (uint8.length === 8 || uint8.length === 32) {
        const half = uint8.length / 2;
        const addrBytes = uint8.slice(0, half);
        const maskBytes = uint8.slice(half);
        const isAllZeros = uint8.every((byte) => byte === 0);
        if (isAllZeros) {
          return uint8.length === 8 ? "0.0.0.0/0" : "::/0";
        }
        const prefixLen = maskBytes.reduce((a2, b) => a2 + (b.toString(2).match(/1/g) || []).length, 0);
        if (uint8.length === 8) {
          const addrStr = Array.from(addrBytes).join(".");
          return `${addrStr}/${prefixLen}`;
        } else {
          const addrStr = this.formatIPv6(addrBytes);
          return `${addrStr}/${prefixLen}`;
        }
      }
      return this.decodeIP(import_pvtsutils4.Convert.ToHex(buf2));
    }
    static fromString(text) {
      if (text.includes("/")) {
        const [addr, prefix] = this.parseCIDR(text);
        const maskBytes = new Uint8Array(addr.length);
        let bitsLeft = prefix;
        for (let i2 = 0; i2 < maskBytes.length; i2++) {
          if (bitsLeft >= 8) {
            maskBytes[i2] = 255;
            bitsLeft -= 8;
          } else if (bitsLeft > 0) {
            maskBytes[i2] = 255 << 8 - bitsLeft;
            bitsLeft = 0;
          }
        }
        const out = new Uint8Array(addr.length * 2);
        out.set(addr, 0);
        out.set(maskBytes, addr.length);
        return out.buffer;
      }
      const bytes = this.isIPv4(text) ? this.parseIPv4(text) : this.parseIPv6(text);
      return new Uint8Array(bytes).buffer;
    }
  };

  // node_modules/@peculiar/asn1-x509/build/es2015/name.js
  var import_pvtsutils5 = __toESM(require_build());
  var RelativeDistinguishedName_1;
  var RDNSequence_1;
  var Name_1;
  var DirectoryString = class DirectoryString2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
    toString() {
      return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.TeletexString })
  ], DirectoryString.prototype, "teletexString", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.PrintableString })
  ], DirectoryString.prototype, "printableString", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.UniversalString })
  ], DirectoryString.prototype, "universalString", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Utf8String })
  ], DirectoryString.prototype, "utf8String", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BmpString })
  ], DirectoryString.prototype, "bmpString", void 0);
  DirectoryString = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], DirectoryString);
  var AttributeValue = class AttributeValue2 extends DirectoryString {
    constructor(params = {}) {
      super(params);
      Object.assign(this, params);
    }
    toString() {
      return this.ia5String || (this.anyValue ? import_pvtsutils5.Convert.ToHex(this.anyValue) : super.toString());
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.IA5String })
  ], AttributeValue.prototype, "ia5String", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any })
  ], AttributeValue.prototype, "anyValue", void 0);
  AttributeValue = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], AttributeValue);
  var AttributeTypeAndValue = class {
    constructor(params = {}) {
      this.type = "";
      this.value = new AttributeValue();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], AttributeTypeAndValue.prototype, "type", void 0);
  __decorate([
    AsnProp({ type: AttributeValue })
  ], AttributeTypeAndValue.prototype, "value", void 0);
  var RelativeDistinguishedName = RelativeDistinguishedName_1 = class RelativeDistinguishedName2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, RelativeDistinguishedName_1.prototype);
    }
  };
  RelativeDistinguishedName = RelativeDistinguishedName_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Set, itemType: AttributeTypeAndValue })
  ], RelativeDistinguishedName);
  var RDNSequence = RDNSequence_1 = class RDNSequence2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, RDNSequence_1.prototype);
    }
  };
  RDNSequence = RDNSequence_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: RelativeDistinguishedName })
  ], RDNSequence);
  var Name = Name_1 = class Name2 extends RDNSequence {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, Name_1.prototype);
    }
  };
  Name = Name_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], Name);

  // node_modules/@peculiar/asn1-x509/build/es2015/general_name.js
  var AsnIpConverter = {
    fromASN: (value2) => IpConverter.toString(AsnOctetStringConverter.fromASN(value2)),
    toASN: (value2) => AsnOctetStringConverter.toASN(IpConverter.fromString(value2))
  };
  var OtherName = class {
    constructor(params = {}) {
      this.typeId = "";
      this.value = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], OtherName.prototype, "typeId", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, context: 0 })
  ], OtherName.prototype, "value", void 0);
  var EDIPartyName = class {
    constructor(params = {}) {
      this.partyName = new DirectoryString();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: DirectoryString, optional: true, context: 0, implicit: true })
  ], EDIPartyName.prototype, "nameAssigner", void 0);
  __decorate([
    AsnProp({ type: DirectoryString, context: 1, implicit: true })
  ], EDIPartyName.prototype, "partyName", void 0);
  var GeneralName = class GeneralName2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: OtherName, context: 0, implicit: true })
  ], GeneralName.prototype, "otherName", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.IA5String, context: 1, implicit: true })
  ], GeneralName.prototype, "rfc822Name", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.IA5String, context: 2, implicit: true })
  ], GeneralName.prototype, "dNSName", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, context: 3, implicit: true })
  ], GeneralName.prototype, "x400Address", void 0);
  __decorate([
    AsnProp({ type: Name, context: 4, implicit: false })
  ], GeneralName.prototype, "directoryName", void 0);
  __decorate([
    AsnProp({ type: EDIPartyName, context: 5 })
  ], GeneralName.prototype, "ediPartyName", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.IA5String, context: 6, implicit: true })
  ], GeneralName.prototype, "uniformResourceIdentifier", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.OctetString,
      context: 7,
      implicit: true,
      converter: AsnIpConverter
    })
  ], GeneralName.prototype, "iPAddress", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier, context: 8, implicit: true })
  ], GeneralName.prototype, "registeredID", void 0);
  GeneralName = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], GeneralName);

  // node_modules/@peculiar/asn1-x509/build/es2015/object_identifiers.js
  var id_pkix = "1.3.6.1.5.5.7";
  var id_pe = `${id_pkix}.1`;
  var id_qt = `${id_pkix}.2`;
  var id_kp = `${id_pkix}.3`;
  var id_ad = `${id_pkix}.48`;
  var id_qt_csp = `${id_qt}.1`;
  var id_qt_unotice = `${id_qt}.2`;
  var id_ad_ocsp = `${id_ad}.1`;
  var id_ad_caIssuers = `${id_ad}.2`;
  var id_ad_timeStamping = `${id_ad}.3`;
  var id_ad_caRepository = `${id_ad}.5`;
  var id_ce = "2.5.29";

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_information_access.js
  var AuthorityInfoAccessSyntax_1;
  var id_pe_authorityInfoAccess = `${id_pe}.1`;
  var AccessDescription = class {
    constructor(params = {}) {
      this.accessMethod = "";
      this.accessLocation = new GeneralName();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], AccessDescription.prototype, "accessMethod", void 0);
  __decorate([
    AsnProp({ type: GeneralName })
  ], AccessDescription.prototype, "accessLocation", void 0);
  var AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = class AuthorityInfoAccessSyntax2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_1.prototype);
    }
  };
  AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
  ], AuthorityInfoAccessSyntax);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/authority_key_identifier.js
  var id_ce_authorityKeyIdentifier = `${id_ce}.35`;
  var KeyIdentifier = class extends OctetString2 {
  };
  var AuthorityKeyIdentifier = class {
    constructor(params = {}) {
      if (params) {
        Object.assign(this, params);
      }
    }
  };
  __decorate([
    AsnProp({ type: KeyIdentifier, context: 0, optional: true, implicit: true })
  ], AuthorityKeyIdentifier.prototype, "keyIdentifier", void 0);
  __decorate([
    AsnProp({ type: GeneralName, context: 1, optional: true, implicit: true, repeated: "sequence" })
  ], AuthorityKeyIdentifier.prototype, "authorityCertIssuer", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Integer,
      context: 2,
      optional: true,
      implicit: true,
      converter: AsnIntegerArrayBufferConverter
    })
  ], AuthorityKeyIdentifier.prototype, "authorityCertSerialNumber", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/basic_constraints.js
  var id_ce_basicConstraints = `${id_ce}.19`;
  var BasicConstraints = class {
    constructor(params = {}) {
      this.cA = false;
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Boolean, defaultValue: false })
  ], BasicConstraints.prototype, "cA", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, optional: true })
  ], BasicConstraints.prototype, "pathLenConstraint", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/general_names.js
  var GeneralNames_1;
  var GeneralNames = GeneralNames_1 = class GeneralNames2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, GeneralNames_1.prototype);
    }
  };
  GeneralNames = GeneralNames_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralName })
  ], GeneralNames);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_issuer.js
  var CertificateIssuer_1;
  var id_ce_certificateIssuer = `${id_ce}.29`;
  var CertificateIssuer = CertificateIssuer_1 = class CertificateIssuer2 extends GeneralNames {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, CertificateIssuer_1.prototype);
    }
  };
  CertificateIssuer = CertificateIssuer_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], CertificateIssuer);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/certificate_policies.js
  var CertificatePolicies_1;
  var id_ce_certificatePolicies = `${id_ce}.32`;
  var id_ce_certificatePolicies_anyPolicy = `${id_ce_certificatePolicies}.0`;
  var DisplayText = class DisplayText2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
    toString() {
      return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.IA5String })
  ], DisplayText.prototype, "ia5String", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.VisibleString })
  ], DisplayText.prototype, "visibleString", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BmpString })
  ], DisplayText.prototype, "bmpString", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Utf8String })
  ], DisplayText.prototype, "utf8String", void 0);
  DisplayText = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], DisplayText);
  var NoticeReference = class {
    constructor(params = {}) {
      this.organization = new DisplayText();
      this.noticeNumbers = [];
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: DisplayText })
  ], NoticeReference.prototype, "organization", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, repeated: "sequence" })
  ], NoticeReference.prototype, "noticeNumbers", void 0);
  var UserNotice = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: NoticeReference, optional: true })
  ], UserNotice.prototype, "noticeRef", void 0);
  __decorate([
    AsnProp({ type: DisplayText, optional: true })
  ], UserNotice.prototype, "explicitText", void 0);
  var Qualifier = class Qualifier2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.IA5String })
  ], Qualifier.prototype, "cPSuri", void 0);
  __decorate([
    AsnProp({ type: UserNotice })
  ], Qualifier.prototype, "userNotice", void 0);
  Qualifier = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], Qualifier);
  var PolicyQualifierInfo = class {
    constructor(params = {}) {
      this.policyQualifierId = "";
      this.qualifier = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], PolicyQualifierInfo.prototype, "policyQualifierId", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any })
  ], PolicyQualifierInfo.prototype, "qualifier", void 0);
  var PolicyInformation = class {
    constructor(params = {}) {
      this.policyIdentifier = "";
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], PolicyInformation.prototype, "policyIdentifier", void 0);
  __decorate([
    AsnProp({ type: PolicyQualifierInfo, repeated: "sequence", optional: true })
  ], PolicyInformation.prototype, "policyQualifiers", void 0);
  var CertificatePolicies = CertificatePolicies_1 = class CertificatePolicies2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, CertificatePolicies_1.prototype);
    }
  };
  CertificatePolicies = CertificatePolicies_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyInformation })
  ], CertificatePolicies);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_number.js
  var id_ce_cRLNumber = `${id_ce}.20`;
  var CRLNumber = class CRLNumber2 {
    constructor(value2 = 0) {
      this.value = value2;
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], CRLNumber.prototype, "value", void 0);
  CRLNumber = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], CRLNumber);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_delta_indicator.js
  var id_ce_deltaCRLIndicator = `${id_ce}.27`;
  var BaseCRLNumber = class BaseCRLNumber2 extends CRLNumber {
  };
  BaseCRLNumber = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], BaseCRLNumber);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_distribution_points.js
  var CRLDistributionPoints_1;
  var id_ce_cRLDistributionPoints = `${id_ce}.31`;
  var ReasonFlags;
  (function(ReasonFlags2) {
    ReasonFlags2[ReasonFlags2["unused"] = 1] = "unused";
    ReasonFlags2[ReasonFlags2["keyCompromise"] = 2] = "keyCompromise";
    ReasonFlags2[ReasonFlags2["cACompromise"] = 4] = "cACompromise";
    ReasonFlags2[ReasonFlags2["affiliationChanged"] = 8] = "affiliationChanged";
    ReasonFlags2[ReasonFlags2["superseded"] = 16] = "superseded";
    ReasonFlags2[ReasonFlags2["cessationOfOperation"] = 32] = "cessationOfOperation";
    ReasonFlags2[ReasonFlags2["certificateHold"] = 64] = "certificateHold";
    ReasonFlags2[ReasonFlags2["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
    ReasonFlags2[ReasonFlags2["aACompromise"] = 256] = "aACompromise";
  })(ReasonFlags || (ReasonFlags = {}));
  var Reason = class extends BitString2 {
    toJSON() {
      const res = [];
      const flags = this.toNumber();
      if (flags & ReasonFlags.aACompromise) {
        res.push("aACompromise");
      }
      if (flags & ReasonFlags.affiliationChanged) {
        res.push("affiliationChanged");
      }
      if (flags & ReasonFlags.cACompromise) {
        res.push("cACompromise");
      }
      if (flags & ReasonFlags.certificateHold) {
        res.push("certificateHold");
      }
      if (flags & ReasonFlags.cessationOfOperation) {
        res.push("cessationOfOperation");
      }
      if (flags & ReasonFlags.keyCompromise) {
        res.push("keyCompromise");
      }
      if (flags & ReasonFlags.privilegeWithdrawn) {
        res.push("privilegeWithdrawn");
      }
      if (flags & ReasonFlags.superseded) {
        res.push("superseded");
      }
      if (flags & ReasonFlags.unused) {
        res.push("unused");
      }
      return res;
    }
    toString() {
      return `[${this.toJSON().join(", ")}]`;
    }
  };
  var DistributionPointName = class DistributionPointName2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralName, context: 0, repeated: "sequence", implicit: true })
  ], DistributionPointName.prototype, "fullName", void 0);
  __decorate([
    AsnProp({ type: RelativeDistinguishedName, context: 1, implicit: true })
  ], DistributionPointName.prototype, "nameRelativeToCRLIssuer", void 0);
  DistributionPointName = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], DistributionPointName);
  var DistributionPoint = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: DistributionPointName, context: 0, optional: true })
  ], DistributionPoint.prototype, "distributionPoint", void 0);
  __decorate([
    AsnProp({ type: Reason, context: 1, optional: true, implicit: true })
  ], DistributionPoint.prototype, "reasons", void 0);
  __decorate([
    AsnProp({ type: GeneralName, context: 2, optional: true, repeated: "sequence", implicit: true })
  ], DistributionPoint.prototype, "cRLIssuer", void 0);
  var CRLDistributionPoints = CRLDistributionPoints_1 = class CRLDistributionPoints2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, CRLDistributionPoints_1.prototype);
    }
  };
  CRLDistributionPoints = CRLDistributionPoints_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
  ], CRLDistributionPoints);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_freshest.js
  var FreshestCRL_1;
  var id_ce_freshestCRL = `${id_ce}.46`;
  var FreshestCRL = FreshestCRL_1 = class FreshestCRL2 extends CRLDistributionPoints {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, FreshestCRL_1.prototype);
    }
  };
  FreshestCRL = FreshestCRL_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: DistributionPoint })
  ], FreshestCRL);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_issuing_distribution_point.js
  var id_ce_issuingDistributionPoint = `${id_ce}.28`;
  var IssuingDistributionPoint = class _IssuingDistributionPoint {
    constructor(params = {}) {
      this.onlyContainsUserCerts = _IssuingDistributionPoint.ONLY;
      this.onlyContainsCACerts = _IssuingDistributionPoint.ONLY;
      this.indirectCRL = _IssuingDistributionPoint.ONLY;
      this.onlyContainsAttributeCerts = _IssuingDistributionPoint.ONLY;
      Object.assign(this, params);
    }
  };
  IssuingDistributionPoint.ONLY = false;
  __decorate([
    AsnProp({ type: DistributionPointName, context: 0, optional: true })
  ], IssuingDistributionPoint.prototype, "distributionPoint", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Boolean,
      context: 1,
      defaultValue: IssuingDistributionPoint.ONLY,
      implicit: true
    })
  ], IssuingDistributionPoint.prototype, "onlyContainsUserCerts", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Boolean,
      context: 2,
      defaultValue: IssuingDistributionPoint.ONLY,
      implicit: true
    })
  ], IssuingDistributionPoint.prototype, "onlyContainsCACerts", void 0);
  __decorate([
    AsnProp({ type: Reason, context: 3, optional: true, implicit: true })
  ], IssuingDistributionPoint.prototype, "onlySomeReasons", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Boolean,
      context: 4,
      defaultValue: IssuingDistributionPoint.ONLY,
      implicit: true
    })
  ], IssuingDistributionPoint.prototype, "indirectCRL", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Boolean,
      context: 5,
      defaultValue: IssuingDistributionPoint.ONLY,
      implicit: true
    })
  ], IssuingDistributionPoint.prototype, "onlyContainsAttributeCerts", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/crl_reason.js
  var id_ce_cRLReasons = `${id_ce}.21`;
  var CRLReasons;
  (function(CRLReasons2) {
    CRLReasons2[CRLReasons2["unspecified"] = 0] = "unspecified";
    CRLReasons2[CRLReasons2["keyCompromise"] = 1] = "keyCompromise";
    CRLReasons2[CRLReasons2["cACompromise"] = 2] = "cACompromise";
    CRLReasons2[CRLReasons2["affiliationChanged"] = 3] = "affiliationChanged";
    CRLReasons2[CRLReasons2["superseded"] = 4] = "superseded";
    CRLReasons2[CRLReasons2["cessationOfOperation"] = 5] = "cessationOfOperation";
    CRLReasons2[CRLReasons2["certificateHold"] = 6] = "certificateHold";
    CRLReasons2[CRLReasons2["removeFromCRL"] = 8] = "removeFromCRL";
    CRLReasons2[CRLReasons2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
    CRLReasons2[CRLReasons2["aACompromise"] = 10] = "aACompromise";
  })(CRLReasons || (CRLReasons = {}));
  var CRLReason = class CRLReason2 {
    constructor(reason = CRLReasons.unspecified) {
      this.reason = CRLReasons.unspecified;
      this.reason = reason;
    }
    toJSON() {
      return CRLReasons[this.reason];
    }
    toString() {
      return this.toJSON();
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Enumerated })
  ], CRLReason.prototype, "reason", void 0);
  CRLReason = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], CRLReason);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/extended_key_usage.js
  var ExtendedKeyUsage_1;
  var id_ce_extKeyUsage = `${id_ce}.37`;
  var ExtendedKeyUsage = ExtendedKeyUsage_1 = class ExtendedKeyUsage2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, ExtendedKeyUsage_1.prototype);
    }
  };
  ExtendedKeyUsage = ExtendedKeyUsage_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: AsnPropTypes.ObjectIdentifier })
  ], ExtendedKeyUsage);
  var anyExtendedKeyUsage = `${id_ce_extKeyUsage}.0`;
  var id_kp_serverAuth = `${id_kp}.1`;
  var id_kp_clientAuth = `${id_kp}.2`;
  var id_kp_codeSigning = `${id_kp}.3`;
  var id_kp_emailProtection = `${id_kp}.4`;
  var id_kp_timeStamping = `${id_kp}.8`;
  var id_kp_OCSPSigning = `${id_kp}.9`;

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/inhibit_any_policy.js
  var id_ce_inhibitAnyPolicy = `${id_ce}.54`;
  var InhibitAnyPolicy = class InhibitAnyPolicy2 {
    constructor(value2 = new ArrayBuffer(0)) {
      this.value = value2;
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], InhibitAnyPolicy.prototype, "value", void 0);
  InhibitAnyPolicy = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], InhibitAnyPolicy);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/invalidity_date.js
  var id_ce_invalidityDate = `${id_ce}.24`;
  var InvalidityDate = class InvalidityDate2 {
    constructor(value2) {
      this.value = /* @__PURE__ */ new Date();
      if (value2) {
        this.value = value2;
      }
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralizedTime })
  ], InvalidityDate.prototype, "value", void 0);
  InvalidityDate = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], InvalidityDate);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/issuer_alternative_name.js
  var IssueAlternativeName_1;
  var id_ce_issuerAltName = `${id_ce}.18`;
  var IssueAlternativeName = IssueAlternativeName_1 = class IssueAlternativeName2 extends GeneralNames {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, IssueAlternativeName_1.prototype);
    }
  };
  IssueAlternativeName = IssueAlternativeName_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], IssueAlternativeName);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/key_usage.js
  var id_ce_keyUsage = `${id_ce}.15`;
  var KeyUsageFlags;
  (function(KeyUsageFlags3) {
    KeyUsageFlags3[KeyUsageFlags3["digitalSignature"] = 1] = "digitalSignature";
    KeyUsageFlags3[KeyUsageFlags3["nonRepudiation"] = 2] = "nonRepudiation";
    KeyUsageFlags3[KeyUsageFlags3["keyEncipherment"] = 4] = "keyEncipherment";
    KeyUsageFlags3[KeyUsageFlags3["dataEncipherment"] = 8] = "dataEncipherment";
    KeyUsageFlags3[KeyUsageFlags3["keyAgreement"] = 16] = "keyAgreement";
    KeyUsageFlags3[KeyUsageFlags3["keyCertSign"] = 32] = "keyCertSign";
    KeyUsageFlags3[KeyUsageFlags3["cRLSign"] = 64] = "cRLSign";
    KeyUsageFlags3[KeyUsageFlags3["encipherOnly"] = 128] = "encipherOnly";
    KeyUsageFlags3[KeyUsageFlags3["decipherOnly"] = 256] = "decipherOnly";
  })(KeyUsageFlags || (KeyUsageFlags = {}));
  var KeyUsage = class extends BitString2 {
    toJSON() {
      const flag = this.toNumber();
      const res = [];
      if (flag & KeyUsageFlags.cRLSign) {
        res.push("crlSign");
      }
      if (flag & KeyUsageFlags.dataEncipherment) {
        res.push("dataEncipherment");
      }
      if (flag & KeyUsageFlags.decipherOnly) {
        res.push("decipherOnly");
      }
      if (flag & KeyUsageFlags.digitalSignature) {
        res.push("digitalSignature");
      }
      if (flag & KeyUsageFlags.encipherOnly) {
        res.push("encipherOnly");
      }
      if (flag & KeyUsageFlags.keyAgreement) {
        res.push("keyAgreement");
      }
      if (flag & KeyUsageFlags.keyCertSign) {
        res.push("keyCertSign");
      }
      if (flag & KeyUsageFlags.keyEncipherment) {
        res.push("keyEncipherment");
      }
      if (flag & KeyUsageFlags.nonRepudiation) {
        res.push("nonRepudiation");
      }
      return res;
    }
    toString() {
      return `[${this.toJSON().join(", ")}]`;
    }
  };

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/name_constraints.js
  var GeneralSubtrees_1;
  var id_ce_nameConstraints = `${id_ce}.30`;
  var GeneralSubtree = class {
    constructor(params = {}) {
      this.base = new GeneralName();
      this.minimum = 0;
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralName })
  ], GeneralSubtree.prototype, "base", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, context: 0, defaultValue: 0, implicit: true })
  ], GeneralSubtree.prototype, "minimum", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, context: 1, optional: true, implicit: true })
  ], GeneralSubtree.prototype, "maximum", void 0);
  var GeneralSubtrees = GeneralSubtrees_1 = class GeneralSubtrees2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, GeneralSubtrees_1.prototype);
    }
  };
  GeneralSubtrees = GeneralSubtrees_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: GeneralSubtree })
  ], GeneralSubtrees);
  var NameConstraints = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralSubtrees, context: 0, optional: true, implicit: true })
  ], NameConstraints.prototype, "permittedSubtrees", void 0);
  __decorate([
    AsnProp({ type: GeneralSubtrees, context: 1, optional: true, implicit: true })
  ], NameConstraints.prototype, "excludedSubtrees", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_constraints.js
  var id_ce_policyConstraints = `${id_ce}.36`;
  var PolicyConstraints = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({
      type: AsnPropTypes.Integer,
      context: 0,
      implicit: true,
      optional: true,
      converter: AsnIntegerArrayBufferConverter
    })
  ], PolicyConstraints.prototype, "requireExplicitPolicy", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Integer,
      context: 1,
      implicit: true,
      optional: true,
      converter: AsnIntegerArrayBufferConverter
    })
  ], PolicyConstraints.prototype, "inhibitPolicyMapping", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/policy_mappings.js
  var PolicyMappings_1;
  var id_ce_policyMappings = `${id_ce}.33`;
  var PolicyMapping = class {
    constructor(params = {}) {
      this.issuerDomainPolicy = "";
      this.subjectDomainPolicy = "";
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], PolicyMapping.prototype, "issuerDomainPolicy", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], PolicyMapping.prototype, "subjectDomainPolicy", void 0);
  var PolicyMappings = PolicyMappings_1 = class PolicyMappings2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, PolicyMappings_1.prototype);
    }
  };
  PolicyMappings = PolicyMappings_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: PolicyMapping })
  ], PolicyMappings);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_alternative_name.js
  var SubjectAlternativeName_1;
  var id_ce_subjectAltName = `${id_ce}.17`;
  var SubjectAlternativeName = SubjectAlternativeName_1 = class SubjectAlternativeName2 extends GeneralNames {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, SubjectAlternativeName_1.prototype);
    }
  };
  SubjectAlternativeName = SubjectAlternativeName_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], SubjectAlternativeName);

  // node_modules/@peculiar/asn1-x509/build/es2015/attribute.js
  var Attribute = class {
    constructor(params = {}) {
      this.type = "";
      this.values = [];
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], Attribute.prototype, "type", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
  ], Attribute.prototype, "values", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_directory_attributes.js
  var SubjectDirectoryAttributes_1;
  var id_ce_subjectDirectoryAttributes = `${id_ce}.9`;
  var SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = class SubjectDirectoryAttributes2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, SubjectDirectoryAttributes_1.prototype);
    }
  };
  SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
  ], SubjectDirectoryAttributes);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_key_identifier.js
  var id_ce_subjectKeyIdentifier = `${id_ce}.14`;
  var SubjectKeyIdentifier = class extends KeyIdentifier {
  };

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/private_key_usage_period.js
  var id_ce_privateKeyUsagePeriod = `${id_ce}.16`;
  var PrivateKeyUsagePeriod = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 0, implicit: true, optional: true })
  ], PrivateKeyUsagePeriod.prototype, "notBefore", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralizedTime, context: 1, implicit: true, optional: true })
  ], PrivateKeyUsagePeriod.prototype, "notAfter", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/entrust_version_info.js
  var EntrustInfoFlags;
  (function(EntrustInfoFlags2) {
    EntrustInfoFlags2[EntrustInfoFlags2["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
    EntrustInfoFlags2[EntrustInfoFlags2["newExtensions"] = 2] = "newExtensions";
    EntrustInfoFlags2[EntrustInfoFlags2["pKIXCertificate"] = 4] = "pKIXCertificate";
  })(EntrustInfoFlags || (EntrustInfoFlags = {}));
  var EntrustInfo = class extends BitString2 {
    toJSON() {
      const res = [];
      const flags = this.toNumber();
      if (flags & EntrustInfoFlags.pKIXCertificate) {
        res.push("pKIXCertificate");
      }
      if (flags & EntrustInfoFlags.newExtensions) {
        res.push("newExtensions");
      }
      if (flags & EntrustInfoFlags.keyUpdateAllowed) {
        res.push("keyUpdateAllowed");
      }
      return res;
    }
    toString() {
      return `[${this.toJSON().join(", ")}]`;
    }
  };
  var EntrustVersionInfo = class {
    constructor(params = {}) {
      this.entrustVers = "";
      this.entrustInfoFlags = new EntrustInfo();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralString })
  ], EntrustVersionInfo.prototype, "entrustVers", void 0);
  __decorate([
    AsnProp({ type: EntrustInfo })
  ], EntrustVersionInfo.prototype, "entrustInfoFlags", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/extensions/subject_info_access.js
  var SubjectInfoAccessSyntax_1;
  var id_pe_subjectInfoAccess = `${id_pe}.11`;
  var SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = class SubjectInfoAccessSyntax2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, SubjectInfoAccessSyntax_1.prototype);
    }
  };
  SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: AccessDescription })
  ], SubjectInfoAccessSyntax);

  // node_modules/@peculiar/asn1-x509/build/es2015/algorithm_identifier.js
  var pvtsutils2 = __toESM(require_build());
  var AlgorithmIdentifier = class _AlgorithmIdentifier {
    constructor(params = {}) {
      this.algorithm = "";
      Object.assign(this, params);
    }
    isEqual(data) {
      return data instanceof _AlgorithmIdentifier && data.algorithm == this.algorithm && (data.parameters && this.parameters && pvtsutils2.isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
    }
  };
  __decorate([
    AsnProp({
      type: AsnPropTypes.ObjectIdentifier
    })
  ], AlgorithmIdentifier.prototype, "algorithm", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Any,
      optional: true
    })
  ], AlgorithmIdentifier.prototype, "parameters", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/subject_public_key_info.js
  var SubjectPublicKeyInfo = class {
    constructor(params = {}) {
      this.algorithm = new AlgorithmIdentifier();
      this.subjectPublicKey = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], SubjectPublicKeyInfo.prototype, "algorithm", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString })
  ], SubjectPublicKeyInfo.prototype, "subjectPublicKey", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/time.js
  var Time = class Time2 {
    constructor(time) {
      if (time) {
        if (typeof time === "string" || typeof time === "number" || time instanceof Date) {
          const date = new Date(time);
          if (date.getUTCFullYear() > 2049) {
            this.generalTime = date;
          } else {
            this.utcTime = date;
          }
        } else {
          Object.assign(this, time);
        }
      }
    }
    getTime() {
      const time = this.utcTime || this.generalTime;
      if (!time) {
        throw new Error("Cannot get time from CHOICE object");
      }
      return time;
    }
  };
  __decorate([
    AsnProp({
      type: AsnPropTypes.UTCTime
    })
  ], Time.prototype, "utcTime", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.GeneralizedTime
    })
  ], Time.prototype, "generalTime", void 0);
  Time = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], Time);

  // node_modules/@peculiar/asn1-x509/build/es2015/validity.js
  var Validity = class {
    constructor(params) {
      this.notBefore = new Time(/* @__PURE__ */ new Date());
      this.notAfter = new Time(/* @__PURE__ */ new Date());
      if (params) {
        this.notBefore = new Time(params.notBefore);
        this.notAfter = new Time(params.notAfter);
      }
    }
  };
  __decorate([
    AsnProp({ type: Time })
  ], Validity.prototype, "notBefore", void 0);
  __decorate([
    AsnProp({ type: Time })
  ], Validity.prototype, "notAfter", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/extension.js
  var Extensions_1;
  var Extension = class _Extension {
    constructor(params = {}) {
      this.extnID = "";
      this.critical = _Extension.CRITICAL;
      this.extnValue = new OctetString2();
      Object.assign(this, params);
    }
  };
  Extension.CRITICAL = false;
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], Extension.prototype, "extnID", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Boolean,
      defaultValue: Extension.CRITICAL
    })
  ], Extension.prototype, "critical", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], Extension.prototype, "extnValue", void 0);
  var Extensions = Extensions_1 = class Extensions2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, Extensions_1.prototype);
    }
  };
  Extensions = Extensions_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: Extension })
  ], Extensions);

  // node_modules/@peculiar/asn1-x509/build/es2015/types.js
  var Version;
  (function(Version3) {
    Version3[Version3["v1"] = 0] = "v1";
    Version3[Version3["v2"] = 1] = "v2";
    Version3[Version3["v3"] = 2] = "v3";
  })(Version || (Version = {}));

  // node_modules/@peculiar/asn1-x509/build/es2015/tbs_certificate.js
  var TBSCertificate = class {
    constructor(params = {}) {
      this.version = Version.v1;
      this.serialNumber = new ArrayBuffer(0);
      this.signature = new AlgorithmIdentifier();
      this.issuer = new Name();
      this.validity = new Validity();
      this.subject = new Name();
      this.subjectPublicKeyInfo = new SubjectPublicKeyInfo();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({
      type: AsnPropTypes.Integer,
      context: 0,
      defaultValue: Version.v1
    })
  ], TBSCertificate.prototype, "version", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.Integer,
      converter: AsnIntegerArrayBufferConverter
    })
  ], TBSCertificate.prototype, "serialNumber", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], TBSCertificate.prototype, "signature", void 0);
  __decorate([
    AsnProp({ type: Name })
  ], TBSCertificate.prototype, "issuer", void 0);
  __decorate([
    AsnProp({ type: Validity })
  ], TBSCertificate.prototype, "validity", void 0);
  __decorate([
    AsnProp({ type: Name })
  ], TBSCertificate.prototype, "subject", void 0);
  __decorate([
    AsnProp({ type: SubjectPublicKeyInfo })
  ], TBSCertificate.prototype, "subjectPublicKeyInfo", void 0);
  __decorate([
    AsnProp({
      type: AsnPropTypes.BitString,
      context: 1,
      implicit: true,
      optional: true
    })
  ], TBSCertificate.prototype, "issuerUniqueID", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString, context: 2, implicit: true, optional: true })
  ], TBSCertificate.prototype, "subjectUniqueID", void 0);
  __decorate([
    AsnProp({ type: Extensions, context: 3, optional: true })
  ], TBSCertificate.prototype, "extensions", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/certificate.js
  var Certificate = class {
    constructor(params = {}) {
      this.tbsCertificate = new TBSCertificate();
      this.signatureAlgorithm = new AlgorithmIdentifier();
      this.signatureValue = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: TBSCertificate, raw: true })
  ], Certificate.prototype, "tbsCertificate", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], Certificate.prototype, "signatureAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString })
  ], Certificate.prototype, "signatureValue", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/tbs_cert_list.js
  var RevokedCertificate = class {
    constructor(params = {}) {
      this.userCertificate = new ArrayBuffer(0);
      this.revocationDate = new Time();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RevokedCertificate.prototype, "userCertificate", void 0);
  __decorate([
    AsnProp({ type: Time })
  ], RevokedCertificate.prototype, "revocationDate", void 0);
  __decorate([
    AsnProp({ type: Extension, optional: true, repeated: "sequence" })
  ], RevokedCertificate.prototype, "crlEntryExtensions", void 0);
  var TBSCertList = class {
    constructor(params = {}) {
      this.signature = new AlgorithmIdentifier();
      this.issuer = new Name();
      this.thisUpdate = new Time();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, optional: true })
  ], TBSCertList.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], TBSCertList.prototype, "signature", void 0);
  __decorate([
    AsnProp({ type: Name })
  ], TBSCertList.prototype, "issuer", void 0);
  __decorate([
    AsnProp({ type: Time })
  ], TBSCertList.prototype, "thisUpdate", void 0);
  __decorate([
    AsnProp({ type: Time, optional: true })
  ], TBSCertList.prototype, "nextUpdate", void 0);
  __decorate([
    AsnProp({ type: RevokedCertificate, repeated: "sequence", optional: true })
  ], TBSCertList.prototype, "revokedCertificates", void 0);
  __decorate([
    AsnProp({ type: Extension, optional: true, context: 0, repeated: "sequence" })
  ], TBSCertList.prototype, "crlExtensions", void 0);

  // node_modules/@peculiar/asn1-x509/build/es2015/certificate_list.js
  var CertificateList = class {
    constructor(params = {}) {
      this.tbsCertList = new TBSCertList();
      this.signatureAlgorithm = new AlgorithmIdentifier();
      this.signature = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: TBSCertList, raw: true })
  ], CertificateList.prototype, "tbsCertList", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], CertificateList.prototype, "signatureAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString })
  ], CertificateList.prototype, "signature", void 0);

  // node_modules/@peculiar/x509/build/x509.es.js
  var import_pvtsutils6 = __toESM(require_build());

  // node_modules/@peculiar/asn1-cms/build/es2015/issuer_and_serial_number.js
  var IssuerAndSerialNumber = class {
    constructor(params = {}) {
      this.issuer = new Name();
      this.serialNumber = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: Name })
  ], IssuerAndSerialNumber.prototype, "issuer", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], IssuerAndSerialNumber.prototype, "serialNumber", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/signer_identifier.js
  var SignerIdentifier = class SignerIdentifier2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: SubjectKeyIdentifier, context: 0, implicit: true })
  ], SignerIdentifier.prototype, "subjectKeyIdentifier", void 0);
  __decorate([
    AsnProp({ type: IssuerAndSerialNumber })
  ], SignerIdentifier.prototype, "issuerAndSerialNumber", void 0);
  SignerIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], SignerIdentifier);

  // node_modules/@peculiar/asn1-cms/build/es2015/types.js
  var CMSVersion;
  (function(CMSVersion2) {
    CMSVersion2[CMSVersion2["v0"] = 0] = "v0";
    CMSVersion2[CMSVersion2["v1"] = 1] = "v1";
    CMSVersion2[CMSVersion2["v2"] = 2] = "v2";
    CMSVersion2[CMSVersion2["v3"] = 3] = "v3";
    CMSVersion2[CMSVersion2["v4"] = 4] = "v4";
    CMSVersion2[CMSVersion2["v5"] = 5] = "v5";
  })(CMSVersion || (CMSVersion = {}));
  var DigestAlgorithmIdentifier = class DigestAlgorithmIdentifier2 extends AlgorithmIdentifier {
  };
  DigestAlgorithmIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], DigestAlgorithmIdentifier);
  var SignatureAlgorithmIdentifier = class SignatureAlgorithmIdentifier2 extends AlgorithmIdentifier {
  };
  SignatureAlgorithmIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], SignatureAlgorithmIdentifier);
  var KeyEncryptionAlgorithmIdentifier = class KeyEncryptionAlgorithmIdentifier2 extends AlgorithmIdentifier {
  };
  KeyEncryptionAlgorithmIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], KeyEncryptionAlgorithmIdentifier);
  var ContentEncryptionAlgorithmIdentifier = class ContentEncryptionAlgorithmIdentifier2 extends AlgorithmIdentifier {
  };
  ContentEncryptionAlgorithmIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], ContentEncryptionAlgorithmIdentifier);
  var MessageAuthenticationCodeAlgorithm = class MessageAuthenticationCodeAlgorithm2 extends AlgorithmIdentifier {
  };
  MessageAuthenticationCodeAlgorithm = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], MessageAuthenticationCodeAlgorithm);
  var KeyDerivationAlgorithmIdentifier = class KeyDerivationAlgorithmIdentifier2 extends AlgorithmIdentifier {
  };
  KeyDerivationAlgorithmIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], KeyDerivationAlgorithmIdentifier);

  // node_modules/@peculiar/asn1-cms/build/es2015/attribute.js
  var Attribute2 = class {
    constructor(params = {}) {
      this.attrType = "";
      this.attrValues = [];
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], Attribute2.prototype, "attrType", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
  ], Attribute2.prototype, "attrValues", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/signer_info.js
  var SignerInfos_1;
  var SignerInfo = class {
    constructor(params = {}) {
      this.version = CMSVersion.v0;
      this.sid = new SignerIdentifier();
      this.digestAlgorithm = new DigestAlgorithmIdentifier();
      this.signatureAlgorithm = new SignatureAlgorithmIdentifier();
      this.signature = new OctetString2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], SignerInfo.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: SignerIdentifier })
  ], SignerInfo.prototype, "sid", void 0);
  __decorate([
    AsnProp({ type: DigestAlgorithmIdentifier })
  ], SignerInfo.prototype, "digestAlgorithm", void 0);
  __decorate([
    AsnProp({
      type: Attribute2,
      repeated: "set",
      context: 0,
      implicit: true,
      optional: true,
      raw: true
    })
  ], SignerInfo.prototype, "signedAttrs", void 0);
  __decorate([
    AsnProp({ type: SignatureAlgorithmIdentifier })
  ], SignerInfo.prototype, "signatureAlgorithm", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], SignerInfo.prototype, "signature", void 0);
  __decorate([
    AsnProp({ type: Attribute2, repeated: "set", context: 1, implicit: true, optional: true })
  ], SignerInfo.prototype, "unsignedAttrs", void 0);
  var SignerInfos = SignerInfos_1 = class SignerInfos2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, SignerInfos_1.prototype);
    }
  };
  SignerInfos = SignerInfos_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Set, itemType: SignerInfo })
  ], SignerInfos);

  // node_modules/@peculiar/asn1-cms/build/es2015/attributes.js
  var SigningTime = class SigningTime2 extends Time {
  };
  SigningTime = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], SigningTime);
  var CounterSignature = class CounterSignature2 extends SignerInfo {
  };
  CounterSignature = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], CounterSignature);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_clear_attrs.js
  var ACClearAttrs = class {
    constructor(params = {}) {
      this.acIssuer = new GeneralName();
      this.acSerial = 0;
      this.attrs = [];
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralName })
  ], ACClearAttrs.prototype, "acIssuer", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], ACClearAttrs.prototype, "acSerial", void 0);
  __decorate([
    AsnProp({ type: Attribute, repeated: "sequence" })
  ], ACClearAttrs.prototype, "attrs", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_spec.js
  var AttrSpec_1;
  var AttrSpec = AttrSpec_1 = class AttrSpec2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, AttrSpec_1.prototype);
    }
  };
  AttrSpec = AttrSpec_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: AsnPropTypes.ObjectIdentifier })
  ], AttrSpec);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/aa_controls.js
  var AAControls = class {
    constructor(params = {}) {
      this.permitUnSpecified = true;
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, optional: true })
  ], AAControls.prototype, "pathLenConstraint", void 0);
  __decorate([
    AsnProp({ type: AttrSpec, implicit: true, context: 0, optional: true })
  ], AAControls.prototype, "permittedAttrs", void 0);
  __decorate([
    AsnProp({ type: AttrSpec, implicit: true, context: 1, optional: true })
  ], AAControls.prototype, "excludedAttrs", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Boolean, defaultValue: true })
  ], AAControls.prototype, "permitUnSpecified", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/issuer_serial.js
  var IssuerSerial = class {
    constructor(params = {}) {
      this.issuer = new GeneralNames();
      this.serial = new ArrayBuffer(0);
      this.issuerUID = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralNames })
  ], IssuerSerial.prototype, "issuer", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], IssuerSerial.prototype, "serial", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString, optional: true })
  ], IssuerSerial.prototype, "issuerUID", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/object_digest_info.js
  var DigestedObjectType;
  (function(DigestedObjectType2) {
    DigestedObjectType2[DigestedObjectType2["publicKey"] = 0] = "publicKey";
    DigestedObjectType2[DigestedObjectType2["publicKeyCert"] = 1] = "publicKeyCert";
    DigestedObjectType2[DigestedObjectType2["otherObjectTypes"] = 2] = "otherObjectTypes";
  })(DigestedObjectType || (DigestedObjectType = {}));
  var ObjectDigestInfo = class {
    constructor(params = {}) {
      this.digestedObjectType = DigestedObjectType.publicKey;
      this.digestAlgorithm = new AlgorithmIdentifier();
      this.objectDigest = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Enumerated })
  ], ObjectDigestInfo.prototype, "digestedObjectType", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier, optional: true })
  ], ObjectDigestInfo.prototype, "otherObjectTypeID", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], ObjectDigestInfo.prototype, "digestAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString })
  ], ObjectDigestInfo.prototype, "objectDigest", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/v2_form.js
  var V2Form = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralNames, optional: true })
  ], V2Form.prototype, "issuerName", void 0);
  __decorate([
    AsnProp({ type: IssuerSerial, context: 0, implicit: true, optional: true })
  ], V2Form.prototype, "baseCertificateID", void 0);
  __decorate([
    AsnProp({ type: ObjectDigestInfo, context: 1, implicit: true, optional: true })
  ], V2Form.prototype, "objectDigestInfo", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_issuer.js
  var AttCertIssuer = class AttCertIssuer2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralName, repeated: "sequence" })
  ], AttCertIssuer.prototype, "v1Form", void 0);
  __decorate([
    AsnProp({ type: V2Form, context: 0, implicit: true })
  ], AttCertIssuer.prototype, "v2Form", void 0);
  AttCertIssuer = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], AttCertIssuer);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/attr_cert_validity_period.js
  var AttCertValidityPeriod = class {
    constructor(params = {}) {
      this.notBeforeTime = /* @__PURE__ */ new Date();
      this.notAfterTime = /* @__PURE__ */ new Date();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralizedTime })
  ], AttCertValidityPeriod.prototype, "notBeforeTime", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralizedTime })
  ], AttCertValidityPeriod.prototype, "notAfterTime", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/holder.js
  var Holder = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: IssuerSerial, implicit: true, context: 0, optional: true })
  ], Holder.prototype, "baseCertificateID", void 0);
  __decorate([
    AsnProp({ type: GeneralNames, implicit: true, context: 1, optional: true })
  ], Holder.prototype, "entityName", void 0);
  __decorate([
    AsnProp({ type: ObjectDigestInfo, implicit: true, context: 2, optional: true })
  ], Holder.prototype, "objectDigestInfo", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate_info.js
  var AttCertVersion;
  (function(AttCertVersion2) {
    AttCertVersion2[AttCertVersion2["v2"] = 1] = "v2";
  })(AttCertVersion || (AttCertVersion = {}));
  var AttributeCertificateInfo = class {
    constructor(params = {}) {
      this.version = AttCertVersion.v2;
      this.holder = new Holder();
      this.issuer = new AttCertIssuer();
      this.signature = new AlgorithmIdentifier();
      this.serialNumber = new ArrayBuffer(0);
      this.attrCertValidityPeriod = new AttCertValidityPeriod();
      this.attributes = [];
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], AttributeCertificateInfo.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: Holder })
  ], AttributeCertificateInfo.prototype, "holder", void 0);
  __decorate([
    AsnProp({ type: AttCertIssuer })
  ], AttributeCertificateInfo.prototype, "issuer", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], AttributeCertificateInfo.prototype, "signature", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], AttributeCertificateInfo.prototype, "serialNumber", void 0);
  __decorate([
    AsnProp({ type: AttCertValidityPeriod })
  ], AttributeCertificateInfo.prototype, "attrCertValidityPeriod", void 0);
  __decorate([
    AsnProp({ type: Attribute, repeated: "sequence" })
  ], AttributeCertificateInfo.prototype, "attributes", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString, optional: true })
  ], AttributeCertificateInfo.prototype, "issuerUniqueID", void 0);
  __decorate([
    AsnProp({ type: Extensions, optional: true })
  ], AttributeCertificateInfo.prototype, "extensions", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/attribute_certificate.js
  var AttributeCertificate = class {
    constructor(params = {}) {
      this.acinfo = new AttributeCertificateInfo();
      this.signatureAlgorithm = new AlgorithmIdentifier();
      this.signatureValue = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AttributeCertificateInfo })
  ], AttributeCertificate.prototype, "acinfo", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], AttributeCertificate.prototype, "signatureAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString })
  ], AttributeCertificate.prototype, "signatureValue", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/class_list.js
  var ClassListFlags;
  (function(ClassListFlags2) {
    ClassListFlags2[ClassListFlags2["unmarked"] = 1] = "unmarked";
    ClassListFlags2[ClassListFlags2["unclassified"] = 2] = "unclassified";
    ClassListFlags2[ClassListFlags2["restricted"] = 4] = "restricted";
    ClassListFlags2[ClassListFlags2["confidential"] = 8] = "confidential";
    ClassListFlags2[ClassListFlags2["secret"] = 16] = "secret";
    ClassListFlags2[ClassListFlags2["topSecret"] = 32] = "topSecret";
  })(ClassListFlags || (ClassListFlags = {}));
  var ClassList = class extends BitString2 {
  };

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/security_category.js
  var SecurityCategory = class {
    constructor(params = {}) {
      this.type = "";
      this.value = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier, implicit: true, context: 0 })
  ], SecurityCategory.prototype, "type", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, implicit: true, context: 1 })
  ], SecurityCategory.prototype, "value", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/clearance.js
  var Clearance = class {
    constructor(params = {}) {
      this.policyId = "";
      this.classList = new ClassList(ClassListFlags.unclassified);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], Clearance.prototype, "policyId", void 0);
  __decorate([
    AsnProp({ type: ClassList, defaultValue: new ClassList(ClassListFlags.unclassified) })
  ], Clearance.prototype, "classList", void 0);
  __decorate([
    AsnProp({ type: SecurityCategory, repeated: "set" })
  ], Clearance.prototype, "securityCategories", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/ietf_attr_syntax.js
  var IetfAttrSyntaxValueChoices = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: OctetString2 })
  ], IetfAttrSyntaxValueChoices.prototype, "cotets", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], IetfAttrSyntaxValueChoices.prototype, "oid", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Utf8String })
  ], IetfAttrSyntaxValueChoices.prototype, "string", void 0);
  var IetfAttrSyntax = class {
    constructor(params = {}) {
      this.values = [];
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralNames, implicit: true, context: 0, optional: true })
  ], IetfAttrSyntax.prototype, "policyAuthority", void 0);
  __decorate([
    AsnProp({ type: IetfAttrSyntaxValueChoices, repeated: "sequence" })
  ], IetfAttrSyntax.prototype, "values", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/object_identifiers.js
  var id_pe_ac_auditIdentity = `${id_pe}.4`;
  var id_pe_aaControls = `${id_pe}.6`;
  var id_pe_ac_proxying = `${id_pe}.10`;
  var id_ce_targetInformation = `${id_ce}.55`;
  var id_aca = `${id_pkix}.10`;
  var id_aca_authenticationInfo = `${id_aca}.1`;
  var id_aca_accessIdentity = `${id_aca}.2`;
  var id_aca_chargingIdentity = `${id_aca}.3`;
  var id_aca_group = `${id_aca}.4`;
  var id_aca_encAttrs = `${id_aca}.6`;
  var id_at = "2.5.4";
  var id_at_role = `${id_at}.72`;

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/target.js
  var Targets_1;
  var TargetCert = class {
    constructor(params = {}) {
      this.targetCertificate = new IssuerSerial();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: IssuerSerial })
  ], TargetCert.prototype, "targetCertificate", void 0);
  __decorate([
    AsnProp({ type: GeneralName, optional: true })
  ], TargetCert.prototype, "targetName", void 0);
  __decorate([
    AsnProp({ type: ObjectDigestInfo, optional: true })
  ], TargetCert.prototype, "certDigestInfo", void 0);
  var Target = class Target2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralName, context: 0, implicit: true })
  ], Target.prototype, "targetName", void 0);
  __decorate([
    AsnProp({ type: GeneralName, context: 1, implicit: true })
  ], Target.prototype, "targetGroup", void 0);
  __decorate([
    AsnProp({ type: TargetCert, context: 2, implicit: true })
  ], Target.prototype, "targetCert", void 0);
  Target = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], Target);
  var Targets = Targets_1 = class Targets2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, Targets_1.prototype);
    }
  };
  Targets = Targets_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: Target })
  ], Targets);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/proxy_info.js
  var ProxyInfo_1;
  var ProxyInfo = ProxyInfo_1 = class ProxyInfo2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, ProxyInfo_1.prototype);
    }
  };
  ProxyInfo = ProxyInfo_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: Targets })
  ], ProxyInfo);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/role_syntax.js
  var RoleSyntax = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralNames, implicit: true, context: 0, optional: true })
  ], RoleSyntax.prototype, "roleAuthority", void 0);
  __decorate([
    AsnProp({ type: GeneralName, implicit: true, context: 1 })
  ], RoleSyntax.prototype, "roleName", void 0);

  // node_modules/@peculiar/asn1-x509-attr/build/es2015/svce_auth_info.js
  var SvceAuthInfo = class {
    constructor(params = {}) {
      this.service = new GeneralName();
      this.ident = new GeneralName();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: GeneralName })
  ], SvceAuthInfo.prototype, "service", void 0);
  __decorate([
    AsnProp({ type: GeneralName })
  ], SvceAuthInfo.prototype, "ident", void 0);
  __decorate([
    AsnProp({ type: OctetString2, optional: true })
  ], SvceAuthInfo.prototype, "authInfo", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/certificate_choices.js
  var CertificateSet_1;
  var OtherCertificateFormat = class {
    constructor(params = {}) {
      this.otherCertFormat = "";
      this.otherCert = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], OtherCertificateFormat.prototype, "otherCertFormat", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any })
  ], OtherCertificateFormat.prototype, "otherCert", void 0);
  var CertificateChoices = class CertificateChoices2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: Certificate })
  ], CertificateChoices.prototype, "certificate", void 0);
  __decorate([
    AsnProp({ type: AttributeCertificate, context: 2, implicit: true })
  ], CertificateChoices.prototype, "v2AttrCert", void 0);
  __decorate([
    AsnProp({ type: OtherCertificateFormat, context: 3, implicit: true })
  ], CertificateChoices.prototype, "other", void 0);
  CertificateChoices = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], CertificateChoices);
  var CertificateSet = CertificateSet_1 = class CertificateSet2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, CertificateSet_1.prototype);
    }
  };
  CertificateSet = CertificateSet_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Set, itemType: CertificateChoices })
  ], CertificateSet);

  // node_modules/@peculiar/asn1-cms/build/es2015/content_info.js
  var ContentInfo = class {
    constructor(params = {}) {
      this.contentType = "";
      this.content = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], ContentInfo.prototype, "contentType", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, context: 0 })
  ], ContentInfo.prototype, "content", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/encapsulated_content_info.js
  var EncapsulatedContent = class EncapsulatedContent2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: OctetString2 })
  ], EncapsulatedContent.prototype, "single", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any })
  ], EncapsulatedContent.prototype, "any", void 0);
  EncapsulatedContent = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], EncapsulatedContent);
  var EncapsulatedContentInfo = class {
    constructor(params = {}) {
      this.eContentType = "";
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], EncapsulatedContentInfo.prototype, "eContentType", void 0);
  __decorate([
    AsnProp({ type: EncapsulatedContent, context: 0, optional: true })
  ], EncapsulatedContentInfo.prototype, "eContent", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/encrypted_content_info.js
  var EncryptedContent = class EncryptedContent2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: OctetString2, context: 0, implicit: true, optional: true })
  ], EncryptedContent.prototype, "value", void 0);
  __decorate([
    AsnProp({
      type: OctetString2,
      converter: AsnConstructedOctetStringConverter,
      context: 0,
      implicit: true,
      optional: true,
      repeated: "sequence"
    })
  ], EncryptedContent.prototype, "constructedValue", void 0);
  EncryptedContent = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], EncryptedContent);
  var EncryptedContentInfo = class {
    constructor(params = {}) {
      this.contentType = "";
      this.contentEncryptionAlgorithm = new ContentEncryptionAlgorithmIdentifier();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], EncryptedContentInfo.prototype, "contentType", void 0);
  __decorate([
    AsnProp({ type: ContentEncryptionAlgorithmIdentifier })
  ], EncryptedContentInfo.prototype, "contentEncryptionAlgorithm", void 0);
  __decorate([
    AsnProp({ type: EncryptedContent, optional: true })
  ], EncryptedContentInfo.prototype, "encryptedContent", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/other_key_attribute.js
  var OtherKeyAttribute = class {
    constructor(params = {}) {
      this.keyAttrId = "";
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], OtherKeyAttribute.prototype, "keyAttrId", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, optional: true })
  ], OtherKeyAttribute.prototype, "keyAttr", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/key_agree_recipient_info.js
  var RecipientEncryptedKeys_1;
  var RecipientKeyIdentifier = class {
    constructor(params = {}) {
      this.subjectKeyIdentifier = new SubjectKeyIdentifier();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: SubjectKeyIdentifier })
  ], RecipientKeyIdentifier.prototype, "subjectKeyIdentifier", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralizedTime, optional: true })
  ], RecipientKeyIdentifier.prototype, "date", void 0);
  __decorate([
    AsnProp({ type: OtherKeyAttribute, optional: true })
  ], RecipientKeyIdentifier.prototype, "other", void 0);
  var KeyAgreeRecipientIdentifier = class KeyAgreeRecipientIdentifier2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: RecipientKeyIdentifier, context: 0, implicit: true, optional: true })
  ], KeyAgreeRecipientIdentifier.prototype, "rKeyId", void 0);
  __decorate([
    AsnProp({ type: IssuerAndSerialNumber, optional: true })
  ], KeyAgreeRecipientIdentifier.prototype, "issuerAndSerialNumber", void 0);
  KeyAgreeRecipientIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], KeyAgreeRecipientIdentifier);
  var RecipientEncryptedKey = class {
    constructor(params = {}) {
      this.rid = new KeyAgreeRecipientIdentifier();
      this.encryptedKey = new OctetString2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: KeyAgreeRecipientIdentifier })
  ], RecipientEncryptedKey.prototype, "rid", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], RecipientEncryptedKey.prototype, "encryptedKey", void 0);
  var RecipientEncryptedKeys = RecipientEncryptedKeys_1 = class RecipientEncryptedKeys2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, RecipientEncryptedKeys_1.prototype);
    }
  };
  RecipientEncryptedKeys = RecipientEncryptedKeys_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: RecipientEncryptedKey })
  ], RecipientEncryptedKeys);
  var OriginatorPublicKey = class {
    constructor(params = {}) {
      this.algorithm = new AlgorithmIdentifier();
      this.publicKey = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], OriginatorPublicKey.prototype, "algorithm", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString })
  ], OriginatorPublicKey.prototype, "publicKey", void 0);
  var OriginatorIdentifierOrKey = class OriginatorIdentifierOrKey2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: SubjectKeyIdentifier, context: 0, implicit: true, optional: true })
  ], OriginatorIdentifierOrKey.prototype, "subjectKeyIdentifier", void 0);
  __decorate([
    AsnProp({ type: OriginatorPublicKey, context: 1, implicit: true, optional: true })
  ], OriginatorIdentifierOrKey.prototype, "originatorKey", void 0);
  __decorate([
    AsnProp({ type: IssuerAndSerialNumber, optional: true })
  ], OriginatorIdentifierOrKey.prototype, "issuerAndSerialNumber", void 0);
  OriginatorIdentifierOrKey = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], OriginatorIdentifierOrKey);
  var KeyAgreeRecipientInfo = class {
    constructor(params = {}) {
      this.version = CMSVersion.v3;
      this.originator = new OriginatorIdentifierOrKey();
      this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
      this.recipientEncryptedKeys = new RecipientEncryptedKeys();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], KeyAgreeRecipientInfo.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: OriginatorIdentifierOrKey, context: 0 })
  ], KeyAgreeRecipientInfo.prototype, "originator", void 0);
  __decorate([
    AsnProp({ type: OctetString2, context: 1, optional: true })
  ], KeyAgreeRecipientInfo.prototype, "ukm", void 0);
  __decorate([
    AsnProp({ type: KeyEncryptionAlgorithmIdentifier })
  ], KeyAgreeRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
  __decorate([
    AsnProp({ type: RecipientEncryptedKeys })
  ], KeyAgreeRecipientInfo.prototype, "recipientEncryptedKeys", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/key_trans_recipient_info.js
  var RecipientIdentifier = class RecipientIdentifier2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: SubjectKeyIdentifier, context: 0, implicit: true })
  ], RecipientIdentifier.prototype, "subjectKeyIdentifier", void 0);
  __decorate([
    AsnProp({ type: IssuerAndSerialNumber })
  ], RecipientIdentifier.prototype, "issuerAndSerialNumber", void 0);
  RecipientIdentifier = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], RecipientIdentifier);
  var KeyTransRecipientInfo = class {
    constructor(params = {}) {
      this.version = CMSVersion.v0;
      this.rid = new RecipientIdentifier();
      this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
      this.encryptedKey = new OctetString2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], KeyTransRecipientInfo.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: RecipientIdentifier })
  ], KeyTransRecipientInfo.prototype, "rid", void 0);
  __decorate([
    AsnProp({ type: KeyEncryptionAlgorithmIdentifier })
  ], KeyTransRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], KeyTransRecipientInfo.prototype, "encryptedKey", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/kek_recipient_info.js
  var KEKIdentifier = class {
    constructor(params = {}) {
      this.keyIdentifier = new OctetString2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: OctetString2 })
  ], KEKIdentifier.prototype, "keyIdentifier", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralizedTime, optional: true })
  ], KEKIdentifier.prototype, "date", void 0);
  __decorate([
    AsnProp({ type: OtherKeyAttribute, optional: true })
  ], KEKIdentifier.prototype, "other", void 0);
  var KEKRecipientInfo = class {
    constructor(params = {}) {
      this.version = CMSVersion.v4;
      this.kekid = new KEKIdentifier();
      this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
      this.encryptedKey = new OctetString2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], KEKRecipientInfo.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: KEKIdentifier })
  ], KEKRecipientInfo.prototype, "kekid", void 0);
  __decorate([
    AsnProp({ type: KeyEncryptionAlgorithmIdentifier })
  ], KEKRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], KEKRecipientInfo.prototype, "encryptedKey", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/password_recipient_info.js
  var PasswordRecipientInfo = class {
    constructor(params = {}) {
      this.version = CMSVersion.v0;
      this.keyEncryptionAlgorithm = new KeyEncryptionAlgorithmIdentifier();
      this.encryptedKey = new OctetString2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], PasswordRecipientInfo.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: KeyDerivationAlgorithmIdentifier, context: 0, optional: true })
  ], PasswordRecipientInfo.prototype, "keyDerivationAlgorithm", void 0);
  __decorate([
    AsnProp({ type: KeyEncryptionAlgorithmIdentifier })
  ], PasswordRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], PasswordRecipientInfo.prototype, "encryptedKey", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/recipient_info.js
  var OtherRecipientInfo = class {
    constructor(params = {}) {
      this.oriType = "";
      this.oriValue = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], OtherRecipientInfo.prototype, "oriType", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any })
  ], OtherRecipientInfo.prototype, "oriValue", void 0);
  var RecipientInfo = class RecipientInfo2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: KeyTransRecipientInfo, optional: true })
  ], RecipientInfo.prototype, "ktri", void 0);
  __decorate([
    AsnProp({ type: KeyAgreeRecipientInfo, context: 1, implicit: true, optional: true })
  ], RecipientInfo.prototype, "kari", void 0);
  __decorate([
    AsnProp({ type: KEKRecipientInfo, context: 2, implicit: true, optional: true })
  ], RecipientInfo.prototype, "kekri", void 0);
  __decorate([
    AsnProp({ type: PasswordRecipientInfo, context: 3, implicit: true, optional: true })
  ], RecipientInfo.prototype, "pwri", void 0);
  __decorate([
    AsnProp({ type: OtherRecipientInfo, context: 4, implicit: true, optional: true })
  ], RecipientInfo.prototype, "ori", void 0);
  RecipientInfo = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], RecipientInfo);

  // node_modules/@peculiar/asn1-cms/build/es2015/recipient_infos.js
  var RecipientInfos_1;
  var RecipientInfos = RecipientInfos_1 = class RecipientInfos2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, RecipientInfos_1.prototype);
    }
  };
  RecipientInfos = RecipientInfos_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Set, itemType: RecipientInfo })
  ], RecipientInfos);

  // node_modules/@peculiar/asn1-cms/build/es2015/revocation_info_choice.js
  var RevocationInfoChoices_1;
  var id_ri = `${id_pkix}.16`;
  var id_ri_ocsp_response = `${id_ri}.2`;
  var id_ri_scvp = `${id_ri}.4`;
  var OtherRevocationInfoFormat = class {
    constructor(params = {}) {
      this.otherRevInfoFormat = "";
      this.otherRevInfo = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], OtherRevocationInfoFormat.prototype, "otherRevInfoFormat", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any })
  ], OtherRevocationInfoFormat.prototype, "otherRevInfo", void 0);
  var RevocationInfoChoice = class RevocationInfoChoice2 {
    constructor(params = {}) {
      this.other = new OtherRevocationInfoFormat();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: OtherRevocationInfoFormat, context: 1, implicit: true })
  ], RevocationInfoChoice.prototype, "other", void 0);
  RevocationInfoChoice = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], RevocationInfoChoice);
  var RevocationInfoChoices = RevocationInfoChoices_1 = class RevocationInfoChoices2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, RevocationInfoChoices_1.prototype);
    }
  };
  RevocationInfoChoices = RevocationInfoChoices_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Set, itemType: RevocationInfoChoice })
  ], RevocationInfoChoices);

  // node_modules/@peculiar/asn1-cms/build/es2015/originator_info.js
  var OriginatorInfo = class {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: CertificateSet, context: 0, implicit: true, optional: true })
  ], OriginatorInfo.prototype, "certs", void 0);
  __decorate([
    AsnProp({ type: RevocationInfoChoices, context: 1, implicit: true, optional: true })
  ], OriginatorInfo.prototype, "crls", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/enveloped_data.js
  var UnprotectedAttributes_1;
  var UnprotectedAttributes = UnprotectedAttributes_1 = class UnprotectedAttributes2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, UnprotectedAttributes_1.prototype);
    }
  };
  UnprotectedAttributes = UnprotectedAttributes_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Set, itemType: Attribute2 })
  ], UnprotectedAttributes);
  var EnvelopedData = class {
    constructor(params = {}) {
      this.version = CMSVersion.v0;
      this.recipientInfos = new RecipientInfos();
      this.encryptedContentInfo = new EncryptedContentInfo();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], EnvelopedData.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: OriginatorInfo, context: 0, implicit: true, optional: true })
  ], EnvelopedData.prototype, "originatorInfo", void 0);
  __decorate([
    AsnProp({ type: RecipientInfos })
  ], EnvelopedData.prototype, "recipientInfos", void 0);
  __decorate([
    AsnProp({ type: EncryptedContentInfo })
  ], EnvelopedData.prototype, "encryptedContentInfo", void 0);
  __decorate([
    AsnProp({ type: UnprotectedAttributes, context: 1, implicit: true, optional: true })
  ], EnvelopedData.prototype, "unprotectedAttrs", void 0);

  // node_modules/@peculiar/asn1-cms/build/es2015/object_identifiers.js
  var id_signedData = "1.2.840.113549.1.7.2";

  // node_modules/@peculiar/asn1-cms/build/es2015/signed_data.js
  var DigestAlgorithmIdentifiers_1;
  var DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = class DigestAlgorithmIdentifiers2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, DigestAlgorithmIdentifiers_1.prototype);
    }
  };
  DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Set, itemType: DigestAlgorithmIdentifier })
  ], DigestAlgorithmIdentifiers);
  var SignedData = class {
    constructor(params = {}) {
      this.version = CMSVersion.v0;
      this.digestAlgorithms = new DigestAlgorithmIdentifiers();
      this.encapContentInfo = new EncapsulatedContentInfo();
      this.signerInfos = new SignerInfos();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], SignedData.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: DigestAlgorithmIdentifiers })
  ], SignedData.prototype, "digestAlgorithms", void 0);
  __decorate([
    AsnProp({ type: EncapsulatedContentInfo })
  ], SignedData.prototype, "encapContentInfo", void 0);
  __decorate([
    AsnProp({ type: CertificateSet, context: 0, implicit: true, optional: true })
  ], SignedData.prototype, "certificates", void 0);
  __decorate([
    AsnProp({ type: RevocationInfoChoices, context: 1, implicit: true, optional: true })
  ], SignedData.prototype, "crls", void 0);
  __decorate([
    AsnProp({ type: SignerInfos })
  ], SignedData.prototype, "signerInfos", void 0);

  // node_modules/@peculiar/asn1-ecc/build/es2015/object_identifiers.js
  var id_ecPublicKey = "1.2.840.10045.2.1";
  var id_ecdsaWithSHA1 = "1.2.840.10045.4.1";
  var id_ecdsaWithSHA224 = "1.2.840.10045.4.3.1";
  var id_ecdsaWithSHA256 = "1.2.840.10045.4.3.2";
  var id_ecdsaWithSHA384 = "1.2.840.10045.4.3.3";
  var id_ecdsaWithSHA512 = "1.2.840.10045.4.3.4";
  var id_secp256r1 = "1.2.840.10045.3.1.7";
  var id_secp384r1 = "1.3.132.0.34";
  var id_secp521r1 = "1.3.132.0.35";

  // node_modules/@peculiar/asn1-ecc/build/es2015/algorithms.js
  function create3(algorithm) {
    return new AlgorithmIdentifier({ algorithm });
  }
  var ecdsaWithSHA1 = create3(id_ecdsaWithSHA1);
  var ecdsaWithSHA224 = create3(id_ecdsaWithSHA224);
  var ecdsaWithSHA256 = create3(id_ecdsaWithSHA256);
  var ecdsaWithSHA384 = create3(id_ecdsaWithSHA384);
  var ecdsaWithSHA512 = create3(id_ecdsaWithSHA512);

  // node_modules/@peculiar/asn1-ecc/build/es2015/rfc3279.js
  var FieldID = class FieldID2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], FieldID.prototype, "fieldType", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any })
  ], FieldID.prototype, "parameters", void 0);
  FieldID = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], FieldID);
  var ECPoint = class extends OctetString2 {
  };
  var Curve = class Curve2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.OctetString })
  ], Curve.prototype, "a", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.OctetString })
  ], Curve.prototype, "b", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString, optional: true })
  ], Curve.prototype, "seed", void 0);
  Curve = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], Curve);
  var ECPVer;
  (function(ECPVer2) {
    ECPVer2[ECPVer2["ecpVer1"] = 1] = "ecpVer1";
  })(ECPVer || (ECPVer = {}));
  var SpecifiedECDomain = class SpecifiedECDomain2 {
    constructor(params = {}) {
      this.version = ECPVer.ecpVer1;
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], SpecifiedECDomain.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: FieldID })
  ], SpecifiedECDomain.prototype, "fieldID", void 0);
  __decorate([
    AsnProp({ type: Curve })
  ], SpecifiedECDomain.prototype, "curve", void 0);
  __decorate([
    AsnProp({ type: ECPoint })
  ], SpecifiedECDomain.prototype, "base", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], SpecifiedECDomain.prototype, "order", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, optional: true })
  ], SpecifiedECDomain.prototype, "cofactor", void 0);
  SpecifiedECDomain = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], SpecifiedECDomain);

  // node_modules/@peculiar/asn1-ecc/build/es2015/ec_parameters.js
  var ECParameters = class ECParameters2 {
    constructor(params = {}) {
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], ECParameters.prototype, "namedCurve", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Null })
  ], ECParameters.prototype, "implicitCurve", void 0);
  __decorate([
    AsnProp({ type: SpecifiedECDomain })
  ], ECParameters.prototype, "specifiedCurve", void 0);
  ECParameters = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], ECParameters);

  // node_modules/@peculiar/asn1-ecc/build/es2015/ec_private_key.js
  var ECPrivateKey = class {
    constructor(params = {}) {
      this.version = 1;
      this.privateKey = new OctetString2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], ECPrivateKey.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], ECPrivateKey.prototype, "privateKey", void 0);
  __decorate([
    AsnProp({ type: ECParameters, context: 0, optional: true })
  ], ECPrivateKey.prototype, "parameters", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString, context: 1, optional: true })
  ], ECPrivateKey.prototype, "publicKey", void 0);

  // node_modules/@peculiar/asn1-ecc/build/es2015/ec_signature_value.js
  var ECDSASigValue = class {
    constructor(params = {}) {
      this.r = new ArrayBuffer(0);
      this.s = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], ECDSASigValue.prototype, "r", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], ECDSASigValue.prototype, "s", void 0);

  // node_modules/@peculiar/asn1-rsa/build/es2015/object_identifiers.js
  var id_pkcs_1 = "1.2.840.113549.1.1";
  var id_rsaEncryption = `${id_pkcs_1}.1`;
  var id_RSAES_OAEP = `${id_pkcs_1}.7`;
  var id_pSpecified = `${id_pkcs_1}.9`;
  var id_RSASSA_PSS = `${id_pkcs_1}.10`;
  var id_md2WithRSAEncryption = `${id_pkcs_1}.2`;
  var id_md5WithRSAEncryption = `${id_pkcs_1}.4`;
  var id_sha1WithRSAEncryption = `${id_pkcs_1}.5`;
  var id_sha224WithRSAEncryption = `${id_pkcs_1}.14`;
  var id_sha256WithRSAEncryption = `${id_pkcs_1}.11`;
  var id_sha384WithRSAEncryption = `${id_pkcs_1}.12`;
  var id_sha512WithRSAEncryption = `${id_pkcs_1}.13`;
  var id_sha512_224WithRSAEncryption = `${id_pkcs_1}.15`;
  var id_sha512_256WithRSAEncryption = `${id_pkcs_1}.16`;
  var id_sha1 = "1.3.14.3.2.26";
  var id_sha224 = "2.16.840.1.101.3.4.2.4";
  var id_sha256 = "2.16.840.1.101.3.4.2.1";
  var id_sha384 = "2.16.840.1.101.3.4.2.2";
  var id_sha512 = "2.16.840.1.101.3.4.2.3";
  var id_sha512_224 = "2.16.840.1.101.3.4.2.5";
  var id_sha512_256 = "2.16.840.1.101.3.4.2.6";
  var id_md2 = "1.2.840.113549.2.2";
  var id_md5 = "1.2.840.113549.2.5";
  var id_mgf1 = `${id_pkcs_1}.8`;

  // node_modules/@peculiar/asn1-rsa/build/es2015/algorithms.js
  function create4(algorithm) {
    return new AlgorithmIdentifier({ algorithm, parameters: null });
  }
  var md2 = create4(id_md2);
  var md4 = create4(id_md5);
  var sha13 = create4(id_sha1);
  var sha224 = create4(id_sha224);
  var sha2563 = create4(id_sha256);
  var sha384 = create4(id_sha384);
  var sha5123 = create4(id_sha512);
  var sha512_224 = create4(id_sha512_224);
  var sha512_256 = create4(id_sha512_256);
  var mgf1SHA1 = new AlgorithmIdentifier({
    algorithm: id_mgf1,
    parameters: AsnConvert.serialize(sha13)
  });
  var pSpecifiedEmpty = new AlgorithmIdentifier({
    algorithm: id_pSpecified,
    parameters: AsnConvert.serialize(AsnOctetStringConverter.toASN(new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]).buffer))
  });
  var rsaEncryption = create4(id_rsaEncryption);
  var md2WithRSAEncryption = create4(id_md2WithRSAEncryption);
  var md5WithRSAEncryption = create4(id_md5WithRSAEncryption);
  var sha1WithRSAEncryption = create4(id_sha1WithRSAEncryption);
  var sha224WithRSAEncryption = create4(id_sha512_224WithRSAEncryption);
  var sha256WithRSAEncryption = create4(id_sha512_256WithRSAEncryption);
  var sha384WithRSAEncryption = create4(id_sha384WithRSAEncryption);
  var sha512WithRSAEncryption = create4(id_sha512WithRSAEncryption);
  var sha512_224WithRSAEncryption = create4(id_sha512_224WithRSAEncryption);
  var sha512_256WithRSAEncryption = create4(id_sha512_256WithRSAEncryption);

  // node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsaes_oaep.js
  var RsaEsOaepParams = class {
    constructor(params = {}) {
      this.hashAlgorithm = new AlgorithmIdentifier(sha13);
      this.maskGenAlgorithm = new AlgorithmIdentifier({
        algorithm: id_mgf1,
        parameters: AsnConvert.serialize(sha13)
      });
      this.pSourceAlgorithm = new AlgorithmIdentifier(pSpecifiedEmpty);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha13 })
  ], RsaEsOaepParams.prototype, "hashAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA1 })
  ], RsaEsOaepParams.prototype, "maskGenAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier, context: 2, defaultValue: pSpecifiedEmpty })
  ], RsaEsOaepParams.prototype, "pSourceAlgorithm", void 0);
  var RSAES_OAEP = new AlgorithmIdentifier({
    algorithm: id_RSAES_OAEP,
    parameters: AsnConvert.serialize(new RsaEsOaepParams())
  });

  // node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pss.js
  var RsaSaPssParams = class {
    constructor(params = {}) {
      this.hashAlgorithm = new AlgorithmIdentifier(sha13);
      this.maskGenAlgorithm = new AlgorithmIdentifier({
        algorithm: id_mgf1,
        parameters: AsnConvert.serialize(sha13)
      });
      this.saltLength = 20;
      this.trailerField = 1;
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AlgorithmIdentifier, context: 0, defaultValue: sha13 })
  ], RsaSaPssParams.prototype, "hashAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier, context: 1, defaultValue: mgf1SHA1 })
  ], RsaSaPssParams.prototype, "maskGenAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, context: 2, defaultValue: 20 })
  ], RsaSaPssParams.prototype, "saltLength", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, context: 3, defaultValue: 1 })
  ], RsaSaPssParams.prototype, "trailerField", void 0);
  var RSASSA_PSS = new AlgorithmIdentifier({
    algorithm: id_RSASSA_PSS,
    parameters: AsnConvert.serialize(new RsaSaPssParams())
  });

  // node_modules/@peculiar/asn1-rsa/build/es2015/parameters/rsassa_pkcs1_v1_5.js
  var DigestInfo = class {
    constructor(params = {}) {
      this.digestAlgorithm = new AlgorithmIdentifier();
      this.digest = new OctetString2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], DigestInfo.prototype, "digestAlgorithm", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], DigestInfo.prototype, "digest", void 0);

  // node_modules/@peculiar/asn1-rsa/build/es2015/other_prime_info.js
  var OtherPrimeInfos_1;
  var OtherPrimeInfo = class {
    constructor(params = {}) {
      this.prime = new ArrayBuffer(0);
      this.exponent = new ArrayBuffer(0);
      this.coefficient = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], OtherPrimeInfo.prototype, "prime", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], OtherPrimeInfo.prototype, "exponent", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], OtherPrimeInfo.prototype, "coefficient", void 0);
  var OtherPrimeInfos = OtherPrimeInfos_1 = class OtherPrimeInfos2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, OtherPrimeInfos_1.prototype);
    }
  };
  OtherPrimeInfos = OtherPrimeInfos_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: OtherPrimeInfo })
  ], OtherPrimeInfos);

  // node_modules/@peculiar/asn1-rsa/build/es2015/rsa_private_key.js
  var RSAPrivateKey2 = class {
    constructor(params = {}) {
      this.version = 0;
      this.modulus = new ArrayBuffer(0);
      this.publicExponent = new ArrayBuffer(0);
      this.privateExponent = new ArrayBuffer(0);
      this.prime1 = new ArrayBuffer(0);
      this.prime2 = new ArrayBuffer(0);
      this.exponent1 = new ArrayBuffer(0);
      this.exponent2 = new ArrayBuffer(0);
      this.coefficient = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], RSAPrivateKey2.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPrivateKey2.prototype, "modulus", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPrivateKey2.prototype, "publicExponent", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPrivateKey2.prototype, "privateExponent", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPrivateKey2.prototype, "prime1", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPrivateKey2.prototype, "prime2", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPrivateKey2.prototype, "exponent1", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPrivateKey2.prototype, "exponent2", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPrivateKey2.prototype, "coefficient", void 0);
  __decorate([
    AsnProp({ type: OtherPrimeInfos, optional: true })
  ], RSAPrivateKey2.prototype, "otherPrimeInfos", void 0);

  // node_modules/@peculiar/asn1-rsa/build/es2015/rsa_public_key.js
  var RSAPublicKey2 = class {
    constructor(params = {}) {
      this.modulus = new ArrayBuffer(0);
      this.publicExponent = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPublicKey2.prototype, "modulus", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter })
  ], RSAPublicKey2.prototype, "publicExponent", void 0);

  // node_modules/tsyringe/dist/esm5/types/lifecycle.js
  var Lifecycle;
  (function(Lifecycle2) {
    Lifecycle2[Lifecycle2["Transient"] = 0] = "Transient";
    Lifecycle2[Lifecycle2["Singleton"] = 1] = "Singleton";
    Lifecycle2[Lifecycle2["ResolutionScoped"] = 2] = "ResolutionScoped";
    Lifecycle2[Lifecycle2["ContainerScoped"] = 3] = "ContainerScoped";
  })(Lifecycle || (Lifecycle = {}));
  var lifecycle_default = Lifecycle;

  // node_modules/tsyringe/node_modules/tslib/tslib.es6.js
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (b2.hasOwnProperty(p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  function __extends(d2, b) {
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve8) {
        resolve8(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve8, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve8(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n2) {
      return function(v) {
        return step([n2, v]);
      };
    }
    function step(op) {
      if (f2) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
        if (y = 0, t2) op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f2 = t2 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2) return m2.call(o2);
    if (o2 && typeof o2.length === "number") return {
      next: function() {
        if (o2 && i2 >= o2.length) o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2) return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
      ar = ar.concat(__read(arguments[i2]));
    return ar;
  }

  // node_modules/tsyringe/dist/esm5/reflection-helpers.js
  var INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
  function getParamInfo(target) {
    var params = Reflect.getMetadata("design:paramtypes", target) || [];
    var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
    Object.keys(injectionTokens).forEach(function(key) {
      params[+key] = injectionTokens[key];
    });
    return params;
  }

  // node_modules/tsyringe/dist/esm5/providers/class-provider.js
  function isClassProvider(provider) {
    return !!provider.useClass;
  }

  // node_modules/tsyringe/dist/esm5/providers/factory-provider.js
  function isFactoryProvider(provider) {
    return !!provider.useFactory;
  }

  // node_modules/tsyringe/dist/esm5/lazy-helpers.js
  var DelayedConstructor = (function() {
    function DelayedConstructor2(wrap) {
      this.wrap = wrap;
      this.reflectMethods = [
        "get",
        "getPrototypeOf",
        "setPrototypeOf",
        "getOwnPropertyDescriptor",
        "defineProperty",
        "has",
        "set",
        "deleteProperty",
        "apply",
        "construct",
        "ownKeys"
      ];
    }
    DelayedConstructor2.prototype.createProxy = function(createObject) {
      var _this = this;
      var target = {};
      var init = false;
      var value2;
      var delayedObject = function() {
        if (!init) {
          value2 = createObject(_this.wrap());
          init = true;
        }
        return value2;
      };
      return new Proxy(target, this.createHandler(delayedObject));
    };
    DelayedConstructor2.prototype.createHandler = function(delayedObject) {
      var handler = {};
      var install = function(name9) {
        handler[name9] = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          args[0] = delayedObject();
          var method = Reflect[name9];
          return method.apply(void 0, __spread(args));
        };
      };
      this.reflectMethods.forEach(install);
      return handler;
    };
    return DelayedConstructor2;
  })();

  // node_modules/tsyringe/dist/esm5/providers/injection-token.js
  function isNormalToken(token) {
    return typeof token === "string" || typeof token === "symbol";
  }
  function isTokenDescriptor(descriptor) {
    return typeof descriptor === "object" && "token" in descriptor && "multiple" in descriptor;
  }
  function isTransformDescriptor(descriptor) {
    return typeof descriptor === "object" && "token" in descriptor && "transform" in descriptor;
  }
  function isConstructorToken(token) {
    return typeof token === "function" || token instanceof DelayedConstructor;
  }

  // node_modules/tsyringe/dist/esm5/providers/token-provider.js
  function isTokenProvider(provider) {
    return !!provider.useToken;
  }

  // node_modules/tsyringe/dist/esm5/providers/value-provider.js
  function isValueProvider(provider) {
    return provider.useValue != void 0;
  }

  // node_modules/tsyringe/dist/esm5/providers/provider.js
  function isProvider(provider) {
    return isClassProvider(provider) || isValueProvider(provider) || isTokenProvider(provider) || isFactoryProvider(provider);
  }

  // node_modules/tsyringe/dist/esm5/registry-base.js
  var RegistryBase = (function() {
    function RegistryBase2() {
      this._registryMap = /* @__PURE__ */ new Map();
    }
    RegistryBase2.prototype.entries = function() {
      return this._registryMap.entries();
    };
    RegistryBase2.prototype.getAll = function(key) {
      this.ensure(key);
      return this._registryMap.get(key);
    };
    RegistryBase2.prototype.get = function(key) {
      this.ensure(key);
      var value2 = this._registryMap.get(key);
      return value2[value2.length - 1] || null;
    };
    RegistryBase2.prototype.set = function(key, value2) {
      this.ensure(key);
      this._registryMap.get(key).push(value2);
    };
    RegistryBase2.prototype.setAll = function(key, value2) {
      this._registryMap.set(key, value2);
    };
    RegistryBase2.prototype.has = function(key) {
      this.ensure(key);
      return this._registryMap.get(key).length > 0;
    };
    RegistryBase2.prototype.clear = function() {
      this._registryMap.clear();
    };
    RegistryBase2.prototype.ensure = function(key) {
      if (!this._registryMap.has(key)) {
        this._registryMap.set(key, []);
      }
    };
    return RegistryBase2;
  })();
  var registry_base_default = RegistryBase;

  // node_modules/tsyringe/dist/esm5/registry.js
  var Registry2 = (function(_super) {
    __extends(Registry3, _super);
    function Registry3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return Registry3;
  })(registry_base_default);
  var registry_default = Registry2;

  // node_modules/tsyringe/dist/esm5/resolution-context.js
  var ResolutionContext = /* @__PURE__ */ (function() {
    function ResolutionContext2() {
      this.scopedResolutions = /* @__PURE__ */ new Map();
    }
    return ResolutionContext2;
  })();
  var resolution_context_default = ResolutionContext;

  // node_modules/tsyringe/dist/esm5/error-helpers.js
  function formatDependency(params, idx) {
    if (params === null) {
      return "at position #" + idx;
    }
    var argName = params.split(",")[idx].trim();
    return '"' + argName + '" at position #' + idx;
  }
  function composeErrorMessage(msg, e2, indent) {
    if (indent === void 0) {
      indent = "    ";
    }
    return __spread([msg], e2.message.split("\n").map(function(l2) {
      return indent + l2;
    })).join("\n");
  }
  function formatErrorCtor(ctor, paramIdx, error) {
    var _a4 = __read(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2), _b2 = _a4[1], params = _b2 === void 0 ? null : _b2;
    var dep = formatDependency(params, paramIdx);
    return composeErrorMessage("Cannot inject the dependency " + dep + ' of "' + ctor.name + '" constructor. Reason:', error);
  }

  // node_modules/tsyringe/dist/esm5/types/disposable.js
  function isDisposable(value2) {
    if (typeof value2.dispose !== "function")
      return false;
    var disposeFun = value2.dispose;
    if (disposeFun.length > 0) {
      return false;
    }
    return true;
  }

  // node_modules/tsyringe/dist/esm5/interceptors.js
  var PreResolutionInterceptors = (function(_super) {
    __extends(PreResolutionInterceptors2, _super);
    function PreResolutionInterceptors2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return PreResolutionInterceptors2;
  })(registry_base_default);
  var PostResolutionInterceptors = (function(_super) {
    __extends(PostResolutionInterceptors2, _super);
    function PostResolutionInterceptors2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return PostResolutionInterceptors2;
  })(registry_base_default);
  var Interceptors = /* @__PURE__ */ (function() {
    function Interceptors2() {
      this.preResolution = new PreResolutionInterceptors();
      this.postResolution = new PostResolutionInterceptors();
    }
    return Interceptors2;
  })();
  var interceptors_default = Interceptors;

  // node_modules/tsyringe/dist/esm5/dependency-container.js
  var typeInfo = /* @__PURE__ */ new Map();
  var InternalDependencyContainer = (function() {
    function InternalDependencyContainer2(parent) {
      this.parent = parent;
      this._registry = new registry_default();
      this.interceptors = new interceptors_default();
      this.disposed = false;
      this.disposables = /* @__PURE__ */ new Set();
    }
    InternalDependencyContainer2.prototype.register = function(token, providerOrConstructor, options2) {
      if (options2 === void 0) {
        options2 = { lifecycle: lifecycle_default.Transient };
      }
      this.ensureNotDisposed();
      var provider;
      if (!isProvider(providerOrConstructor)) {
        provider = { useClass: providerOrConstructor };
      } else {
        provider = providerOrConstructor;
      }
      if (isTokenProvider(provider)) {
        var path = [token];
        var tokenProvider = provider;
        while (tokenProvider != null) {
          var currentToken = tokenProvider.useToken;
          if (path.includes(currentToken)) {
            throw new Error("Token registration cycle detected! " + __spread(path, [currentToken]).join(" -> "));
          }
          path.push(currentToken);
          var registration = this._registry.get(currentToken);
          if (registration && isTokenProvider(registration.provider)) {
            tokenProvider = registration.provider;
          } else {
            tokenProvider = null;
          }
        }
      }
      if (options2.lifecycle === lifecycle_default.Singleton || options2.lifecycle == lifecycle_default.ContainerScoped || options2.lifecycle == lifecycle_default.ResolutionScoped) {
        if (isValueProvider(provider) || isFactoryProvider(provider)) {
          throw new Error('Cannot use lifecycle "' + lifecycle_default[options2.lifecycle] + '" with ValueProviders or FactoryProviders');
        }
      }
      this._registry.set(token, { provider, options: options2 });
      return this;
    };
    InternalDependencyContainer2.prototype.registerType = function(from3, to) {
      this.ensureNotDisposed();
      if (isNormalToken(to)) {
        return this.register(from3, {
          useToken: to
        });
      }
      return this.register(from3, {
        useClass: to
      });
    };
    InternalDependencyContainer2.prototype.registerInstance = function(token, instance2) {
      this.ensureNotDisposed();
      return this.register(token, {
        useValue: instance2
      });
    };
    InternalDependencyContainer2.prototype.registerSingleton = function(from3, to) {
      this.ensureNotDisposed();
      if (isNormalToken(from3)) {
        if (isNormalToken(to)) {
          return this.register(from3, {
            useToken: to
          }, { lifecycle: lifecycle_default.Singleton });
        } else if (to) {
          return this.register(from3, {
            useClass: to
          }, { lifecycle: lifecycle_default.Singleton });
        }
        throw new Error('Cannot register a type name as a singleton without a "to" token');
      }
      var useClass = from3;
      if (to && !isNormalToken(to)) {
        useClass = to;
      }
      return this.register(from3, {
        useClass
      }, { lifecycle: lifecycle_default.Singleton });
    };
    InternalDependencyContainer2.prototype.resolve = function(token, context, isOptional) {
      if (context === void 0) {
        context = new resolution_context_default();
      }
      if (isOptional === void 0) {
        isOptional = false;
      }
      this.ensureNotDisposed();
      var registration = this.getRegistration(token);
      if (!registration && isNormalToken(token)) {
        if (isOptional) {
          return void 0;
        }
        throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
      }
      this.executePreResolutionInterceptor(token, "Single");
      if (registration) {
        var result = this.resolveRegistration(registration, context);
        this.executePostResolutionInterceptor(token, result, "Single");
        return result;
      }
      if (isConstructorToken(token)) {
        var result = this.construct(token, context);
        this.executePostResolutionInterceptor(token, result, "Single");
        return result;
      }
      throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
    };
    InternalDependencyContainer2.prototype.executePreResolutionInterceptor = function(token, resolutionType) {
      var e_1, _a4;
      if (this.interceptors.preResolution.has(token)) {
        var remainingInterceptors = [];
        try {
          for (var _b2 = __values(this.interceptors.preResolution.getAll(token)), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var interceptor = _c.value;
            if (interceptor.options.frequency != "Once") {
              remainingInterceptors.push(interceptor);
            }
            interceptor.callback(token, resolutionType);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a4 = _b2.return)) _a4.call(_b2);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        this.interceptors.preResolution.setAll(token, remainingInterceptors);
      }
    };
    InternalDependencyContainer2.prototype.executePostResolutionInterceptor = function(token, result, resolutionType) {
      var e_2, _a4;
      if (this.interceptors.postResolution.has(token)) {
        var remainingInterceptors = [];
        try {
          for (var _b2 = __values(this.interceptors.postResolution.getAll(token)), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var interceptor = _c.value;
            if (interceptor.options.frequency != "Once") {
              remainingInterceptors.push(interceptor);
            }
            interceptor.callback(token, result, resolutionType);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a4 = _b2.return)) _a4.call(_b2);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        this.interceptors.postResolution.setAll(token, remainingInterceptors);
      }
    };
    InternalDependencyContainer2.prototype.resolveRegistration = function(registration, context) {
      this.ensureNotDisposed();
      if (registration.options.lifecycle === lifecycle_default.ResolutionScoped && context.scopedResolutions.has(registration)) {
        return context.scopedResolutions.get(registration);
      }
      var isSingleton = registration.options.lifecycle === lifecycle_default.Singleton;
      var isContainerScoped = registration.options.lifecycle === lifecycle_default.ContainerScoped;
      var returnInstance = isSingleton || isContainerScoped;
      var resolved;
      if (isValueProvider(registration.provider)) {
        resolved = registration.provider.useValue;
      } else if (isTokenProvider(registration.provider)) {
        resolved = returnInstance ? registration.instance || (registration.instance = this.resolve(registration.provider.useToken, context)) : this.resolve(registration.provider.useToken, context);
      } else if (isClassProvider(registration.provider)) {
        resolved = returnInstance ? registration.instance || (registration.instance = this.construct(registration.provider.useClass, context)) : this.construct(registration.provider.useClass, context);
      } else if (isFactoryProvider(registration.provider)) {
        resolved = registration.provider.useFactory(this);
      } else {
        resolved = this.construct(registration.provider, context);
      }
      if (registration.options.lifecycle === lifecycle_default.ResolutionScoped) {
        context.scopedResolutions.set(registration, resolved);
      }
      return resolved;
    };
    InternalDependencyContainer2.prototype.resolveAll = function(token, context, isOptional) {
      var _this = this;
      if (context === void 0) {
        context = new resolution_context_default();
      }
      if (isOptional === void 0) {
        isOptional = false;
      }
      this.ensureNotDisposed();
      var registrations = this.getAllRegistrations(token);
      if (!registrations && isNormalToken(token)) {
        if (isOptional) {
          return [];
        }
        throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
      }
      this.executePreResolutionInterceptor(token, "All");
      if (registrations) {
        var result_1 = registrations.map(function(item) {
          return _this.resolveRegistration(item, context);
        });
        this.executePostResolutionInterceptor(token, result_1, "All");
        return result_1;
      }
      var result = [this.construct(token, context)];
      this.executePostResolutionInterceptor(token, result, "All");
      return result;
    };
    InternalDependencyContainer2.prototype.isRegistered = function(token, recursive2) {
      if (recursive2 === void 0) {
        recursive2 = false;
      }
      this.ensureNotDisposed();
      return this._registry.has(token) || recursive2 && (this.parent || false) && this.parent.isRegistered(token, true);
    };
    InternalDependencyContainer2.prototype.reset = function() {
      this.ensureNotDisposed();
      this._registry.clear();
      this.interceptors.preResolution.clear();
      this.interceptors.postResolution.clear();
    };
    InternalDependencyContainer2.prototype.clearInstances = function() {
      var e_3, _a4;
      this.ensureNotDisposed();
      try {
        for (var _b2 = __values(this._registry.entries()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
          this._registry.setAll(token, registrations.filter(function(registration) {
            return !isValueProvider(registration.provider);
          }).map(function(registration) {
            registration.instance = void 0;
            return registration;
          }));
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a4 = _b2.return)) _a4.call(_b2);
        } finally {
          if (e_3) throw e_3.error;
        }
      }
    };
    InternalDependencyContainer2.prototype.createChildContainer = function() {
      var e_4, _a4;
      this.ensureNotDisposed();
      var childContainer = new InternalDependencyContainer2(this);
      try {
        for (var _b2 = __values(this._registry.entries()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
          if (registrations.some(function(_a5) {
            var options2 = _a5.options;
            return options2.lifecycle === lifecycle_default.ContainerScoped;
          })) {
            childContainer._registry.setAll(token, registrations.map(function(registration) {
              if (registration.options.lifecycle === lifecycle_default.ContainerScoped) {
                return {
                  provider: registration.provider,
                  options: registration.options
                };
              }
              return registration;
            }));
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a4 = _b2.return)) _a4.call(_b2);
        } finally {
          if (e_4) throw e_4.error;
        }
      }
      return childContainer;
    };
    InternalDependencyContainer2.prototype.beforeResolution = function(token, callback, options2) {
      if (options2 === void 0) {
        options2 = { frequency: "Always" };
      }
      this.interceptors.preResolution.set(token, {
        callback,
        options: options2
      });
    };
    InternalDependencyContainer2.prototype.afterResolution = function(token, callback, options2) {
      if (options2 === void 0) {
        options2 = { frequency: "Always" };
      }
      this.interceptors.postResolution.set(token, {
        callback,
        options: options2
      });
    };
    InternalDependencyContainer2.prototype.dispose = function() {
      return __awaiter(this, void 0, void 0, function() {
        var promises;
        return __generator(this, function(_a4) {
          switch (_a4.label) {
            case 0:
              this.disposed = true;
              promises = [];
              this.disposables.forEach(function(disposable) {
                var maybePromise = disposable.dispose();
                if (maybePromise) {
                  promises.push(maybePromise);
                }
              });
              return [4, Promise.all(promises)];
            case 1:
              _a4.sent();
              return [2];
          }
        });
      });
    };
    InternalDependencyContainer2.prototype.getRegistration = function(token) {
      if (this.isRegistered(token)) {
        return this._registry.get(token);
      }
      if (this.parent) {
        return this.parent.getRegistration(token);
      }
      return null;
    };
    InternalDependencyContainer2.prototype.getAllRegistrations = function(token) {
      if (this.isRegistered(token)) {
        return this._registry.getAll(token);
      }
      if (this.parent) {
        return this.parent.getAllRegistrations(token);
      }
      return null;
    };
    InternalDependencyContainer2.prototype.construct = function(ctor, context) {
      var _this = this;
      if (ctor instanceof DelayedConstructor) {
        return ctor.createProxy(function(target) {
          return _this.resolve(target, context);
        });
      }
      var instance2 = (function() {
        var paramInfo = typeInfo.get(ctor);
        if (!paramInfo || paramInfo.length === 0) {
          if (ctor.length === 0) {
            return new ctor();
          } else {
            throw new Error('TypeInfo not known for "' + ctor.name + '"');
          }
        }
        var params = paramInfo.map(_this.resolveParams(context, ctor));
        return new (ctor.bind.apply(ctor, __spread([void 0], params)))();
      })();
      if (isDisposable(instance2)) {
        this.disposables.add(instance2);
      }
      return instance2;
    };
    InternalDependencyContainer2.prototype.resolveParams = function(context, ctor) {
      var _this = this;
      return function(param, idx) {
        var _a4, _b2, _c;
        try {
          if (isTokenDescriptor(param)) {
            if (isTransformDescriptor(param)) {
              return param.multiple ? (_a4 = _this.resolve(param.transform)).transform.apply(_a4, __spread([_this.resolveAll(param.token, new resolution_context_default(), param.isOptional)], param.transformArgs)) : (_b2 = _this.resolve(param.transform)).transform.apply(_b2, __spread([_this.resolve(param.token, context, param.isOptional)], param.transformArgs));
            } else {
              return param.multiple ? _this.resolveAll(param.token, new resolution_context_default(), param.isOptional) : _this.resolve(param.token, context, param.isOptional);
            }
          } else if (isTransformDescriptor(param)) {
            return (_c = _this.resolve(param.transform, context)).transform.apply(_c, __spread([_this.resolve(param.token, context)], param.transformArgs));
          }
          return _this.resolve(param, context);
        } catch (e2) {
          throw new Error(formatErrorCtor(ctor, idx, e2));
        }
      };
    };
    InternalDependencyContainer2.prototype.ensureNotDisposed = function() {
      if (this.disposed) {
        throw new Error("This container has been disposed, you cannot interact with a disposed container");
      }
    };
    return InternalDependencyContainer2;
  })();
  var instance = new InternalDependencyContainer();

  // node_modules/tsyringe/dist/esm5/decorators/injectable.js
  function injectable(options2) {
    return function(target) {
      typeInfo.set(target, getParamInfo(target));
      if (options2 && options2.token) {
        if (!Array.isArray(options2.token)) {
          instance.register(options2.token, target);
        } else {
          options2.token.forEach(function(token) {
            instance.register(token, target);
          });
        }
      }
    };
  }
  var injectable_default = injectable;

  // node_modules/tsyringe/dist/esm5/index.js
  if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
    throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);
  }

  // node_modules/@peculiar/asn1-pfx/build/es2015/attribute.js
  var PKCS12AttrSet_1;
  var PKCS12Attribute = class {
    constructor(params = {}) {
      this.attrId = "";
      this.attrValues = [];
      Object.assign(params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], PKCS12Attribute.prototype, "attrId", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, repeated: "set" })
  ], PKCS12Attribute.prototype, "attrValues", void 0);
  var PKCS12AttrSet = PKCS12AttrSet_1 = class PKCS12AttrSet2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, PKCS12AttrSet_1.prototype);
    }
  };
  PKCS12AttrSet = PKCS12AttrSet_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: PKCS12Attribute })
  ], PKCS12AttrSet);

  // node_modules/@peculiar/asn1-pfx/build/es2015/authenticated_safe.js
  var AuthenticatedSafe_1;
  var AuthenticatedSafe = AuthenticatedSafe_1 = class AuthenticatedSafe2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, AuthenticatedSafe_1.prototype);
    }
  };
  AuthenticatedSafe = AuthenticatedSafe_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: ContentInfo })
  ], AuthenticatedSafe);

  // node_modules/@peculiar/asn1-pfx/build/es2015/object_identifiers.js
  var id_rsadsi = "1.2.840.113549";
  var id_pkcs = `${id_rsadsi}.1`;
  var id_pkcs_12 = `${id_pkcs}.12`;
  var id_pkcs_12PbeIds = `${id_pkcs_12}.1`;
  var id_pbeWithSHAAnd128BitRC4 = `${id_pkcs_12PbeIds}.1`;
  var id_pbeWithSHAAnd40BitRC4 = `${id_pkcs_12PbeIds}.2`;
  var id_pbeWithSHAAnd3_KeyTripleDES_CBC = `${id_pkcs_12PbeIds}.3`;
  var id_pbeWithSHAAnd2_KeyTripleDES_CBC = `${id_pkcs_12PbeIds}.4`;
  var id_pbeWithSHAAnd128BitRC2_CBC = `${id_pkcs_12PbeIds}.5`;
  var id_pbewithSHAAnd40BitRC2_CBC = `${id_pkcs_12PbeIds}.6`;
  var id_bagtypes = `${id_pkcs_12}.10.1`;

  // node_modules/@peculiar/asn1-pfx/build/es2015/bags/types.js
  var id_keyBag = `${id_bagtypes}.1`;
  var id_pkcs8ShroudedKeyBag = `${id_bagtypes}.2`;
  var id_certBag = `${id_bagtypes}.3`;
  var id_CRLBag = `${id_bagtypes}.4`;
  var id_SecretBag = `${id_bagtypes}.5`;
  var id_SafeContents = `${id_bagtypes}.6`;
  var id_pkcs_9 = "1.2.840.113549.1.9";

  // node_modules/@peculiar/asn1-pfx/build/es2015/bags/cert_bag.js
  var CertBag = class {
    constructor(params = {}) {
      this.certId = "";
      this.certValue = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], CertBag.prototype, "certId", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, context: 0 })
  ], CertBag.prototype, "certValue", void 0);
  var id_certTypes = `${id_pkcs_9}.22`;
  var id_x509Certificate = `${id_certTypes}.1`;
  var id_sdsiCertificate = `${id_certTypes}.2`;

  // node_modules/@peculiar/asn1-pfx/build/es2015/bags/crl_bag.js
  var CRLBag = class {
    constructor(params = {}) {
      this.crlId = "";
      this.crltValue = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], CRLBag.prototype, "crlId", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, context: 0 })
  ], CRLBag.prototype, "crltValue", void 0);
  var id_crlTypes = `${id_pkcs_9}.23`;
  var id_x509CRL = `${id_crlTypes}.1`;

  // node_modules/@peculiar/asn1-pkcs8/build/es2015/encrypted_private_key_info.js
  var EncryptedData = class extends OctetString2 {
  };
  var EncryptedPrivateKeyInfo = class {
    constructor(params = {}) {
      this.encryptionAlgorithm = new AlgorithmIdentifier();
      this.encryptedData = new EncryptedData();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], EncryptedPrivateKeyInfo.prototype, "encryptionAlgorithm", void 0);
  __decorate([
    AsnProp({ type: EncryptedData })
  ], EncryptedPrivateKeyInfo.prototype, "encryptedData", void 0);

  // node_modules/@peculiar/asn1-pkcs8/build/es2015/private_key_info.js
  var Attributes_1;
  var Version2;
  (function(Version3) {
    Version3[Version3["v1"] = 0] = "v1";
  })(Version2 || (Version2 = {}));
  var PrivateKey2 = class extends OctetString2 {
  };
  var Attributes = Attributes_1 = class Attributes2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, Attributes_1.prototype);
    }
  };
  Attributes = Attributes_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
  ], Attributes);
  var PrivateKeyInfo = class {
    constructor(params = {}) {
      this.version = Version2.v1;
      this.privateKeyAlgorithm = new AlgorithmIdentifier();
      this.privateKey = new PrivateKey2();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], PrivateKeyInfo.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);
  __decorate([
    AsnProp({ type: PrivateKey2 })
  ], PrivateKeyInfo.prototype, "privateKey", void 0);
  __decorate([
    AsnProp({ type: Attributes, implicit: true, context: 0, optional: true })
  ], PrivateKeyInfo.prototype, "attributes", void 0);

  // node_modules/@peculiar/asn1-pfx/build/es2015/bags/key_bag.js
  var KeyBag = class KeyBag2 extends PrivateKeyInfo {
  };
  KeyBag = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], KeyBag);

  // node_modules/@peculiar/asn1-pfx/build/es2015/bags/pkcs8_shrouded_key_bag.js
  var PKCS8ShroudedKeyBag = class PKCS8ShroudedKeyBag2 extends EncryptedPrivateKeyInfo {
  };
  PKCS8ShroudedKeyBag = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], PKCS8ShroudedKeyBag);

  // node_modules/@peculiar/asn1-pfx/build/es2015/bags/secret_bag.js
  var SecretBag = class {
    constructor(params = {}) {
      this.secretTypeId = "";
      this.secretValue = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], SecretBag.prototype, "secretTypeId", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, context: 0 })
  ], SecretBag.prototype, "secretValue", void 0);

  // node_modules/@peculiar/asn1-pfx/build/es2015/mac_data.js
  var MacData = class {
    constructor(params = {}) {
      this.mac = new DigestInfo();
      this.macSalt = new OctetString2();
      this.iterations = 1;
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: DigestInfo })
  ], MacData.prototype, "mac", void 0);
  __decorate([
    AsnProp({ type: OctetString2 })
  ], MacData.prototype, "macSalt", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer, defaultValue: 1 })
  ], MacData.prototype, "iterations", void 0);

  // node_modules/@peculiar/asn1-pfx/build/es2015/pfx.js
  var PFX = class {
    constructor(params = {}) {
      this.version = 3;
      this.authSafe = new ContentInfo();
      this.macData = new MacData();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], PFX.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: ContentInfo })
  ], PFX.prototype, "authSafe", void 0);
  __decorate([
    AsnProp({ type: MacData, optional: true })
  ], PFX.prototype, "macData", void 0);

  // node_modules/@peculiar/asn1-pfx/build/es2015/safe_bag.js
  var SafeContents_1;
  var SafeBag = class {
    constructor(params = {}) {
      this.bagId = "";
      this.bagValue = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], SafeBag.prototype, "bagId", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.Any, context: 0 })
  ], SafeBag.prototype, "bagValue", void 0);
  __decorate([
    AsnProp({ type: PKCS12Attribute, repeated: "set", optional: true })
  ], SafeBag.prototype, "bagAttributes", void 0);
  var SafeContents = SafeContents_1 = class SafeContents2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, SafeContents_1.prototype);
    }
  };
  SafeContents = SafeContents_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: SafeBag })
  ], SafeContents);

  // node_modules/@peculiar/asn1-pkcs9/build/es2015/index.js
  var ExtensionRequest_1;
  var ExtendedCertificateAttributes_1;
  var SMIMECapabilities_1;
  var id_pkcs9 = "1.2.840.113549.1.9";
  var id_pkcs9_mo = `${id_pkcs9}.0`;
  var id_pkcs9_oc = `${id_pkcs9}.24`;
  var id_pkcs9_at = `${id_pkcs9}.25`;
  var id_pkcs9_sx = `${id_pkcs9}.26`;
  var id_pkcs9_mr = `${id_pkcs9}.27`;
  var id_pkcs9_oc_pkcsEntity = `${id_pkcs9_oc}.1`;
  var id_pkcs9_oc_naturalPerson = `${id_pkcs9_oc}.2`;
  var id_pkcs9_at_emailAddress = `${id_pkcs9}.1`;
  var id_pkcs9_at_unstructuredName = `${id_pkcs9}.2`;
  var id_pkcs9_at_contentType = `${id_pkcs9}.3`;
  var id_pkcs9_at_messageDigest = `${id_pkcs9}.4`;
  var id_pkcs9_at_signingTime = `${id_pkcs9}.5`;
  var id_pkcs9_at_counterSignature = `${id_pkcs9}.6`;
  var id_pkcs9_at_challengePassword = `${id_pkcs9}.7`;
  var id_pkcs9_at_unstructuredAddress = `${id_pkcs9}.8`;
  var id_pkcs9_at_extendedCertificateAttributes = `${id_pkcs9}.9`;
  var id_pkcs9_at_signingDescription = `${id_pkcs9}.13`;
  var id_pkcs9_at_extensionRequest = `${id_pkcs9}.14`;
  var id_pkcs9_at_smimeCapabilities = `${id_pkcs9}.15`;
  var id_pkcs9_at_friendlyName = `${id_pkcs9}.20`;
  var id_pkcs9_at_localKeyId = `${id_pkcs9}.21`;
  var id_pkcs9_at_pkcs15Token = `${id_pkcs9_at}.1`;
  var id_pkcs9_at_encryptedPrivateKeyInfo = `${id_pkcs9_at}.2`;
  var id_pkcs9_at_randomNonce = `${id_pkcs9_at}.3`;
  var id_pkcs9_at_sequenceNumber = `${id_pkcs9_at}.4`;
  var id_pkcs9_at_pkcs7PDU = `${id_pkcs9_at}.5`;
  var id_ietf_at = `1.3.6.1.5.5.7.9`;
  var id_pkcs9_at_dateOfBirth = `${id_ietf_at}.1`;
  var id_pkcs9_at_placeOfBirth = `${id_ietf_at}.2`;
  var id_pkcs9_at_gender = `${id_ietf_at}.3`;
  var id_pkcs9_at_countryOfCitizenship = `${id_ietf_at}.4`;
  var id_pkcs9_at_countryOfResidence = `${id_ietf_at}.5`;
  var id_pkcs9_sx_pkcs9String = `${id_pkcs9_sx}.1`;
  var id_pkcs9_sx_signingTime = `${id_pkcs9_sx}.2`;
  var id_pkcs9_mr_caseIgnoreMatch = `${id_pkcs9_mr}.1`;
  var id_pkcs9_mr_signingTimeMatch = `${id_pkcs9_mr}.2`;
  var id_smime = `${id_pkcs9}.16`;
  var id_certTypes2 = `${id_pkcs9}.22`;
  var crlTypes = `${id_pkcs9}.23`;
  var id_at_pseudonym = `${id_at}.65`;
  var PKCS9String = class PKCS9String2 extends DirectoryString {
    constructor(params = {}) {
      super(params);
    }
    toString() {
      const o2 = {};
      o2.toString();
      return this.ia5String || super.toString();
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.IA5String })
  ], PKCS9String.prototype, "ia5String", void 0);
  PKCS9String = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], PKCS9String);
  var Pkcs7PDU = class Pkcs7PDU2 extends ContentInfo {
  };
  Pkcs7PDU = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], Pkcs7PDU);
  var UserPKCS12 = class UserPKCS122 extends PFX {
  };
  UserPKCS12 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], UserPKCS12);
  var EncryptedPrivateKeyInfo2 = class EncryptedPrivateKeyInfo3 extends EncryptedPrivateKeyInfo {
  };
  EncryptedPrivateKeyInfo2 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], EncryptedPrivateKeyInfo2);
  var EmailAddress = class EmailAddress2 {
    constructor(value2 = "") {
      this.value = value2;
    }
    toString() {
      return this.value;
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.IA5String })
  ], EmailAddress.prototype, "value", void 0);
  EmailAddress = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], EmailAddress);
  var UnstructuredName = class UnstructuredName2 extends PKCS9String {
  };
  UnstructuredName = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], UnstructuredName);
  var UnstructuredAddress = class UnstructuredAddress2 extends DirectoryString {
  };
  UnstructuredAddress = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], UnstructuredAddress);
  var DateOfBirth = class DateOfBirth2 {
    constructor(value2 = /* @__PURE__ */ new Date()) {
      this.value = value2;
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.GeneralizedTime })
  ], DateOfBirth.prototype, "value", void 0);
  DateOfBirth = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], DateOfBirth);
  var PlaceOfBirth = class PlaceOfBirth2 extends DirectoryString {
  };
  PlaceOfBirth = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], PlaceOfBirth);
  var Gender = class Gender2 {
    constructor(value2 = "M") {
      this.value = value2;
    }
    toString() {
      return this.value;
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.PrintableString })
  ], Gender.prototype, "value", void 0);
  Gender = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], Gender);
  var CountryOfCitizenship = class CountryOfCitizenship2 {
    constructor(value2 = "") {
      this.value = value2;
    }
    toString() {
      return this.value;
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.PrintableString })
  ], CountryOfCitizenship.prototype, "value", void 0);
  CountryOfCitizenship = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], CountryOfCitizenship);
  var CountryOfResidence = class CountryOfResidence2 extends CountryOfCitizenship {
  };
  CountryOfResidence = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], CountryOfResidence);
  var Pseudonym = class Pseudonym2 extends DirectoryString {
  };
  Pseudonym = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], Pseudonym);
  var ContentType = class ContentType2 {
    constructor(value2 = "") {
      this.value = value2;
    }
    toString() {
      return this.value;
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.ObjectIdentifier })
  ], ContentType.prototype, "value", void 0);
  ContentType = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], ContentType);
  var SigningTime3 = class SigningTime4 extends Time {
  };
  SigningTime3 = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], SigningTime3);
  var SequenceNumber = class SequenceNumber2 {
    constructor(value2 = 0) {
      this.value = value2;
    }
    toString() {
      return this.value.toString();
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], SequenceNumber.prototype, "value", void 0);
  SequenceNumber = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], SequenceNumber);
  var CounterSignature3 = class CounterSignature4 extends SignerInfo {
  };
  CounterSignature3 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], CounterSignature3);
  var ChallengePassword = class ChallengePassword2 extends DirectoryString {
  };
  ChallengePassword = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], ChallengePassword);
  var ExtensionRequest = ExtensionRequest_1 = class ExtensionRequest2 extends Extensions {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, ExtensionRequest_1.prototype);
    }
  };
  ExtensionRequest = ExtensionRequest_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], ExtensionRequest);
  var ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = class ExtendedCertificateAttributes2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, ExtendedCertificateAttributes_1.prototype);
    }
  };
  ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Set, itemType: Attribute2 })
  ], ExtendedCertificateAttributes);
  var FriendlyName = class FriendlyName2 {
    constructor(value2 = "") {
      this.value = value2;
    }
    toString() {
      return this.value;
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.BmpString })
  ], FriendlyName.prototype, "value", void 0);
  FriendlyName = __decorate([
    AsnType({ type: AsnTypeTypes.Choice })
  ], FriendlyName);
  var SMIMECapability = class SMIMECapability2 extends AlgorithmIdentifier {
  };
  SMIMECapability = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence })
  ], SMIMECapability);
  var SMIMECapabilities = SMIMECapabilities_1 = class SMIMECapabilities2 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, SMIMECapabilities_1.prototype);
    }
  };
  SMIMECapabilities = SMIMECapabilities_1 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: SMIMECapability })
  ], SMIMECapabilities);

  // node_modules/@peculiar/asn1-csr/build/es2015/attributes.js
  var Attributes_12;
  var Attributes3 = Attributes_12 = class Attributes4 extends AsnArray {
    constructor(items) {
      super(items);
      Object.setPrototypeOf(this, Attributes_12.prototype);
    }
  };
  Attributes3 = Attributes_12 = __decorate([
    AsnType({ type: AsnTypeTypes.Sequence, itemType: Attribute })
  ], Attributes3);

  // node_modules/@peculiar/asn1-csr/build/es2015/certification_request_info.js
  var CertificationRequestInfo = class {
    constructor(params = {}) {
      this.version = 0;
      this.subject = new Name();
      this.subjectPKInfo = new SubjectPublicKeyInfo();
      this.attributes = new Attributes3();
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: AsnPropTypes.Integer })
  ], CertificationRequestInfo.prototype, "version", void 0);
  __decorate([
    AsnProp({ type: Name })
  ], CertificationRequestInfo.prototype, "subject", void 0);
  __decorate([
    AsnProp({ type: SubjectPublicKeyInfo })
  ], CertificationRequestInfo.prototype, "subjectPKInfo", void 0);
  __decorate([
    AsnProp({ type: Attributes3, implicit: true, context: 0 })
  ], CertificationRequestInfo.prototype, "attributes", void 0);

  // node_modules/@peculiar/asn1-csr/build/es2015/certification_request.js
  var CertificationRequest = class {
    constructor(params = {}) {
      this.certificationRequestInfo = new CertificationRequestInfo();
      this.signatureAlgorithm = new AlgorithmIdentifier();
      this.signature = new ArrayBuffer(0);
      Object.assign(this, params);
    }
  };
  __decorate([
    AsnProp({ type: CertificationRequestInfo, raw: true })
  ], CertificationRequest.prototype, "certificationRequestInfo", void 0);
  __decorate([
    AsnProp({ type: AlgorithmIdentifier })
  ], CertificationRequest.prototype, "signatureAlgorithm", void 0);
  __decorate([
    AsnProp({ type: AsnPropTypes.BitString })
  ], CertificationRequest.prototype, "signature", void 0);

  // node_modules/@peculiar/x509/build/x509.es.js
  var diAlgorithm = "crypto.algorithm";
  var AlgorithmProvider = class {
    getAlgorithms() {
      return instance.resolveAll(diAlgorithm);
    }
    toAsnAlgorithm(alg) {
      ({ ...alg });
      for (const algorithm of this.getAlgorithms()) {
        const res = algorithm.toAsnAlgorithm(alg);
        if (res) {
          return res;
        }
      }
      if (/^[0-9.]+$/.test(alg.name)) {
        const res = new AlgorithmIdentifier({
          algorithm: alg.name
        });
        if ("parameters" in alg) {
          const unknown = alg;
          res.parameters = unknown.parameters;
        }
        return res;
      }
      throw new Error("Cannot convert WebCrypto algorithm to ASN.1 algorithm");
    }
    toWebAlgorithm(alg) {
      for (const algorithm of this.getAlgorithms()) {
        const res = algorithm.toWebAlgorithm(alg);
        if (res) {
          return res;
        }
      }
      const unknown = {
        name: alg.algorithm,
        parameters: alg.parameters
      };
      return unknown;
    }
  };
  var diAlgorithmProvider = "crypto.algorithmProvider";
  instance.registerSingleton(diAlgorithmProvider, AlgorithmProvider);
  var EcAlgorithm_1;
  var idVersionOne = "1.3.36.3.3.2.8.1.1";
  var idBrainpoolP160r1 = `${idVersionOne}.1`;
  var idBrainpoolP160t1 = `${idVersionOne}.2`;
  var idBrainpoolP192r1 = `${idVersionOne}.3`;
  var idBrainpoolP192t1 = `${idVersionOne}.4`;
  var idBrainpoolP224r1 = `${idVersionOne}.5`;
  var idBrainpoolP224t1 = `${idVersionOne}.6`;
  var idBrainpoolP256r1 = `${idVersionOne}.7`;
  var idBrainpoolP256t1 = `${idVersionOne}.8`;
  var idBrainpoolP320r1 = `${idVersionOne}.9`;
  var idBrainpoolP320t1 = `${idVersionOne}.10`;
  var idBrainpoolP384r1 = `${idVersionOne}.11`;
  var idBrainpoolP384t1 = `${idVersionOne}.12`;
  var idBrainpoolP512r1 = `${idVersionOne}.13`;
  var idBrainpoolP512t1 = `${idVersionOne}.14`;
  var brainpoolP160r1 = "brainpoolP160r1";
  var brainpoolP160t1 = "brainpoolP160t1";
  var brainpoolP192r1 = "brainpoolP192r1";
  var brainpoolP192t1 = "brainpoolP192t1";
  var brainpoolP224r1 = "brainpoolP224r1";
  var brainpoolP224t1 = "brainpoolP224t1";
  var brainpoolP256r1 = "brainpoolP256r1";
  var brainpoolP256t1 = "brainpoolP256t1";
  var brainpoolP320r1 = "brainpoolP320r1";
  var brainpoolP320t1 = "brainpoolP320t1";
  var brainpoolP384r1 = "brainpoolP384r1";
  var brainpoolP384t1 = "brainpoolP384t1";
  var brainpoolP512r1 = "brainpoolP512r1";
  var brainpoolP512t1 = "brainpoolP512t1";
  var ECDSA = "ECDSA";
  var EcAlgorithm = EcAlgorithm_1 = class EcAlgorithm2 {
    toAsnAlgorithm(alg) {
      switch (alg.name.toLowerCase()) {
        case ECDSA.toLowerCase():
          if ("hash" in alg) {
            const hash = typeof alg.hash === "string" ? alg.hash : alg.hash.name;
            switch (hash.toLowerCase()) {
              case "sha-1":
                return ecdsaWithSHA1;
              case "sha-256":
                return ecdsaWithSHA256;
              case "sha-384":
                return ecdsaWithSHA384;
              case "sha-512":
                return ecdsaWithSHA512;
            }
          } else if ("namedCurve" in alg) {
            let parameters = "";
            switch (alg.namedCurve) {
              case "P-256":
                parameters = id_secp256r1;
                break;
              case "K-256":
                parameters = EcAlgorithm_1.SECP256K1;
                break;
              case "P-384":
                parameters = id_secp384r1;
                break;
              case "P-521":
                parameters = id_secp521r1;
                break;
              case brainpoolP160r1:
                parameters = idBrainpoolP160r1;
                break;
              case brainpoolP160t1:
                parameters = idBrainpoolP160t1;
                break;
              case brainpoolP192r1:
                parameters = idBrainpoolP192r1;
                break;
              case brainpoolP192t1:
                parameters = idBrainpoolP192t1;
                break;
              case brainpoolP224r1:
                parameters = idBrainpoolP224r1;
                break;
              case brainpoolP224t1:
                parameters = idBrainpoolP224t1;
                break;
              case brainpoolP256r1:
                parameters = idBrainpoolP256r1;
                break;
              case brainpoolP256t1:
                parameters = idBrainpoolP256t1;
                break;
              case brainpoolP320r1:
                parameters = idBrainpoolP320r1;
                break;
              case brainpoolP320t1:
                parameters = idBrainpoolP320t1;
                break;
              case brainpoolP384r1:
                parameters = idBrainpoolP384r1;
                break;
              case brainpoolP384t1:
                parameters = idBrainpoolP384t1;
                break;
              case brainpoolP512r1:
                parameters = idBrainpoolP512r1;
                break;
              case brainpoolP512t1:
                parameters = idBrainpoolP512t1;
                break;
            }
            if (parameters) {
              return new AlgorithmIdentifier({
                algorithm: id_ecPublicKey,
                parameters: AsnConvert.serialize(new ECParameters({ namedCurve: parameters }))
              });
            }
          }
      }
      return null;
    }
    toWebAlgorithm(alg) {
      switch (alg.algorithm) {
        case id_ecdsaWithSHA1:
          return { name: ECDSA, hash: { name: "SHA-1" } };
        case id_ecdsaWithSHA256:
          return { name: ECDSA, hash: { name: "SHA-256" } };
        case id_ecdsaWithSHA384:
          return { name: ECDSA, hash: { name: "SHA-384" } };
        case id_ecdsaWithSHA512:
          return { name: ECDSA, hash: { name: "SHA-512" } };
        case id_ecPublicKey: {
          if (!alg.parameters) {
            throw new TypeError("Cannot get required parameters from EC algorithm");
          }
          const parameters = AsnConvert.parse(alg.parameters, ECParameters);
          switch (parameters.namedCurve) {
            case id_secp256r1:
              return { name: ECDSA, namedCurve: "P-256" };
            case EcAlgorithm_1.SECP256K1:
              return { name: ECDSA, namedCurve: "K-256" };
            case id_secp384r1:
              return { name: ECDSA, namedCurve: "P-384" };
            case id_secp521r1:
              return { name: ECDSA, namedCurve: "P-521" };
            case idBrainpoolP160r1:
              return { name: ECDSA, namedCurve: brainpoolP160r1 };
            case idBrainpoolP160t1:
              return { name: ECDSA, namedCurve: brainpoolP160t1 };
            case idBrainpoolP192r1:
              return { name: ECDSA, namedCurve: brainpoolP192r1 };
            case idBrainpoolP192t1:
              return { name: ECDSA, namedCurve: brainpoolP192t1 };
            case idBrainpoolP224r1:
              return { name: ECDSA, namedCurve: brainpoolP224r1 };
            case idBrainpoolP224t1:
              return { name: ECDSA, namedCurve: brainpoolP224t1 };
            case idBrainpoolP256r1:
              return { name: ECDSA, namedCurve: brainpoolP256r1 };
            case idBrainpoolP256t1:
              return { name: ECDSA, namedCurve: brainpoolP256t1 };
            case idBrainpoolP320r1:
              return { name: ECDSA, namedCurve: brainpoolP320r1 };
            case idBrainpoolP320t1:
              return { name: ECDSA, namedCurve: brainpoolP320t1 };
            case idBrainpoolP384r1:
              return { name: ECDSA, namedCurve: brainpoolP384r1 };
            case idBrainpoolP384t1:
              return { name: ECDSA, namedCurve: brainpoolP384t1 };
            case idBrainpoolP512r1:
              return { name: ECDSA, namedCurve: brainpoolP512r1 };
            case idBrainpoolP512t1:
              return { name: ECDSA, namedCurve: brainpoolP512t1 };
          }
        }
      }
      return null;
    }
  };
  EcAlgorithm.SECP256K1 = "1.3.132.0.10";
  EcAlgorithm = EcAlgorithm_1 = __decorate([
    injectable_default()
  ], EcAlgorithm);
  instance.registerSingleton(diAlgorithm, EcAlgorithm);
  var NAME2 = Symbol("name");
  var VALUE = Symbol("value");
  var TextObject = class {
    constructor(name9, items = {}, value2 = "") {
      this[NAME2] = name9;
      this[VALUE] = value2;
      for (const key in items) {
        this[key] = items[key];
      }
    }
  };
  TextObject.NAME = NAME2;
  TextObject.VALUE = VALUE;
  var DefaultAlgorithmSerializer = class {
    static toTextObject(alg) {
      const obj = new TextObject("Algorithm Identifier", {}, OidSerializer.toString(alg.algorithm));
      if (alg.parameters) {
        switch (alg.algorithm) {
          case id_ecPublicKey: {
            const ecAlg = new EcAlgorithm().toWebAlgorithm(alg);
            if (ecAlg && "namedCurve" in ecAlg) {
              obj["Named Curve"] = ecAlg.namedCurve;
            } else {
              obj["Parameters"] = alg.parameters;
            }
            break;
          }
          default:
            obj["Parameters"] = alg.parameters;
        }
      }
      return obj;
    }
  };
  var OidSerializer = class {
    static toString(oid) {
      const name9 = this.items[oid];
      if (name9) {
        return name9;
      }
      return oid;
    }
  };
  OidSerializer.items = {
    [id_sha1]: "sha1",
    [id_sha224]: "sha224",
    [id_sha256]: "sha256",
    [id_sha384]: "sha384",
    [id_sha512]: "sha512",
    [id_rsaEncryption]: "rsaEncryption",
    [id_sha1WithRSAEncryption]: "sha1WithRSAEncryption",
    [id_sha224WithRSAEncryption]: "sha224WithRSAEncryption",
    [id_sha256WithRSAEncryption]: "sha256WithRSAEncryption",
    [id_sha384WithRSAEncryption]: "sha384WithRSAEncryption",
    [id_sha512WithRSAEncryption]: "sha512WithRSAEncryption",
    [id_ecPublicKey]: "ecPublicKey",
    [id_ecdsaWithSHA1]: "ecdsaWithSHA1",
    [id_ecdsaWithSHA224]: "ecdsaWithSHA224",
    [id_ecdsaWithSHA256]: "ecdsaWithSHA256",
    [id_ecdsaWithSHA384]: "ecdsaWithSHA384",
    [id_ecdsaWithSHA512]: "ecdsaWithSHA512",
    [id_kp_serverAuth]: "TLS WWW server authentication",
    [id_kp_clientAuth]: "TLS WWW client authentication",
    [id_kp_codeSigning]: "Code Signing",
    [id_kp_emailProtection]: "E-mail Protection",
    [id_kp_timeStamping]: "Time Stamping",
    [id_kp_OCSPSigning]: "OCSP Signing",
    [id_signedData]: "Signed Data"
  };
  var TextConverter = class {
    static serialize(obj) {
      return this.serializeObj(obj).join("\n");
    }
    static pad(deep = 0) {
      return "".padStart(2 * deep, " ");
    }
    static serializeObj(obj, deep = 0) {
      const res = [];
      let pad = this.pad(deep++);
      let value2 = "";
      const objValue = obj[TextObject.VALUE];
      if (objValue) {
        value2 = ` ${objValue}`;
      }
      res.push(`${pad}${obj[TextObject.NAME]}:${value2}`);
      pad = this.pad(deep);
      for (const key in obj) {
        if (typeof key === "symbol") {
          continue;
        }
        const value3 = obj[key];
        const keyValue = key ? `${key}: ` : "";
        if (typeof value3 === "string" || typeof value3 === "number" || typeof value3 === "boolean") {
          res.push(`${pad}${keyValue}${value3}`);
        } else if (value3 instanceof Date) {
          res.push(`${pad}${keyValue}${value3.toUTCString()}`);
        } else if (Array.isArray(value3)) {
          for (const obj2 of value3) {
            obj2[TextObject.NAME] = key;
            res.push(...this.serializeObj(obj2, deep));
          }
        } else if (value3 instanceof TextObject) {
          value3[TextObject.NAME] = key;
          res.push(...this.serializeObj(value3, deep));
        } else if (import_pvtsutils6.BufferSourceConverter.isBufferSource(value3)) {
          if (key) {
            res.push(`${pad}${keyValue}`);
            res.push(...this.serializeBufferSource(value3, deep + 1));
          } else {
            res.push(...this.serializeBufferSource(value3, deep));
          }
        } else if ("toTextObject" in value3) {
          const obj2 = value3.toTextObject();
          obj2[TextObject.NAME] = key;
          res.push(...this.serializeObj(obj2, deep));
        } else {
          throw new TypeError("Cannot serialize data in text format. Unsupported type.");
        }
      }
      return res;
    }
    static serializeBufferSource(buffer2, deep = 0) {
      const pad = this.pad(deep);
      const view = import_pvtsutils6.BufferSourceConverter.toUint8Array(buffer2);
      const res = [];
      for (let i2 = 0; i2 < view.length; ) {
        const row = [];
        for (let j = 0; j < 16 && i2 < view.length; j++) {
          if (j === 8) {
            row.push("");
          }
          const hex = view[i2++].toString(16).padStart(2, "0");
          row.push(hex);
        }
        res.push(`${pad}${row.join(" ")}`);
      }
      return res;
    }
    static serializeAlgorithm(alg) {
      return this.algorithmSerializer.toTextObject(alg);
    }
  };
  TextConverter.oidSerializer = OidSerializer;
  TextConverter.algorithmSerializer = DefaultAlgorithmSerializer;
  var _AsnData_rawData;
  var AsnData = class _AsnData {
    get rawData() {
      if (!__classPrivateFieldGet(this, _AsnData_rawData, "f")) {
        __classPrivateFieldSet(this, _AsnData_rawData, AsnConvert.serialize(this.asn), "f");
      }
      return __classPrivateFieldGet(this, _AsnData_rawData, "f");
    }
    constructor(...args) {
      _AsnData_rawData.set(this, void 0);
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        this.asn = AsnConvert.parse(args[0], args[1]);
        __classPrivateFieldSet(this, _AsnData_rawData, import_pvtsutils6.BufferSourceConverter.toArrayBuffer(args[0]), "f");
        this.onInit(this.asn);
      } else {
        this.asn = args[0];
        this.onInit(this.asn);
      }
    }
    equal(data) {
      if (data instanceof _AsnData) {
        return (0, import_pvtsutils6.isEqual)(data.rawData, this.rawData);
      }
      return false;
    }
    toString(format3 = "text") {
      switch (format3) {
        case "asn":
          return AsnConvert.toString(this.rawData);
        case "text":
          return TextConverter.serialize(this.toTextObject());
        case "hex":
          return import_pvtsutils6.Convert.ToHex(this.rawData);
        case "base64":
          return import_pvtsutils6.Convert.ToBase64(this.rawData);
        case "base64url":
          return import_pvtsutils6.Convert.ToBase64Url(this.rawData);
        default:
          throw TypeError("Argument 'format' is unsupported value");
      }
    }
    getTextName() {
      const constructor = this.constructor;
      return constructor.NAME;
    }
    toTextObject() {
      const obj = this.toTextObjectEmpty();
      obj[""] = this.rawData;
      return obj;
    }
    toTextObjectEmpty(value2) {
      return new TextObject(this.getTextName(), {}, value2);
    }
  };
  _AsnData_rawData = /* @__PURE__ */ new WeakMap();
  AsnData.NAME = "ASN";
  var Extension2 = class _Extension extends AsnData {
    constructor(...args) {
      let raw;
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        raw = import_pvtsutils6.BufferSourceConverter.toArrayBuffer(args[0]);
      } else {
        raw = AsnConvert.serialize(new Extension({
          extnID: args[0],
          critical: args[1],
          extnValue: new OctetString2(import_pvtsutils6.BufferSourceConverter.toArrayBuffer(args[2]))
        }));
      }
      super(raw, Extension);
    }
    onInit(asn) {
      this.type = asn.extnID;
      this.critical = asn.critical;
      this.value = asn.extnValue.buffer;
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      obj[""] = this.value;
      return obj;
    }
    toTextObjectWithoutValue() {
      const obj = this.toTextObjectEmpty(this.critical ? "critical" : void 0);
      if (obj[TextObject.NAME] === _Extension.NAME) {
        obj[TextObject.NAME] = OidSerializer.toString(this.type);
      }
      return obj;
    }
  };
  var _a2;
  var CryptoProvider = class _CryptoProvider {
    static isCryptoKeyPair(data) {
      return data && data.privateKey && data.publicKey;
    }
    static isCryptoKey(data) {
      return data && data.usages && data.type && data.algorithm && data.extractable !== void 0;
    }
    constructor() {
      this.items = /* @__PURE__ */ new Map();
      this[_a2] = "CryptoProvider";
      if (typeof self !== "undefined" && typeof crypto !== "undefined") {
        this.set(_CryptoProvider.DEFAULT, crypto);
      } else if (typeof global !== "undefined" && global.crypto && global.crypto.subtle) {
        this.set(_CryptoProvider.DEFAULT, global.crypto);
      }
    }
    clear() {
      this.items.clear();
    }
    delete(key) {
      return this.items.delete(key);
    }
    forEach(callbackfn, thisArg) {
      return this.items.forEach(callbackfn, thisArg);
    }
    has(key) {
      return this.items.has(key);
    }
    get size() {
      return this.items.size;
    }
    entries() {
      return this.items.entries();
    }
    keys() {
      return this.items.keys();
    }
    values() {
      return this.items.values();
    }
    [Symbol.iterator]() {
      return this.items[Symbol.iterator]();
    }
    get(key = _CryptoProvider.DEFAULT) {
      const crypto2 = this.items.get(key.toLowerCase());
      if (!crypto2) {
        throw new Error(`Cannot get Crypto by name '${key}'`);
      }
      return crypto2;
    }
    set(key, value2) {
      if (typeof key === "string") {
        if (!value2) {
          throw new TypeError("Argument 'value' is required");
        }
        this.items.set(key.toLowerCase(), value2);
      } else {
        this.items.set(_CryptoProvider.DEFAULT, key);
      }
      return this;
    }
  };
  _a2 = Symbol.toStringTag;
  CryptoProvider.DEFAULT = "default";
  var cryptoProvider = new CryptoProvider();
  var OID_REGEX = /^[0-2](?:\.[1-9][0-9]*)+$/;
  function isOID(id) {
    return new RegExp(OID_REGEX).test(id);
  }
  var NameIdentifier = class {
    constructor(names2 = {}) {
      this.items = {};
      for (const id in names2) {
        this.register(id, names2[id]);
      }
    }
    get(idOrName) {
      return this.items[idOrName] || null;
    }
    findId(idOrName) {
      if (!isOID(idOrName)) {
        return this.get(idOrName);
      }
      return idOrName;
    }
    register(id, name9) {
      this.items[id] = name9;
      this.items[name9] = id;
    }
  };
  var names = new NameIdentifier();
  names.register("CN", "2.5.4.3");
  names.register("L", "2.5.4.7");
  names.register("ST", "2.5.4.8");
  names.register("O", "2.5.4.10");
  names.register("OU", "2.5.4.11");
  names.register("C", "2.5.4.6");
  names.register("DC", "0.9.2342.19200300.100.1.25");
  names.register("E", "1.2.840.113549.1.9.1");
  names.register("G", "2.5.4.42");
  names.register("I", "2.5.4.43");
  names.register("SN", "2.5.4.4");
  names.register("T", "2.5.4.12");
  function replaceUnknownCharacter(text, char) {
    return `\\${import_pvtsutils6.Convert.ToHex(import_pvtsutils6.Convert.FromUtf8String(char)).toUpperCase()}`;
  }
  function escape2(data) {
    return data.replace(/([,+"\\<>;])/g, "\\$1").replace(/^([ #])/, "\\$1").replace(/([ ]$)/, "\\$1").replace(/([\r\n\t])/, replaceUnknownCharacter);
  }
  var Name3 = class _Name {
    static isASCII(text) {
      for (let i2 = 0; i2 < text.length; i2++) {
        const code8 = text.charCodeAt(i2);
        if (code8 > 255) {
          return false;
        }
      }
      return true;
    }
    static isPrintableString(text) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/g.test(text);
    }
    constructor(data, extraNames = {}) {
      this.extraNames = new NameIdentifier();
      this.asn = new Name();
      for (const key in extraNames) {
        if (Object.prototype.hasOwnProperty.call(extraNames, key)) {
          const value2 = extraNames[key];
          this.extraNames.register(key, value2);
        }
      }
      if (typeof data === "string") {
        this.asn = this.fromString(data);
      } else if (data instanceof Name) {
        this.asn = data;
      } else if (import_pvtsutils6.BufferSourceConverter.isBufferSource(data)) {
        this.asn = AsnConvert.parse(data, Name);
      } else {
        this.asn = this.fromJSON(data);
      }
    }
    getField(idOrName) {
      const id = this.extraNames.findId(idOrName) || names.findId(idOrName);
      const res = [];
      for (const name9 of this.asn) {
        for (const rdn of name9) {
          if (rdn.type === id) {
            res.push(rdn.value.toString());
          }
        }
      }
      return res;
    }
    getName(idOrName) {
      return this.extraNames.get(idOrName) || names.get(idOrName);
    }
    toString() {
      return this.asn.map((rdn) => rdn.map((o2) => {
        const type = this.getName(o2.type) || o2.type;
        const value2 = o2.value.anyValue ? `#${import_pvtsutils6.Convert.ToHex(o2.value.anyValue)}` : escape2(o2.value.toString());
        return `${type}=${value2}`;
      }).join("+")).join(", ");
    }
    toJSON() {
      var _a4;
      const json = [];
      for (const rdn of this.asn) {
        const jsonItem = {};
        for (const attr of rdn) {
          const type = this.getName(attr.type) || attr.type;
          (_a4 = jsonItem[type]) !== null && _a4 !== void 0 ? _a4 : jsonItem[type] = [];
          jsonItem[type].push(attr.value.anyValue ? `#${import_pvtsutils6.Convert.ToHex(attr.value.anyValue)}` : attr.value.toString());
        }
        json.push(jsonItem);
      }
      return json;
    }
    fromString(data) {
      const asn = new Name();
      const regex = /(\d\.[\d.]*\d|[A-Za-z]+)=((?:"")|(?:".*?[^\\]")|(?:[^,+"\\](?=[,+]|$))|(?:[^,+].*?(?:[^\\][,+]))|(?:))([,+])?/g;
      let matches = null;
      let level = ",";
      while (matches = regex.exec(`${data},`)) {
        let [, type, value2] = matches;
        const lastChar = value2[value2.length - 1];
        if (lastChar === "," || lastChar === "+") {
          value2 = value2.slice(0, value2.length - 1);
          matches[3] = lastChar;
        }
        const next = matches[3];
        type = this.getTypeOid(type);
        const attr = this.createAttribute(type, value2);
        if (level === "+") {
          asn[asn.length - 1].push(attr);
        } else {
          asn.push(new RelativeDistinguishedName([attr]));
        }
        level = next;
      }
      return asn;
    }
    fromJSON(data) {
      const asn = new Name();
      for (const item of data) {
        const asnRdn = new RelativeDistinguishedName();
        for (const type in item) {
          const typeId = this.getTypeOid(type);
          const values = item[type];
          for (const value2 of values) {
            const asnAttr = this.createAttribute(typeId, value2);
            asnRdn.push(asnAttr);
          }
        }
        asn.push(asnRdn);
      }
      return asn;
    }
    getTypeOid(type) {
      if (!/[\d.]+/.test(type)) {
        type = this.getName(type) || "";
      }
      if (!type) {
        throw new Error(`Cannot get OID for name type '${type}'`);
      }
      return type;
    }
    createAttribute(type, value2) {
      const attr = new AttributeTypeAndValue({ type });
      if (typeof value2 === "object") {
        for (const key in value2) {
          switch (key) {
            case "ia5String":
              attr.value.ia5String = value2[key];
              break;
            case "utf8String":
              attr.value.utf8String = value2[key];
              break;
            case "universalString":
              attr.value.universalString = value2[key];
              break;
            case "bmpString":
              attr.value.bmpString = value2[key];
              break;
            case "printableString":
              attr.value.printableString = value2[key];
              break;
          }
        }
      } else if (value2[0] === "#") {
        attr.value.anyValue = import_pvtsutils6.Convert.FromHex(value2.slice(1));
      } else {
        const processedValue = this.processStringValue(value2);
        if (type === this.getName("E") || type === this.getName("DC")) {
          attr.value.ia5String = processedValue;
        } else {
          if (_Name.isPrintableString(processedValue)) {
            attr.value.printableString = processedValue;
          } else {
            attr.value.utf8String = processedValue;
          }
        }
      }
      return attr;
    }
    processStringValue(value2) {
      const quotedMatches = /"(.*?[^\\])?"/.exec(value2);
      if (quotedMatches) {
        value2 = quotedMatches[1];
      }
      return value2.replace(/\\0a/ig, "\n").replace(/\\0d/ig, "\r").replace(/\\0g/ig, "	").replace(/\\(.)/g, "$1");
    }
    toArrayBuffer() {
      return AsnConvert.serialize(this.asn);
    }
    async getThumbprint(...args) {
      var _a4;
      let crypto2;
      let algorithm = "SHA-1";
      if (args.length >= 1 && !((_a4 = args[0]) === null || _a4 === void 0 ? void 0 : _a4.subtle)) {
        algorithm = args[0] || algorithm;
        crypto2 = args[1] || cryptoProvider.get();
      } else {
        crypto2 = args[0] || cryptoProvider.get();
      }
      return await crypto2.subtle.digest(algorithm, this.toArrayBuffer());
    }
  };
  var ERR_GN_CONSTRUCTOR = "Cannot initialize GeneralName from ASN.1 data.";
  var ERR_GN_STRING_FORMAT = `${ERR_GN_CONSTRUCTOR} Unsupported string format in use.`;
  var ERR_GUID = `${ERR_GN_CONSTRUCTOR} Value doesn't match to GUID regular expression.`;
  var GUID_REGEX = /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i;
  var id_GUID = "1.3.6.1.4.1.311.25.1";
  var id_UPN = "1.3.6.1.4.1.311.20.2.3";
  var DNS3 = "dns";
  var DN = "dn";
  var EMAIL = "email";
  var IP2 = "ip";
  var URL2 = "url";
  var GUID = "guid";
  var UPN = "upn";
  var REGISTERED_ID = "id";
  var GeneralName3 = class extends AsnData {
    constructor(...args) {
      let name9;
      if (args.length === 2) {
        switch (args[0]) {
          case DN: {
            const derName = new Name3(args[1]).toArrayBuffer();
            const asnName = AsnConvert.parse(derName, Name);
            name9 = new GeneralName({ directoryName: asnName });
            break;
          }
          case DNS3:
            name9 = new GeneralName({ dNSName: args[1] });
            break;
          case EMAIL:
            name9 = new GeneralName({ rfc822Name: args[1] });
            break;
          case GUID: {
            const matches = new RegExp(GUID_REGEX, "i").exec(args[1]);
            if (!matches) {
              throw new Error("Cannot parse GUID value. Value doesn't match to regular expression");
            }
            const hex = matches.slice(1).map((o2, i2) => {
              if (i2 < 3) {
                return import_pvtsutils6.Convert.ToHex(new Uint8Array(import_pvtsutils6.Convert.FromHex(o2)).reverse());
              }
              return o2;
            }).join("");
            name9 = new GeneralName({
              otherName: new OtherName({
                typeId: id_GUID,
                value: AsnConvert.serialize(new OctetString2(import_pvtsutils6.Convert.FromHex(hex)))
              })
            });
            break;
          }
          case IP2:
            name9 = new GeneralName({ iPAddress: args[1] });
            break;
          case REGISTERED_ID:
            name9 = new GeneralName({ registeredID: args[1] });
            break;
          case UPN: {
            name9 = new GeneralName({
              otherName: new OtherName({
                typeId: id_UPN,
                value: AsnConvert.serialize(AsnUtf8StringConverter.toASN(args[1]))
              })
            });
            break;
          }
          case URL2:
            name9 = new GeneralName({ uniformResourceIdentifier: args[1] });
            break;
          default:
            throw new Error("Cannot create GeneralName. Unsupported type of the name");
        }
      } else if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        name9 = AsnConvert.parse(args[0], GeneralName);
      } else {
        name9 = args[0];
      }
      super(name9);
    }
    onInit(asn) {
      if (asn.dNSName != void 0) {
        this.type = DNS3;
        this.value = asn.dNSName;
      } else if (asn.rfc822Name != void 0) {
        this.type = EMAIL;
        this.value = asn.rfc822Name;
      } else if (asn.iPAddress != void 0) {
        this.type = IP2;
        this.value = asn.iPAddress;
      } else if (asn.uniformResourceIdentifier != void 0) {
        this.type = URL2;
        this.value = asn.uniformResourceIdentifier;
      } else if (asn.registeredID != void 0) {
        this.type = REGISTERED_ID;
        this.value = asn.registeredID;
      } else if (asn.directoryName != void 0) {
        this.type = DN;
        this.value = new Name3(asn.directoryName).toString();
      } else if (asn.otherName != void 0) {
        if (asn.otherName.typeId === id_GUID) {
          this.type = GUID;
          const guid = AsnConvert.parse(asn.otherName.value, OctetString2);
          const matches = new RegExp(GUID_REGEX, "i").exec(import_pvtsutils6.Convert.ToHex(guid));
          if (!matches) {
            throw new Error(ERR_GUID);
          }
          this.value = matches.slice(1).map((o2, i2) => {
            if (i2 < 3) {
              return import_pvtsutils6.Convert.ToHex(new Uint8Array(import_pvtsutils6.Convert.FromHex(o2)).reverse());
            }
            return o2;
          }).join("-");
        } else if (asn.otherName.typeId === id_UPN) {
          this.type = UPN;
          this.value = AsnConvert.parse(asn.otherName.value, DirectoryString).toString();
        } else {
          throw new Error(ERR_GN_STRING_FORMAT);
        }
      } else {
        throw new Error(ERR_GN_STRING_FORMAT);
      }
    }
    toJSON() {
      return {
        type: this.type,
        value: this.value
      };
    }
    toTextObject() {
      let type;
      switch (this.type) {
        case DN:
        case DNS3:
        case GUID:
        case IP2:
        case REGISTERED_ID:
        case UPN:
        case URL2:
          type = this.type.toUpperCase();
          break;
        case EMAIL:
          type = "Email";
          break;
        default:
          throw new Error("Unsupported GeneralName type");
      }
      let value2 = this.value;
      if (this.type === REGISTERED_ID) {
        value2 = OidSerializer.toString(value2);
      }
      return new TextObject(type, void 0, value2);
    }
  };
  var GeneralNames3 = class extends AsnData {
    constructor(params) {
      let names2;
      if (params instanceof GeneralNames) {
        names2 = params;
      } else if (Array.isArray(params)) {
        const items = [];
        for (const name9 of params) {
          if (name9 instanceof GeneralName) {
            items.push(name9);
          } else {
            const asnName = AsnConvert.parse(new GeneralName3(name9.type, name9.value).rawData, GeneralName);
            items.push(asnName);
          }
        }
        names2 = new GeneralNames(items);
      } else if (import_pvtsutils6.BufferSourceConverter.isBufferSource(params)) {
        names2 = AsnConvert.parse(params, GeneralNames);
      } else {
        throw new Error("Cannot initialize GeneralNames. Incorrect incoming arguments");
      }
      super(names2);
    }
    onInit(asn) {
      const items = [];
      for (const asnName of asn) {
        let name9 = null;
        try {
          name9 = new GeneralName3(asnName);
        } catch {
          continue;
        }
        items.push(name9);
      }
      this.items = items;
    }
    toJSON() {
      return this.items.map((o2) => o2.toJSON());
    }
    toTextObject() {
      const res = super.toTextObjectEmpty();
      for (const name9 of this.items) {
        const nameObj = name9.toTextObject();
        let field = res[nameObj[TextObject.NAME]];
        if (!Array.isArray(field)) {
          field = [];
          res[nameObj[TextObject.NAME]] = field;
        }
        field.push(nameObj);
      }
      return res;
    }
  };
  GeneralNames3.NAME = "GeneralNames";
  var rPaddingTag = "-{5}";
  var rEolChars = "\\n";
  var rNameTag = `[^${rEolChars}]+`;
  var rBeginTag = `${rPaddingTag}BEGIN (${rNameTag}(?=${rPaddingTag}))${rPaddingTag}`;
  var rEndTag = `${rPaddingTag}END \\1${rPaddingTag}`;
  var rEolGroup = "\\n";
  var rHeaderKey = `[^:${rEolChars}]+`;
  var rHeaderValue = `(?:[^${rEolChars}]+${rEolGroup}(?: +[^${rEolChars}]+${rEolGroup})*)`;
  var rBase64Chars = "[a-zA-Z0-9=+/]+";
  var rBase64 = `(?:${rBase64Chars}${rEolGroup})+`;
  var rPem = `${rBeginTag}${rEolGroup}(?:((?:${rHeaderKey}: ${rHeaderValue})+))?${rEolGroup}?(${rBase64})${rEndTag}`;
  var PemConverter = class {
    static isPem(data) {
      return typeof data === "string" && new RegExp(rPem, "g").test(data.replace(/\r/g, ""));
    }
    static decodeWithHeaders(pem) {
      pem = pem.replace(/\r/g, "");
      const pattern = new RegExp(rPem, "g");
      const res = [];
      let matches = null;
      while (matches = pattern.exec(pem)) {
        const base642 = matches[3].replace(new RegExp(`[${rEolChars}]+`, "g"), "");
        const pemStruct = {
          type: matches[1],
          headers: [],
          rawData: import_pvtsutils6.Convert.FromBase64(base642)
        };
        const headersString = matches[2];
        if (headersString) {
          const headers = headersString.split(new RegExp(rEolGroup, "g"));
          let lastHeader = null;
          for (const header of headers) {
            const [key, value2] = header.split(/:(.*)/);
            if (value2 === void 0) {
              if (!lastHeader) {
                throw new Error("Cannot parse PEM string. Incorrect header value");
              }
              lastHeader.value += key.trim();
            } else {
              if (lastHeader) {
                pemStruct.headers.push(lastHeader);
              }
              lastHeader = { key, value: value2.trim() };
            }
          }
          if (lastHeader) {
            pemStruct.headers.push(lastHeader);
          }
        }
        res.push(pemStruct);
      }
      return res;
    }
    static decode(pem) {
      const blocks = this.decodeWithHeaders(pem);
      return blocks.map((o2) => o2.rawData);
    }
    static decodeFirst(pem) {
      const items = this.decode(pem);
      if (!items.length) {
        throw new RangeError("PEM string doesn't contain any objects");
      }
      return items[0];
    }
    static encode(rawData, tag) {
      if (Array.isArray(rawData)) {
        const raws = new Array();
        if (tag) {
          rawData.forEach((element) => {
            if (!import_pvtsutils6.BufferSourceConverter.isBufferSource(element)) {
              throw new TypeError("Cannot encode array of BufferSource in PEM format. Not all items of the array are BufferSource");
            }
            raws.push(this.encodeStruct({
              type: tag,
              rawData: import_pvtsutils6.BufferSourceConverter.toArrayBuffer(element)
            }));
          });
        } else {
          rawData.forEach((element) => {
            if (!("type" in element)) {
              throw new TypeError("Cannot encode array of PemStruct in PEM format. Not all items of the array are PemStrut");
            }
            raws.push(this.encodeStruct(element));
          });
        }
        return raws.join("\n");
      } else {
        if (!tag) {
          throw new Error("Required argument 'tag' is missed");
        }
        return this.encodeStruct({
          type: tag,
          rawData: import_pvtsutils6.BufferSourceConverter.toArrayBuffer(rawData)
        });
      }
    }
    static encodeStruct(pem) {
      var _a4;
      const upperCaseType = pem.type.toLocaleUpperCase();
      const res = [];
      res.push(`-----BEGIN ${upperCaseType}-----`);
      if ((_a4 = pem.headers) === null || _a4 === void 0 ? void 0 : _a4.length) {
        for (const header of pem.headers) {
          res.push(`${header.key}: ${header.value}`);
        }
        res.push("");
      }
      const base642 = import_pvtsutils6.Convert.ToBase64(pem.rawData);
      let sliced;
      let offset = 0;
      const rows = Array();
      while (offset < base642.length) {
        if (base642.length - offset < 64) {
          sliced = base642.substring(offset);
        } else {
          sliced = base642.substring(offset, offset + 64);
          offset += 64;
        }
        if (sliced.length !== 0) {
          rows.push(sliced);
          if (sliced.length < 64) {
            break;
          }
        } else {
          break;
        }
      }
      res.push(...rows);
      res.push(`-----END ${upperCaseType}-----`);
      return res.join("\n");
    }
  };
  PemConverter.CertificateTag = "CERTIFICATE";
  PemConverter.CrlTag = "CRL";
  PemConverter.CertificateRequestTag = "CERTIFICATE REQUEST";
  PemConverter.PublicKeyTag = "PUBLIC KEY";
  PemConverter.PrivateKeyTag = "PRIVATE KEY";
  var PemData = class _PemData extends AsnData {
    static isAsnEncoded(data) {
      return import_pvtsutils6.BufferSourceConverter.isBufferSource(data) || typeof data === "string";
    }
    static toArrayBuffer(raw) {
      if (typeof raw === "string") {
        if (PemConverter.isPem(raw)) {
          return PemConverter.decode(raw)[0];
        } else if (import_pvtsutils6.Convert.isHex(raw)) {
          return import_pvtsutils6.Convert.FromHex(raw);
        } else if (import_pvtsutils6.Convert.isBase64(raw)) {
          return import_pvtsutils6.Convert.FromBase64(raw);
        } else if (import_pvtsutils6.Convert.isBase64Url(raw)) {
          return import_pvtsutils6.Convert.FromBase64Url(raw);
        } else {
          throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url");
        }
      } else {
        const buffer2 = import_pvtsutils6.BufferSourceConverter.toUint8Array(raw);
        if (buffer2.length > 0 && buffer2[0] === 48) {
          return import_pvtsutils6.BufferSourceConverter.toArrayBuffer(raw);
        }
        const stringRaw = import_pvtsutils6.Convert.ToBinary(raw);
        if (PemConverter.isPem(stringRaw)) {
          return PemConverter.decode(stringRaw)[0];
        } else if (import_pvtsutils6.Convert.isHex(stringRaw)) {
          return import_pvtsutils6.Convert.FromHex(stringRaw);
        } else if (import_pvtsutils6.Convert.isBase64(stringRaw)) {
          return import_pvtsutils6.Convert.FromBase64(stringRaw);
        } else if (import_pvtsutils6.Convert.isBase64Url(stringRaw)) {
          return import_pvtsutils6.Convert.FromBase64Url(stringRaw);
        }
        throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url");
      }
    }
    constructor(...args) {
      if (_PemData.isAsnEncoded(args[0])) {
        super(_PemData.toArrayBuffer(args[0]), args[1]);
      } else {
        super(args[0]);
      }
    }
    toString(format3 = "pem") {
      switch (format3) {
        case "pem":
          return PemConverter.encode(this.rawData, this.tag);
        default:
          return super.toString(format3);
      }
    }
  };
  var PublicKey2 = class _PublicKey extends PemData {
    static async create(data, crypto2 = cryptoProvider.get()) {
      if (data instanceof _PublicKey) {
        return data;
      } else if (CryptoProvider.isCryptoKey(data)) {
        if (data.type !== "public") {
          throw new TypeError("Public key is required");
        }
        const spki = await crypto2.subtle.exportKey("spki", data);
        return new _PublicKey(spki);
      } else if (data.publicKey) {
        return data.publicKey;
      } else if (import_pvtsutils6.BufferSourceConverter.isBufferSource(data)) {
        return new _PublicKey(data);
      } else {
        throw new TypeError("Unsupported PublicKeyType");
      }
    }
    constructor(param) {
      if (PemData.isAsnEncoded(param)) {
        super(param, SubjectPublicKeyInfo);
      } else {
        super(param);
      }
      this.tag = PemConverter.PublicKeyTag;
    }
    async export(...args) {
      let crypto2;
      let keyUsages = ["verify"];
      let algorithm = { hash: "SHA-256", ...this.algorithm };
      if (args.length > 1) {
        algorithm = args[0] || algorithm;
        keyUsages = args[1] || keyUsages;
        crypto2 = args[2] || cryptoProvider.get();
      } else {
        crypto2 = args[0] || cryptoProvider.get();
      }
      let raw = this.rawData;
      const asnSpki = AsnConvert.parse(this.rawData, SubjectPublicKeyInfo);
      if (asnSpki.algorithm.algorithm === id_RSASSA_PSS) {
        raw = convertSpkiToRsaPkcs1(asnSpki, raw);
      }
      return crypto2.subtle.importKey("spki", raw, algorithm, true, keyUsages);
    }
    onInit(asn) {
      const algProv = instance.resolve(diAlgorithmProvider);
      const algorithm = this.algorithm = algProv.toWebAlgorithm(asn.algorithm);
      switch (asn.algorithm.algorithm) {
        case id_rsaEncryption: {
          const rsaPublicKey = AsnConvert.parse(asn.subjectPublicKey, RSAPublicKey2);
          const modulus = import_pvtsutils6.BufferSourceConverter.toUint8Array(rsaPublicKey.modulus);
          algorithm.publicExponent = import_pvtsutils6.BufferSourceConverter.toUint8Array(rsaPublicKey.publicExponent);
          algorithm.modulusLength = (!modulus[0] ? modulus.slice(1) : modulus).byteLength << 3;
          break;
        }
      }
    }
    async getThumbprint(...args) {
      var _a4;
      let crypto2;
      let algorithm = "SHA-1";
      if (args.length >= 1 && !((_a4 = args[0]) === null || _a4 === void 0 ? void 0 : _a4.subtle)) {
        algorithm = args[0] || algorithm;
        crypto2 = args[1] || cryptoProvider.get();
      } else {
        crypto2 = args[0] || cryptoProvider.get();
      }
      return await crypto2.subtle.digest(algorithm, this.rawData);
    }
    async getKeyIdentifier(...args) {
      let crypto2;
      let algorithm = "SHA-1";
      if (args.length === 1) {
        if (typeof args[0] === "string") {
          algorithm = args[0];
          crypto2 = cryptoProvider.get();
        } else {
          crypto2 = args[0];
        }
      } else if (args.length === 2) {
        algorithm = args[0];
        crypto2 = args[1];
      } else {
        crypto2 = cryptoProvider.get();
      }
      const asn = AsnConvert.parse(this.rawData, SubjectPublicKeyInfo);
      return await crypto2.subtle.digest(algorithm, asn.subjectPublicKey);
    }
    toTextObject() {
      const obj = this.toTextObjectEmpty();
      const asn = AsnConvert.parse(this.rawData, SubjectPublicKeyInfo);
      obj["Algorithm"] = TextConverter.serializeAlgorithm(asn.algorithm);
      switch (asn.algorithm.algorithm) {
        case id_ecPublicKey:
          obj["EC Point"] = asn.subjectPublicKey;
          break;
        case id_rsaEncryption:
        default:
          obj["Raw Data"] = asn.subjectPublicKey;
      }
      return obj;
    }
  };
  function convertSpkiToRsaPkcs1(asnSpki, raw) {
    asnSpki.algorithm = new AlgorithmIdentifier({
      algorithm: id_rsaEncryption,
      parameters: null
    });
    raw = AsnConvert.serialize(asnSpki);
    return raw;
  }
  var AuthorityKeyIdentifierExtension = class _AuthorityKeyIdentifierExtension extends Extension2 {
    static async create(param, critical = false, crypto2 = cryptoProvider.get()) {
      if ("name" in param && "serialNumber" in param) {
        return new _AuthorityKeyIdentifierExtension(param, critical);
      }
      const key = await PublicKey2.create(param, crypto2);
      const id = await key.getKeyIdentifier(crypto2);
      return new _AuthorityKeyIdentifierExtension(import_pvtsutils6.Convert.ToHex(id), critical);
    }
    constructor(...args) {
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
      } else if (typeof args[0] === "string") {
        const value2 = new AuthorityKeyIdentifier({ keyIdentifier: new KeyIdentifier(import_pvtsutils6.Convert.FromHex(args[0])) });
        super(id_ce_authorityKeyIdentifier, args[1], AsnConvert.serialize(value2));
      } else {
        const certId = args[0];
        const certIdName = certId.name instanceof GeneralNames3 ? AsnConvert.parse(certId.name.rawData, GeneralNames) : certId.name;
        const value2 = new AuthorityKeyIdentifier({
          authorityCertIssuer: certIdName,
          authorityCertSerialNumber: import_pvtsutils6.Convert.FromHex(certId.serialNumber)
        });
        super(id_ce_authorityKeyIdentifier, args[1], AsnConvert.serialize(value2));
      }
    }
    onInit(asn) {
      super.onInit(asn);
      const aki = AsnConvert.parse(asn.extnValue, AuthorityKeyIdentifier);
      if (aki.keyIdentifier) {
        this.keyId = import_pvtsutils6.Convert.ToHex(aki.keyIdentifier);
      }
      if (aki.authorityCertIssuer || aki.authorityCertSerialNumber) {
        this.certId = {
          name: aki.authorityCertIssuer || [],
          serialNumber: aki.authorityCertSerialNumber ? import_pvtsutils6.Convert.ToHex(aki.authorityCertSerialNumber) : ""
        };
      }
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      const asn = AsnConvert.parse(this.value, AuthorityKeyIdentifier);
      if (asn.authorityCertIssuer) {
        obj["Authority Issuer"] = new GeneralNames3(asn.authorityCertIssuer).toTextObject();
      }
      if (asn.authorityCertSerialNumber) {
        obj["Authority Serial Number"] = asn.authorityCertSerialNumber;
      }
      if (asn.keyIdentifier) {
        obj[""] = asn.keyIdentifier;
      }
      return obj;
    }
  };
  AuthorityKeyIdentifierExtension.NAME = "Authority Key Identifier";
  var BasicConstraintsExtension = class extends Extension2 {
    constructor(...args) {
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
        const value2 = AsnConvert.parse(this.value, BasicConstraints);
        this.ca = value2.cA;
        this.pathLength = value2.pathLenConstraint;
      } else {
        const value2 = new BasicConstraints({
          cA: args[0],
          pathLenConstraint: args[1]
        });
        super(id_ce_basicConstraints, args[2], AsnConvert.serialize(value2));
        this.ca = args[0];
        this.pathLength = args[1];
      }
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      if (this.ca) {
        obj["CA"] = this.ca;
      }
      if (this.pathLength !== void 0) {
        obj["Path Length"] = this.pathLength;
      }
      return obj;
    }
  };
  BasicConstraintsExtension.NAME = "Basic Constraints";
  var ExtendedKeyUsage3;
  (function(ExtendedKeyUsage4) {
    ExtendedKeyUsage4["serverAuth"] = "1.3.6.1.5.5.7.3.1";
    ExtendedKeyUsage4["clientAuth"] = "1.3.6.1.5.5.7.3.2";
    ExtendedKeyUsage4["codeSigning"] = "1.3.6.1.5.5.7.3.3";
    ExtendedKeyUsage4["emailProtection"] = "1.3.6.1.5.5.7.3.4";
    ExtendedKeyUsage4["timeStamping"] = "1.3.6.1.5.5.7.3.8";
    ExtendedKeyUsage4["ocspSigning"] = "1.3.6.1.5.5.7.3.9";
  })(ExtendedKeyUsage3 || (ExtendedKeyUsage3 = {}));
  var ExtendedKeyUsageExtension = class extends Extension2 {
    constructor(...args) {
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
        const value2 = AsnConvert.parse(this.value, ExtendedKeyUsage);
        this.usages = value2.map((o2) => o2);
      } else {
        const value2 = new ExtendedKeyUsage(args[0]);
        super(id_ce_extKeyUsage, args[1], AsnConvert.serialize(value2));
        this.usages = args[0];
      }
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      obj[""] = this.usages.map((o2) => OidSerializer.toString(o2)).join(", ");
      return obj;
    }
  };
  ExtendedKeyUsageExtension.NAME = "Extended Key Usages";
  var KeyUsageFlags2;
  (function(KeyUsageFlags3) {
    KeyUsageFlags3[KeyUsageFlags3["digitalSignature"] = 1] = "digitalSignature";
    KeyUsageFlags3[KeyUsageFlags3["nonRepudiation"] = 2] = "nonRepudiation";
    KeyUsageFlags3[KeyUsageFlags3["keyEncipherment"] = 4] = "keyEncipherment";
    KeyUsageFlags3[KeyUsageFlags3["dataEncipherment"] = 8] = "dataEncipherment";
    KeyUsageFlags3[KeyUsageFlags3["keyAgreement"] = 16] = "keyAgreement";
    KeyUsageFlags3[KeyUsageFlags3["keyCertSign"] = 32] = "keyCertSign";
    KeyUsageFlags3[KeyUsageFlags3["cRLSign"] = 64] = "cRLSign";
    KeyUsageFlags3[KeyUsageFlags3["encipherOnly"] = 128] = "encipherOnly";
    KeyUsageFlags3[KeyUsageFlags3["decipherOnly"] = 256] = "decipherOnly";
  })(KeyUsageFlags2 || (KeyUsageFlags2 = {}));
  var KeyUsagesExtension = class extends Extension2 {
    constructor(...args) {
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
        const value2 = AsnConvert.parse(this.value, KeyUsage);
        this.usages = value2.toNumber();
      } else {
        const value2 = new KeyUsage(args[0]);
        super(id_ce_keyUsage, args[1], AsnConvert.serialize(value2));
        this.usages = args[0];
      }
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      const asn = AsnConvert.parse(this.value, KeyUsage);
      obj[""] = asn.toJSON().join(", ");
      return obj;
    }
  };
  KeyUsagesExtension.NAME = "Key Usages";
  var SubjectKeyIdentifierExtension = class _SubjectKeyIdentifierExtension extends Extension2 {
    static async create(publicKey2, critical = false, crypto2 = cryptoProvider.get()) {
      const key = await PublicKey2.create(publicKey2, crypto2);
      const id = await key.getKeyIdentifier(crypto2);
      return new _SubjectKeyIdentifierExtension(import_pvtsutils6.Convert.ToHex(id), critical);
    }
    constructor(...args) {
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
        const value2 = AsnConvert.parse(this.value, SubjectKeyIdentifier);
        this.keyId = import_pvtsutils6.Convert.ToHex(value2);
      } else {
        const identifier = typeof args[0] === "string" ? import_pvtsutils6.Convert.FromHex(args[0]) : args[0];
        const value2 = new SubjectKeyIdentifier(identifier);
        super(id_ce_subjectKeyIdentifier, args[1], AsnConvert.serialize(value2));
        this.keyId = import_pvtsutils6.Convert.ToHex(identifier);
      }
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      const asn = AsnConvert.parse(this.value, SubjectKeyIdentifier);
      obj[""] = asn;
      return obj;
    }
  };
  SubjectKeyIdentifierExtension.NAME = "Subject Key Identifier";
  var SubjectAlternativeNameExtension = class extends Extension2 {
    constructor(...args) {
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
      } else {
        super(id_ce_subjectAltName, args[1], new GeneralNames3(args[0] || []).rawData);
      }
    }
    onInit(asn) {
      super.onInit(asn);
      const value2 = AsnConvert.parse(asn.extnValue, SubjectAlternativeName);
      this.names = new GeneralNames3(value2);
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      const namesObj = this.names.toTextObject();
      for (const key in namesObj) {
        obj[key] = namesObj[key];
      }
      return obj;
    }
  };
  SubjectAlternativeNameExtension.NAME = "Subject Alternative Name";
  var ExtensionFactory = class {
    static register(id, type) {
      this.items.set(id, type);
    }
    static create(data) {
      const extension = new Extension2(data);
      const Type2 = this.items.get(extension.type);
      if (Type2) {
        return new Type2(data);
      }
      return extension;
    }
  };
  ExtensionFactory.items = /* @__PURE__ */ new Map();
  var CertificatePolicyExtension = class extends Extension2 {
    constructor(...args) {
      var _a4;
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
        const asnPolicies = AsnConvert.parse(this.value, CertificatePolicies);
        this.policies = asnPolicies.map((o2) => o2.policyIdentifier);
      } else {
        const policies = args[0];
        const critical = (_a4 = args[1]) !== null && _a4 !== void 0 ? _a4 : false;
        const value2 = new CertificatePolicies(policies.map((o2) => new PolicyInformation({
          policyIdentifier: o2
        })));
        super(id_ce_certificatePolicies, critical, AsnConvert.serialize(value2));
        this.policies = policies;
      }
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      obj["Policy"] = this.policies.map((o2) => new TextObject("", {}, OidSerializer.toString(o2)));
      return obj;
    }
  };
  CertificatePolicyExtension.NAME = "Certificate Policies";
  ExtensionFactory.register(id_ce_certificatePolicies, CertificatePolicyExtension);
  var CRLDistributionPointsExtension = class extends Extension2 {
    constructor(...args) {
      var _a4;
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
      } else if (Array.isArray(args[0]) && typeof args[0][0] === "string") {
        const urls = args[0];
        const dps = urls.map((url) => {
          return new DistributionPoint({
            distributionPoint: new DistributionPointName({
              fullName: [new GeneralName({ uniformResourceIdentifier: url })]
            })
          });
        });
        const value2 = new CRLDistributionPoints(dps);
        super(id_ce_cRLDistributionPoints, args[1], AsnConvert.serialize(value2));
      } else {
        const value2 = new CRLDistributionPoints(args[0]);
        super(id_ce_cRLDistributionPoints, args[1], AsnConvert.serialize(value2));
      }
      (_a4 = this.distributionPoints) !== null && _a4 !== void 0 ? _a4 : this.distributionPoints = [];
    }
    onInit(asn) {
      super.onInit(asn);
      const crlExt = AsnConvert.parse(asn.extnValue, CRLDistributionPoints);
      this.distributionPoints = crlExt;
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      obj["Distribution Point"] = this.distributionPoints.map((dp) => {
        var _a4;
        const dpObj = {};
        if (dp.distributionPoint) {
          dpObj[""] = (_a4 = dp.distributionPoint.fullName) === null || _a4 === void 0 ? void 0 : _a4.map((name9) => new GeneralName3(name9).toString()).join(", ");
        }
        if (dp.reasons) {
          dpObj["Reasons"] = dp.reasons.toString();
        }
        if (dp.cRLIssuer) {
          dpObj["CRL Issuer"] = dp.cRLIssuer.map((issuer) => issuer.toString()).join(", ");
        }
        return dpObj;
      });
      return obj;
    }
  };
  CRLDistributionPointsExtension.NAME = "CRL Distribution Points";
  var AuthorityInfoAccessExtension = class extends Extension2 {
    constructor(...args) {
      var _a4, _b2, _c, _d;
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
      } else if (args[0] instanceof AuthorityInfoAccessSyntax) {
        const value2 = new AuthorityInfoAccessSyntax(args[0]);
        super(id_pe_authorityInfoAccess, args[1], AsnConvert.serialize(value2));
      } else {
        const params = args[0];
        const value2 = new AuthorityInfoAccessSyntax();
        addAccessDescriptions(value2, params, id_ad_ocsp, "ocsp");
        addAccessDescriptions(value2, params, id_ad_caIssuers, "caIssuers");
        addAccessDescriptions(value2, params, id_ad_timeStamping, "timeStamping");
        addAccessDescriptions(value2, params, id_ad_caRepository, "caRepository");
        super(id_pe_authorityInfoAccess, args[1], AsnConvert.serialize(value2));
      }
      (_a4 = this.ocsp) !== null && _a4 !== void 0 ? _a4 : this.ocsp = [];
      (_b2 = this.caIssuers) !== null && _b2 !== void 0 ? _b2 : this.caIssuers = [];
      (_c = this.timeStamping) !== null && _c !== void 0 ? _c : this.timeStamping = [];
      (_d = this.caRepository) !== null && _d !== void 0 ? _d : this.caRepository = [];
    }
    onInit(asn) {
      super.onInit(asn);
      this.ocsp = [];
      this.caIssuers = [];
      this.timeStamping = [];
      this.caRepository = [];
      const aia = AsnConvert.parse(asn.extnValue, AuthorityInfoAccessSyntax);
      aia.forEach((accessDescription) => {
        switch (accessDescription.accessMethod) {
          case id_ad_ocsp:
            this.ocsp.push(new GeneralName3(accessDescription.accessLocation));
            break;
          case id_ad_caIssuers:
            this.caIssuers.push(new GeneralName3(accessDescription.accessLocation));
            break;
          case id_ad_timeStamping:
            this.timeStamping.push(new GeneralName3(accessDescription.accessLocation));
            break;
          case id_ad_caRepository:
            this.caRepository.push(new GeneralName3(accessDescription.accessLocation));
            break;
        }
      });
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      if (this.ocsp.length) {
        addUrlsToObject(obj, "OCSP", this.ocsp);
      }
      if (this.caIssuers.length) {
        addUrlsToObject(obj, "CA Issuers", this.caIssuers);
      }
      if (this.timeStamping.length) {
        addUrlsToObject(obj, "Time Stamping", this.timeStamping);
      }
      if (this.caRepository.length) {
        addUrlsToObject(obj, "CA Repository", this.caRepository);
      }
      return obj;
    }
  };
  AuthorityInfoAccessExtension.NAME = "Authority Info Access";
  function addUrlsToObject(obj, key, urls) {
    if (urls.length === 1) {
      obj[key] = urls[0].toTextObject();
    } else {
      const names2 = new TextObject("");
      urls.forEach((name9, index) => {
        const nameObj = name9.toTextObject();
        const indexedKey = `${nameObj[TextObject.NAME]} ${index + 1}`;
        let field = names2[indexedKey];
        if (!Array.isArray(field)) {
          field = [];
          names2[indexedKey] = field;
        }
        field.push(nameObj);
      });
      obj[key] = names2;
    }
  }
  function addAccessDescriptions(value2, params, method, key) {
    const items = params[key];
    if (items) {
      const array = Array.isArray(items) ? items : [items];
      array.forEach((url) => {
        if (typeof url === "string") {
          url = new GeneralName3("url", url);
        }
        value2.push(new AccessDescription({
          accessMethod: method,
          accessLocation: AsnConvert.parse(url.rawData, GeneralName)
        }));
      });
    }
  }
  var IssuerAlternativeNameExtension = class extends Extension2 {
    constructor(...args) {
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
      } else {
        super(id_ce_issuerAltName, args[1], new GeneralNames3(args[0] || []).rawData);
      }
    }
    onInit(asn) {
      super.onInit(asn);
      const value2 = AsnConvert.parse(asn.extnValue, GeneralNames);
      this.names = new GeneralNames3(value2);
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      const namesObj = this.names.toTextObject();
      for (const key in namesObj) {
        obj[key] = namesObj[key];
      }
      return obj;
    }
  };
  IssuerAlternativeNameExtension.NAME = "Issuer Alternative Name";
  var Attribute3 = class _Attribute extends AsnData {
    constructor(...args) {
      let raw;
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        raw = import_pvtsutils6.BufferSourceConverter.toArrayBuffer(args[0]);
      } else {
        const type = args[0];
        const values = Array.isArray(args[1]) ? args[1].map((o2) => import_pvtsutils6.BufferSourceConverter.toArrayBuffer(o2)) : [];
        raw = AsnConvert.serialize(new Attribute({ type, values }));
      }
      super(raw, Attribute);
    }
    onInit(asn) {
      this.type = asn.type;
      this.values = asn.values;
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      obj["Value"] = this.values.map((o2) => new TextObject("", { "": o2 }));
      return obj;
    }
    toTextObjectWithoutValue() {
      const obj = this.toTextObjectEmpty();
      if (obj[TextObject.NAME] === _Attribute.NAME) {
        obj[TextObject.NAME] = OidSerializer.toString(this.type);
      }
      return obj;
    }
  };
  Attribute3.NAME = "Attribute";
  var ChallengePasswordAttribute = class extends Attribute3 {
    constructor(...args) {
      var _a4;
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
      } else {
        const value2 = new ChallengePassword({
          printableString: args[0]
        });
        super(id_pkcs9_at_challengePassword, [AsnConvert.serialize(value2)]);
      }
      (_a4 = this.password) !== null && _a4 !== void 0 ? _a4 : this.password = "";
    }
    onInit(asn) {
      super.onInit(asn);
      if (this.values[0]) {
        const value2 = AsnConvert.parse(this.values[0], ChallengePassword);
        this.password = value2.toString();
      }
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      obj[TextObject.VALUE] = this.password;
      return obj;
    }
  };
  ChallengePasswordAttribute.NAME = "Challenge Password";
  var ExtensionsAttribute = class extends Attribute3 {
    constructor(...args) {
      var _a4;
      if (import_pvtsutils6.BufferSourceConverter.isBufferSource(args[0])) {
        super(args[0]);
      } else {
        const extensions2 = args[0];
        const value2 = new Extensions();
        for (const extension of extensions2) {
          value2.push(AsnConvert.parse(extension.rawData, Extension));
        }
        super(id_pkcs9_at_extensionRequest, [AsnConvert.serialize(value2)]);
      }
      (_a4 = this.items) !== null && _a4 !== void 0 ? _a4 : this.items = [];
    }
    onInit(asn) {
      super.onInit(asn);
      if (this.values[0]) {
        const value2 = AsnConvert.parse(this.values[0], Extensions);
        this.items = value2.map((o2) => ExtensionFactory.create(AsnConvert.serialize(o2)));
      }
    }
    toTextObject() {
      const obj = this.toTextObjectWithoutValue();
      const extensions2 = this.items.map((o2) => o2.toTextObject());
      for (const extension of extensions2) {
        obj[extension[TextObject.NAME]] = extension;
      }
      return obj;
    }
  };
  ExtensionsAttribute.NAME = "Extensions";
  var AttributeFactory = class {
    static register(id, type) {
      this.items.set(id, type);
    }
    static create(data) {
      const attribute = new Attribute3(data);
      const Type2 = this.items.get(attribute.type);
      if (Type2) {
        return new Type2(data);
      }
      return attribute;
    }
  };
  AttributeFactory.items = /* @__PURE__ */ new Map();
  var diAsnSignatureFormatter = "crypto.signatureFormatter";
  var AsnDefaultSignatureFormatter = class {
    toAsnSignature(algorithm, signature) {
      return import_pvtsutils6.BufferSourceConverter.toArrayBuffer(signature);
    }
    toWebSignature(algorithm, signature) {
      return import_pvtsutils6.BufferSourceConverter.toArrayBuffer(signature);
    }
  };
  var RsaAlgorithm_1;
  var RsaAlgorithm = RsaAlgorithm_1 = class RsaAlgorithm2 {
    static createPssParams(hash, saltLength) {
      const hashAlgorithm = RsaAlgorithm_1.getHashAlgorithm(hash);
      if (!hashAlgorithm) {
        return null;
      }
      return new RsaSaPssParams({
        hashAlgorithm,
        maskGenAlgorithm: new AlgorithmIdentifier({
          algorithm: id_mgf1,
          parameters: AsnConvert.serialize(hashAlgorithm)
        }),
        saltLength
      });
    }
    static getHashAlgorithm(alg) {
      const algProv = instance.resolve(diAlgorithmProvider);
      if (typeof alg === "string") {
        return algProv.toAsnAlgorithm({ name: alg });
      }
      if (typeof alg === "object" && alg && "name" in alg) {
        return algProv.toAsnAlgorithm(alg);
      }
      return null;
    }
    toAsnAlgorithm(alg) {
      switch (alg.name.toLowerCase()) {
        case "rsassa-pkcs1-v1_5":
          if ("hash" in alg) {
            let hash;
            if (typeof alg.hash === "string") {
              hash = alg.hash;
            } else if (alg.hash && typeof alg.hash === "object" && "name" in alg.hash && typeof alg.hash.name === "string") {
              hash = alg.hash.name.toUpperCase();
            } else {
              throw new Error("Cannot get hash algorithm name");
            }
            switch (hash.toLowerCase()) {
              case "sha-1":
                return new AlgorithmIdentifier({ algorithm: id_sha1WithRSAEncryption, parameters: null });
              case "sha-256":
                return new AlgorithmIdentifier({ algorithm: id_sha256WithRSAEncryption, parameters: null });
              case "sha-384":
                return new AlgorithmIdentifier({ algorithm: id_sha384WithRSAEncryption, parameters: null });
              case "sha-512":
                return new AlgorithmIdentifier({ algorithm: id_sha512WithRSAEncryption, parameters: null });
            }
          } else {
            return new AlgorithmIdentifier({ algorithm: id_rsaEncryption, parameters: null });
          }
          break;
        case "rsa-pss":
          if ("hash" in alg) {
            if (!("saltLength" in alg && typeof alg.saltLength === "number")) {
              throw new Error("Cannot get 'saltLength' from 'alg' argument");
            }
            const pssParams = RsaAlgorithm_1.createPssParams(alg.hash, alg.saltLength);
            if (!pssParams) {
              throw new Error("Cannot create PSS parameters");
            }
            return new AlgorithmIdentifier({ algorithm: id_RSASSA_PSS, parameters: AsnConvert.serialize(pssParams) });
          } else {
            return new AlgorithmIdentifier({ algorithm: id_RSASSA_PSS, parameters: null });
          }
      }
      return null;
    }
    toWebAlgorithm(alg) {
      switch (alg.algorithm) {
        case id_rsaEncryption:
          return { name: "RSASSA-PKCS1-v1_5" };
        case id_sha1WithRSAEncryption:
          return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-1" } };
        case id_sha256WithRSAEncryption:
          return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
        case id_sha384WithRSAEncryption:
          return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-384" } };
        case id_sha512WithRSAEncryption:
          return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-512" } };
        case id_RSASSA_PSS:
          if (alg.parameters) {
            const pssParams = AsnConvert.parse(alg.parameters, RsaSaPssParams);
            const algProv = instance.resolve(diAlgorithmProvider);
            const hashAlg = algProv.toWebAlgorithm(pssParams.hashAlgorithm);
            return {
              name: "RSA-PSS",
              hash: hashAlg,
              saltLength: pssParams.saltLength
            };
          } else {
            return { name: "RSA-PSS" };
          }
      }
      return null;
    }
  };
  RsaAlgorithm = RsaAlgorithm_1 = __decorate([
    injectable_default()
  ], RsaAlgorithm);
  instance.registerSingleton(diAlgorithm, RsaAlgorithm);
  var ShaAlgorithm = class ShaAlgorithm2 {
    toAsnAlgorithm(alg) {
      switch (alg.name.toLowerCase()) {
        case "sha-1":
          return new AlgorithmIdentifier({ algorithm: id_sha1 });
        case "sha-256":
          return new AlgorithmIdentifier({ algorithm: id_sha256 });
        case "sha-384":
          return new AlgorithmIdentifier({ algorithm: id_sha384 });
        case "sha-512":
          return new AlgorithmIdentifier({ algorithm: id_sha512 });
      }
      return null;
    }
    toWebAlgorithm(alg) {
      switch (alg.algorithm) {
        case id_sha1:
          return { name: "SHA-1" };
        case id_sha256:
          return { name: "SHA-256" };
        case id_sha384:
          return { name: "SHA-384" };
        case id_sha512:
          return { name: "SHA-512" };
      }
      return null;
    }
  };
  ShaAlgorithm = __decorate([
    injectable_default()
  ], ShaAlgorithm);
  instance.registerSingleton(diAlgorithm, ShaAlgorithm);
  var AsnEcSignatureFormatter = class _AsnEcSignatureFormatter {
    addPadding(pointSize, data) {
      const bytes = import_pvtsutils6.BufferSourceConverter.toUint8Array(data);
      const res = new Uint8Array(pointSize);
      res.set(bytes, pointSize - bytes.length);
      return res.buffer;
    }
    removePadding(data, positive2 = false) {
      let bytes = import_pvtsutils6.BufferSourceConverter.toUint8Array(data);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        if (!bytes[i2]) {
          continue;
        }
        bytes = bytes.slice(i2);
        break;
      }
      if (positive2 && bytes[0] > 127) {
        const result = new Uint8Array(bytes.length + 1);
        result.set(bytes, 1);
        return result.buffer;
      }
      return bytes.buffer;
    }
    toAsnSignature(algorithm, signature) {
      if (algorithm.name === "ECDSA") {
        const namedCurve = algorithm.namedCurve;
        const pointSize = _AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || _AsnEcSignatureFormatter.defaultNamedCurveSize;
        const ecSignature = new ECDSASigValue();
        const uint8Signature = import_pvtsutils6.BufferSourceConverter.toUint8Array(signature);
        ecSignature.r = this.removePadding(uint8Signature.slice(0, pointSize), true);
        ecSignature.s = this.removePadding(uint8Signature.slice(pointSize, pointSize + pointSize), true);
        return AsnConvert.serialize(ecSignature);
      }
      return null;
    }
    toWebSignature(algorithm, signature) {
      if (algorithm.name === "ECDSA") {
        const ecSigValue = AsnConvert.parse(signature, ECDSASigValue);
        const namedCurve = algorithm.namedCurve;
        const pointSize = _AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || _AsnEcSignatureFormatter.defaultNamedCurveSize;
        const r2 = this.addPadding(pointSize, this.removePadding(ecSigValue.r));
        const s2 = this.addPadding(pointSize, this.removePadding(ecSigValue.s));
        return (0, import_pvtsutils6.combine)(r2, s2);
      }
      return null;
    }
  };
  AsnEcSignatureFormatter.namedCurveSize = /* @__PURE__ */ new Map();
  AsnEcSignatureFormatter.defaultNamedCurveSize = 32;
  var idX25519 = "1.3.101.110";
  var idX448 = "1.3.101.111";
  var idEd25519 = "1.3.101.112";
  var idEd448 = "1.3.101.113";
  var EdAlgorithm = class EdAlgorithm2 {
    toAsnAlgorithm(alg) {
      let algorithm = null;
      switch (alg.name.toLowerCase()) {
        case "ed25519":
          algorithm = idEd25519;
          break;
        case "x25519":
          algorithm = idX25519;
          break;
        case "eddsa":
          switch (alg.namedCurve.toLowerCase()) {
            case "ed25519":
              algorithm = idEd25519;
              break;
            case "ed448":
              algorithm = idEd448;
              break;
          }
          break;
        case "ecdh-es":
          switch (alg.namedCurve.toLowerCase()) {
            case "x25519":
              algorithm = idX25519;
              break;
            case "x448":
              algorithm = idX448;
              break;
          }
      }
      if (algorithm) {
        return new AlgorithmIdentifier({
          algorithm
        });
      }
      return null;
    }
    toWebAlgorithm(alg) {
      switch (alg.algorithm) {
        case idEd25519:
          return { name: "Ed25519" };
        case idEd448:
          return { name: "EdDSA", namedCurve: "Ed448" };
        case idX25519:
          return { name: "X25519" };
        case idX448:
          return { name: "ECDH-ES", namedCurve: "X448" };
      }
      return null;
    }
  };
  EdAlgorithm = __decorate([
    injectable_default()
  ], EdAlgorithm);
  instance.registerSingleton(diAlgorithm, EdAlgorithm);
  var _Pkcs10CertificateRequest_tbs;
  var _Pkcs10CertificateRequest_subjectName;
  var _Pkcs10CertificateRequest_subject;
  var _Pkcs10CertificateRequest_signatureAlgorithm;
  var _Pkcs10CertificateRequest_signature;
  var _Pkcs10CertificateRequest_publicKey;
  var _Pkcs10CertificateRequest_attributes;
  var _Pkcs10CertificateRequest_extensions;
  var Pkcs10CertificateRequest = class extends PemData {
    get subjectName() {
      if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_subjectName, "f")) {
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_subjectName, new Name3(this.asn.certificationRequestInfo.subject), "f");
      }
      return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_subjectName, "f");
    }
    get subject() {
      if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_subject, "f")) {
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_subject, this.subjectName.toString(), "f");
      }
      return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_subject, "f");
    }
    get signatureAlgorithm() {
      if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_signatureAlgorithm, "f")) {
        const algProv = instance.resolve(diAlgorithmProvider);
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_signatureAlgorithm, algProv.toWebAlgorithm(this.asn.signatureAlgorithm), "f");
      }
      return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_signatureAlgorithm, "f");
    }
    get signature() {
      if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_signature, "f")) {
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_signature, this.asn.signature, "f");
      }
      return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_signature, "f");
    }
    get publicKey() {
      if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_publicKey, "f")) {
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_publicKey, new PublicKey2(this.asn.certificationRequestInfo.subjectPKInfo), "f");
      }
      return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_publicKey, "f");
    }
    get attributes() {
      if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_attributes, "f")) {
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_attributes, this.asn.certificationRequestInfo.attributes.map((o2) => AttributeFactory.create(AsnConvert.serialize(o2))), "f");
      }
      return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_attributes, "f");
    }
    get extensions() {
      if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_extensions, "f")) {
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_extensions, [], "f");
        const extensions2 = this.getAttribute(id_pkcs9_at_extensionRequest);
        if (extensions2 instanceof ExtensionsAttribute) {
          __classPrivateFieldSet(this, _Pkcs10CertificateRequest_extensions, extensions2.items, "f");
        }
      }
      return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_extensions, "f");
    }
    get tbs() {
      if (!__classPrivateFieldGet(this, _Pkcs10CertificateRequest_tbs, "f")) {
        __classPrivateFieldSet(this, _Pkcs10CertificateRequest_tbs, this.asn.certificationRequestInfoRaw || AsnConvert.serialize(this.asn.certificationRequestInfo), "f");
      }
      return __classPrivateFieldGet(this, _Pkcs10CertificateRequest_tbs, "f");
    }
    constructor(param) {
      const args = PemData.isAsnEncoded(param) ? [param, CertificationRequest] : [param];
      super(args[0], args[1]);
      _Pkcs10CertificateRequest_tbs.set(this, void 0);
      _Pkcs10CertificateRequest_subjectName.set(this, void 0);
      _Pkcs10CertificateRequest_subject.set(this, void 0);
      _Pkcs10CertificateRequest_signatureAlgorithm.set(this, void 0);
      _Pkcs10CertificateRequest_signature.set(this, void 0);
      _Pkcs10CertificateRequest_publicKey.set(this, void 0);
      _Pkcs10CertificateRequest_attributes.set(this, void 0);
      _Pkcs10CertificateRequest_extensions.set(this, void 0);
      this.tag = PemConverter.CertificateRequestTag;
    }
    onInit(_asn) {
    }
    getAttribute(type) {
      for (const attr of this.attributes) {
        if (attr.type === type) {
          return attr;
        }
      }
      return null;
    }
    getAttributes(type) {
      return this.attributes.filter((o2) => o2.type === type);
    }
    getExtension(type) {
      for (const ext of this.extensions) {
        if (ext.type === type) {
          return ext;
        }
      }
      return null;
    }
    getExtensions(type) {
      return this.extensions.filter((o2) => o2.type === type);
    }
    async verify(crypto2 = cryptoProvider.get()) {
      const algorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
      const publicKey2 = await this.publicKey.export(algorithm, ["verify"], crypto2);
      const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
      let signature = null;
      for (const signatureFormatter of signatureFormatters) {
        signature = signatureFormatter.toWebSignature(algorithm, this.signature);
        if (signature) {
          break;
        }
      }
      if (!signature) {
        throw Error("Cannot convert WebCrypto signature value to ASN.1 format");
      }
      const ok = await crypto2.subtle.verify(this.signatureAlgorithm, publicKey2, signature, this.tbs);
      return ok;
    }
    toTextObject() {
      const obj = this.toTextObjectEmpty();
      const req = AsnConvert.parse(this.rawData, CertificationRequest);
      const tbs = req.certificationRequestInfo;
      const data = new TextObject("", {
        "Version": `${Version[tbs.version]} (${tbs.version})`,
        "Subject": this.subject,
        "Subject Public Key Info": this.publicKey
      });
      if (this.attributes.length) {
        const attrs = new TextObject("");
        for (const ext of this.attributes) {
          const attrObj = ext.toTextObject();
          attrs[attrObj[TextObject.NAME]] = attrObj;
        }
        data["Attributes"] = attrs;
      }
      obj["Data"] = data;
      obj["Signature"] = new TextObject("", {
        "Algorithm": TextConverter.serializeAlgorithm(req.signatureAlgorithm),
        "": req.signature
      });
      return obj;
    }
  };
  _Pkcs10CertificateRequest_tbs = /* @__PURE__ */ new WeakMap(), _Pkcs10CertificateRequest_subjectName = /* @__PURE__ */ new WeakMap(), _Pkcs10CertificateRequest_subject = /* @__PURE__ */ new WeakMap(), _Pkcs10CertificateRequest_signatureAlgorithm = /* @__PURE__ */ new WeakMap(), _Pkcs10CertificateRequest_signature = /* @__PURE__ */ new WeakMap(), _Pkcs10CertificateRequest_publicKey = /* @__PURE__ */ new WeakMap(), _Pkcs10CertificateRequest_attributes = /* @__PURE__ */ new WeakMap(), _Pkcs10CertificateRequest_extensions = /* @__PURE__ */ new WeakMap();
  Pkcs10CertificateRequest.NAME = "PKCS#10 Certificate Request";
  var _X509Certificate_tbs;
  var _X509Certificate_serialNumber;
  var _X509Certificate_subjectName;
  var _X509Certificate_subject;
  var _X509Certificate_issuerName;
  var _X509Certificate_issuer;
  var _X509Certificate_notBefore;
  var _X509Certificate_notAfter;
  var _X509Certificate_signatureAlgorithm;
  var _X509Certificate_signature;
  var _X509Certificate_extensions;
  var _X509Certificate_publicKey;
  var X509Certificate = class extends PemData {
    get publicKey() {
      if (!__classPrivateFieldGet(this, _X509Certificate_publicKey, "f")) {
        __classPrivateFieldSet(this, _X509Certificate_publicKey, new PublicKey2(this.asn.tbsCertificate.subjectPublicKeyInfo), "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_publicKey, "f");
    }
    get serialNumber() {
      if (!__classPrivateFieldGet(this, _X509Certificate_serialNumber, "f")) {
        const tbs = this.asn.tbsCertificate;
        let serialNumberBytes = new Uint8Array(tbs.serialNumber);
        if (serialNumberBytes.length > 1 && serialNumberBytes[0] === 0 && serialNumberBytes[1] > 127) {
          serialNumberBytes = serialNumberBytes.slice(1);
        }
        __classPrivateFieldSet(this, _X509Certificate_serialNumber, import_pvtsutils6.Convert.ToHex(serialNumberBytes), "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_serialNumber, "f");
    }
    get subjectName() {
      if (!__classPrivateFieldGet(this, _X509Certificate_subjectName, "f")) {
        __classPrivateFieldSet(this, _X509Certificate_subjectName, new Name3(this.asn.tbsCertificate.subject), "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_subjectName, "f");
    }
    get subject() {
      if (!__classPrivateFieldGet(this, _X509Certificate_subject, "f")) {
        __classPrivateFieldSet(this, _X509Certificate_subject, this.subjectName.toString(), "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_subject, "f");
    }
    get issuerName() {
      if (!__classPrivateFieldGet(this, _X509Certificate_issuerName, "f")) {
        __classPrivateFieldSet(this, _X509Certificate_issuerName, new Name3(this.asn.tbsCertificate.issuer), "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_issuerName, "f");
    }
    get issuer() {
      if (!__classPrivateFieldGet(this, _X509Certificate_issuer, "f")) {
        __classPrivateFieldSet(this, _X509Certificate_issuer, this.issuerName.toString(), "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_issuer, "f");
    }
    get notBefore() {
      if (!__classPrivateFieldGet(this, _X509Certificate_notBefore, "f")) {
        const notBefore = this.asn.tbsCertificate.validity.notBefore.utcTime || this.asn.tbsCertificate.validity.notBefore.generalTime;
        if (!notBefore) {
          throw new Error("Cannot get 'notBefore' value");
        }
        __classPrivateFieldSet(this, _X509Certificate_notBefore, notBefore, "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_notBefore, "f");
    }
    get notAfter() {
      if (!__classPrivateFieldGet(this, _X509Certificate_notAfter, "f")) {
        const notAfter = this.asn.tbsCertificate.validity.notAfter.utcTime || this.asn.tbsCertificate.validity.notAfter.generalTime;
        if (!notAfter) {
          throw new Error("Cannot get 'notAfter' value");
        }
        __classPrivateFieldSet(this, _X509Certificate_notAfter, notAfter, "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_notAfter, "f");
    }
    get signatureAlgorithm() {
      if (!__classPrivateFieldGet(this, _X509Certificate_signatureAlgorithm, "f")) {
        const algProv = instance.resolve(diAlgorithmProvider);
        __classPrivateFieldSet(this, _X509Certificate_signatureAlgorithm, algProv.toWebAlgorithm(this.asn.signatureAlgorithm), "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_signatureAlgorithm, "f");
    }
    get signature() {
      if (!__classPrivateFieldGet(this, _X509Certificate_signature, "f")) {
        __classPrivateFieldSet(this, _X509Certificate_signature, this.asn.signatureValue, "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_signature, "f");
    }
    get extensions() {
      if (!__classPrivateFieldGet(this, _X509Certificate_extensions, "f")) {
        __classPrivateFieldSet(this, _X509Certificate_extensions, [], "f");
        if (this.asn.tbsCertificate.extensions) {
          __classPrivateFieldSet(this, _X509Certificate_extensions, this.asn.tbsCertificate.extensions.map((o2) => ExtensionFactory.create(AsnConvert.serialize(o2))), "f");
        }
      }
      return __classPrivateFieldGet(this, _X509Certificate_extensions, "f");
    }
    get tbs() {
      if (!__classPrivateFieldGet(this, _X509Certificate_tbs, "f")) {
        __classPrivateFieldSet(this, _X509Certificate_tbs, this.asn.tbsCertificateRaw || AsnConvert.serialize(this.asn.tbsCertificate), "f");
      }
      return __classPrivateFieldGet(this, _X509Certificate_tbs, "f");
    }
    constructor(param) {
      const args = PemData.isAsnEncoded(param) ? [param, Certificate] : [param];
      super(args[0], args[1]);
      _X509Certificate_tbs.set(this, void 0);
      _X509Certificate_serialNumber.set(this, void 0);
      _X509Certificate_subjectName.set(this, void 0);
      _X509Certificate_subject.set(this, void 0);
      _X509Certificate_issuerName.set(this, void 0);
      _X509Certificate_issuer.set(this, void 0);
      _X509Certificate_notBefore.set(this, void 0);
      _X509Certificate_notAfter.set(this, void 0);
      _X509Certificate_signatureAlgorithm.set(this, void 0);
      _X509Certificate_signature.set(this, void 0);
      _X509Certificate_extensions.set(this, void 0);
      _X509Certificate_publicKey.set(this, void 0);
      this.tag = PemConverter.CertificateTag;
    }
    onInit(_asn) {
    }
    getExtension(type) {
      for (const ext of this.extensions) {
        if (typeof type === "string") {
          if (ext.type === type) {
            return ext;
          }
        } else {
          if (ext instanceof type) {
            return ext;
          }
        }
      }
      return null;
    }
    getExtensions(type) {
      return this.extensions.filter((o2) => {
        if (typeof type === "string") {
          return o2.type === type;
        } else {
          return o2 instanceof type;
        }
      });
    }
    async verify(params = {}, crypto2 = cryptoProvider.get()) {
      let keyAlgorithm;
      let publicKey2;
      const paramsKey = params.publicKey;
      try {
        if (!paramsKey) {
          keyAlgorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
          publicKey2 = await this.publicKey.export(keyAlgorithm, ["verify"], crypto2);
        } else if ("publicKey" in paramsKey) {
          keyAlgorithm = { ...paramsKey.publicKey.algorithm, ...this.signatureAlgorithm };
          publicKey2 = await paramsKey.publicKey.export(keyAlgorithm, ["verify"], crypto2);
        } else if (paramsKey instanceof PublicKey2) {
          keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
          publicKey2 = await paramsKey.export(keyAlgorithm, ["verify"], crypto2);
        } else if (import_pvtsutils6.BufferSourceConverter.isBufferSource(paramsKey)) {
          const key = new PublicKey2(paramsKey);
          keyAlgorithm = { ...key.algorithm, ...this.signatureAlgorithm };
          publicKey2 = await key.export(keyAlgorithm, ["verify"], crypto2);
        } else {
          keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
          publicKey2 = paramsKey;
        }
      } catch (_e) {
        return false;
      }
      const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
      let signature = null;
      for (const signatureFormatter of signatureFormatters) {
        signature = signatureFormatter.toWebSignature(keyAlgorithm, this.signature);
        if (signature) {
          break;
        }
      }
      if (!signature) {
        throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
      }
      const ok = await crypto2.subtle.verify(this.signatureAlgorithm, publicKey2, signature, this.tbs);
      if (params.signatureOnly) {
        return ok;
      } else {
        const date = params.date || /* @__PURE__ */ new Date();
        const time = date.getTime();
        return ok && this.notBefore.getTime() < time && time < this.notAfter.getTime();
      }
    }
    async getThumbprint(...args) {
      let crypto2;
      let algorithm = "SHA-1";
      if (args[0]) {
        if (!args[0].subtle) {
          algorithm = args[0] || algorithm;
          crypto2 = args[1];
        } else {
          crypto2 = args[0];
        }
      }
      crypto2 !== null && crypto2 !== void 0 ? crypto2 : crypto2 = cryptoProvider.get();
      return await crypto2.subtle.digest(algorithm, this.rawData);
    }
    async isSelfSigned(crypto2 = cryptoProvider.get()) {
      return this.subject === this.issuer && await this.verify({ signatureOnly: true }, crypto2);
    }
    toTextObject() {
      const obj = this.toTextObjectEmpty();
      const cert = AsnConvert.parse(this.rawData, Certificate);
      const tbs = cert.tbsCertificate;
      const data = new TextObject("", {
        "Version": `${Version[tbs.version]} (${tbs.version})`,
        "Serial Number": tbs.serialNumber,
        "Signature Algorithm": TextConverter.serializeAlgorithm(tbs.signature),
        "Issuer": this.issuer,
        "Validity": new TextObject("", {
          "Not Before": tbs.validity.notBefore.getTime(),
          "Not After": tbs.validity.notAfter.getTime()
        }),
        "Subject": this.subject,
        "Subject Public Key Info": this.publicKey
      });
      if (tbs.issuerUniqueID) {
        data["Issuer Unique ID"] = tbs.issuerUniqueID;
      }
      if (tbs.subjectUniqueID) {
        data["Subject Unique ID"] = tbs.subjectUniqueID;
      }
      if (this.extensions.length) {
        const extensions2 = new TextObject("");
        for (const ext of this.extensions) {
          const extObj = ext.toTextObject();
          extensions2[extObj[TextObject.NAME]] = extObj;
        }
        data["Extensions"] = extensions2;
      }
      obj["Data"] = data;
      obj["Signature"] = new TextObject("", {
        "Algorithm": TextConverter.serializeAlgorithm(cert.signatureAlgorithm),
        "": cert.signatureValue
      });
      return obj;
    }
  };
  _X509Certificate_tbs = /* @__PURE__ */ new WeakMap(), _X509Certificate_serialNumber = /* @__PURE__ */ new WeakMap(), _X509Certificate_subjectName = /* @__PURE__ */ new WeakMap(), _X509Certificate_subject = /* @__PURE__ */ new WeakMap(), _X509Certificate_issuerName = /* @__PURE__ */ new WeakMap(), _X509Certificate_issuer = /* @__PURE__ */ new WeakMap(), _X509Certificate_notBefore = /* @__PURE__ */ new WeakMap(), _X509Certificate_notAfter = /* @__PURE__ */ new WeakMap(), _X509Certificate_signatureAlgorithm = /* @__PURE__ */ new WeakMap(), _X509Certificate_signature = /* @__PURE__ */ new WeakMap(), _X509Certificate_extensions = /* @__PURE__ */ new WeakMap(), _X509Certificate_publicKey = /* @__PURE__ */ new WeakMap();
  X509Certificate.NAME = "Certificate";
  function generateCertificateSerialNumber(input, crypto2 = cryptoProvider.get()) {
    const inputView = import_pvtsutils6.BufferSourceConverter.toUint8Array(import_pvtsutils6.Convert.FromHex(input || ""));
    let serialNumber = inputView && inputView.length && inputView.some((o2) => o2 > 0) ? new Uint8Array(inputView) : void 0;
    if (!serialNumber) {
      serialNumber = crypto2.getRandomValues(new Uint8Array(16));
    }
    let firstNonZero = 0;
    while (firstNonZero < serialNumber.length - 1 && serialNumber[firstNonZero] === 0) {
      firstNonZero++;
    }
    serialNumber = serialNumber.slice(firstNonZero);
    if (serialNumber[0] > 127) {
      const newSerialNumber = new Uint8Array(serialNumber.length + 1);
      newSerialNumber[0] = 0;
      newSerialNumber.set(serialNumber, 1);
      serialNumber = newSerialNumber;
    }
    return serialNumber.buffer;
  }
  var X509CertificateGenerator = class {
    static async createSelfSigned(params, crypto2 = cryptoProvider.get()) {
      if (!params.keys.privateKey) {
        throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");
      }
      if (!params.keys.publicKey) {
        throw new Error("Bad field 'keys' in 'params' argument. 'publicKey' is empty");
      }
      return this.create({
        serialNumber: params.serialNumber,
        subject: params.name,
        issuer: params.name,
        notBefore: params.notBefore,
        notAfter: params.notAfter,
        publicKey: params.keys.publicKey,
        signingKey: params.keys.privateKey,
        signingAlgorithm: params.signingAlgorithm,
        extensions: params.extensions
      }, crypto2);
    }
    static async create(params, crypto2 = cryptoProvider.get()) {
      var _a4;
      let spki;
      if (params.publicKey instanceof PublicKey2) {
        spki = params.publicKey.rawData;
      } else if ("publicKey" in params.publicKey) {
        spki = params.publicKey.publicKey.rawData;
      } else if (import_pvtsutils6.BufferSourceConverter.isBufferSource(params.publicKey)) {
        spki = params.publicKey;
      } else {
        spki = await crypto2.subtle.exportKey("spki", params.publicKey);
      }
      const serialNumber = generateCertificateSerialNumber(params.serialNumber);
      const notBefore = params.notBefore || /* @__PURE__ */ new Date();
      const notAfter = params.notAfter || new Date(notBefore.getTime() + 31536e6);
      const asnX509 = new Certificate({
        tbsCertificate: new TBSCertificate({
          version: Version.v3,
          serialNumber,
          validity: new Validity({
            notBefore,
            notAfter
          }),
          extensions: new Extensions(((_a4 = params.extensions) === null || _a4 === void 0 ? void 0 : _a4.map((o2) => AsnConvert.parse(o2.rawData, Extension))) || []),
          subjectPublicKeyInfo: AsnConvert.parse(spki, SubjectPublicKeyInfo)
        })
      });
      if (params.subject) {
        const name9 = params.subject instanceof Name3 ? params.subject : new Name3(params.subject);
        asnX509.tbsCertificate.subject = AsnConvert.parse(name9.toArrayBuffer(), Name);
      }
      if (params.issuer) {
        const name9 = params.issuer instanceof Name3 ? params.issuer : new Name3(params.issuer);
        asnX509.tbsCertificate.issuer = AsnConvert.parse(name9.toArrayBuffer(), Name);
      }
      const defaultSigningAlgorithm = {
        hash: "SHA-256"
      };
      const signatureAlgorithm = "signingKey" in params ? { ...defaultSigningAlgorithm, ...params.signingAlgorithm, ...params.signingKey.algorithm } : { ...defaultSigningAlgorithm, ...params.signingAlgorithm };
      const algProv = instance.resolve(diAlgorithmProvider);
      asnX509.tbsCertificate.signature = asnX509.signatureAlgorithm = algProv.toAsnAlgorithm(signatureAlgorithm);
      const tbs = AsnConvert.serialize(asnX509.tbsCertificate);
      const signatureValue = "signingKey" in params ? await crypto2.subtle.sign(signatureAlgorithm, params.signingKey, tbs) : params.signature;
      const signatureFormatters = instance.resolveAll(diAsnSignatureFormatter).reverse();
      let asnSignature = null;
      for (const signatureFormatter of signatureFormatters) {
        asnSignature = signatureFormatter.toAsnSignature(signatureAlgorithm, signatureValue);
        if (asnSignature) {
          break;
        }
      }
      if (!asnSignature) {
        throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
      }
      asnX509.signatureValue = asnSignature;
      return new X509Certificate(AsnConvert.serialize(asnX509));
    }
  };
  var _X509CrlEntry_serialNumber;
  var _X509CrlEntry_revocationDate;
  var _X509CrlEntry_reason;
  var _X509CrlEntry_invalidity;
  var _X509CrlEntry_extensions;
  var X509CrlReason;
  (function(X509CrlReason2) {
    X509CrlReason2[X509CrlReason2["unspecified"] = 0] = "unspecified";
    X509CrlReason2[X509CrlReason2["keyCompromise"] = 1] = "keyCompromise";
    X509CrlReason2[X509CrlReason2["cACompromise"] = 2] = "cACompromise";
    X509CrlReason2[X509CrlReason2["affiliationChanged"] = 3] = "affiliationChanged";
    X509CrlReason2[X509CrlReason2["superseded"] = 4] = "superseded";
    X509CrlReason2[X509CrlReason2["cessationOfOperation"] = 5] = "cessationOfOperation";
    X509CrlReason2[X509CrlReason2["certificateHold"] = 6] = "certificateHold";
    X509CrlReason2[X509CrlReason2["removeFromCRL"] = 8] = "removeFromCRL";
    X509CrlReason2[X509CrlReason2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
    X509CrlReason2[X509CrlReason2["aACompromise"] = 10] = "aACompromise";
  })(X509CrlReason || (X509CrlReason = {}));
  _X509CrlEntry_serialNumber = /* @__PURE__ */ new WeakMap(), _X509CrlEntry_revocationDate = /* @__PURE__ */ new WeakMap(), _X509CrlEntry_reason = /* @__PURE__ */ new WeakMap(), _X509CrlEntry_invalidity = /* @__PURE__ */ new WeakMap(), _X509CrlEntry_extensions = /* @__PURE__ */ new WeakMap();
  var _X509Crl_tbs;
  var _X509Crl_signatureAlgorithm;
  var _X509Crl_issuerName;
  var _X509Crl_thisUpdate;
  var _X509Crl_nextUpdate;
  var _X509Crl_entries;
  var _X509Crl_extensions;
  _X509Crl_tbs = /* @__PURE__ */ new WeakMap(), _X509Crl_signatureAlgorithm = /* @__PURE__ */ new WeakMap(), _X509Crl_issuerName = /* @__PURE__ */ new WeakMap(), _X509Crl_thisUpdate = /* @__PURE__ */ new WeakMap(), _X509Crl_nextUpdate = /* @__PURE__ */ new WeakMap(), _X509Crl_entries = /* @__PURE__ */ new WeakMap(), _X509Crl_extensions = /* @__PURE__ */ new WeakMap();
  ExtensionFactory.register(id_ce_basicConstraints, BasicConstraintsExtension);
  ExtensionFactory.register(id_ce_extKeyUsage, ExtendedKeyUsageExtension);
  ExtensionFactory.register(id_ce_keyUsage, KeyUsagesExtension);
  ExtensionFactory.register(id_ce_subjectKeyIdentifier, SubjectKeyIdentifierExtension);
  ExtensionFactory.register(id_ce_authorityKeyIdentifier, AuthorityKeyIdentifierExtension);
  ExtensionFactory.register(id_ce_subjectAltName, SubjectAlternativeNameExtension);
  ExtensionFactory.register(id_ce_cRLDistributionPoints, CRLDistributionPointsExtension);
  ExtensionFactory.register(id_pe_authorityInfoAccess, AuthorityInfoAccessExtension);
  ExtensionFactory.register(id_ce_issuerAltName, IssuerAlternativeNameExtension);
  AttributeFactory.register(id_pkcs9_at_challengePassword, ChallengePasswordAttribute);
  AttributeFactory.register(id_pkcs9_at_extensionRequest, ExtensionsAttribute);
  instance.registerSingleton(diAsnSignatureFormatter, AsnDefaultSignatureFormatter);
  instance.registerSingleton(diAsnSignatureFormatter, AsnEcSignatureFormatter);
  AsnEcSignatureFormatter.namedCurveSize.set("P-256", 32);
  AsnEcSignatureFormatter.namedCurveSize.set("K-256", 32);
  AsnEcSignatureFormatter.namedCurveSize.set("P-384", 48);
  AsnEcSignatureFormatter.namedCurveSize.set("P-521", 66);

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/listener.browser.js
  var WebRTCDirectListener = class extends TypedEventEmitter {
    async listen() {
      throw new UnimplementedError("WebRTCTransport.createListener");
    }
    getAddrs() {
      return [];
    }
    updateAnnounceAddrs() {
    }
    async close() {
    }
  };

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/sdp.js
  var multibaseDecoder = Object.values(bases).map((b) => b.decoder).reduce((d2, b) => d2.or(b));
  var fingerprintRegex = /^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;
  function getFingerprintFromSdp(sdp) {
    if (sdp == null) {
      return void 0;
    }
    const searchResult = sdp.match(fingerprintRegex);
    return searchResult?.groups?.fingerprint;
  }
  function certhash(ma) {
    const components = ma.getComponents();
    const certhash2 = components.find((c2) => c2.code === CODE_CERTHASH)?.value;
    if (certhash2 === void 0 || certhash2 === "") {
      throw new InvalidParametersError(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`);
    }
    return certhash2;
  }
  function decodeCerthash(certhash2) {
    return digest_exports.decode(multibaseDecoder.decode(certhash2));
  }
  function ma2Fingerprint(ma) {
    const multihashDecoded = decodeCerthash(certhash(ma));
    const prefix = toSupportedHashFunction(multihashDecoded.code);
    const fingerprint = multihashDecoded.digest.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    const sdp = fingerprint.match(/.{1,2}/g);
    if (sdp == null) {
      throw new InvalidFingerprintError(fingerprint, ma.toString());
    }
    return `${prefix} ${sdp.join(":").toUpperCase()}`;
  }
  function fingerprint2Ma(fingerprint) {
    const output = fingerprint.split(":").map((str) => parseInt(str, 16));
    const encoded = Uint8Array.from(output);
    const digest2 = create(sha256.code, encoded);
    return multiaddr(`/certhash/${base64url.encode(digest2.bytes)}`);
  }
  function toSupportedHashFunction(code8) {
    switch (code8) {
      case 17:
        return "sha-1";
      case 18:
        return "sha-256";
      case 19:
        return "sha-512";
      default:
        throw new UnsupportedHashAlgorithmError(code8);
    }
  }
  function serverAnswerFromMultiaddr(ma, ufrag) {
    const { host, port, type } = getNetConfig(ma);
    if (type !== "ip4" && type !== "ip6") {
      throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
    }
    const fingerprint = ma2Fingerprint(ma);
    const sdp = `v=0
o=- 0 0 IN IP${type === "ip4" ? 4 : 6} ${host}
s=-
t=0 0
a=ice-lite
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
c=IN IP${type === "ip4" ? 4 : 6} ${host}
a=mid:0
a=ice-options:ice2
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:${fingerprint}
a=setup:passive
a=sctp-port:5000
a=max-message-size:${MAX_MESSAGE_SIZE3}
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host
a=end-of-candidates
`;
    return {
      type: "answer",
      sdp
    };
  }
  function clientOfferFromMultiAddr(ma, ufrag) {
    const { host, port, type } = getNetConfig(ma);
    if (type !== "ip4" && type !== "ip6") {
      throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
    }
    const sdp = `v=0
o=- 0 0 IN IP${type === "ip4" ? 4 : 6} ${host}
s=-
c=IN IP${type === "ip4" ? 4 : 6} ${host}
t=0 0
a=ice-options:ice2,trickle
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:active
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=sctp-port:5000
a=max-message-size:${MAX_MESSAGE_SIZE3}
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host
a=end-of-candidates
`;
    return {
      type: "offer",
      sdp
    };
  }
  function munge(desc, ufrag) {
    if (desc.sdp === void 0) {
      throw new InvalidParametersError("Can't munge a missing SDP");
    }
    const lineBreak = desc.sdp.includes("\r\n") ? "\r\n" : "\n";
    try {
      desc.sdp = desc.sdp.replace(/\na=ice-ufrag:[^\n]*\n/, "\na=ice-ufrag:" + ufrag + lineBreak).replace(/\na=ice-pwd:[^\n]*\n/, "\na=ice-pwd:" + ufrag + lineBreak);
    } catch {
    }
    return desc;
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/generate-noise-prologue.js
  var PREFIX = fromString2("libp2p-webrtc-noise:");
  function generateNoisePrologue(localFingerprint, remoteAddr, role) {
    const localFpString = localFingerprint.trim().toLowerCase().replaceAll(":", "");
    const localFpArray = fromString2(localFpString, "hex");
    const local = create(sha256.code, localFpArray);
    const remote = multibaseDecoder.decode(certhash(remoteAddr));
    const byteLength = PREFIX.byteLength + local.bytes.byteLength + remote.byteLength;
    if (role === "server") {
      return concat([PREFIX, remote, local.bytes], byteLength);
    }
    return concat([PREFIX, local.bytes, remote], byteLength);
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/connect.js
  var CONNECTION_STATE_CHANGE_EVENT = isFirefox ? "iceconnectionstatechange" : "connectionstatechange";
  function isServer(options2, peerConnection) {
    return options2.role === "server";
  }
  async function connect(peerConnection, muxerFactory, ufrag, options2) {
    const handshakeDataChannel = peerConnection.createDataChannel("", { negotiated: true, id: 0 });
    try {
      if (options2.role === "client") {
        options2.log.trace("client creating local offer");
        const offerSdp = await peerConnection.createOffer();
        options2.log.trace("client created local offer %s", offerSdp.sdp);
        const mungedOfferSdp = munge(offerSdp, ufrag);
        options2.log.trace("client setting local offer %s", mungedOfferSdp.sdp);
        await peerConnection.setLocalDescription(mungedOfferSdp);
        const answerSdp = serverAnswerFromMultiaddr(options2.remoteAddr, ufrag);
        options2.log.trace("client setting server description %s", answerSdp.sdp);
        await peerConnection.setRemoteDescription(answerSdp);
      } else {
        const offerSdp = clientOfferFromMultiAddr(options2.remoteAddr, ufrag);
        options2.log.trace("server setting client %s %s", offerSdp.type, offerSdp.sdp);
        await peerConnection.setRemoteDescription(offerSdp);
        options2.log.trace("server creating local answer");
        const answerSdp = await peerConnection.createAnswer();
        options2.log.trace("server created local answer");
        const mungedAnswerSdp = munge(answerSdp, ufrag);
        options2.log.trace("server setting local description %s", answerSdp.sdp);
        await peerConnection.setLocalDescription(mungedAnswerSdp);
      }
      if (handshakeDataChannel.readyState !== "open") {
        options2.log.trace("%s wait for handshake channel to open, starting status %s", options2.role, handshakeDataChannel.readyState);
        await pEvent(handshakeDataChannel, "open", options2);
      }
      options2.log.trace("%s handshake channel opened", options2.role);
      if (isServer(options2, peerConnection)) {
        const remoteFingerprint = peerConnection.remoteFingerprint()?.value ?? "";
        options2.remoteAddr = options2.remoteAddr.encapsulate(fingerprint2Ma(remoteFingerprint));
      }
      const localFingerprint = getFingerprintFromSdp(peerConnection.localDescription?.sdp);
      if (localFingerprint == null) {
        throw new WebRTCTransportError("Could not get fingerprint from local description sdp");
      }
      options2.log.trace("%s performing noise handshake", options2.role);
      const noisePrologue = generateNoisePrologue(localFingerprint, options2.remoteAddr, options2.role);
      const connectionEncrypter = noise({ prologueBytes: noisePrologue })(options2);
      const handshakeStream = createStream2({
        channel: handshakeDataChannel,
        direction: "outbound",
        isHandshake: true,
        log: options2.log,
        ...options2.dataChannel ?? {}
      });
      const maConn = toMultiaddrConnection({
        // @ts-expect-error types are broken
        peerConnection,
        remoteAddr: options2.remoteAddr,
        metrics: options2.events,
        direction: options2.role === "client" ? "outbound" : "inbound",
        log: options2.logger.forComponent("libp2p:webrtc-direct:connection")
      });
      peerConnection.addEventListener(CONNECTION_STATE_CHANGE_EVENT, () => {
        switch (peerConnection.connectionState) {
          case "failed":
          case "disconnected":
          case "closed":
            maConn.close().catch((err2) => {
              options2.log.error("error closing connection - %e", err2);
              maConn.abort(err2);
            });
            break;
          default:
            break;
        }
      });
      options2.events?.increment({ peer_connection: true });
      if (options2.role === "client") {
        options2.log.trace("%s secure inbound", options2.role);
        const result2 = await connectionEncrypter.secureInbound(handshakeStream, {
          remotePeer: options2.remotePeer,
          signal: options2.signal,
          skipStreamMuxerNegotiation: true
        });
        options2.log.trace("%s upgrade outbound", options2.role);
        return await options2.upgrader.upgradeOutbound(maConn, {
          skipProtection: true,
          skipEncryption: true,
          remotePeer: result2.remotePeer,
          muxerFactory,
          signal: options2.signal
        });
      }
      options2.log.trace("%s secure outbound", options2.role);
      const result = await connectionEncrypter.secureOutbound(handshakeStream, {
        remotePeer: options2.remotePeer,
        signal: options2.signal,
        skipStreamMuxerNegotiation: true
      });
      maConn.remoteAddr = maConn.remoteAddr.encapsulate(`/p2p/${result.remotePeer}`);
      options2.log.trace("%s upgrade inbound", options2.role);
      await options2.upgrader.upgradeInbound(maConn, {
        skipProtection: true,
        skipEncryption: true,
        remotePeer: result.remotePeer,
        muxerFactory,
        signal: options2.signal
      });
    } catch (err2) {
      handshakeDataChannel.close();
      peerConnection.close();
      throw err2;
    }
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/get-rtcpeerconnection.browser.js
  async function createDialerRTCPeerConnection(role, ufrag, options2 = {}) {
    let certificate = options2.certificate;
    if (certificate == null) {
      certificate = await RTCPeerConnection.generateCertificate({
        name: "ECDSA",
        // @ts-expect-error missing from lib.dom.d.ts but required by chrome
        namedCurve: "P-256"
        // hash: sdp.toSupportedHashFunction(hashName)
      });
    }
    const rtcConfig = typeof options2.rtcConfiguration === "function" ? await options2.rtcConfiguration() : options2.rtcConfiguration;
    const peerConnection = new RTCPeerConnection({
      ...rtcConfig ?? {},
      certificates: [certificate]
    });
    const muxerFactory = new DataChannelMuxerFactory({
      peerConnection,
      metrics: options2.events,
      dataChannelOptions: options2.dataChannel
    });
    return {
      peerConnection,
      muxerFactory
    };
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/pem.js
  async function formatAsPem(privateKey) {
    const keyPair = await privateKeyToCryptoKeyPair(privateKey);
    const exported = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
    return [
      "-----BEGIN PRIVATE KEY-----",
      ...toString2(new Uint8Array(exported), "base64pad").split(/(.{64})/).filter(Boolean),
      "-----END PRIVATE KEY-----"
    ].join("\n");
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/transport.js
  var WebRTCDirectTransport = class {
    log;
    metrics;
    components;
    init;
    certificate;
    privateKey;
    emitter;
    renewCertificateTask;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:webrtc-direct");
      this.components = components;
      this.init = init;
      this.emitter = new TypedEventEmitter();
      if (init.certificateLifespan != null && init.certificateRenewalThreshold != null && init.certificateRenewalThreshold >= init.certificateLifespan) {
        throw new InvalidParametersError("Certificate renewal threshold must be less than certificate lifespan");
      }
      if (components.metrics != null) {
        this.metrics = {
          dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total", {
            label: "event",
            help: "Total count of WebRTC-direct dial events by type"
          })
        };
      }
    }
    [transportSymbol] = true;
    [Symbol.toStringTag] = "@libp2p/webrtc-direct";
    [serviceCapabilities] = [
      "@libp2p/transport"
    ];
    async start() {
      this.certificate = await this.getCertificate();
    }
    async stop() {
      if (this.renewCertificateTask != null) {
        clearTimeout(this.renewCertificateTask);
      }
      this.certificate = void 0;
    }
    /**
     * Dial a given multiaddr
     */
    async dial(ma, options2) {
      this.log("dial %a", ma);
      options2.signal.throwIfAborted();
      let theirPeerId;
      const remotePeerString = ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
      if (remotePeerString != null) {
        theirPeerId = peerIdFromString(remotePeerString);
      }
      const ufrag = genUfrag();
      const { peerConnection, muxerFactory } = await createDialerRTCPeerConnection("client", ufrag, {
        rtcConfiguration: typeof this.init.rtcConfiguration === "function" ? await this.init.rtcConfiguration() : this.init.rtcConfiguration ?? {},
        dataChannel: this.init.dataChannel
      });
      try {
        return await connect(peerConnection, muxerFactory, ufrag, {
          role: "client",
          log: this.log,
          logger: this.components.logger,
          events: this.metrics?.dialerEvents,
          signal: options2.signal,
          remoteAddr: ma,
          dataChannel: this.init.dataChannel,
          upgrader: options2.upgrader,
          peerId: this.components.peerId,
          remotePeer: theirPeerId,
          privateKey: this.components.privateKey
        });
      } catch (err2) {
        peerConnection.close();
        throw err2;
      }
    }
    /**
     * Create a transport listener - this will throw in browsers
     */
    createListener(options2) {
      if (this.certificate == null) {
        throw new NotStartedError();
      }
      return new WebRTCDirectListener(this.components, {
        ...this.init,
        ...options2,
        certificate: this.certificate,
        emitter: this.emitter
      });
    }
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs) {
      return multiaddrs.filter(WebRTCDirect.exactMatch);
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs) {
      return this.listenFilter(multiaddrs);
    }
    async getCertificate(forceRenew) {
      if (isTransportCertificate(this.init.certificate)) {
        this.log("using provided TLS certificate");
        return this.init.certificate;
      }
      const privateKey = await this.loadOrCreatePrivateKey();
      const { pem, certhash: certhash2 } = await this.loadOrCreateCertificate(privateKey, forceRenew);
      return {
        privateKey: await formatAsPem(privateKey),
        pem,
        certhash: certhash2
      };
    }
    async loadOrCreatePrivateKey() {
      if (this.privateKey != null) {
        return this.privateKey;
      }
      const keychainName = this.init.certificateKeychainName ?? DEFAULT_CERTIFICATE_PRIVATE_KEY_NAME;
      const keychain2 = this.getKeychain();
      try {
        if (keychain2 == null) {
          this.log("no keychain configured - not checking for stored private key");
          throw new NotFoundError();
        }
        this.log.trace("checking for stored private key");
        this.privateKey = await keychain2.exportKey(keychainName);
      } catch (err2) {
        if (err2.name !== "NotFoundError") {
          throw err2;
        }
        this.log.trace("generating private key");
        this.privateKey = await generateKeyPair("ECDSA", "P-256");
        if (keychain2 != null) {
          this.log.trace("storing private key");
          await keychain2.importKey(keychainName, this.privateKey);
        } else {
          this.log("no keychain configured - not storing private key");
        }
      }
      return this.privateKey;
    }
    async loadOrCreateCertificate(privateKey, forceRenew) {
      if (this.certificate != null && forceRenew !== true) {
        return this.certificate;
      }
      let cert;
      const dsKey = new Key(this.init.certificateDatastoreKey ?? DEFAULT_CERTIFICATE_DATASTORE_KEY);
      const keyPair = await privateKeyToCryptoKeyPair(privateKey);
      try {
        if (forceRenew === true) {
          this.log.trace("forcing renewal of TLS certificate");
          throw new NotFoundError();
        }
        this.log.trace("checking for stored TLS certificate");
        cert = await this.loadCertificate(dsKey, keyPair);
      } catch (err2) {
        if (err2.name !== "NotFoundError") {
          throw err2;
        }
        this.log.trace("generating new TLS certificate");
        cert = await this.createCertificate(dsKey, keyPair);
      }
      let renewTime = cert.notAfter.getTime() - (this.init.certificateRenewalThreshold ?? DEFAULT_CERTIFICATE_RENEWAL_THRESHOLD) - Date.now();
      if (renewTime < 0) {
        renewTime = 100;
      }
      this.log("will renew TLS certificate after %d ms", renewTime);
      this.renewCertificateTask = setTimeout(() => {
        this.log("renewing TLS certificate");
        this.getCertificate(true).then((cert2) => {
          this.certificate = cert2;
          this.emitter.safeDispatchEvent("certificate:renew", {
            detail: cert2
          });
        }).catch((err2) => {
          this.log.error("could not renew certificate - %e", err2);
        });
      }, renewTime);
      return {
        pem: cert.toString("pem"),
        certhash: base64url.encode((await sha256.digest(new Uint8Array(cert.rawData))).bytes)
      };
    }
    async loadCertificate(dsKey, keyPair) {
      const buf2 = await this.components.datastore.get(dsKey);
      const cert = new X509Certificate(buf2);
      const expiryTime = cert.notAfter.getTime() - (this.init.certificateRenewalThreshold ?? DEFAULT_CERTIFICATE_RENEWAL_THRESHOLD);
      if (Date.now() > expiryTime) {
        this.log("stored TLS certificate has expired");
        throw new NotFoundError();
      }
      this.log("loaded certificate, expires in %d ms", expiryTime);
      const exportedCertKey = await cert.publicKey.export(crypto);
      const rawCertKey = await crypto.subtle.exportKey("raw", exportedCertKey);
      const rawKeyPairKey = await crypto.subtle.exportKey("raw", keyPair.publicKey);
      if (!equals3(new Uint8Array(rawCertKey, 0, rawCertKey.byteLength), new Uint8Array(rawKeyPairKey, 0, rawKeyPairKey.byteLength))) {
        this.log("stored TLS certificate public key did not match public key from private key");
        throw new NotFoundError();
      }
      this.log("loaded certificate, expiry time is %o", expiryTime);
      return cert;
    }
    async createCertificate(dsKey, keyPair) {
      const notBefore = /* @__PURE__ */ new Date();
      const notAfter = new Date(Date.now() + (this.init.certificateLifespan ?? DEFAULT_CERTIFICATE_LIFESPAN));
      notBefore.setMilliseconds(0);
      notAfter.setMilliseconds(0);
      const cert = await X509CertificateGenerator.createSelfSigned({
        serialNumber: (BigInt(Math.random().toString().replace(".", "")) * 100000n).toString(16),
        name: "CN=example.com, C=US, L=CA, O=example, ST=CA",
        notBefore,
        notAfter,
        keys: keyPair,
        extensions: [
          new BasicConstraintsExtension(false, void 0, true)
        ]
      }, crypto);
      if (this.getKeychain() != null) {
        this.log.trace("storing TLS certificate");
        await this.components.datastore.put(dsKey, fromString2(cert.toString("pem")));
      } else {
        this.log("no keychain is configured so not storing TLS certificate since the private key will not be reused");
      }
      return cert;
    }
    getKeychain() {
      try {
        return this.components.keychain;
      } catch {
      }
    }
  };
  function isTransportCertificate(obj) {
    if (obj == null) {
      return false;
    }
    return typeof obj.privateKey === "string" && typeof obj.pem === "string" && typeof obj.certhash === "string";
  }

  // node_modules/@libp2p/webrtc/dist/src/index.js
  function webRTCDirect(init) {
    return (components) => new WebRTCDirectTransport(components, init);
  }
  function webRTC(init) {
    return (components) => new WebRTCTransport(components, init);
  }

  // node_modules/@libp2p/websockets/dist/src/listener.browser.js
  function createListener2() {
    throw new Error("WebSocket Servers can not be created in the browser!");
  }

  // node_modules/@libp2p/websockets/dist/src/websocket-to-conn.js
  var DEFAULT_MAX_BUFFERED_AMOUNT = 1024 * 1024 * 4;
  var DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL = 10;
  var WebSocketMultiaddrConnection = class extends AbstractMultiaddrConnection {
    websocket;
    maxBufferedAmount;
    checkBufferedAmountTask;
    constructor(init) {
      super(init);
      this.websocket = init.websocket;
      this.maxBufferedAmount = init.maxBufferedAmount ?? DEFAULT_MAX_BUFFERED_AMOUNT;
      this.checkBufferedAmountTask = repeatingTask(this.checkBufferedAmount.bind(this), init.bufferedAmountPollInterval ?? DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL);
      this.websocket.addEventListener("close", (evt) => {
        this.log('closed - code %d, reason "%s", wasClean %s', evt.code, evt.reason, evt.wasClean);
        this.checkBufferedAmountTask.stop();
        if (!evt.wasClean) {
          this.onRemoteReset();
          return;
        }
        this.onTransportClosed();
      }, { once: true });
      this.websocket.addEventListener("message", (evt) => {
        try {
          let buf2;
          if (typeof evt.data === "string") {
            buf2 = fromString2(evt.data);
          } else if (evt.data instanceof ArrayBuffer) {
            buf2 = new Uint8Array(evt.data, 0, evt.data.byteLength);
          } else {
            this.abort(new Error("Incorrect binary type"));
            return;
          }
          this.onData(buf2);
        } catch (err2) {
          this.log.error("error receiving data - %e", err2);
        }
      });
    }
    sendData(data) {
      for (const buf2 of data) {
        this.websocket.send(buf2);
      }
      const canSendMore = this.websocket.bufferedAmount < this.maxBufferedAmount;
      if (!canSendMore) {
        this.checkBufferedAmountTask.start();
      }
      return {
        sentBytes: data.byteLength,
        canSendMore
      };
    }
    sendReset() {
      this.websocket.close(1006);
    }
    async sendClose(options2) {
      this.websocket.close();
      options2?.signal?.throwIfAborted();
    }
    sendPause() {
    }
    sendResume() {
    }
    checkBufferedAmount() {
      this.log("buffered amount now %d", this.websocket.bufferedAmount);
      if (this.websocket.bufferedAmount === 0) {
        this.checkBufferedAmountTask.stop();
        this.safeDispatchEvent("drain");
      }
    }
  };
  function webSocketToMaConn(init) {
    return new WebSocketMultiaddrConnection(init);
  }

  // node_modules/@libp2p/websockets/dist/src/index.js
  var WebSockets2 = class {
    log;
    init;
    logger;
    metrics;
    components;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:websockets");
      this.logger = components.logger;
      this.components = components;
      this.init = init;
      if (components.metrics != null) {
        this.metrics = {
          dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
            label: "event",
            help: "Total count of WebSockets dialer events by type"
          })
        };
      }
    }
    [transportSymbol] = true;
    [Symbol.toStringTag] = "@libp2p/websockets";
    [serviceCapabilities] = [
      "@libp2p/transport"
    ];
    async dial(ma, options2) {
      this.log("dialing %s", ma);
      options2 = options2 ?? {};
      const maConn = webSocketToMaConn({
        websocket: await this._connect(ma, options2),
        remoteAddr: ma,
        metrics: this.metrics?.dialerEvents,
        direction: "outbound",
        log: this.components.logger.forComponent("libp2p:websockets:connection"),
        maxBufferedAmount: this.init.maxBufferedAmount,
        bufferedAmountPollInterval: this.init.bufferedAmountPollInterval
      });
      this.log("new outbound connection %s", maConn.remoteAddr);
      const conn = await options2.upgrader.upgradeOutbound(maConn, options2);
      this.log("outbound connection %s upgraded", maConn.remoteAddr);
      return conn;
    }
    async _connect(ma, options2) {
      options2?.signal?.throwIfAborted();
      const uri = multiaddrToUri(ma);
      this.log("create websocket connection to %s", uri);
      const websocket = new WebSocket(uri);
      websocket.binaryType = "arraybuffer";
      try {
        options2.onProgress?.(new CustomProgressEvent("websockets:open-connection"));
        await pEvent(websocket, "open", options2);
      } catch (err2) {
        if (options2.signal?.aborted) {
          this.metrics?.dialerEvents.increment({ abort: true });
          throw new ConnectionFailedError(`Could not connect to ${uri}`);
        } else {
          this.metrics?.dialerEvents.increment({ error: true });
        }
        try {
          websocket.close();
        } catch {
        }
        throw err2;
      }
      this.log("connected %s", ma);
      this.metrics?.dialerEvents.increment({ connect: true });
      return websocket;
    }
    /**
     * Creates a WebSockets listener. The provided `handler` function will be called
     * anytime a new incoming Connection has been successfully upgraded via
     * `upgrader.upgradeInbound`
     */
    createListener(options2) {
      return createListener2({
        logger: this.logger,
        events: this.components.events,
        metrics: this.components.metrics
      }, {
        ...this.init,
        ...options2
      });
    }
    listenFilter(multiaddrs) {
      return multiaddrs.filter((ma) => WebSockets.exactMatch(ma) || WebSocketsSecure.exactMatch(ma));
    }
    dialFilter(multiaddrs) {
      return this.listenFilter(multiaddrs);
    }
  };
  function webSockets(init = {}) {
    return (components) => {
      return new WebSockets2(components, init);
    };
  }

  // node_modules/ipns/dist/src/selector.js
  var import_timestamp_nano3 = __toESM(require_timestamp_min(), 1);
  function ipnsSelector(key, data) {
    const entries = data.map((buf2, index) => ({
      record: unmarshalIPNSRecord(buf2),
      index
    }));
    entries.sort((a2, b) => {
      const aSeq = a2.record.sequence;
      const bSeq = b.record.sequence;
      if (aSeq > bSeq) {
        return -1;
      } else if (aSeq < bSeq) {
        return 1;
      }
      if (a2.record.validityType === IpnsEntry.ValidityType.EOL && b.record.validityType === IpnsEntry.ValidityType.EOL) {
        const recordAValidityDate = import_timestamp_nano3.default.fromString(a2.record.validity).toDate();
        const recordBValidityDate = import_timestamp_nano3.default.fromString(b.record.validity).toDate();
        if (recordAValidityDate.getTime() > recordBValidityDate.getTime()) {
          return -1;
        }
        if (recordAValidityDate.getTime() < recordBValidityDate.getTime()) {
          return 1;
        }
      }
      return 0;
    });
    return entries[0].index;
  }

  // node_modules/helia/dist/src/version.js
  var version2 = "6.0.8";
  var name8 = "helia";

  // node_modules/helia/dist/src/utils/bootstrappers.js
  var bootstrapConfig = {
    list: [
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
      // va1 is not in the TXT records for _dnsaddr.bootstrap.libp2p.io yet
      // so use the host name directly
      "/dnsaddr/va1.bootstrap.libp2p.io/p2p/12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8",
      "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"
    ]
  };

  // node_modules/helia/dist/src/utils/libp2p-defaults.browser.js
  function libp2pDefaults(options2 = {}) {
    const agentVersion = `${name8}/${version2} ${userAgent()}`;
    return {
      privateKey: options2.privateKey,
      dns: options2.dns,
      nodeInfo: {
        userAgent: agentVersion
      },
      addresses: {
        listen: [
          "/p2p-circuit",
          "/webrtc"
        ]
      },
      transports: [
        circuitRelayTransport(),
        webRTC(),
        webRTCDirect(),
        webSockets()
      ],
      connectionEncrypters: [
        noise()
      ],
      streamMuxers: [
        yamux(),
        mplex()
      ],
      peerDiscovery: [
        bootstrap(bootstrapConfig)
      ],
      services: {
        autoNAT: autoNAT(),
        dcutr: dcutr(),
        delegatedRouting: () => createDelegatedRoutingV1HttpApiClient("https://delegated-ipfs.dev", delegatedHTTPRoutingDefaults()),
        dht: kadDHT({
          clientMode: true,
          validators: {
            ipns: ipnsValidator
          },
          selectors: {
            ipns: ipnsSelector
          }
        }),
        identify: identify(),
        identifyPush: identifyPush(),
        keychain: keychain(options2.keychain),
        ping: ping(),
        http: http()
      }
    };
  }

  // node_modules/helia/dist/src/utils/libp2p.js
  async function createLibp2p2(options2) {
    const libp2pOptions = options2.libp2p ?? {};
    if (libp2pOptions.privateKey == null && options2.datastore != null) {
      libp2pOptions.privateKey = await loadOrCreateSelfKey(options2.datastore, options2.keychain);
    }
    const defaults2 = libp2pDefaults(libp2pOptions);
    defaults2.datastore = defaults2.datastore ?? options2.datastore;
    const node = await createLibp2p({
      ...defaults2,
      ...libp2pOptions,
      start: false
    });
    return node;
  }

  // node_modules/helia/dist/src/utils/helia-defaults.js
  async function heliaDefaults(init = {}) {
    const datastore = init.datastore ?? new MemoryDatastore();
    const blockstore = init.blockstore ?? new MemoryBlockstore();
    let libp2p;
    if (isLibp2p(init.libp2p)) {
      libp2p = init.libp2p;
    } else {
      libp2p = await createLibp2p2({
        ...init,
        libp2p: {
          dns: init.dns,
          ...init.libp2p,
          // ignore the libp2p start parameter as it should be on the main init
          // object instead
          start: void 0
        },
        datastore
      });
    }
    return {
      ...init,
      libp2p,
      datastore,
      blockstore,
      blockBrokers: init.blockBrokers ?? [
        trustlessGateway(),
        bitswap()
      ],
      routers: init.routers ?? [
        libp2pRouting(libp2p),
        httpGatewayRouting()
      ],
      metrics: libp2p.metrics
    };
  }

  // node_modules/helia/dist/src/index.js
  async function createHelia(init = {}) {
    const options2 = await heliaDefaults(init);
    const helia2 = new Helia(options2);
    if (options2.start !== false) {
      await helia2.start();
    }
    return helia2;
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/libp2p-defaults.browser.js
  function getLibp2pConfig() {
    const libp2pDefaultOptions = libp2pDefaults();
    libp2pDefaultOptions.start = false;
    libp2pDefaultOptions.addresses = { listen: [] };
    libp2pDefaultOptions.transports = [webRTCDirect(), webSockets()];
    libp2pDefaultOptions.peerDiscovery = [];
    const services = {
      dcutr: libp2pDefaultOptions.services.dcutr,
      identify: libp2pDefaultOptions.services.identify,
      keychain: libp2pDefaultOptions.services.keychain,
      ping: libp2pDefaultOptions.services.ping
    };
    return {
      ...libp2pDefaultOptions,
      start: false,
      services
    };
  }

  // node_modules/quick-lru/index.js
  var QuickLRU = class extends Map {
    #size = 0;
    #cache = /* @__PURE__ */ new Map();
    #oldCache = /* @__PURE__ */ new Map();
    #maxSize;
    #maxAge;
    #onEviction;
    constructor(options2 = {}) {
      super();
      if (!(options2.maxSize && options2.maxSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      if (typeof options2.maxAge === "number" && options2.maxAge === 0) {
        throw new TypeError("`maxAge` must be a number greater than 0");
      }
      this.#maxSize = options2.maxSize;
      this.#maxAge = options2.maxAge || Number.POSITIVE_INFINITY;
      this.#onEviction = options2.onEviction;
    }
    // For tests.
    get __oldCache() {
      return this.#oldCache;
    }
    #emitEvictions(cache3) {
      if (typeof this.#onEviction !== "function") {
        return;
      }
      for (const [key, item] of cache3) {
        this.#onEviction(key, item.value);
      }
    }
    #deleteIfExpired(key, item) {
      if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
        if (typeof this.#onEviction === "function") {
          this.#onEviction(key, item.value);
        }
        return this.delete(key);
      }
      return false;
    }
    #getOrDeleteIfExpired(key, item) {
      const deleted = this.#deleteIfExpired(key, item);
      if (deleted === false) {
        return item.value;
      }
    }
    #getItemValue(key, item) {
      return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
    }
    #peek(key, cache3) {
      const item = cache3.get(key);
      return this.#getItemValue(key, item);
    }
    #set(key, value2) {
      this.#cache.set(key, value2);
      this.#size++;
      if (this.#size >= this.#maxSize) {
        this.#size = 0;
        this.#emitEvictions(this.#oldCache);
        this.#oldCache = this.#cache;
        this.#cache = /* @__PURE__ */ new Map();
      }
    }
    #moveToRecent(key, item) {
      this.#oldCache.delete(key);
      this.#set(key, item);
    }
    *#entriesAscending() {
      for (const item of this.#oldCache) {
        const [key, value2] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value2);
          if (deleted === false) {
            yield item;
          }
        }
      }
      for (const item of this.#cache) {
        const [key, value2] = item;
        const deleted = this.#deleteIfExpired(key, value2);
        if (deleted === false) {
          yield item;
        }
      }
    }
    get(key) {
      if (this.#cache.has(key)) {
        const item = this.#cache.get(key);
        return this.#getItemValue(key, item);
      }
      if (this.#oldCache.has(key)) {
        const item = this.#oldCache.get(key);
        if (this.#deleteIfExpired(key, item) === false) {
          this.#moveToRecent(key, item);
          return item.value;
        }
      }
    }
    set(key, value2, { maxAge = this.#maxAge } = {}) {
      const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
      if (this.#cache.has(key)) {
        this.#cache.set(key, {
          value: value2,
          expiry
        });
      } else {
        this.#set(key, { value: value2, expiry });
      }
      return this;
    }
    has(key) {
      if (this.#cache.has(key)) {
        return !this.#deleteIfExpired(key, this.#cache.get(key));
      }
      if (this.#oldCache.has(key)) {
        return !this.#deleteIfExpired(key, this.#oldCache.get(key));
      }
      return false;
    }
    peek(key) {
      if (this.#cache.has(key)) {
        return this.#peek(key, this.#cache);
      }
      if (this.#oldCache.has(key)) {
        return this.#peek(key, this.#oldCache);
      }
    }
    expiresIn(key) {
      const item = this.#cache.get(key) ?? this.#oldCache.get(key);
      if (item) {
        return item.expiry ? item.expiry - Date.now() : Number.POSITIVE_INFINITY;
      }
    }
    delete(key) {
      const deleted = this.#cache.delete(key);
      if (deleted) {
        this.#size--;
      }
      return this.#oldCache.delete(key) || deleted;
    }
    clear() {
      this.#cache.clear();
      this.#oldCache.clear();
      this.#size = 0;
    }
    resize(newSize) {
      if (!(newSize && newSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      const items = [...this.#entriesAscending()];
      const removeCount = items.length - newSize;
      if (removeCount < 0) {
        this.#cache = new Map(items);
        this.#oldCache = /* @__PURE__ */ new Map();
        this.#size = items.length;
      } else {
        if (removeCount > 0) {
          this.#emitEvictions(items.slice(0, removeCount));
        }
        this.#oldCache = new Map(items.slice(removeCount));
        this.#cache = /* @__PURE__ */ new Map();
        this.#size = 0;
      }
      this.#maxSize = newSize;
    }
    evict(count = 1) {
      const requested = Number(count);
      if (!requested || requested <= 0) {
        return;
      }
      const items = [...this.#entriesAscending()];
      const evictCount = Math.trunc(Math.min(requested, Math.max(items.length - 1, 0)));
      if (evictCount <= 0) {
        return;
      }
      this.#emitEvictions(items.slice(0, evictCount));
      this.#oldCache = new Map(items.slice(evictCount));
      this.#cache = /* @__PURE__ */ new Map();
      this.#size = 0;
    }
    *keys() {
      for (const [key] of this) {
        yield key;
      }
    }
    *values() {
      for (const [, value2] of this) {
        yield value2;
      }
    }
    *[Symbol.iterator]() {
      for (const item of this.#cache) {
        const [key, value2] = item;
        const deleted = this.#deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
      for (const item of this.#oldCache) {
        const [key, value2] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value2);
          if (deleted === false) {
            yield [key, value2.value];
          }
        }
      }
    }
    *entriesDescending() {
      let items = [...this.#cache];
      for (let i2 = items.length - 1; i2 >= 0; --i2) {
        const item = items[i2];
        const [key, value2] = item;
        const deleted = this.#deleteIfExpired(key, value2);
        if (deleted === false) {
          yield [key, value2.value];
        }
      }
      items = [...this.#oldCache];
      for (let i2 = items.length - 1; i2 >= 0; --i2) {
        const item = items[i2];
        const [key, value2] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value2);
          if (deleted === false) {
            yield [key, value2.value];
          }
        }
      }
    }
    *entriesAscending() {
      for (const [key, value2] of this.#entriesAscending()) {
        yield [key, value2.value];
      }
    }
    get size() {
      if (!this.#size) {
        return this.#oldCache.size;
      }
      let oldCacheSize = 0;
      for (const key of this.#oldCache.keys()) {
        if (!this.#cache.has(key)) {
          oldCacheSize++;
        }
      }
      return Math.min(this.#size + oldCacheSize, this.#maxSize);
    }
    get maxSize() {
      return this.#maxSize;
    }
    get maxAge() {
      return this.#maxAge;
    }
    entries() {
      return this.entriesAscending();
    }
    forEach(callbackFunction, thisArgument = this) {
      for (const [key, value2] of this.entriesAscending()) {
        callbackFunction.call(thisArgument, value2, key, this);
      }
    }
    get [Symbol.toStringTag]() {
      return "QuickLRU";
    }
    toString() {
      return `QuickLRU(${this.size}/${this.maxSize})`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  };

  // node_modules/@helia/dnslink/dist/src/constants.js
  var CACHE_SIZE = 1e3;
  var CACHE_MAX_AGE = 3e4;
  var CACHE_MAX_ANSWERS = 10;

  // node_modules/@helia/dnslink/dist/src/errors.js
  var DNSLinkNotFoundError = class extends Error {
    static name = "DNSLinkNotFoundError";
    constructor(message2 = "DNSLink not found") {
      super(message2);
      this.name = "DNSLinkNotFoundError";
    }
  };
  var InvalidNamespaceError = class extends Error {
    static name = "InvalidNamespaceError";
    constructor(message2 = "Invalid namespace") {
      super(message2);
      this.name = "InvalidNamespaceError";
    }
  };

  // node_modules/@helia/dnslink/dist/src/namespaces/ipfs.js
  var ipfs = (value2, answer) => {
    const [, protocol, cid, ...rest] = value2.split("/");
    if (protocol !== "ipfs") {
      throw new InvalidNamespaceError(`Namespace ${protocol} was not "ipfs"`);
    }
    return {
      namespace: "ipfs",
      cid: CID.parse(cid),
      path: rest.length > 0 ? `/${rest.join("/")}` : "",
      answer
    };
  };

  // node_modules/@helia/dnslink/dist/src/namespaces/ipns.js
  var ipns = (value2, answer) => {
    const [, protocol, peerId, ...rest] = value2.split("/");
    if (protocol !== "ipns") {
      throw new InvalidNamespaceError(`Namespace ${protocol} was not "ipns"`);
    }
    return {
      namespace: "ipns",
      peerId: peerIdFromString(peerId),
      path: rest.length > 0 ? `/${rest.join("/")}` : "",
      answer
    };
  };

  // node_modules/@helia/dnslink/dist/src/dnslink.js
  var DNSLink = class {
    dns;
    log;
    namespaces;
    cache;
    cacheMaxAnswers;
    constructor(components, init = {}) {
      this.dns = components.dns;
      this.log = components.logger.forComponent("helia:dnslink");
      this.namespaces = {
        ipfs,
        ipns,
        ...init.namespaces
      };
      this.cache = new QuickLRU({
        maxSize: init.cacheSize ?? CACHE_SIZE,
        maxAge: init.cacheMaxAge ?? CACHE_MAX_AGE
      });
      this.cacheMaxAnswers = init.cacheMaxAnswers ?? CACHE_MAX_ANSWERS;
    }
    async resolve(domain, options2 = {}) {
      if (options2.nocache !== true) {
        const cached = this.cache.get(domain);
        if (cached != null) {
          const answers = [...cached.values()];
          if (answers.length > 0) {
            return answers;
          }
        }
      }
      const result = await this.recursiveResolveDomain(domain, options2.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH, options2);
      const cache3 = new QuickLRU({
        maxSize: this.cacheMaxAnswers
      });
      result.forEach((result2, index) => {
        cache3.set(index, result2, {
          maxAge: result2.answer.TTL * 1e3
        });
      });
      let maxTTL = result.reduce((acc, curr) => {
        const ttl = curr.answer.TTL * 1e3;
        if (ttl > acc) {
          return ttl;
        }
        return acc;
      }, 0);
      if (this.cache.maxAge < maxTTL) {
        maxTTL = this.cache.maxAge;
      }
      this.cache.set(domain, cache3, {
        maxAge: maxTTL
      });
      return result;
    }
    async recursiveResolveDomain(domain, depth, options2 = {}) {
      if (depth === 0) {
        throw new Error("recursion limit exceeded");
      }
      if (!domain.startsWith("_dnslink.")) {
        domain = `_dnslink.${domain}`;
      }
      try {
        return await this.recursiveResolveDnslink(domain, depth, options2);
      } catch (err2) {
        if (err2.code !== "ENOTFOUND" && err2.code !== "ENODATA" && err2.name !== "DNSLinkNotFoundError" && err2.name !== "NotFoundError") {
          throw err2;
        }
        if (domain.startsWith("_dnslink.")) {
          domain = domain.replace("_dnslink.", "");
        } else {
          domain = `_dnslink.${domain}`;
        }
        return this.recursiveResolveDnslink(domain, depth, options2);
      }
    }
    async recursiveResolveDnslink(domain, depth, options2 = {}) {
      if (depth === 0) {
        throw new Error("recursion limit exceeded");
      }
      this.log("query %s for TXT and CNAME records", domain);
      const txtRecordsResponse = await this.dns.query(domain, {
        ...options2,
        types: [
          RecordType.TXT
        ]
      });
      const txtRecords = (txtRecordsResponse?.Answer ?? []).sort((a2, b) => a2.data.localeCompare(b.data));
      this.log("found %d TXT records for %s", txtRecords.length, domain);
      const output = [];
      for (const answer of txtRecords) {
        try {
          let result = answer.data;
          if (result.startsWith('"') && result.endsWith('"')) {
            result = result.substring(1, result.length - 1);
          }
          if (!result.startsWith("dnslink=")) {
            continue;
          }
          this.log("%s TXT %s", answer.name, result);
          result = result.replace("dnslink=", "");
          const [, protocol, domainOrCID] = result.split("/");
          if (protocol === "dnslink") {
            return await this.recursiveResolveDomain(domainOrCID, depth - 1, options2);
          }
          const parser2 = this.namespaces[protocol];
          if (parser2 == null) {
            this.log('unknown protocol "%s" in DNSLink record for domain: %s', protocol, domain);
            continue;
          }
          output.push(parser2(result, answer));
        } catch (err2) {
          this.log.error("could not parse DNS link record for domain %s, %s - %e", domain, answer.data, err2);
        }
      }
      if (output.length > 0) {
        return output;
      }
      this.log("no DNSLink records found for %s, falling back to CNAME", domain);
      const cnameRecordsResponse = await this.dns.query(domain, {
        ...options2,
        types: [
          RecordType.CNAME
        ]
      });
      const cnameRecords = (cnameRecordsResponse?.Answer ?? []).sort((a2, b) => a2.data.localeCompare(b.data));
      this.log("found %d CNAME records for %s", cnameRecords.length, domain);
      for (const cname of cnameRecords) {
        try {
          return await this.recursiveResolveDomain(cname.data, depth - 1, options2);
        } catch (err2) {
          this.log.error("domain %s cname %s had no DNSLink records - %e", domain, cname.data, err2);
        }
      }
      throw new DNSLinkNotFoundError(`No DNSLink records found for domain: ${domain}`);
    }
  };

  // node_modules/@helia/dnslink/dist/src/index.js
  function dnsLink(components, options2 = {}) {
    return new DNSLink(components, options2);
  }

  // node_modules/@helia/ipns/dist/src/constants.js
  var MINUTE = 60 * 1e3;
  var HOUR = 60 * MINUTE;
  var DEFAULT_LIFETIME_MS = 48 * HOUR;
  var DHT_EXPIRY_MS = 48 * HOUR;
  var REPUBLISH_THRESHOLD = 24 * HOUR;
  var DEFAULT_TTL_NS2 = BigInt(MINUTE) * 5000000n;

  // node_modules/@helia/ipns/dist/src/errors.js
  var RecordsFailedValidationError = class extends Error {
    static name = "RecordsFailedValidationError";
    constructor(message2 = "Records failed validation") {
      super(message2);
      this.name = "RecordsFailedValidationError";
    }
  };
  var UnsupportedMultibasePrefixError = class extends Error {
    static name = "UnsupportedMultibasePrefixError";
    constructor(message2 = "Unsupported multibase prefix") {
      super(message2);
      this.name = "UnsupportedMultibasePrefixError";
    }
  };
  var UnsupportedMultihashCodecError = class extends Error {
    static name = "UnsupportedMultihashCodecError";
    constructor(message2 = "Unsupported multihash codec") {
      super(message2);
      this.name = "UnsupportedMultihashCodecError";
    }
  };
  var InvalidValueError2 = class extends Error {
    static name = "InvalidValueError";
    constructor(message2 = "Invalid value") {
      super(message2);
      this.name = "InvalidValueError";
    }
  };

  // node_modules/@helia/ipns/dist/src/utils.js
  var LIBP2P_KEY_CODEC = 114;
  var IDENTITY_CODEC3 = 0;
  var SHA2_256_CODEC2 = 18;
  function isCodec2(digest2, codec) {
    return digest2.code === codec;
  }
  var DHT_RECORD_PREFIX = "/dht/record/";
  var IPNS_METADATA_PREFIX = "/ipns/metadata/";
  function dhtRoutingKey(key) {
    return new Key(DHT_RECORD_PREFIX + toString2(key, "base32"), false);
  }
  function ipnsMetadataKey(key) {
    return new Key(IPNS_METADATA_PREFIX + toString2(key, "base32"), false);
  }
  function isCID(obj) {
    return obj?.asCID === obj;
  }
  function isLibp2pCID(obj) {
    if (!isCID(obj)) {
      return false;
    }
    if (obj.code !== LIBP2P_KEY_CODEC) {
      throw new InvalidParametersError(`CID codec ${obj.code} was not libp2p-key`);
    }
    if (obj.multihash.code !== IDENTITY_CODEC3 && obj.multihash.code !== SHA2_256_CODEC2) {
      throw new InvalidParametersError(`Multihash algorithm codec ${obj.multihash.code} was not Identity or SHA256 hash`);
    }
    return true;
  }

  // node_modules/@helia/ipns/dist/src/ipns/resolver.js
  var bases2 = {
    [base36.prefix]: base36,
    [base58btc.prefix]: base58btc
  };
  var IPNSResolver = class {
    routers;
    localStore;
    log;
    constructor(components, init) {
      this.log = components.logger.forComponent("helia:ipns");
      this.localStore = init.localStore;
      this.routers = init.routers;
    }
    async resolve(key, options2 = {}) {
      const digest2 = isPublicKey(key) || isPeerId(key) ? key.toMultihash() : isLibp2pCID(key) ? key.multihash : key;
      const routingKey = multihashToIPNSRoutingKey(digest2);
      const record = await this.#findIpnsRecord(routingKey, options2);
      return {
        ...await this.#resolve(record.value, options2),
        record
      };
    }
    async #resolve(ipfsPath, options2 = {}) {
      const parts = ipfsPath.split("/");
      try {
        const scheme = parts[1];
        if (scheme === "ipns") {
          const str = parts[2];
          const prefix = str.substring(0, 1);
          let buf2;
          if (prefix === "1" || prefix === "Q") {
            buf2 = base58btc.decode(`z${str}`);
          } else if (bases2[prefix] != null) {
            buf2 = bases2[prefix].decode(str);
          } else {
            throw new UnsupportedMultibasePrefixError(`Unsupported multibase prefix "${prefix}"`);
          }
          let digest2;
          try {
            digest2 = decode4(buf2);
          } catch {
            digest2 = CID.decode(buf2).multihash;
          }
          if (!isCodec2(digest2, IDENTITY_CODEC3) && !isCodec2(digest2, SHA2_256_CODEC2)) {
            throw new UnsupportedMultihashCodecError(`Unsupported multihash codec "${digest2.code}"`);
          }
          const { cid } = await this.resolve(digest2, options2);
          const path = parts.slice(3).join("/");
          return {
            cid,
            path: path === "" ? void 0 : path
          };
        } else if (scheme === "ipfs") {
          const cid = CID.parse(parts[2]);
          const path = parts.slice(3).join("/");
          return {
            cid,
            path: path === "" ? void 0 : path
          };
        }
      } catch (err2) {
        this.log.error("error parsing ipfs path - %e", err2);
      }
      this.log.error("invalid ipfs path %s", ipfsPath);
      throw new InvalidValueError2("Invalid value");
    }
    async #findIpnsRecord(routingKey, options2 = {}) {
      const records = [];
      const cached = await this.localStore.has(routingKey, options2);
      if (cached) {
        this.log("record is present in the cache");
        if (options2.nocache !== true) {
          try {
            const { record: record2, created } = await this.localStore.get(routingKey, options2);
            this.log("record retrieved from cache");
            await ipnsValidator(routingKey, record2);
            this.log("record was valid");
            const ipnsRecord = unmarshalIPNSRecord(record2);
            const ttlMs = Number((ipnsRecord.ttl ?? DEFAULT_TTL_NS2) / 1000000n);
            const ttlExpires = created.getTime() + ttlMs;
            if (ttlExpires > Date.now()) {
              this.log("record TTL was valid");
              return ipnsRecord;
            }
            if (options2.offline === true) {
              this.log("record TTL has been reached but we are resolving offline-only, returning record");
              return ipnsRecord;
            }
            this.log("record TTL has been reached, searching routing for updates");
            records.push(record2);
          } catch (err2) {
            this.log("cached record was invalid - %e", err2);
            await this.localStore.delete(routingKey, options2);
          }
        } else {
          this.log("ignoring local cache due to nocache=true option");
        }
      }
      if (options2.offline === true) {
        throw new NotFoundError("Record was not present in the cache or has expired");
      }
      this.log("did not have record locally");
      let foundInvalid = 0;
      await Promise.all(this.routers.map(async (router) => {
        let record2;
        try {
          record2 = await router.get(routingKey, {
            ...options2,
            validate: false
          });
        } catch (err2) {
          this.log.error("error finding IPNS record - %e", err2);
          return;
        }
        try {
          await ipnsValidator(routingKey, record2);
          records.push(record2);
        } catch (err2) {
          foundInvalid++;
          this.log.error("error finding IPNS record - %e", err2);
        }
      }));
      if (records.length === 0) {
        if (foundInvalid > 0) {
          throw new RecordsFailedValidationError(`${foundInvalid > 1 ? `${foundInvalid} records` : "Record"} found for routing key ${foundInvalid > 1 ? "were" : "was"} invalid`);
        }
        throw new NotFoundError("Could not find record for routing key");
      }
      const record = records[ipnsSelector(routingKey, records)];
      await this.localStore.put(routingKey, record, options2);
      return unmarshalIPNSRecord(record);
    }
  };

  // node_modules/@helia/ipns/dist/src/pb/metadata.js
  var IPNSPublishMetadata;
  (function(IPNSPublishMetadata2) {
    let _codec;
    IPNSPublishMetadata2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.keyName != null && obj.keyName !== "") {
            w.uint32(10);
            w.string(obj.keyName);
          }
          if (obj.lifetime != null && obj.lifetime !== 0) {
            w.uint32(16);
            w.uint32(obj.lifetime);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4, opts = {}) => {
          const obj = {
            keyName: "",
            lifetime: 0
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.keyName = reader2.string();
                break;
              }
              case 2: {
                obj.lifetime = reader2.uint32();
                break;
              }
              default: {
                reader2.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    IPNSPublishMetadata2.encode = (obj) => {
      return encodeMessage(obj, IPNSPublishMetadata2.codec());
    };
    IPNSPublishMetadata2.decode = (buf2, opts) => {
      return decodeMessage(buf2, IPNSPublishMetadata2.codec(), opts);
    };
  })(IPNSPublishMetadata || (IPNSPublishMetadata = {}));

  // node_modules/@helia/ipns/dist/src/local-store.js
  function localStore(datastore, log18) {
    return {
      async put(routingKey, marshalledRecord, options2 = {}) {
        try {
          const key = dhtRoutingKey(routingKey);
          try {
            const existingBuf = await datastore.get(key);
            const existingRecord = Libp2pRecord.deserialize(existingBuf);
            if (equals3(existingRecord.value, marshalledRecord)) {
              return;
            }
          } catch (err2) {
            if (err2.name !== "NotFoundError") {
              throw err2;
            }
          }
          const record = new Libp2pRecord(routingKey, marshalledRecord, /* @__PURE__ */ new Date());
          options2.onProgress?.(new CustomProgressEvent("ipns:routing:datastore:put"));
          const batch2 = datastore.batch();
          batch2.put(key, record.serialize());
          if (options2.metadata != null) {
            batch2.put(ipnsMetadataKey(routingKey), IPNSPublishMetadata.encode(options2.metadata));
          }
          await batch2.commit(options2);
        } catch (err2) {
          options2.onProgress?.(new CustomProgressEvent("ipns:routing:datastore:error", err2));
          throw err2;
        }
      },
      async get(routingKey, options2 = {}) {
        try {
          const key = dhtRoutingKey(routingKey);
          options2.onProgress?.(new CustomProgressEvent("ipns:routing:datastore:get"));
          const buf2 = await datastore.get(key, options2);
          const record = Libp2pRecord.deserialize(buf2);
          return {
            record: record.value,
            created: record.timeReceived
          };
        } catch (err2) {
          options2.onProgress?.(new CustomProgressEvent("ipns:routing:datastore:error", err2));
          throw err2;
        }
      },
      async has(routingKey, options2 = {}) {
        const key = dhtRoutingKey(routingKey);
        return datastore.has(key, options2);
      },
      async delete(routingKey, options2) {
        const key = dhtRoutingKey(routingKey);
        const batch2 = datastore.batch();
        batch2.delete(key);
        batch2.delete(ipnsMetadataKey(routingKey));
        await batch2.commit(options2);
      },
      async *list(options2 = {}) {
        try {
          options2.onProgress?.(new CustomProgressEvent("ipns:routing:datastore:list"));
          for await (const { key, value: value2 } of datastore.query({
            prefix: DHT_RECORD_PREFIX
          }, options2)) {
            try {
              const libp2pRecord = Libp2pRecord.deserialize(value2);
              const keyString = key.toString();
              const routingKeyBase32 = keyString.substring(DHT_RECORD_PREFIX.length);
              const routingKey = fromString2(routingKeyBase32, "base32");
              const metadataKey = ipnsMetadataKey(routingKey);
              let metadata;
              try {
                const metadataBuf = await datastore.get(metadataKey, options2);
                metadata = IPNSPublishMetadata.decode(metadataBuf);
              } catch (err2) {
                log18.error("Error deserializing metadata for %s - %e", routingKeyBase32, err2);
              }
              yield {
                routingKey,
                metadata,
                record: libp2pRecord.value,
                created: libp2pRecord.timeReceived
              };
            } catch (err2) {
              log18.error("Error deserializing record - %e", err2);
            }
          }
        } catch (err2) {
          options2.onProgress?.(new CustomProgressEvent("ipns:routing:datastore:error", err2));
          throw err2;
        }
      }
    };
  }

  // node_modules/@helia/ipns/dist/src/routing/helia.js
  var HeliaRouting = class {
    routing;
    constructor(routing) {
      this.routing = routing;
    }
    async put(routingKey, marshaledRecord, options2 = {}) {
      try {
        await this.routing.put(routingKey, marshaledRecord, options2);
      } catch (err2) {
        options2.onProgress?.(new CustomProgressEvent("ipns:routing:helia:error", err2));
        throw err2;
      }
    }
    async get(routingKey, options2 = {}) {
      try {
        return await this.routing.get(routingKey, options2);
      } catch (err2) {
        options2.onProgress?.(new CustomProgressEvent("ipns:routing:helia:error", err2));
        throw err2;
      }
    }
  };
  function helia(routing) {
    return new HeliaRouting(routing);
  }

  // node_modules/@helia/ipns/dist/src/routing/local-store.js
  function localStoreRouting(localStore2) {
    return {
      async put(routingKey, marshaledRecord, options2) {
        await localStore2.put(routingKey, marshaledRecord, options2);
      },
      async get(routingKey, options2) {
        const { record } = await localStore2.get(routingKey, options2);
        return record;
      }
    };
  }

  // node_modules/@helia/ipns/dist/src/index.js
  function ipnsResolver(components, options2 = {}) {
    const store = localStore(components.datastore, components.logger.forComponent("helia:ipns:local-store"));
    const routers = [
      localStoreRouting(store),
      helia(components.routing),
      ...options2.routers ?? []
    ];
    return new IPNSResolver(components, {
      routers,
      localStore: store
    });
  }

  // node_modules/@helia/verified-fetch/dist/src/errors.js
  var InvalidRangeError = class extends Error {
    static name = "InvalidRangeError";
    constructor(message2 = "Invalid range request") {
      super(message2);
      this.name = "InvalidRangeError";
    }
  };
  var NoContentError = class extends Error {
    static name = "NoContentError";
    constructor(message2 = "No content found") {
      super(message2);
      this.name = "NoContentError";
    }
  };
  var SubdomainNotSupportedError = class extends Error {
    static name = "SubdomainNotSupportedError";
    constructor(message2 = "Subdomain not supported") {
      super(message2);
      this.name = "SubdomainNotSupportedError";
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/utils/request-headers.js
  function getHeader(headers, header) {
    if (headers == null) {
      return void 0;
    }
    if (headers instanceof Headers) {
      return headers.get(header) ?? void 0;
    }
    if (Array.isArray(headers)) {
      const entry = headers.find(([key2]) => key2.toLowerCase() === header.toLowerCase());
      return entry?.[1];
    }
    const key = Object.keys(headers).find((k) => k.toLowerCase() === header.toLowerCase());
    if (key == null) {
      return void 0;
    }
    return headers[key];
  }
  function calculateByteRangeIndexes(start2, end, fileSize) {
    if ((start2 ?? 0) > (end ?? Infinity)) {
      throw new InvalidRangeError("Invalid range: Range-start index is greater than range-end index.");
    }
    if (start2 != null && (end ?? 0) >= (fileSize ?? Infinity)) {
      throw new InvalidRangeError("Invalid range: Range-end index is greater than or equal to the size of the file.");
    }
    if (start2 == null && (end ?? 0) > (fileSize ?? Infinity)) {
      throw new InvalidRangeError("Invalid range: Range-end index is greater than the size of the file.");
    }
    if (start2 != null && start2 < 0) {
      throw new InvalidRangeError("Invalid range: Range-start index cannot be negative.");
    }
    if (start2 != null && end != null) {
      return { byteSize: end - start2 + 1, start: start2, end };
    } else if (start2 == null && end != null) {
      if (fileSize == null) {
        return { end };
      }
      if (end === fileSize) {
        return { byteSize: fileSize, start: 0, end: fileSize - 1 };
      }
      return { byteSize: end, start: fileSize - end, end: fileSize - 1 };
    } else if (start2 != null && end == null) {
      if (fileSize == null) {
        return { start: start2 };
      }
      const end2 = fileSize - 1;
      const byteSize = fileSize - start2;
      return { byteSize, start: start2, end: end2 };
    }
    return { byteSize: fileSize, start: 0, end: fileSize != null ? fileSize - 1 : 0 };
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/response-headers.js
  function setCacheControlHeader({ ttl, protocol, response }) {
    if (response.headers.has("cache-control")) {
      return;
    }
    let headerValue;
    if (protocol === "ipfs") {
      headerValue = "public, max-age=29030400, immutable";
    } else if (ttl == null) {
      headerValue = "public, max-age=300";
    } else {
      headerValue = `public, max-age=${ttl}`;
    }
    response.headers.set("cache-control", headerValue);
  }
  function getContentRangeHeader({ byteStart, byteEnd, byteSize }) {
    const total = byteSize ?? "*";
    if ((byteEnd ?? 0) >= (byteSize ?? Infinity)) {
      throw new InvalidRangeError("Invalid range: Range-end index is greater than or equal to the size of the file.");
    }
    if ((byteStart ?? 0) >= (byteSize ?? Infinity)) {
      throw new InvalidRangeError("Invalid range: Range-start index is greater than or equal to the size of the file.");
    }
    if (byteStart != null && byteEnd == null) {
      if (byteSize == null) {
        return `bytes */${total}`;
      }
      return `bytes ${byteStart}-${byteSize - 1}/${byteSize}`;
    }
    if (byteStart == null && byteEnd != null) {
      if (byteSize == null) {
        return `bytes */${total}`;
      }
      const end = byteSize - 1;
      const start2 = end - byteEnd + 1;
      return `bytes ${start2}-${end}/${byteSize}`;
    }
    if (byteStart == null && byteEnd == null) {
      return `bytes */${total}`;
    }
    return `bytes ${byteStart}-${byteEnd}/${total}`;
  }
  function setIpfsRoots(response, ipfsRoots) {
    if (ipfsRoots != null) {
      response.headers.set("X-Ipfs-Roots", getIpfsRoots(ipfsRoots));
    }
  }
  function getIpfsRoots(ipfsRoots) {
    return ipfsRoots.map((cid) => cid.toV1().toString()).join(",");
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/byte-range-context.js
  function getBodySizeSync(body) {
    if (typeof body === "string") {
      return body.length;
    }
    if (body instanceof ArrayBuffer || body instanceof Uint8Array) {
      return body.byteLength;
    }
    if (body instanceof Blob) {
      return body.size;
    }
    if (body instanceof ReadableStream) {
      return null;
    }
    return null;
  }
  function getByteRangeFromHeader(rangeHeader) {
    if (!rangeHeader.startsWith("bytes=")) {
      throw new InvalidRangeError("Invalid range request");
    }
    const rangesStr = rangeHeader.substring(6);
    const rangeParts = rangesStr.split(",").map((part) => part.trim());
    const ranges = [];
    for (const part of rangeParts) {
      const match = part.match(/^(?<start>\d+)?-(?<end>\d+)?$/);
      if (match?.groups == null) {
        throw new InvalidRangeError(`Invalid range specification: ${part}`);
      }
      const { start: start2, end } = match.groups;
      ranges.push({
        start: start2 ?? null,
        end: end ?? null
      });
    }
    if (ranges.length === 0) {
      throw new InvalidRangeError("No valid ranges found");
    }
    return { ranges };
  }
  var ByteRangeContext = class {
    headers;
    isRangeRequest;
    /**
     * This property is purposefully only set in `set fileSize` and should not be set directly.
     */
    _fileSize;
    _body = null;
    rangeRequestHeader;
    log;
    /**
     * multiPartBoundary is required for multipart responses
     */
    multiPartBoundary;
    requestRanges = [];
    byteRanges = [];
    isMultiRangeRequest = false;
    // to be set by isValidRangeRequest so that we don't need to re-check the byteRanges
    _isValidRangeRequest = false;
    constructor(logger2, headers) {
      this.headers = headers;
      this.log = logger2.newScope("byte-range-context");
      this.rangeRequestHeader = getHeader(this.headers, "Range");
      if (this.rangeRequestHeader != null) {
        this.isRangeRequest = true;
        this.log.trace("range request detected");
        try {
          const { ranges } = getByteRangeFromHeader(this.rangeRequestHeader);
          this.isMultiRangeRequest = ranges.length > 1;
          this.requestRanges = ranges.map((range) => ({
            start: range.start != null ? parseInt(range.start) : null,
            end: range.end != null ? parseInt(range.end) : null
          }));
          this.multiPartBoundary = `multipart_byteranges_${Math.floor(Math.random() * 1e9)}`;
        } catch (e2) {
          this.log.error("error parsing range request header - %e", e2);
          this.requestRanges = [];
        }
        this.setOffsetDetails();
      } else {
        this.log.trace("no range request detected");
        this.isRangeRequest = false;
      }
    }
    getByteRanges() {
      return this.byteRanges;
    }
    /**
     * You can pass a function when you need to support multi-range requests but have your own slicing logic, such as in the case of dag-pb/unixfs.
     *
     * @param bodyOrProvider - A supported body type or a function that returns a supported body type.
     * @param contentType - The content type of the body.
     */
    setBody(bodyOrProvider, contentType = "application/octet-stream") {
      if (typeof bodyOrProvider === "function") {
        this._body = this.createRangeStream(bodyOrProvider, contentType);
      } else {
        this._body = bodyOrProvider;
        this.setFileSize(this._fileSize ?? getBodySizeSync(bodyOrProvider));
      }
      this.log.trace("set request body with fileSize %o", this._fileSize);
    }
    getBody(responseContentType) {
      const body = this._body;
      if (body == null) {
        this.log.trace("body is null");
        return body;
      }
      if (!this.isRangeRequest || !this.isValidRangeRequest) {
        this.log.trace("returning body unmodified for non-range, or invalid range, request");
        return body;
      }
      if (this.isMultiRangeRequest) {
        if (this._body instanceof ReadableStream) {
          return this._body;
        }
        return itToBrowserReadableStream(this.getMultipartBody(responseContentType));
      }
      if (this.byteRanges.length > 0) {
        const range = this.byteRanges[0];
        if (body instanceof ReadableStream) {
          return body;
        }
        if (range.start != null || range.end != null) {
          this.log.trace("returning body with byteStart=%o, byteEnd=%o, byteSize=%o", range.start, range.end, range.size);
        }
        return this.getSlicedBody(body, range);
      }
      this.log.error("returning unmodified body for valid range request");
      return body;
    }
    getSlicedBody(body, range) {
      const offset = range.start ?? 0;
      let length4;
      if (range.end != null && range.start != null) {
        length4 = range.end - range.start + 1;
      } else {
        length4 = void 0;
      }
      this.log.trace("slicing body with offset=%o and length=%o", offset, length4);
      if (typeof body === "string") {
        return body.slice(offset, length4 !== void 0 ? offset + length4 : void 0);
      } else if (body instanceof Blob) {
        return body.slice(offset, length4 !== void 0 ? offset + length4 : void 0);
      } else if (body instanceof ArrayBuffer || body instanceof Uint8Array) {
        return body.slice(offset, length4 !== void 0 ? offset + length4 : void 0);
      }
      return body;
    }
    /**
     * Sometimes, we need to set the fileSize explicitly because we can't calculate
     * the size of the body (e.g. for unixfs content where we call .stat).
     *
     * This fileSize should otherwise only be called from `setBody`.
     */
    setFileSize(size) {
      this._fileSize = size != null ? Number(size) : null;
      this._isValidRangeRequest = false;
      this.log.trace("set _fileSize to %o", this._fileSize);
      this.setOffsetDetails();
    }
    getFileSize() {
      return this._fileSize;
    }
    isValidByteStart(byteStart, byteEnd) {
      if (byteStart != null) {
        if (byteStart < 0) {
          return false;
        }
        if (this._fileSize != null && byteStart >= this._fileSize) {
          return false;
        }
        if (byteEnd != null && byteStart > byteEnd) {
          return false;
        }
      }
      return true;
    }
    isValidByteEnd(byteStart, byteEnd) {
      if (byteEnd != null) {
        if (byteEnd < 0) {
          this.log.trace("invalid range request, byteEnd is less than 0");
          return false;
        }
        if (this._fileSize != null && byteEnd >= this._fileSize) {
          this.log.trace("invalid range request, byteEnd is greater than fileSize");
          return false;
        }
        if (byteStart != null && byteEnd < byteStart) {
          this.log.trace("invalid range request, byteEnd is less than byteStart");
          return false;
        }
      }
      return true;
    }
    isValidByteRange(range) {
      this.log.trace("validating byte range: %o", range);
      if (range.start != null && !this.isValidByteStart(range.start, range.end)) {
        this.log.trace("invalid range request, byteStart is less than 0 or greater than fileSize");
        return false;
      }
      if (range.end != null && !this.isValidByteEnd(range.start, range.end)) {
        this.log.trace("invalid range request, byteEnd is less than 0 or greater than fileSize");
        return false;
      }
      return true;
    }
    /**
     * We may get the values required to determine if this is a valid range request at different times
     * so we need to calculate it when asked.
     */
    get isValidRangeRequest() {
      if (this._isValidRangeRequest) {
        return true;
      }
      if (!this.isRangeRequest) {
        return false;
      }
      if (this.byteRanges.length === 0) {
        this.log.trace("invalid range request, no valid ranges");
        return false;
      }
      const isValid2 = this.byteRanges.every((range) => this.isValidByteRange(range));
      if (!isValid2) {
        this.log.trace("invalid range request, not all ranges are valid");
        return false;
      }
      this._isValidRangeRequest = true;
      return true;
    }
    // /**
    //  * Given all the information we have, this function returns the offset that will be used when:
    //  * 1. calling unixfs.cat
    //  * 2. slicing the body
    //  */
    // public offset (range: ByteRange): number {
    //   if (this.byteRanges.length > 0) {
    //     return this.byteRanges[0].start ?? 0
    //   }
    //   return 0
    // }
    /**
     * Given all the information we have, this function returns the length that will be used when:
     * 1. calling unixfs.cat
     * 2. slicing the body
     */
    getLength(range) {
      if (!this.isValidRangeRequest) {
        this.log.error("cannot get length for invalid range request");
        return void 0;
      }
      if (this.isMultiRangeRequest && range == null) {
        return void 0;
      }
      range ??= this.byteRanges[0];
      this.log.trace("getting length for range: %o", range);
      if (range.end != null && range.start != null) {
        return range.end - range.start + 1;
      }
      if (range.end != null) {
        return range.end + 1;
      }
      return range.size;
    }
    /**
     * Converts a range request header into helia/unixfs supported range options
     * Note that the gateway specification says we "MAY" support multiple ranges (https://specs.ipfs.tech/http-gateways/path-gateway/#range-request-header) but we don't
     *
     * Also note that @helia/unixfs and ipfs-unixfs-exporter expect length and offset to be numbers, the range header is a string, and the size of the resource is likely a bigint.
     *
     * SUPPORTED:
     * Range: bytes=<range-start>-<range-end>
     * Range: bytes=<range-start>-
     * Range: bytes=-<suffix-length> // must pass size so we can calculate the offset. suffix-length is the number of bytes from the end of the file.
     * Range: bytes=<range-start>-<range-end>, <range-start>-<range-end>
     * Range: bytes=<range-start>-<range-end>, <range-start>-<range-end>, <range-start>-<range-end>
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range#directives
     */
    setOffsetDetails() {
      if (this.requestRanges.length === 0) {
        this.log.trace("no request ranges defined");
        return;
      }
      try {
        this.byteRanges = this.requestRanges.map((range) => {
          const { start: start2, end, byteSize } = calculateByteRangeIndexes(range.start ?? void 0, range.end ?? void 0, this._fileSize ?? void 0);
          return { start: start2, end, size: byteSize };
        });
        this.log.trace("set byte ranges: %o", this.byteRanges);
      } catch (e2) {
        this.log.error("error setting offset details: %o", e2);
        this.byteRanges = [];
      }
    }
    /**
     * Helper to convert a SliceableBody to a Uint8Array
     */
    async convertToUint8Array(content) {
      if (typeof content === "string") {
        return new TextEncoder().encode(content);
      }
      if ("arrayBuffer" in content && typeof content.arrayBuffer === "function") {
        const buffer2 = await content.arrayBuffer();
        return new Uint8Array(buffer2);
      }
      if ("byteLength" in content && !("buffer" in content)) {
        return new Uint8Array(content);
      }
      if ("buffer" in content && "byteLength" in content && "byteOffset" in content) {
        return content;
      }
      throw new Error("Unsupported content type for multipart response");
    }
    async *getMultipartBody(responseContentType = "application/octet-stream") {
      const body = this._body;
      if (body instanceof ReadableStream) {
        return body;
      }
      if (body === null) {
        throw new Error("Cannot create multipart body from null");
      }
      const encoder2 = new TextEncoder();
      for (const range of this.byteRanges) {
        if (range.start === void 0 || range.end === void 0) {
          continue;
        }
        const partHeaderString = `\r
--${this.multiPartBoundary}\r
Content-Type: ${responseContentType}\r
Content-Range: ${getContentRangeHeader({
          byteStart: range.start,
          byteEnd: range.end,
          byteSize: this._fileSize ?? void 0
        })}\r
\r
`;
        yield encoder2.encode(partHeaderString);
        const slicedContent = this.getSlicedBodyForRange(body, range.start, range.end);
        yield await this.convertToUint8Array(slicedContent);
      }
      yield encoder2.encode(`\r
--${this.multiPartBoundary}--`);
    }
    getSlicedBodyForRange(body, start2, end) {
      const offset = start2;
      const length4 = end - start2 + 1;
      this.log.trace("slicing body with offset=%o and length=%o", offset, length4);
      if (typeof body === "string") {
        return body.slice(offset, offset + length4);
      } else if (body instanceof Blob) {
        return body.slice(offset, offset + length4);
      } else if (body instanceof ArrayBuffer || body instanceof Uint8Array) {
        return body.slice(offset, offset + length4);
      } else {
        return body;
      }
    }
    /**
     * Returns the content type for the response.
     * For multipart ranges, this will be multipart/byteranges with a boundary.
     */
    getContentType() {
      if (this.isMultiRangeRequest && this.isValidRangeRequest) {
        return `multipart/byteranges; boundary=${this.multiPartBoundary}`;
      }
      return void 0;
    }
    /**
     * This function returns the value of the "content-range" header.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range
     *
     * Returns a string representing the following content ranges:
     *
     * @example
     * - Content-Range: <unit> <byteStart>-<byteEnd>/<byteSize>
     * - Content-Range: <unit> <byteStart>-<byteEnd>/*
     */
    // - Content-Range: <unit> */<byteSize> // this is purposefully not in jsdoc block
    get contentRangeHeaderValue() {
      if (!this.isValidRangeRequest) {
        this.log.error("cannot get contentRangeHeaderValue for invalid range request");
        throw new InvalidRangeError("Invalid range request");
      }
      if (this.isMultiRangeRequest) {
        this.log.error("contentRangeHeaderValue should not be called for multipart responses");
        throw new InvalidRangeError("Content-Range header not applicable for multipart responses");
      }
      if (this.byteRanges.length > 0) {
        const range = this.byteRanges[0];
        return getContentRangeHeader({
          byteStart: range.start,
          byteEnd: range.end,
          byteSize: this._fileSize ?? void 0
        });
      }
      throw new InvalidRangeError("No valid ranges found");
    }
    // Unified method to create a stream for either single or multi-range requests
    createRangeStream(contentProvider, contentType) {
      const encoder2 = new TextEncoder();
      const byteRanges = this.byteRanges;
      const multiPartBoundary = this.multiPartBoundary;
      const fileSize = this._fileSize;
      const log18 = this.log;
      const isMultiRangeRequest = this.isMultiRangeRequest;
      if (byteRanges.length === 0) {
        log18.error("Cannot create range stream with no byte ranges");
        throw new InvalidRangeError("No valid ranges found");
      }
      return new ReadableStream({
        async start(controller) {
          try {
            for (const range of byteRanges) {
              if (isMultiRangeRequest) {
                const partHeader = `\r
--${multiPartBoundary}\r
Content-Type: ${contentType}\r
Content-Range: ${getContentRangeHeader({
                  byteStart: range.start,
                  byteEnd: range.end,
                  byteSize: fileSize ?? void 0
                })}\r
\r
`;
                controller.enqueue(encoder2.encode(partHeader));
              }
              try {
                const rangeContent = contentProvider(range);
                for await (const chunk of rangeContent) {
                  controller.enqueue(chunk);
                }
              } catch (err2) {
                log18.error("Error processing range %o: %o", range, err2);
                throw err2;
              }
            }
            if (isMultiRangeRequest) {
              controller.enqueue(encoder2.encode(`\r
--${multiPartBoundary}--`));
            }
            controller.close();
          } catch (err2) {
            log18.error("Error processing range(s): %o", err2);
            controller.error(err2);
          }
        }
      });
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/utils/responses.js
  function setField(response, name9, value2) {
    Object.defineProperty(response, name9, {
      enumerable: true,
      configurable: false,
      set: () => {
      },
      get: () => value2
    });
  }
  function setType(response, value2) {
    setField(response, "type", value2);
  }
  function setUrl(response, value2) {
    setField(response, "url", value2);
  }
  function setRedirected(response) {
    setField(response, "redirected", true);
  }
  function okResponse(url, body, init) {
    const response = new Response(body, {
      ...init ?? {},
      status: 200,
      statusText: "OK"
    });
    if (init?.redirected === true) {
      setRedirected(response);
    }
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function internalServerErrorResponse(url, body, init) {
    const response = new Response(body, {
      ...init ?? {},
      status: 500,
      statusText: "Internal Server Error"
    });
    response.headers.set("X-Content-Type-Options", "nosniff");
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function badGatewayResponse(url, body, init) {
    const response = new Response(body, {
      ...init ?? {},
      status: 502,
      statusText: "Bad Gateway"
    });
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function notImplementedResponse(url, body, init) {
    const response = new Response(body, {
      ...init ?? {},
      status: 501,
      statusText: "Not Implemented"
    });
    response.headers.set("X-Content-Type-Options", "nosniff");
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function notAcceptableResponse(url, body, init) {
    const response = new Response(body, {
      ...init ?? {},
      status: 406,
      statusText: "Not Acceptable"
    });
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function notFoundResponse(url, body, init) {
    const response = new Response(body, {
      ...init ?? {},
      status: 404,
      statusText: "Not Found"
    });
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function isArrayOfErrors(body) {
    return Array.isArray(body) && body.every((e2) => e2 instanceof Error);
  }
  function badRequestResponse(url, errors, init) {
    let stack;
    let convertedErrors;
    if (isArrayOfErrors(errors)) {
      stack = errors[errors.length - 1].stack;
      convertedErrors = errors.map((e2) => ({ message: e2.message, stack: e2.stack ?? "" }));
    } else if (errors instanceof Error) {
      stack = errors.stack;
      convertedErrors = [{ message: errors.message, stack: errors.stack ?? "" }];
    }
    const bodyJson = JSON.stringify({
      stack,
      errors: convertedErrors
    });
    const response = new Response(bodyJson, {
      status: 400,
      statusText: "Bad Request",
      ...init ?? {},
      headers: {
        ...init?.headers ?? {},
        "Content-Type": "application/json"
      }
    });
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function movedPermanentlyResponse(url, location, init) {
    const response = new Response(null, {
      ...init ?? {},
      status: 301,
      statusText: "Moved Permanently",
      headers: {
        ...init?.headers ?? {},
        location
      }
    });
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function okRangeResponse(url, body, { byteRangeContext, log: log18 }, init) {
    if (!byteRangeContext.isRangeRequest) {
      return okResponse(url, body, init);
    }
    if (!byteRangeContext.isValidRangeRequest) {
      return badRangeResponse(url, body, init);
    }
    let response;
    try {
      const headers = new Headers(init?.headers);
      const multipartContentType = byteRangeContext.getContentType();
      if (multipartContentType != null) {
        headers.set("content-type", multipartContentType);
      } else {
        if (byteRangeContext.isMultiRangeRequest) {
          headers.set("content-type", "multipart/byteranges");
        } else {
          headers.set("content-range", byteRangeContext.contentRangeHeaderValue);
        }
      }
      response = new Response(body, {
        ...init ?? {},
        status: 206,
        statusText: "Partial Content",
        headers
      });
    } catch (e2) {
      log18?.error("failed to create range response", e2);
      return badRangeResponse(url, body, init);
    }
    if (init?.redirected === true) {
      setRedirected(response);
    }
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }
  function badRangeResponse(url, body, init) {
    const response = new Response(body, {
      ...init ?? {},
      status: 416,
      statusText: "Requested Range Not Satisfiable"
    });
    setType(response, "basic");
    setUrl(response, url);
    return response;
  }

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-base.js
  var BasePlugin = class {
    codes = [];
    pluginOptions;
    _log;
    get log() {
      if (this._log == null) {
        this._log = this.pluginOptions.logger.newScope(this.id);
      }
      return this._log;
    }
    constructor(options2) {
      this.pluginOptions = options2;
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-byte-range-context.js
  var ByteRangeContextPlugin = class extends BasePlugin {
    id = "byte-range-context-plugin";
    /**
     * Return false if the ByteRangeContext has already been set, otherwise return true.
     */
    canHandle(context) {
      return context.byteRangeContext == null;
    }
    async handle(context) {
      context.byteRangeContext = new ByteRangeContext(this.pluginOptions.logger, context.options?.headers);
      context.modified++;
      if (context.byteRangeContext.isRangeRequest && !context.byteRangeContext.isValidRangeRequest) {
        return badRangeResponse(context.resource);
      }
      return null;
    }
  };

  // node_modules/@ipld/car/src/decoder-common.js
  var import_varint2 = __toESM(require_varint(), 1);
  var V2_HEADER_LENGTH = (
    /* characteristics */
    16 + 8 + 8 + 8
  );
  function decodeVarint2(bytes, seeker) {
    if (!bytes.length) {
      throw new Error("Unexpected end of data");
    }
    const i2 = import_varint2.default.decode(bytes);
    seeker.seek(
      /** @type {number} */
      import_varint2.default.decode.bytes
    );
    return i2;
  }
  function decodeV2Header(bytes) {
    const dv2 = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;
    const header = {
      version: 2,
      /** @type {[bigint, bigint]} */
      characteristics: [
        dv2.getBigUint64(offset, true),
        dv2.getBigUint64(offset += 8, true)
      ],
      dataOffset: Number(dv2.getBigUint64(offset += 8, true)),
      dataSize: Number(dv2.getBigUint64(offset += 8, true)),
      indexOffset: Number(dv2.getBigUint64(offset += 8, true))
    };
    return header;
  }

  // node_modules/@ipld/car/src/header-validator.js
  var Kinds = {
    Null: (
      /**
       * @param obj
       * @returns {undefined|null}
       */
      (obj) => obj === null ? obj : void 0
    ),
    Int: (
      /**
       * @param obj
       * @returns {undefined|number}
       */
      (obj) => Number.isInteger(obj) ? obj : void 0
    ),
    Float: (
      /**
       * @param obj
       * @returns {undefined|number}
       */
      (obj) => typeof obj === "number" && Number.isFinite(obj) ? obj : void 0
    ),
    String: (
      /**
       * @param obj
       * @returns {undefined|string}
       */
      (obj) => typeof obj === "string" ? obj : void 0
    ),
    Bool: (
      /**
       * @param obj
       * @returns {undefined|boolean}
       */
      (obj) => typeof obj === "boolean" ? obj : void 0
    ),
    Bytes: (
      /**
       * @param obj
       * @returns {undefined|Uint8Array}
       */
      (obj) => obj instanceof Uint8Array ? obj : void 0
    ),
    Link: (
      /**
       * @param obj
       * @returns {undefined|object}
       */
      (obj) => obj !== null && typeof obj === "object" && obj.asCID === obj ? obj : void 0
    ),
    List: (
      /**
       * @param obj
       * @returns {undefined|Array<any>}
       */
      (obj) => Array.isArray(obj) ? obj : void 0
    ),
    Map: (
      /**
       * @param obj
       * @returns {undefined|object}
       */
      (obj) => obj !== null && typeof obj === "object" && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : void 0
    )
  };
  var Types = {
    "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
    "CarV1HeaderOrV2Pragma > roots (anon)": (
      /**
       * @param obj
       * @returns {undefined|any}
       */
      (obj) => {
        if (Kinds.List(obj) === void 0) {
          return void 0;
        }
        for (let i2 = 0; i2 < obj.length; i2++) {
          let v = obj[i2];
          v = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
          if (v === void 0) {
            return void 0;
          }
          if (v !== obj[i2]) {
            const ret = obj.slice(0, i2);
            for (let j = i2; j < obj.length; j++) {
              let v2 = obj[j];
              v2 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
              if (v2 === void 0) {
                return void 0;
              }
              ret.push(v2);
            }
            return ret;
          }
        }
        return obj;
      }
    ),
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: (
      /**
       * @param obj
       * @returns {undefined|any}
       */
      (obj) => {
        if (Kinds.Map(obj) === void 0) {
          return void 0;
        }
        const entries = Object.entries(obj);
        let ret = obj;
        let requiredCount = 1;
        for (let i2 = 0; i2 < entries.length; i2++) {
          const [key, value2] = entries[i2];
          switch (key) {
            case "roots":
              {
                const v = Types["CarV1HeaderOrV2Pragma > roots (anon)"](obj[key]);
                if (v === void 0) {
                  return void 0;
                }
                if (v !== value2 || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j = 0; j < i2; j++) {
                      ret[entries[j][0]] = entries[j][1];
                    }
                  }
                  ret.roots = v;
                }
              }
              break;
            case "version":
              {
                requiredCount--;
                const v = Types.Int(obj[key]);
                if (v === void 0) {
                  return void 0;
                }
                if (v !== value2 || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j = 0; j < i2; j++) {
                      ret[entries[j][0]] = entries[j][1];
                    }
                  }
                  ret.version = v;
                }
              }
              break;
            default:
              return void 0;
          }
        }
        if (requiredCount > 0) {
          return void 0;
        }
        return ret;
      }
    )
  };
  var Reprs = {
    "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
    "CarV1HeaderOrV2Pragma > roots (anon)": (
      /**
       * @param obj
       * @returns {undefined|any}
       */
      (obj) => {
        if (Kinds.List(obj) === void 0) {
          return void 0;
        }
        for (let i2 = 0; i2 < obj.length; i2++) {
          let v = obj[i2];
          v = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
          if (v === void 0) {
            return void 0;
          }
          if (v !== obj[i2]) {
            const ret = obj.slice(0, i2);
            for (let j = i2; j < obj.length; j++) {
              let v2 = obj[j];
              v2 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
              if (v2 === void 0) {
                return void 0;
              }
              ret.push(v2);
            }
            return ret;
          }
        }
        return obj;
      }
    ),
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: (
      /**
       * @param obj
       * @returns {undefined|any}
       */
      (obj) => {
        if (Kinds.Map(obj) === void 0) {
          return void 0;
        }
        const entries = Object.entries(obj);
        let ret = obj;
        let requiredCount = 1;
        for (let i2 = 0; i2 < entries.length; i2++) {
          const [key, value2] = entries[i2];
          switch (key) {
            case "roots":
              {
                const v = Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](value2);
                if (v === void 0) {
                  return void 0;
                }
                if (v !== value2 || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j = 0; j < i2; j++) {
                      ret[entries[j][0]] = entries[j][1];
                    }
                  }
                  ret.roots = v;
                }
              }
              break;
            case "version":
              {
                requiredCount--;
                const v = Reprs.Int(value2);
                if (v === void 0) {
                  return void 0;
                }
                if (v !== value2 || ret !== obj) {
                  if (ret === obj) {
                    ret = {};
                    for (let j = 0; j < i2; j++) {
                      ret[entries[j][0]] = entries[j][1];
                    }
                  }
                  ret.version = v;
                }
              }
              break;
            default:
              return void 0;
          }
        }
        if (requiredCount > 0) {
          return void 0;
        }
        return ret;
      }
    )
  };
  var CarV1HeaderOrV2Pragma = {
    toTyped: Types.CarV1HeaderOrV2Pragma,
    toRepresentation: Reprs.CarV1HeaderOrV2Pragma
  };

  // node_modules/cborg/lib/length.js
  var cborEncoders2 = makeCborEncoders();

  // node_modules/@ipld/car/src/buffer-writer.js
  var import_varint3 = __toESM(require_varint(), 1);
  var headerPreludeTokens = [
    new Token(Type.map, 2),
    new Token(Type.string, "version"),
    new Token(Type.uint, 1),
    new Token(Type.string, "roots")
  ];
  var CID_TAG = new Token(Type.tag, 42);

  // node_modules/@ipld/car/src/decoder.js
  async function readHeader(reader2, strictVersion) {
    const length4 = decodeVarint2(await reader2.upTo(8), reader2);
    if (length4 === 0) {
      throw new Error("Invalid CAR header (zero length)");
    }
    const header = await reader2.exactly(length4, true);
    const block = decode11(header);
    if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
      throw new Error("Invalid CAR header format");
    }
    if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
      throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
    }
    if (block.version === 1) {
      if (!Array.isArray(block.roots)) {
        throw new Error("Invalid CAR header format");
      }
      return block;
    }
    if (block.roots !== void 0) {
      throw new Error("Invalid CAR header format");
    }
    const v2Header = decodeV2Header(await reader2.exactly(V2_HEADER_LENGTH, true));
    reader2.seek(v2Header.dataOffset - reader2.pos);
    const v1Header = await readHeader(reader2, 1);
    return Object.assign(v1Header, v2Header);
  }
  function bytesReader(bytes) {
    let pos = 0;
    return {
      async upTo(length4) {
        const out = bytes.subarray(pos, pos + Math.min(length4, bytes.length - pos));
        return out;
      },
      async exactly(length4, seek = false) {
        if (length4 > bytes.length - pos) {
          throw new Error("Unexpected end of data");
        }
        const out = bytes.subarray(pos, pos + length4);
        if (seek) {
          pos += length4;
        }
        return out;
      },
      seek(length4) {
        pos += length4;
      },
      get pos() {
        return pos;
      }
    };
  }

  // node_modules/@ipld/car/src/encoder.js
  var import_varint4 = __toESM(require_varint(), 1);
  var CAR_V1_VERSION = 1;
  function createHeader(roots) {
    const headerBytes = encode10({ version: CAR_V1_VERSION, roots });
    const varintBytes = import_varint4.default.encode(headerBytes.length);
    const header = new Uint8Array(varintBytes.length + headerBytes.length);
    header.set(varintBytes, 0);
    header.set(headerBytes, varintBytes.length);
    return header;
  }
  function createEncoder(writer) {
    return {
      /**
       * @param {CID[]} roots
       * @returns {Promise<void>}
       */
      async setRoots(roots) {
        const bytes = createHeader(roots);
        await writer.write(bytes);
      },
      /**
       * @param {Block} block
       * @returns {Promise<void>}
       */
      async writeBlock(block) {
        const { cid, bytes } = block;
        await writer.write(new Uint8Array(import_varint4.default.encode(cid.bytes.length + bytes.length)));
        await writer.write(cid.bytes);
        if (bytes.length) {
          await writer.write(bytes);
        }
      },
      /**
       * @returns {Promise<void>}
       */
      async close() {
        await writer.end();
      },
      /**
       * @returns {number}
       */
      version() {
        return CAR_V1_VERSION;
      }
    };
  }

  // node_modules/@ipld/car/src/iterator-channel.js
  function noop2() {
  }
  function create5() {
    const chunkQueue = [];
    let drainer = null;
    let drainerResolver = noop2;
    let ended = false;
    let outWait = null;
    let outWaitResolver = noop2;
    const makeDrainer = () => {
      if (!drainer) {
        drainer = new Promise((resolve8) => {
          drainerResolver = () => {
            drainer = null;
            drainerResolver = noop2;
            resolve8();
          };
        });
      }
      return drainer;
    };
    const writer = {
      /**
       * @param {T} chunk
       * @returns {Promise<void>}
       */
      write(chunk) {
        chunkQueue.push(chunk);
        const drainer2 = makeDrainer();
        outWaitResolver();
        return drainer2;
      },
      async end() {
        ended = true;
        const drainer2 = makeDrainer();
        outWaitResolver();
        await drainer2;
      }
    };
    const iterator = {
      /** @returns {Promise<IteratorResult<T>>} */
      async next() {
        const chunk = chunkQueue.shift();
        if (chunk) {
          if (chunkQueue.length === 0) {
            drainerResolver();
          }
          return { done: false, value: chunk };
        }
        if (ended) {
          drainerResolver();
          return { done: true, value: void 0 };
        }
        if (!outWait) {
          outWait = new Promise((resolve8) => {
            outWaitResolver = () => {
              outWait = null;
              outWaitResolver = noop2;
              return resolve8(iterator.next());
            };
          });
        }
        return outWait;
      }
    };
    return { writer, iterator };
  }

  // node_modules/@ipld/car/src/writer-browser.js
  var CarWriter = class _CarWriter {
    /**
     * @param {CID[]} roots
     * @param {CarEncoder} encoder
     */
    constructor(roots, encoder2) {
      this._encoder = encoder2;
      this._mutex = encoder2.setRoots(roots);
      this._ended = false;
    }
    /**
     * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
     *
     * @function
     * @memberof CarWriter
     * @instance
     * @async
     * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
     * @returns {Promise<void>} The returned promise will only resolve once the
     * bytes this block generates are written to the `out` iterable.
     */
    async put(block) {
      if (!(block.bytes instanceof Uint8Array) || !block.cid) {
        throw new TypeError("Can only write {cid, bytes} objects");
      }
      if (this._ended) {
        throw new Error("Already closed");
      }
      const cid = CID.asCID(block.cid);
      if (!cid) {
        throw new TypeError("Can only write {cid, bytes} objects");
      }
      this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }));
      return this._mutex;
    }
    /**
     * Finalise the CAR archive and signal that the `out` iterable should end once
     * any remaining bytes are written.
     *
     * @function
     * @memberof CarWriter
     * @instance
     * @async
     * @returns {Promise<void>}
     */
    async close() {
      if (this._ended) {
        throw new Error("Already closed");
      }
      await this._mutex;
      this._ended = true;
      return this._encoder.close();
    }
    /**
     * Returns the version number of the CAR file being written
     *
     * @returns {number}
     */
    version() {
      return this._encoder.version();
    }
    /**
     * Create a new CAR writer "channel" which consists of a
     * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
     *
     * @async
     * @static
     * @memberof CarWriter
     * @param {CID[] | CID | void} roots
     * @returns {WriterChannel} The channel takes the form of
     * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
     */
    static create(roots) {
      roots = toRoots(roots);
      const { encoder: encoder2, iterator } = encodeWriter();
      const writer = new _CarWriter(roots, encoder2);
      const out = new CarWriterOut(iterator);
      return { writer, out };
    }
    /**
     * Create a new CAR appender "channel" which consists of a
     * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
     * This appender does not consider roots and does not produce a CAR header.
     * It is designed to append blocks to an _existing_ CAR archive. It is
     * expected that `out` will be concatenated onto the end of an existing
     * archive that already has a properly formatted header.
     *
     * @async
     * @static
     * @memberof CarWriter
     * @returns {WriterChannel} The channel takes the form of
     * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
     */
    static createAppender() {
      const { encoder: encoder2, iterator } = encodeWriter();
      encoder2.setRoots = () => Promise.resolve();
      const writer = new _CarWriter([], encoder2);
      const out = new CarWriterOut(iterator);
      return { writer, out };
    }
    /**
     * Update the list of roots in the header of an existing CAR as represented
     * in a Uint8Array.
     *
     * This operation is an _overwrite_, the total length of the CAR will not be
     * modified. A rejection will occur if the new header will not be the same
     * length as the existing header, in which case the CAR will not be modified.
     * It is the responsibility of the user to ensure that the roots being
     * replaced encode as the same length as the new roots.
     *
     * The byte array passed in an argument will be modified and also returned
     * upon successful modification.
     *
     * @async
     * @static
     * @memberof CarWriter
     * @param {Uint8Array} bytes
     * @param {CID[]} roots - A new list of roots to replace the existing list in
     * the CAR header. The new header must take up the same number of bytes as the
     * existing header, so the roots should collectively be the same byte length
     * as the existing roots.
     * @returns {Promise<Uint8Array>}
     */
    static async updateRootsInBytes(bytes, roots) {
      const reader2 = bytesReader(bytes);
      await readHeader(reader2);
      const newHeader = createHeader(roots);
      if (Number(reader2.pos) !== newHeader.length) {
        throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader2.pos} bytes, new header is ${newHeader.length} bytes)`);
      }
      bytes.set(newHeader, 0);
      return bytes;
    }
  };
  var CarWriterOut = class {
    /**
     * @param {AsyncIterator<Uint8Array>} iterator
     */
    constructor(iterator) {
      this._iterator = iterator;
    }
    [Symbol.asyncIterator]() {
      if (this._iterating) {
        throw new Error("Multiple iterator not supported");
      }
      this._iterating = true;
      return this._iterator;
    }
  };
  function encodeWriter() {
    const iw = create5();
    const { writer, iterator } = iw;
    const encoder2 = createEncoder(writer);
    return { encoder: encoder2, iterator };
  }
  function toRoots(roots) {
    if (roots === void 0) {
      return [];
    }
    if (!Array.isArray(roots)) {
      const cid = CID.asCID(roots);
      if (!cid) {
        throw new TypeError("roots must be a single CID or an array of CIDs");
      }
      return [cid];
    }
    const _roots = [];
    for (const root of roots) {
      const _root = CID.asCID(root);
      if (!_root) {
        throw new TypeError("roots must be a single CID or an array of CIDs");
      }
      _roots.push(_root);
    }
    return _roots;
  }

  // node_modules/@helia/car/dist/src/constants.js
  var DAG_PB_CODEC_CODE = 112;
  var RAW_PB_CODEC_CODE = 85;
  var IDENTITY_CODEC_CODE = 0;

  // node_modules/@helia/car/dist/src/export-strategies/subgraph-exporter.js
  var SubgraphExporter = class {
    async *export(cid, blockstore, getCodec2, options2) {
      const walker = breadthFirstWalker({
        blockstore,
        getCodec: getCodec2
      });
      for await (const node of walker.walk(cid, options2)) {
        yield node.block;
      }
    }
  };

  // node_modules/@helia/car/dist/src/car.js
  var Car = class {
    components;
    log;
    constructor(components) {
      this.components = components;
      this.log = components.logger.forComponent("helia:car");
    }
    async import(reader2, options2) {
      await src_default3(this.components.blockstore.putMany(src_default5(reader2.blocks(), ({ cid, bytes }) => ({ cid, bytes })), options2));
    }
    async *export(root, options2) {
      const roots = Array.isArray(root) ? root : [root];
      const { writer, out } = CarWriter.create(roots);
      const iter = out[Symbol.asyncIterator]();
      const controller = new AbortController();
      this._export(roots, writer, options2).catch((err2) => {
        this.log.error("error during streaming export - %e", err2);
        controller.abort(err2);
      });
      while (true) {
        const { done, value: value2 } = await raceSignal(iter.next(), controller.signal);
        if (controller.signal.aborted) {
          throw controller.signal.reason;
        }
        if (value2 != null) {
          yield value2;
        }
        if (done === true) {
          break;
        }
      }
    }
    async _export(roots, writer, options2) {
      const traversalStrategy = options2?.traversal;
      for (const root of roots) {
        if (root.multihash.code === IDENTITY_CODEC_CODE) {
          continue;
        }
        const exportStrategy = options2?.exporter ?? (root.code === DAG_PB_CODEC_CODE ? new UnixFSExporter() : new SubgraphExporter());
        let current = root;
        let underRoot = false;
        if (traversalStrategy != null) {
          for await (const { cid, bytes } of traversalStrategy.traverse(current, this.components.blockstore, this.components.getCodec, options2)) {
            this.log.trace("next CID on path to %c is %c", root, cid);
            current = cid;
            if (root.equals(cid)) {
              underRoot = true;
            }
            if (underRoot || options2?.includeTraversalBlocks === true) {
              if (options2?.blockFilter?.has(cid.multihash.bytes) === true) {
                continue;
              }
              options2?.blockFilter?.add(cid.multihash.bytes);
              await writer.put({
                cid,
                bytes
              });
            }
          }
        }
        for await (const { cid, bytes } of exportStrategy.export(current, this.components.blockstore, this.components.getCodec, options2)) {
          if (options2?.blockFilter?.has(cid.multihash.bytes) === true) {
            continue;
          }
          if (cid.multihash.code === IDENTITY_CODEC_CODE) {
            continue;
          }
          if (underRoot && cid.equals(current)) {
            continue;
          }
          options2?.blockFilter?.add(cid.multihash.bytes);
          await writer.put({
            cid,
            bytes
          });
        }
      }
      await writer.close();
    }
  };

  // node_modules/@helia/car/dist/src/export-strategies/block-exporter.js
  var BlockExporter = class {
    async *export(cid, blockstore, getCodec2, options2) {
      const bytes = await src_default7(blockstore.get(cid, options2));
      yield createUnsafe({
        cid,
        bytes,
        codec: await getCodec2(cid.code)
      });
    }
  };

  // node_modules/ipfs-unixfs/dist/src/errors.js
  var InvalidTypeError = class _InvalidTypeError extends Error {
    static name = "InvalidTypeError";
    static code = "ERR_INVALID_TYPE";
    name = _InvalidTypeError.name;
    code = _InvalidTypeError.code;
    constructor(message2 = "Invalid type") {
      super(message2);
    }
  };
  var InvalidUnixFSMessageError = class _InvalidUnixFSMessageError extends Error {
    static name = "InvalidUnixFSMessageError";
    static code = "ERR_INVALID_MESSAGE";
    name = _InvalidUnixFSMessageError.name;
    code = _InvalidUnixFSMessageError.code;
    constructor(message2 = "Invalid message") {
      super(message2);
    }
  };

  // node_modules/ipfs-unixfs/dist/src/unixfs.js
  var Data;
  (function(Data2) {
    let DataType;
    (function(DataType2) {
      DataType2["Raw"] = "Raw";
      DataType2["Directory"] = "Directory";
      DataType2["File"] = "File";
      DataType2["Metadata"] = "Metadata";
      DataType2["Symlink"] = "Symlink";
      DataType2["HAMTShard"] = "HAMTShard";
    })(DataType = Data2.DataType || (Data2.DataType = {}));
    let __DataTypeValues;
    (function(__DataTypeValues2) {
      __DataTypeValues2[__DataTypeValues2["Raw"] = 0] = "Raw";
      __DataTypeValues2[__DataTypeValues2["Directory"] = 1] = "Directory";
      __DataTypeValues2[__DataTypeValues2["File"] = 2] = "File";
      __DataTypeValues2[__DataTypeValues2["Metadata"] = 3] = "Metadata";
      __DataTypeValues2[__DataTypeValues2["Symlink"] = 4] = "Symlink";
      __DataTypeValues2[__DataTypeValues2["HAMTShard"] = 5] = "HAMTShard";
    })(__DataTypeValues || (__DataTypeValues = {}));
    (function(DataType2) {
      DataType2.codec = () => {
        return enumeration(__DataTypeValues);
      };
    })(DataType = Data2.DataType || (Data2.DataType = {}));
    let _codec;
    Data2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Type != null) {
            w.uint32(8);
            Data2.DataType.codec().encode(obj.Type, w);
          }
          if (obj.Data != null) {
            w.uint32(18);
            w.bytes(obj.Data);
          }
          if (obj.filesize != null) {
            w.uint32(24);
            w.uint64(obj.filesize);
          }
          if (obj.blocksizes != null) {
            for (const value2 of obj.blocksizes) {
              w.uint32(32);
              w.uint64(value2);
            }
          }
          if (obj.hashType != null) {
            w.uint32(40);
            w.uint64(obj.hashType);
          }
          if (obj.fanout != null) {
            w.uint32(48);
            w.uint64(obj.fanout);
          }
          if (obj.mode != null) {
            w.uint32(56);
            w.uint32(obj.mode);
          }
          if (obj.mtime != null) {
            w.uint32(66);
            UnixTime.codec().encode(obj.mtime, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4) => {
          const obj = {
            blocksizes: []
          };
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Type = Data2.DataType.codec().decode(reader2);
                break;
              case 2:
                obj.Data = reader2.bytes();
                break;
              case 3:
                obj.filesize = reader2.uint64();
                break;
              case 4:
                obj.blocksizes.push(reader2.uint64());
                break;
              case 5:
                obj.hashType = reader2.uint64();
                break;
              case 6:
                obj.fanout = reader2.uint64();
                break;
              case 7:
                obj.mode = reader2.uint32();
                break;
              case 8:
                obj.mtime = UnixTime.codec().decode(reader2, reader2.uint32());
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Data2.encode = (obj) => {
      return encodeMessage(obj, Data2.codec());
    };
    Data2.decode = (buf2) => {
      return decodeMessage(buf2, Data2.codec());
    };
  })(Data || (Data = {}));
  var UnixTime;
  (function(UnixTime2) {
    let _codec;
    UnixTime2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.Seconds != null) {
            w.uint32(8);
            w.int64(obj.Seconds);
          }
          if (obj.FractionalNanoseconds != null) {
            w.uint32(21);
            w.fixed32(obj.FractionalNanoseconds);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.Seconds = reader2.int64();
                break;
              case 2:
                obj.FractionalNanoseconds = reader2.fixed32();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    UnixTime2.encode = (obj) => {
      return encodeMessage(obj, UnixTime2.codec());
    };
    UnixTime2.decode = (buf2) => {
      return decodeMessage(buf2, UnixTime2.codec());
    };
  })(UnixTime || (UnixTime = {}));
  var Metadata;
  (function(Metadata2) {
    let _codec;
    Metadata2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.MimeType != null) {
            w.uint32(10);
            w.string(obj.MimeType);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader2, length4) => {
          const obj = {};
          const end = length4 == null ? reader2.len : reader2.pos + length4;
          while (reader2.pos < end) {
            const tag = reader2.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.MimeType = reader2.string();
                break;
              default:
                reader2.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Metadata2.encode = (obj) => {
      return encodeMessage(obj, Metadata2.codec());
    };
    Metadata2.decode = (buf2) => {
      return decodeMessage(buf2, Metadata2.codec());
    };
  })(Metadata || (Metadata = {}));

  // node_modules/ipfs-unixfs/dist/src/index.js
  var types = {
    Raw: "raw",
    Directory: "directory",
    File: "file",
    Metadata: "metadata",
    Symlink: "symlink",
    HAMTShard: "hamt-sharded-directory"
  };
  var dirTypes = [
    "directory",
    "hamt-sharded-directory"
  ];
  var DEFAULT_FILE_MODE = parseInt("0644", 8);
  var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
  var MAX_FANOUT = BigInt(1 << 10);
  var UnixFS = class _UnixFS {
    /**
     * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
     */
    static unmarshal(marshaled) {
      const message2 = Data.decode(marshaled);
      if (message2.fanout != null && message2.fanout > MAX_FANOUT) {
        throw new InvalidUnixFSMessageError(`Fanout size was too large - ${message2.fanout} > ${MAX_FANOUT}`);
      }
      const data = new _UnixFS({
        type: types[message2.Type != null ? message2.Type.toString() : "File"],
        data: message2.Data,
        blockSizes: message2.blocksizes,
        mode: message2.mode,
        mtime: message2.mtime != null ? {
          secs: message2.mtime.Seconds ?? 0n,
          nsecs: message2.mtime.FractionalNanoseconds
        } : void 0,
        fanout: message2.fanout
      });
      data._originalMode = message2.mode ?? 0;
      return data;
    }
    type;
    data;
    blockSizes;
    hashType;
    fanout;
    mtime;
    _mode;
    _originalMode;
    constructor(options2 = {
      type: "file"
    }) {
      const { type, data, blockSizes, hashType, fanout, mtime, mode } = options2;
      if (type != null && !Object.values(types).includes(type)) {
        throw new InvalidTypeError("Type: " + type + " is not valid");
      }
      this.type = type ?? "file";
      this.data = data;
      this.hashType = hashType;
      this.fanout = fanout;
      this.blockSizes = blockSizes ?? [];
      this._originalMode = 0;
      this.mode = mode;
      this.mtime = mtime;
    }
    set mode(mode) {
      if (mode == null) {
        this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
      } else {
        this._mode = mode & 4095;
      }
    }
    get mode() {
      return this._mode;
    }
    isDirectory() {
      return dirTypes.includes(this.type);
    }
    addBlockSize(size) {
      this.blockSizes.push(size);
    }
    removeBlockSize(index) {
      this.blockSizes.splice(index, 1);
    }
    /**
     * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else
     */
    fileSize() {
      if (this.isDirectory()) {
        return 0n;
      }
      let sum = 0n;
      this.blockSizes.forEach((size) => {
        sum += size;
      });
      if (this.data != null) {
        sum += BigInt(this.data.length);
      }
      return sum;
    }
    /**
     * encode to protobuf Uint8Array
     */
    marshal() {
      let type;
      switch (this.type) {
        case "raw":
          type = Data.DataType.Raw;
          break;
        case "directory":
          type = Data.DataType.Directory;
          break;
        case "file":
          type = Data.DataType.File;
          break;
        case "metadata":
          type = Data.DataType.Metadata;
          break;
        case "symlink":
          type = Data.DataType.Symlink;
          break;
        case "hamt-sharded-directory":
          type = Data.DataType.HAMTShard;
          break;
        default:
          throw new InvalidTypeError(`Type: ${type} is not valid`);
      }
      let data = this.data;
      if (this.data == null || this.data.length === 0) {
        data = void 0;
      }
      let mode;
      if (this.mode != null) {
        mode = this._originalMode & 4294963200 | (this.mode ?? 0);
        if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
          mode = void 0;
        }
        if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
          mode = void 0;
        }
      }
      let mtime;
      if (this.mtime != null) {
        mtime = {
          Seconds: this.mtime.secs,
          FractionalNanoseconds: this.mtime.nsecs
        };
      }
      return Data.encode({
        Type: type,
        Data: data,
        filesize: this.isDirectory() ? void 0 : this.fileSize(),
        blocksizes: this.blockSizes,
        hashType: this.hashType,
        fanout: this.fanout,
        mode,
        mtime
      });
    }
  };

  // node_modules/@helia/car/dist/src/errors.js
  var NotUnixFSError = class extends Error {
    static code = "ERR_NOT_UNIXFS";
    static message = "Not a UnixFS node";
    static name = "NotUnixFSError";
    code = "ERR_NOT_UNIXFS";
    message = "Not a UnixFS node";
    name = "NotUnixFSError";
  };
  var NotDescendantError = class extends Error {
    static name = "NotDescendantError";
    name = "NotDescendantError";
  };
  var InvalidTraversalError = class extends Error {
    static name = "InvalidTraversalError";
    name = "InvalidTraversalError";
  };

  // node_modules/@helia/car/dist/src/export-strategies/unixfs-exporter.js
  function isRawBlock(block) {
    return block.cid.code === RAW_PB_CODEC_CODE;
  }
  function isDagPBBlock(block) {
    return block.cid.code === DAG_PB_CODEC_CODE;
  }
  function isFile(block) {
    if (isRawBlock(block)) {
      return true;
    } else if (isDagPBBlock(block) && block.value.Data != null) {
      const u = UnixFS.unmarshal(block.value.Data);
      return u.type === "file" || u.type === "raw";
    } else {
      throw new NotUnixFSError("Encountered non raw/dag-pb CID in UnixFS DAG");
    }
  }
  var UnixFSExporter = class {
    options;
    constructor(options2) {
      this.options = options2;
    }
    async *export(cid, blockstore, getCodec2, options2) {
      if (cid.code !== DAG_PB_CODEC_CODE && cid.code !== RAW_PB_CODEC_CODE) {
        throw new NotUnixFSError("Target CID was not UnixFS - use the SubGraphExporter to export arbitrary graphs");
      }
      const walker = depthFirstWalker({
        blockstore,
        getCodec: getCodec2
      });
      const offset = this.options?.offset ?? 0;
      const length4 = this.options?.length ?? Infinity;
      const listingOnly = this.options?.listingOnly ?? false;
      if (offset < 0) {
        throw new InvalidParametersError("Offset cannot be negative");
      }
      if (length4 < 0) {
        throw new InvalidParametersError("Length cannot be negative");
      }
      let exportingFile;
      const abortController = new AbortController();
      const signal = anySignal([
        abortController.signal,
        options2?.signal
      ]);
      setMaxListeners(Infinity, abortController.signal, signal);
      function includeChild(child, parent) {
        if (exportingFile == null) {
          exportingFile = isFile(parent);
        }
        if (!exportingFile) {
          const link = parent.value.Links.find((l2) => l2.Hash.equals(child));
          const u = UnixFS.unmarshal(parent.value.Data ?? new Uint8Array());
          if (u.type === "directory") {
            return !listingOnly;
          }
          if (u.type === "hamt-sharded-directory" && listingOnly) {
            return link?.Name?.length === 2;
          }
          return true;
        }
        const childIndex = parent.value.Links.findIndex((link) => link.Hash.equals(child));
        const layout = UnixFS.unmarshal(parent.value.Data ?? new Uint8Array());
        const start2 = offset;
        const end = start2 + length4;
        const childStart = Number([...layout.blockSizes].slice(0, childIndex).reduce((curr, acc) => curr + acc, 0n));
        const childEnd = childStart + Number(layout.blockSizes[childIndex]);
        if (start2 >= childStart && start2 < childEnd) {
          return true;
        }
        if (end >= childStart && end < childEnd) {
          return true;
        }
        if (start2 <= childStart && end >= childEnd) {
          return true;
        }
        return false;
      }
      try {
        for await (const node of walker.walk(cid, {
          ...options2,
          includeChild,
          signal
        })) {
          yield node.block;
        }
      } finally {
        abortController.abort();
        signal.clear();
      }
    }
  };

  // node_modules/@helia/car/dist/src/traversal-strategies/cid-path.js
  var CIDPath = class {
    path;
    constructor(path) {
      this.path = path;
    }
    async *traverse(root, blockstore, getCodec2, options2) {
      if (!this.path.some((c2) => c2.equals(root))) {
        throw new InvalidTraversalError(`CIDPath traversal must include ${root}`);
      }
      let parentBlock;
      for (const cid of this.path) {
        if (parentBlock != null) {
          let isChild = false;
          for (const [, child] of parentBlock.links()) {
            if (child.equals(cid)) {
              isChild = true;
              break;
            }
          }
          if (!isChild) {
            throw new NotDescendantError(`${cid} is not a child of ${parentBlock.cid}`);
          }
        }
        const bytes = await src_default7(blockstore.get(cid, options2));
        const block = createUnsafe({
          cid,
          bytes,
          codec: await getCodec2(cid.code)
        });
        parentBlock = block;
        yield block;
      }
    }
  };

  // node_modules/it-last/dist/src/index.js
  function isAsyncIterable14(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function last(source) {
    if (isAsyncIterable14(source)) {
      return (async () => {
        let res2;
        for await (const entry of source) {
          res2 = entry;
        }
        return res2;
      })();
    }
    let res;
    for (const entry of source) {
      res = entry;
    }
    return res;
  }
  var src_default14 = last;

  // node_modules/ipfs-unixfs-exporter/dist/src/errors.js
  var BadPathError = class _BadPathError extends Error {
    static name = "BadPathError";
    static code = "ERR_BAD_PATH";
    name = _BadPathError.name;
    code = _BadPathError.code;
    constructor(message2 = "Bad path") {
      super(message2);
    }
  };
  var NotFoundError3 = class _NotFoundError extends Error {
    static name = "NotFoundError";
    static code = "ERR_NOT_FOUND";
    name = _NotFoundError.name;
    code = _NotFoundError.code;
    constructor(message2 = "Not found") {
      super(message2);
    }
  };
  var NoResolverError = class _NoResolverError extends Error {
    static name = "NoResolverError";
    static code = "ERR_NO_RESOLVER";
    name = _NoResolverError.name;
    code = _NoResolverError.code;
    constructor(message2 = "No resolver") {
      super(message2);
    }
  };
  var NotUnixFSError2 = class _NotUnixFSError extends Error {
    static name = "NotUnixFSError";
    static code = "ERR_NOT_UNIXFS";
    name = _NotUnixFSError.name;
    code = _NotUnixFSError.code;
    constructor(message2 = "Not UnixFS") {
      super(message2);
    }
  };
  var OverReadError = class _OverReadError extends Error {
    static name = "OverReadError";
    static code = "ERR_OVER_READ";
    name = _OverReadError.name;
    code = _OverReadError.code;
    constructor(message2 = "Over read") {
      super(message2);
    }
  };
  var UnderReadError = class _UnderReadError extends Error {
    static name = "UnderReadError";
    static code = "ERR_UNDER_READ";
    name = _UnderReadError.name;
    code = _UnderReadError.code;
    constructor(message2 = "Under read") {
      super(message2);
    }
  };
  var NoPropError = class _NoPropError extends Error {
    static name = "NoPropError";
    static code = "ERR_NO_PROP";
    name = _NoPropError.name;
    code = _NoPropError.code;
    constructor(message2 = "No Property found") {
      super(message2);
    }
  };
  var InvalidParametersError3 = class _InvalidParametersError extends Error {
    static name = "InvalidParametersError";
    static code = "ERR_INVALID_PARAMS";
    name = _InvalidParametersError.name;
    code = _InvalidParametersError.code;
    constructor(message2 = "Invalid parameters") {
      super(message2);
    }
  };

  // node_modules/ipfs-unixfs-exporter/dist/src/utils/resolve-object-path.js
  function resolveObjectPath(object, block, cid, name9, path, toResolve, depth) {
    let subObject = object;
    let subPath = path;
    while (toResolve.length > 0) {
      const prop = toResolve[0];
      if (prop in subObject) {
        toResolve.shift();
        subPath = `${subPath}/${prop}`;
        const subObjectCid = CID.asCID(subObject[prop]);
        if (subObjectCid != null) {
          return {
            entry: {
              type: "object",
              name: name9,
              path,
              cid,
              node: block,
              depth,
              size: BigInt(block.length),
              content: async function* () {
                yield object;
              }
            },
            next: {
              cid: subObjectCid,
              name: prop,
              path: subPath,
              toResolve
            }
          };
        }
        subObject = subObject[prop];
      } else {
        throw new NoPropError(`No property named ${prop} found in node ${cid}`);
      }
    }
    return {
      entry: {
        type: "object",
        name: name9,
        path,
        cid,
        node: block,
        depth,
        size: BigInt(block.length),
        content: async function* () {
          yield object;
        }
      }
    };
  }

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-cbor.js
  var resolve = async (cid, name9, path, toResolve, resolve8, depth, blockstore, options2) => {
    const block = await src_default7(blockstore.get(cid, options2));
    const object = decode11(block);
    return resolveObjectPath(object, block, cid, name9, path, toResolve, depth);
  };
  var dag_cbor_default = resolve;

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/dag-json.js
  var resolve2 = async (cid, name9, path, toResolve, resolve8, depth, blockstore, options2) => {
    const block = await src_default7(blockstore.get(cid, options2));
    const object = decode13(block);
    return resolveObjectPath(object, block, cid, name9, path, toResolve, depth);
  };
  var dag_json_default = resolve2;

  // node_modules/ipfs-unixfs-exporter/dist/src/utils/extract-data-from-block.js
  function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
    const blockLength = BigInt(block.length);
    const blockEnd = BigInt(blockStart + blockLength);
    if (requestedStart >= blockEnd || requestedEnd < blockStart) {
      return new Uint8Array(0);
    }
    if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
      block = block.subarray(0, Number(requestedEnd - blockStart));
    }
    if (requestedStart >= blockStart && requestedStart < blockEnd) {
      block = block.subarray(Number(requestedStart - blockStart));
    }
    return block;
  }
  var extract_data_from_block_default = extractDataFromBlock;

  // node_modules/ipfs-unixfs-exporter/dist/src/utils/validate-offset-and-length.js
  var validateOffsetAndLength = (size, offset = 0, length4 = size) => {
    const fileSize = BigInt(size);
    const start2 = BigInt(offset ?? 0);
    let end = BigInt(length4);
    if (end !== fileSize) {
      end = start2 + end;
    }
    if (end > fileSize) {
      end = fileSize;
    }
    if (start2 < 0n) {
      throw new InvalidParametersError3("Offset must be greater than or equal to 0");
    }
    if (start2 > fileSize) {
      throw new InvalidParametersError3("Offset must be less than the file size");
    }
    if (end < 0n) {
      throw new InvalidParametersError3("Length must be greater than or equal to 0");
    }
    if (end > fileSize) {
      throw new InvalidParametersError3("Length must be less than the file size");
    }
    return {
      start: start2,
      end
    };
  };
  var validate_offset_and_length_default = validateOffsetAndLength;

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/identity.js
  var rawContent = (node) => {
    async function* contentGenerator(options2 = {}) {
      const { start: start2, end } = validate_offset_and_length_default(node.length, options2.offset, options2.length);
      const buf2 = extract_data_from_block_default(node, 0n, start2, end);
      options2.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:identity", {
        bytesRead: BigInt(buf2.byteLength),
        totalBytes: end - start2,
        fileSize: BigInt(node.byteLength)
      }));
      yield buf2;
    }
    return contentGenerator;
  };
  var resolve3 = async (cid, name9, path, toResolve, resolve8, depth, blockstore, options2) => {
    if (toResolve.length > 0) {
      throw new NotFoundError3(`No link named ${path} found in raw node ${cid}`);
    }
    const buf2 = decode4(cid.multihash.bytes);
    return {
      entry: {
        type: "identity",
        name: name9,
        path,
        cid,
        content: rawContent(buf2.digest),
        depth,
        size: BigInt(buf2.digest.length),
        node: buf2.digest
      }
    };
  };
  var identity_default = resolve3;

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/json.js
  var resolve4 = async (cid, name9, path, toResolve, resolve8, depth, blockstore, options2) => {
    const block = await src_default7(blockstore.get(cid, options2));
    const object = decode6(block);
    return resolveObjectPath(object, block, cid, name9, path, toResolve, depth);
  };
  var json_default = resolve4;

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/raw.js
  var rawContent2 = (node) => {
    async function* contentGenerator(options2 = {}) {
      const { start: start2, end } = validate_offset_and_length_default(node.length, options2.offset, options2.length);
      const buf2 = extract_data_from_block_default(node, 0n, start2, end);
      options2.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:raw", {
        bytesRead: BigInt(buf2.byteLength),
        totalBytes: end - start2,
        fileSize: BigInt(node.byteLength)
      }));
      yield buf2;
    }
    return contentGenerator;
  };
  var resolve5 = async (cid, name9, path, toResolve, resolve8, depth, blockstore, options2) => {
    if (toResolve.length > 0) {
      throw new NotFoundError3(`No link named ${path} found in raw node ${cid}`);
    }
    const block = await src_default7(blockstore.get(cid, options2));
    return {
      entry: {
        type: "raw",
        name: name9,
        path,
        cid,
        content: rawContent2(block),
        depth,
        size: BigInt(block.length),
        node: block
      }
    };
  };
  var raw_default = resolve5;

  // node_modules/@multiformats/murmur3/src/index.js
  var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
  function fromNumberTo32BitBuf(number) {
    const bytes = new Array(4);
    for (let i2 = 0; i2 < 4; i2++) {
      bytes[i2] = number & 255;
      number = number >> 8;
    }
    return new Uint8Array(bytes);
  }
  var murmur332 = from2({
    name: "murmur3-32",
    code: 35,
    encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
  });
  var murmur3128 = from2({
    name: "murmur3-128",
    code: 34,
    encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
  });
  var murmur364 = from2({
    name: "murmur3-x64-64",
    code: 34,
    encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input)).subarray(0, 8)
  });

  // node_modules/hamt-sharding/dist/src/bucket.js
  var import_sparse_array = __toESM(require_sparse_array(), 1);
  var Bucket2 = class _Bucket {
    _options;
    _popCount;
    _parent;
    _posAtParent;
    _children;
    key;
    constructor(options2, parent, posAtParent = 0) {
      this._options = options2;
      this._popCount = 0;
      this._parent = parent;
      this._posAtParent = posAtParent;
      this._children = new import_sparse_array.default();
      this.key = null;
    }
    async put(key, value2) {
      const place = await this._findNewBucketAndPos(key);
      place.bucket._putAt(place, key, value2);
    }
    async get(key) {
      const child = await this._findChild(key);
      if (child != null) {
        return child.value;
      }
    }
    async del(key) {
      const place = await this._findPlace(key);
      const child = place.bucket._at(place.pos);
      if (child != null && child.key === key) {
        place.bucket._delAt(place.pos);
      }
    }
    leafCount() {
      const children = this._children.compactArray();
      return children.reduce((acc, child) => {
        if (child instanceof _Bucket) {
          return acc + child.leafCount();
        }
        return acc + 1;
      }, 0);
    }
    childrenCount() {
      return this._children.length;
    }
    onlyChild() {
      return this._children.get(0);
    }
    *eachLeafSeries() {
      const children = this._children.compactArray();
      for (const child of children) {
        if (child instanceof _Bucket) {
          yield* child.eachLeafSeries();
        } else {
          yield child;
        }
      }
    }
    serialize(map2, reduce2) {
      const acc = [];
      return reduce2(this._children.reduce((acc2, child, index) => {
        if (child != null) {
          if (child instanceof _Bucket) {
            acc2.push(child.serialize(map2, reduce2));
          } else {
            acc2.push(map2(child, index));
          }
        }
        return acc2;
      }, acc));
    }
    async asyncTransform(asyncMap, asyncReduce) {
      return asyncTransformBucket(this, asyncMap, asyncReduce);
    }
    toJSON() {
      return this.serialize(mapNode, reduceNodes);
    }
    prettyPrint() {
      return JSON.stringify(this.toJSON(), null, "  ");
    }
    tableSize() {
      return Math.pow(2, this._options.bits);
    }
    async _findChild(key) {
      const result = await this._findPlace(key);
      const child = result.bucket._at(result.pos);
      if (child instanceof _Bucket) {
        return void 0;
      }
      if (child != null && child.key === key) {
        return child;
      }
    }
    async _findPlace(key) {
      const hashValue = this._options.hash(typeof key === "string" ? fromString2(key) : key);
      const index = await hashValue.take(this._options.bits);
      const child = this._children.get(index);
      if (child instanceof _Bucket) {
        return child._findPlace(hashValue);
      }
      return {
        bucket: this,
        pos: index,
        hash: hashValue,
        existingChild: child
      };
    }
    async _findNewBucketAndPos(key) {
      const place = await this._findPlace(key);
      if (place.existingChild != null && place.existingChild.key !== key) {
        const bucket = new _Bucket(this._options, place.bucket, place.pos);
        place.bucket._putObjectAt(place.pos, bucket);
        const newPlace = await bucket._findPlace(place.existingChild.hash);
        newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
        return bucket._findNewBucketAndPos(place.hash);
      }
      return place;
    }
    _putAt(place, key, value2) {
      this._putObjectAt(place.pos, {
        key,
        value: value2,
        hash: place.hash
      });
    }
    _putObjectAt(pos, object) {
      if (this._children.get(pos) == null) {
        this._popCount++;
      }
      this._children.set(pos, object);
    }
    _delAt(pos) {
      if (pos === -1) {
        throw new Error("Invalid position");
      }
      if (this._children.get(pos) != null) {
        this._popCount--;
      }
      this._children.unset(pos);
      this._level();
    }
    _level() {
      if (this._parent != null && this._popCount <= 1) {
        if (this._popCount === 1) {
          const onlyChild = this._children.find(exists);
          if (onlyChild != null && !(onlyChild instanceof _Bucket)) {
            const hash = onlyChild.hash;
            hash.untake(this._options.bits);
            const place = {
              pos: this._posAtParent,
              hash,
              bucket: this._parent
            };
            this._parent._putAt(place, onlyChild.key, onlyChild.value);
          }
        } else {
          this._parent._delAt(this._posAtParent);
        }
      }
    }
    _at(index) {
      return this._children.get(index);
    }
  };
  function exists(o2) {
    return Boolean(o2);
  }
  function mapNode(node, _) {
    return node.key;
  }
  function reduceNodes(nodes) {
    return nodes;
  }
  async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
    const output = [];
    for (const child of bucket._children.compactArray()) {
      if (child instanceof Bucket2) {
        await asyncTransformBucket(child, asyncMap, asyncReduce);
      } else {
        const mappedChildren = await asyncMap(child);
        output.push({
          bitField: bucket._children.bitField(),
          children: mappedChildren
        });
      }
    }
    return asyncReduce(output);
  }

  // node_modules/hamt-sharding/dist/src/consumable-buffer.js
  var START_MASKS = [
    255,
    254,
    252,
    248,
    240,
    224,
    192,
    128
  ];
  var STOP_MASKS = [
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255
  ];
  var ConsumableBuffer = class {
    _value;
    _currentBytePos;
    _currentBitPos;
    constructor(value2) {
      this._value = value2;
      this._currentBytePos = value2.length - 1;
      this._currentBitPos = 7;
    }
    availableBits() {
      return this._currentBitPos + 1 + this._currentBytePos * 8;
    }
    totalBits() {
      return this._value.length * 8;
    }
    take(bits2) {
      let pendingBits = bits2;
      let result = 0;
      while (pendingBits > 0 && this._haveBits()) {
        const byte = this._value[this._currentBytePos];
        const availableBits = this._currentBitPos + 1;
        const taking = Math.min(availableBits, pendingBits);
        const value2 = byteBitsToInt(byte, availableBits - taking, taking);
        result = (result << taking) + value2;
        pendingBits -= taking;
        this._currentBitPos -= taking;
        if (this._currentBitPos < 0) {
          this._currentBitPos = 7;
          this._currentBytePos--;
        }
      }
      return result;
    }
    untake(bits2) {
      this._currentBitPos += bits2;
      while (this._currentBitPos > 7) {
        this._currentBitPos -= 8;
        this._currentBytePos += 1;
      }
    }
    _haveBits() {
      return this._currentBytePos >= 0;
    }
  };
  function byteBitsToInt(byte, start2, length4) {
    const mask = maskFor(start2, length4);
    return (byte & mask) >>> start2;
  }
  function maskFor(start2, length4) {
    return START_MASKS[start2] & STOP_MASKS[Math.min(length4 + start2 - 1, 7)];
  }

  // node_modules/hamt-sharding/dist/src/consumable-hash.js
  function wrapHash(hashFn2) {
    function hashing(value2) {
      if (value2 instanceof InfiniteHash) {
        return value2;
      } else {
        return new InfiniteHash(value2, hashFn2);
      }
    }
    return hashing;
  }
  var InfiniteHash = class {
    _value;
    _hashFn;
    _depth;
    _availableBits;
    _currentBufferIndex;
    _buffers;
    constructor(value2, hashFn2) {
      if (!(value2 instanceof Uint8Array)) {
        throw new Error("can only hash Uint8Arrays");
      }
      this._value = value2;
      this._hashFn = hashFn2;
      this._depth = -1;
      this._availableBits = 0;
      this._currentBufferIndex = 0;
      this._buffers = [];
    }
    async take(bits2) {
      let pendingBits = bits2;
      while (this._availableBits < pendingBits) {
        await this._produceMoreBits();
      }
      let result = 0;
      while (pendingBits > 0) {
        const hash = this._buffers[this._currentBufferIndex];
        const available = Math.min(hash.availableBits(), pendingBits);
        const took = hash.take(available);
        result = (result << available) + took;
        pendingBits -= available;
        this._availableBits -= available;
        if (hash.availableBits() === 0) {
          this._currentBufferIndex++;
        }
      }
      return result;
    }
    untake(bits2) {
      let pendingBits = bits2;
      while (pendingBits > 0) {
        const hash = this._buffers[this._currentBufferIndex];
        const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
        hash.untake(availableForUntake);
        pendingBits -= availableForUntake;
        this._availableBits += availableForUntake;
        if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
          this._depth--;
          this._currentBufferIndex--;
        }
      }
    }
    async _produceMoreBits() {
      this._depth++;
      const value2 = this._depth > 0 ? concat([this._value, Uint8Array.from([this._depth])]) : this._value;
      const hashValue = await this._hashFn(value2);
      const buffer2 = new ConsumableBuffer(hashValue);
      this._buffers.push(buffer2);
      this._availableBits += buffer2.availableBits();
    }
  };

  // node_modules/hamt-sharding/dist/src/index.js
  function createHAMT(options2) {
    if (options2 == null || options2.hashFn == null) {
      throw new Error("please define an options.hashFn");
    }
    const bucketOptions = {
      bits: options2.bits ?? 8,
      hash: wrapHash(options2.hashFn)
    };
    return new Bucket2(bucketOptions);
  }

  // node_modules/ipfs-unixfs-exporter/dist/src/utils/find-cid-in-shard.js
  var hashFn = async function(buf2) {
    return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
  };
  var addLinksToHamtBucket = async (links2, bucket, rootBucket) => {
    const padLength = (bucket.tableSize() - 1).toString(16).length;
    await Promise.all(links2.map(async (link) => {
      if (link.Name == null) {
        throw new Error("Unexpected Link without a Name");
      }
      if (link.Name.length === padLength) {
        const pos = parseInt(link.Name, 16);
        bucket._putObjectAt(pos, new Bucket2({
          hash: rootBucket._options.hash,
          bits: rootBucket._options.bits
        }, bucket, pos));
        return;
      }
      await rootBucket.put(link.Name.substring(2), true);
    }));
  };
  var toPrefix = (position, padLength) => {
    return position.toString(16).toUpperCase().padStart(padLength, "0").substring(0, padLength);
  };
  var toBucketPath = (position) => {
    let bucket = position.bucket;
    const path = [];
    while (bucket._parent != null) {
      path.push(bucket);
      bucket = bucket._parent;
    }
    path.push(bucket);
    return path.reverse();
  };
  var findShardCid = async (node, name9, blockstore, context, options2) => {
    if (context == null) {
      if (node.Data == null) {
        throw new NotUnixFSError2("no data in PBNode");
      }
      let dir;
      try {
        dir = UnixFS.unmarshal(node.Data);
      } catch (err2) {
        throw new NotUnixFSError2(err2.message);
      }
      if (dir.type !== "hamt-sharded-directory") {
        throw new NotUnixFSError2("not a HAMT");
      }
      if (dir.fanout == null) {
        throw new NotUnixFSError2("missing fanout");
      }
      const rootBucket = createHAMT({
        hashFn,
        bits: Math.log2(Number(dir.fanout))
      });
      context = {
        rootBucket,
        hamtDepth: 1,
        lastBucket: rootBucket
      };
    }
    const padLength = (context.lastBucket.tableSize() - 1).toString(16).length;
    await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
    const position = await context.rootBucket._findNewBucketAndPos(name9);
    let prefix = toPrefix(position.pos, padLength);
    const bucketPath = toBucketPath(position);
    if (bucketPath.length > context.hamtDepth) {
      context.lastBucket = bucketPath[context.hamtDepth];
      prefix = toPrefix(context.lastBucket._posAtParent, padLength);
    }
    const link = node.Links.find((link2) => {
      if (link2.Name == null) {
        return false;
      }
      const entryPrefix = link2.Name.substring(0, padLength);
      const entryName = link2.Name.substring(padLength);
      if (entryPrefix !== prefix) {
        return false;
      }
      if (entryName !== "" && entryName !== name9) {
        return false;
      }
      return true;
    });
    if (link == null) {
      return;
    }
    if (link.Name != null && link.Name.substring(padLength) === name9) {
      return link.Hash;
    }
    context.hamtDepth++;
    const block = await src_default7(blockstore.get(link.Hash, options2));
    node = decode14(block);
    return findShardCid(node, name9, blockstore, context, options2);
  };
  var find_cid_in_shard_default = findShardCid;

  // node_modules/ipfs-unixfs-exporter/dist/src/utils/is-basic-exporter-options.js
  function isBasicExporterOptions(obj) {
    return obj?.extended === false;
  }

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/directory.js
  var directoryContent = (cid, node, unixfs2, path, resolve8, depth, blockstore) => {
    async function* yieldDirectoryContent(options2 = {}) {
      const offset = options2.offset ?? 0;
      const length4 = options2.length ?? node.Links.length;
      const links2 = node.Links.slice(offset, length4);
      options2.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:directory", {
        cid
      }));
      yield* pipe(links2, (source) => src_default5(source, (link) => {
        return async () => {
          const linkName = link.Name ?? "";
          const linkPath = `${path}/${linkName}`;
          if (isBasicExporterOptions(options2)) {
            const basic = {
              cid: link.Hash,
              name: linkName,
              path: linkPath
            };
            return basic;
          }
          const result = await resolve8(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options2);
          return result.entry;
        };
      }), (source) => parallel(source, {
        ordered: true,
        concurrency: options2.blockReadConcurrency
      }), (source) => src_default8(source, (entry) => entry != null));
    }
    return yieldDirectoryContent;
  };
  var directory_default = directoryContent;

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/file.js
  async function walkDAG(blockstore, node, queue, streamPosition, start2, end, options2) {
    if (node instanceof Uint8Array) {
      const buf2 = extract_data_from_block_default(node, streamPosition, start2, end);
      queue.push(buf2);
      return;
    }
    if (node.Data == null) {
      throw new NotUnixFSError2("no data in PBNode");
    }
    let file;
    try {
      file = UnixFS.unmarshal(node.Data);
    } catch (err2) {
      throw new NotUnixFSError2(err2.message);
    }
    if (file.data != null) {
      const data = file.data;
      const buf2 = extract_data_from_block_default(data, streamPosition, start2, end);
      queue.push(buf2);
      streamPosition += BigInt(buf2.byteLength);
    }
    const childOps = [];
    if (node.Links.length !== file.blockSizes.length) {
      throw new NotUnixFSError2("Inconsistent block sizes and dag links");
    }
    for (let i2 = 0; i2 < node.Links.length; i2++) {
      const childLink = node.Links[i2];
      const childStart = streamPosition;
      const childEnd = childStart + file.blockSizes[i2];
      if (start2 >= childStart && start2 < childEnd || // child has offset byte
      end >= childStart && end <= childEnd || // child has end byte
      start2 < childStart && end > childEnd) {
        childOps.push({
          link: childLink,
          blockStart: streamPosition
        });
      }
      streamPosition = childEnd;
      if (streamPosition > end) {
        break;
      }
    }
    await pipe(childOps, (source) => src_default5(source, (op) => {
      return async () => {
        const block = await src_default7(blockstore.get(op.link.Hash, options2));
        return {
          ...op,
          block
        };
      };
    }), (source) => parallel(source, {
      ordered: true,
      concurrency: options2.blockReadConcurrency
    }), async (source) => {
      for await (const { link, block, blockStart } of source) {
        let child;
        switch (link.Hash.code) {
          case code6:
            child = decode14(block);
            break;
          case code3:
            child = block;
            break;
          default:
            queue.end(new NotUnixFSError2(`Unsupported codec: ${link.Hash.code}`));
            return;
        }
        const childQueue = new PQueue({
          concurrency: 1
        });
        childQueue.on("error", (error) => {
          queue.end(error);
        });
        void childQueue.add(async () => {
          options2.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:file", {
            cid: link.Hash
          }));
          await walkDAG(blockstore, child, queue, blockStart, start2, end, options2);
        });
        await childQueue.onIdle();
      }
    });
    if (streamPosition >= end) {
      queue.end();
    }
  }
  var fileContent = (cid, node, unixfs2, path, resolve8, depth, blockstore) => {
    async function* yieldFileContent(options2 = {}) {
      const fileSize = unixfs2.fileSize();
      if (fileSize === void 0) {
        throw new Error("File was a directory");
      }
      const { start: start2, end } = validate_offset_and_length_default(fileSize, options2.offset, options2.length);
      if (end === 0n) {
        return;
      }
      let read4 = 0n;
      const wanted = end - start2;
      const queue = pushable();
      options2.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:file", {
        cid
      }));
      void walkDAG(blockstore, node, queue, 0n, start2, end, options2).catch((err2) => {
        queue.end(err2);
      });
      for await (const buf2 of queue) {
        if (buf2 == null) {
          continue;
        }
        read4 += BigInt(buf2.byteLength);
        if (read4 > wanted) {
          queue.end();
          throw new OverReadError("Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect");
        }
        if (read4 === wanted) {
          queue.end();
        }
        options2.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:unixfs:file", {
          bytesRead: read4,
          totalBytes: wanted,
          fileSize
        }));
        yield buf2;
      }
      if (read4 < wanted) {
        throw new UnderReadError("Traversed entire DAG but did not read enough bytes");
      }
    }
    return yieldFileContent;
  };
  var file_default = fileContent;

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
  var hamtShardedDirectoryContent = (cid, node, unixfs2, path, resolve8, depth, blockstore) => {
    function yieldHamtDirectoryContent(options2 = {}) {
      options2.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:hamt-sharded-directory", {
        cid
      }));
      return listDirectory(node, path, resolve8, depth, blockstore, options2);
    }
    return yieldHamtDirectoryContent;
  };
  async function* listDirectory(node, path, resolve8, depth, blockstore, options2) {
    const links2 = node.Links;
    if (node.Data == null) {
      throw new NotUnixFSError2("no data in PBNode");
    }
    let dir;
    try {
      dir = UnixFS.unmarshal(node.Data);
    } catch (err2) {
      throw new NotUnixFSError2(err2.message);
    }
    if (dir.fanout == null) {
      throw new NotUnixFSError2("missing fanout");
    }
    const padLength = (dir.fanout - 1n).toString(16).length;
    const results = pipe(links2, (source) => src_default5(source, (link) => {
      return async () => {
        const name9 = link.Name != null ? link.Name.substring(padLength) : null;
        if (name9 != null && name9 !== "") {
          const linkPath = `${path}/${name9}`;
          if (isBasicExporterOptions(options2)) {
            const basic = {
              cid: link.Hash,
              name: name9,
              path: linkPath
            };
            return {
              entries: [
                basic
              ]
            };
          }
          const result = await resolve8(link.Hash, name9, linkPath, [], depth + 1, blockstore, options2);
          return {
            entries: [
              result.entry
            ].filter(Boolean)
          };
        } else {
          const block = await src_default7(blockstore.get(link.Hash, options2));
          node = decode14(block);
          options2.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:hamt-sharded-directory", {
            cid: link.Hash
          }));
          return {
            entries: listDirectory(node, path, resolve8, depth, blockstore, options2)
          };
        }
      };
    }), (source) => parallel(source, {
      ordered: true,
      concurrency: options2.blockReadConcurrency
    }));
    for await (const { entries } of results) {
      yield* entries;
    }
  }
  var hamt_sharded_directory_default = hamtShardedDirectoryContent;

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/unixfs-v1/index.js
  var findLinkCid = (node, name9) => {
    const link = node.Links.find((link2) => link2.Name === name9);
    return link?.Hash;
  };
  var contentExporters = {
    raw: file_default,
    file: file_default,
    directory: directory_default,
    "hamt-sharded-directory": hamt_sharded_directory_default,
    metadata: (cid, node, unixfs2, path, resolve8, depth, blockstore) => {
      return () => [];
    },
    symlink: (cid, node, unixfs2, path, resolve8, depth, blockstore) => {
      return () => [];
    }
  };
  var unixFsResolver = async (cid, name9, path, toResolve, resolve8, depth, blockstore, options2) => {
    if (isBasicExporterOptions(options2) && toResolve.length === 0) {
      const basic = {
        cid,
        name: name9,
        path
      };
      return {
        entry: basic
      };
    }
    const block = await src_default7(blockstore.get(cid, options2));
    const node = decode14(block);
    let unixfs2;
    let next;
    if (name9 == null) {
      name9 = cid.toString();
    }
    if (node.Data == null) {
      throw new NotUnixFSError2("no data in PBNode");
    }
    try {
      unixfs2 = UnixFS.unmarshal(node.Data);
    } catch (err2) {
      throw new NotUnixFSError2(err2.message);
    }
    if (path == null) {
      path = name9;
    }
    if (toResolve.length > 0) {
      let linkCid;
      if (unixfs2?.type === "hamt-sharded-directory") {
        linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
      } else {
        linkCid = findLinkCid(node, toResolve[0]);
      }
      if (linkCid == null) {
        throw new NotFoundError3("file does not exist");
      }
      const nextName = toResolve.shift();
      const nextPath = `${path}/${nextName}`;
      next = {
        cid: linkCid,
        toResolve,
        name: nextName ?? "",
        path: nextPath
      };
    }
    const content = contentExporters[unixfs2.type](cid, node, unixfs2, path, resolve8, depth, blockstore);
    if (content == null) {
      throw new NotFoundError3("could not find content exporter");
    }
    if (unixfs2.isDirectory()) {
      return {
        entry: {
          type: "directory",
          name: name9,
          path,
          cid,
          content,
          unixfs: unixfs2,
          depth,
          node,
          size: unixfs2.fileSize()
        },
        next
      };
    }
    return {
      entry: {
        type: "file",
        name: name9,
        path,
        cid,
        content,
        unixfs: unixfs2,
        depth,
        node,
        size: unixfs2.fileSize()
      },
      next
    };
  };
  var unixfs_v1_default = unixFsResolver;

  // node_modules/ipfs-unixfs-exporter/dist/src/resolvers/index.js
  var resolvers = {
    [code6]: unixfs_v1_default,
    [code3]: raw_default,
    [code4]: dag_cbor_default,
    [code5]: dag_json_default,
    [identity.code]: identity_default,
    [code2]: json_default
  };
  var resolve6 = async (cid, name9, path, toResolve, depth, blockstore, options2) => {
    const resolver = resolvers[cid.code];
    if (resolver == null) {
      throw new NoResolverError(`No resolver for code ${cid.code}`);
    }
    return resolver(cid, name9, path, toResolve, resolve6, depth, blockstore, options2);
  };
  var resolvers_default = resolve6;

  // node_modules/ipfs-unixfs-exporter/dist/src/index.js
  var toPathComponents = (path = "") => {
    return (path.trim().match(/([^\\^/]|\\\/)+/g) ?? []).filter(Boolean);
  };
  var cidAndRest = (path) => {
    if (path instanceof Uint8Array) {
      return {
        cid: CID.decode(path),
        toResolve: []
      };
    }
    const cid = CID.asCID(path);
    if (cid != null) {
      return {
        cid,
        toResolve: []
      };
    }
    if (typeof path === "string") {
      if (path.indexOf("/ipfs/") === 0) {
        path = path.substring(6);
      }
      const output = toPathComponents(path);
      return {
        cid: CID.parse(output[0]),
        toResolve: output.slice(1)
      };
    }
    throw new BadPathError(`Unknown path type ${path}`);
  };
  async function* walkPath(path, blockstore, options2 = {}) {
    let { cid, toResolve } = cidAndRest(path);
    let name9 = cid.toString();
    let entryPath = name9;
    const startingDepth = toResolve.length;
    while (true) {
      const result = await resolvers_default(cid, name9, entryPath, toResolve, startingDepth, blockstore, options2);
      if (result.entry == null && result.next == null) {
        throw new NotFoundError3(`Could not resolve ${path}`);
      }
      if (result.entry != null) {
        yield result.entry;
      }
      if (result.next == null) {
        return;
      }
      toResolve = result.next.toResolve;
      cid = result.next.cid;
      name9 = result.next.name;
      entryPath = result.next.path;
    }
  }
  async function exporter2(path, blockstore, options2 = {}) {
    const result = await src_default14(walkPath(path, blockstore, options2));
    if (result == null) {
      throw new NotFoundError3(`Could not resolve ${path}`);
    }
    return result;
  }
  async function* recursive(path, blockstore, options2 = {}) {
    const node = await exporter2(path, blockstore, options2);
    if (node == null) {
      return;
    }
    yield node;
    if (node.type === "directory") {
      for await (const child of recurse(node, options2)) {
        yield child;
      }
    }
    async function* recurse(node2, options3) {
      for await (const file of node2.content(options3)) {
        yield file;
        if (file instanceof Uint8Array) {
          continue;
        }
        if (file.type === "directory") {
          yield* recurse(file, options3);
        }
      }
    }
  }

  // node_modules/@helia/car/dist/src/index.js
  function car(helia2) {
    return new Car(helia2);
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/get-offset-and-length.js
  function getOffsetAndLength(entry, entityBytes) {
    if (entityBytes == null) {
      return {
        offset: 0,
        length: Infinity
      };
    }
    const parts = entityBytes.split(":");
    const start2 = parseInt(parts[0], 10);
    const end = parts[1] === "*" ? Infinity : parseInt(parts[1], 10);
    if (isNaN(start2) || isNaN(end)) {
      throw new Error("Could not parse entity-bytes");
    }
    const entrySize = Number(entry.size);
    if (start2 >= 0) {
      if (end >= 0) {
        return {
          offset: start2,
          length: end - start2
        };
      } else {
        return {
          offset: start2,
          length: entrySize - start2 + end
        };
      }
    }
    let offset = entrySize + start2;
    if (Math.abs(start2) > entrySize) {
      offset = 0;
    }
    if (end >= 0) {
      return {
        offset,
        length: entrySize - offset + end
      };
    }
    return {
      offset,
      length: entrySize - offset + end
    };
  }

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-car.js
  function getFilename({ cid, ipfsPath, query }) {
    if (query.filename != null) {
      return query.filename;
    }
    const filename = ipfsPath.replace(/\/ipfs\//, "").replace(/\/ipns\//, "").replace(/\//g, "_");
    return `${filename}.car`;
  }
  function getDagScope({ query }) {
    const dagScope = query["dag-scope"];
    if (dagScope === "all" || dagScope === "entity" || dagScope === "block") {
      return dagScope;
    }
    if (query["entity-bytes"]) {
      return "entity";
    }
    return "all";
  }
  var CarPlugin = class extends BasePlugin {
    id = "car-plugin";
    canHandle(context) {
      if (context.byteRangeContext == null) {
        return false;
      }
      if (context.pathDetails == null) {
        return false;
      }
      return context.accept?.mimeType.startsWith("application/vnd.ipld.car") === true || context.query.format === "car";
    }
    async handle(context) {
      const { options: options2, pathDetails, cid, query, accept } = context;
      const order = accept?.options.order === "dfs" ? "dfs" : "unk";
      const duplicates = accept?.options.dups !== "n";
      if (pathDetails == null) {
        throw new Error("attempted to handle request for car with no path details");
      }
      const { getBlockstore, helia: helia2 } = this.pluginOptions;
      context.reqFormat = "car";
      context.query.download = true;
      context.query.filename = getFilename(context);
      const blockstore = getBlockstore(cid, context.resource, options2?.session ?? true, options2);
      const c2 = car({
        blockstore,
        getCodec: helia2.getCodec,
        logger: helia2.logger
      });
      const carExportOptions = {
        ...options2,
        includeTraversalBlocks: true
      };
      if (!duplicates) {
        carExportOptions.blockFilter = createScalableCuckooFilter(1024);
      }
      if (pathDetails.ipfsRoots.length > 1) {
        carExportOptions.traversal = new CIDPath(pathDetails.ipfsRoots);
      }
      const dagScope = getDagScope(context);
      const target = pathDetails.terminalElement.cid ?? cid;
      if (dagScope === "block") {
        carExportOptions.exporter = new BlockExporter();
      } else if (dagScope === "entity") {
        if (target.code === code6) {
          const options3 = {
            listingOnly: true
          };
          const slice2 = getOffsetAndLength(pathDetails.terminalElement, query["entity-bytes"]?.toString());
          options3.offset = slice2.offset;
          options3.length = slice2.length;
          carExportOptions.exporter = new UnixFSExporter(options3);
        } else {
          carExportOptions.exporter = new BlockExporter();
        }
      } else {
        carExportOptions.exporter = new SubgraphExporter();
      }
      context.byteRangeContext.setBody(itToBrowserReadableStream(c2.export(target, carExportOptions)));
      const response = okRangeResponse(context.resource, context.byteRangeContext.getBody("application/vnd.ipld.car; version=1"), {
        byteRangeContext: context.byteRangeContext,
        log: this.log
      });
      response.headers.set("content-type", context.byteRangeContext.getContentType() ?? `application/vnd.ipld.car; version=1; order=${order}; dups=${duplicates ? "y" : "n"}`);
      return response;
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/utils/dag-cbor-to-safe-json.js
  function dagCborToSafeJSON(buf2) {
    const obj = decode9(buf2, {
      allowIndefinite: false,
      coerceUndefinedToNull: false,
      allowNaN: false,
      allowInfinity: false,
      strict: true,
      useMaps: false,
      rejectDuplicateMapKeys: true,
      // this is different to `DAG-CBOR` - the reason we disallow BigInts is
      // because we are about to re-encode to `JSON` which does not support
      // BigInts. Blocks containing large numbers should be deserialized using a
      // cbor decoder instead
      allowBigInt: false
    });
    return new TextDecoder().decode(encode11(obj));
  }

  // node_modules/@helia/unixfs/dist/src/errors.js
  var UnixFSError = class extends Error {
    name;
    code;
    constructor(message2, name9, code8) {
      super(message2);
      this.name = name9;
      this.code = code8;
    }
  };
  var NotUnixFSError3 = class extends UnixFSError {
    constructor(message2 = "not a Unixfs node") {
      super(message2, "NotUnixFSError", "ERR_NOT_UNIXFS");
    }
  };
  var InvalidPBNodeError = class extends UnixFSError {
    constructor(message2 = "invalid PBNode") {
      super(message2, "InvalidPBNodeError", "ERR_INVALID_PB_NODE");
    }
  };
  var UnknownError = class extends UnixFSError {
    constructor(message2 = "unknown error") {
      super(message2, "InvalidPBNodeError", "ERR_UNKNOWN_ERROR");
    }
  };
  var AlreadyExistsError = class extends UnixFSError {
    constructor(message2 = "path already exists") {
      super(message2, "AlreadyExistsError", "ERR_ALREADY_EXISTS");
    }
  };
  var DoesNotExistError = class extends UnixFSError {
    constructor(message2 = "path does not exist") {
      super(message2, "DoesNotExistError", "ERR_DOES_NOT_EXIST");
    }
  };
  var NoContentError2 = class extends UnixFSError {
    constructor(message2 = "no content") {
      super(message2, "NoContentError", "ERR_NO_CONTENT");
    }
  };
  var NotAFileError = class extends UnixFSError {
    constructor(message2 = "not a file") {
      super(message2, "NotAFileError", "ERR_NOT_A_FILE");
    }
  };
  var NotADirectoryError = class extends UnixFSError {
    constructor(message2 = "not a directory") {
      super(message2, "NotADirectoryError", "ERR_NOT_A_DIRECTORY");
    }
  };
  var InvalidParametersError4 = class extends UnixFSError {
    constructor(message2 = "invalid parameters") {
      super(message2, "InvalidParametersError", "ERR_INVALID_PARAMETERS");
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/utils/walk-path.js
  async function walkPath2(blockstore, path, options2) {
    const ipfsRoots = [];
    let terminalElement;
    for await (const entry of walkPath(path, blockstore, options2)) {
      ipfsRoots.push(entry.cid);
      terminalElement = entry;
    }
    if (terminalElement == null) {
      throw new DoesNotExistError("No terminal element found");
    }
    return {
      ipfsRoots,
      terminalElement
    };
  }
  function isObjectNode(node) {
    return node.type === "object";
  }
  async function handlePathWalking({ cid, path, resource, options: options2, blockstore, log: log18 }) {
    try {
      return await walkPath2(blockstore, `${cid}/${path}`, options2);
    } catch (err2) {
      if (options2?.signal?.aborted) {
        throw new AbortError(options2?.signal?.reason);
      }
      if (["ERR_NO_PROP", "ERR_NO_TERMINAL_ELEMENT", "ERR_NOT_FOUND"].includes(err2.code)) {
        return notFoundResponse(resource);
      }
      log18.error('error walking path "%s" - %e', path, err2);
      return badGatewayResponse(resource, "Error walking path");
    }
  }

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-dag-cbor.js
  var DagCborPlugin = class extends BasePlugin {
    id = "dag-cbor-plugin";
    codes = [code4];
    canHandle({ cid, accept, pathDetails, byteRangeContext, plugins }) {
      if (pathDetails == null) {
        return false;
      }
      if (!isObjectNode(pathDetails.terminalElement)) {
        return false;
      }
      if (cid.code !== code4) {
        return false;
      }
      if (byteRangeContext == null) {
        return false;
      }
      if (accept != null && accept.mimeType === "text/html" && plugins.includes("dag-cbor-plugin-html-preview")) {
        return false;
      }
      return isObjectNode(pathDetails.terminalElement);
    }
    async handle(context) {
      const { cid, path, resource, accept, pathDetails: { terminalElement, ipfsRoots } } = context;
      this.log.trace("fetching %c/%s", cid, path);
      const block = terminalElement.node;
      let body;
      if (accept?.mimeType === "application/octet-stream" || accept?.mimeType === "application/vnd.ipld.dag-cbor" || accept?.mimeType === "application/cbor") {
        body = block;
      } else if (accept?.mimeType === "application/vnd.ipld.dag-json") {
        try {
          const obj = decode11(block);
          body = encode12(obj);
        } catch (err2) {
          this.log.error("could not transform %c to application/vnd.ipld.dag-json", err2);
          return notAcceptableResponse(resource);
        }
      } else {
        try {
          body = dagCborToSafeJSON(block);
        } catch (err2) {
          if (accept?.mimeType === "application/json") {
            this.log('could not decode DAG-CBOR as JSON-safe, but the client sent "Accept: application/json"', err2);
            return notAcceptableResponse(resource);
          }
          this.log("could not decode DAG-CBOR as JSON-safe, falling back to `application/octet-stream`", err2);
          body = block;
        }
      }
      context.byteRangeContext.setBody(body);
      const responseContentType = accept?.mimeType ?? (body instanceof Uint8Array ? "application/octet-stream" : "application/json");
      const response = okRangeResponse(resource, context.byteRangeContext.getBody(responseContentType), { byteRangeContext: context.byteRangeContext, log: this.log });
      response.headers.set("content-type", context.byteRangeContext.getContentType() ?? responseContentType);
      this.log.trace('setting content type to "%s"', context.byteRangeContext.getContentType() ?? responseContentType);
      setIpfsRoots(response, ipfsRoots);
      return response;
    }
  };

  // node_modules/it-batch/dist/src/index.js
  function isAsyncIterable15(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function batch(source, size = 1) {
    size = Number(size);
    if (isAsyncIterable15(source)) {
      return (async function* () {
        let things = [];
        if (size < 1) {
          size = 1;
        }
        if (size !== Math.round(size)) {
          throw new Error("Batch size must be an integer");
        }
        for await (const thing of source) {
          things.push(thing);
          while (things.length >= size) {
            yield things.slice(0, size);
            things = things.slice(size);
          }
        }
        while (things.length > 0) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      })();
    }
    return (function* () {
      let things = [];
      if (size < 1) {
        size = 1;
      }
      if (size !== Math.round(size)) {
        throw new Error("Batch size must be an integer");
      }
      for (const thing of source) {
        things.push(thing);
        while (things.length >= size) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      }
      while (things.length > 0) {
        yield things.slice(0, size);
        things = things.slice(size);
      }
    })();
  }
  var src_default15 = batch;

  // node_modules/it-parallel-batch/dist/src/index.js
  async function* parallelBatch(source, size = 1) {
    for await (const tasks of src_default15(source, size)) {
      const things = tasks.map(async (p2) => {
        return p2().then((value2) => ({ ok: true, value: value2 }), (err2) => ({ ok: false, err: err2 }));
      });
      for (let i2 = 0; i2 < things.length; i2++) {
        const result = await things[i2];
        if (result.ok) {
          yield result.value;
        } else {
          throw result.err;
        }
      }
    }
  }

  // node_modules/ipfs-unixfs-importer/dist/src/chunker/fixed-size.js
  var DEFAULT_CHUNK_SIZE = 262144;
  var fixedSize = (options2 = {}) => {
    const chunkSize = options2.chunkSize ?? DEFAULT_CHUNK_SIZE;
    return async function* fixedSizeChunker(source) {
      let list = new Uint8ArrayList();
      let currentLength = 0;
      let emitted = false;
      for await (const buffer2 of source) {
        list.append(buffer2);
        currentLength += buffer2.length;
        while (currentLength >= chunkSize) {
          yield list.slice(0, chunkSize);
          emitted = true;
          if (chunkSize === list.length) {
            list = new Uint8ArrayList();
            currentLength = 0;
          } else {
            const newBl = new Uint8ArrayList();
            newBl.append(list.sublist(chunkSize));
            list = newBl;
            currentLength -= chunkSize;
          }
        }
      }
      if (!emitted || currentLength > 0) {
        yield list.subarray(0, currentLength);
      }
    };
  };

  // node_modules/ipfs-unixfs-importer/dist/src/utils/persist.js
  var persist = async (buffer2, blockstore, options2) => {
    if (options2.codec == null) {
      options2.codec = src_exports5;
    }
    const multihash = await sha256.digest(buffer2);
    const cid = CID.create(options2.cidVersion, options2.codec.code, multihash);
    await blockstore.put(cid, buffer2, options2);
    return cid;
  };

  // node_modules/ipfs-unixfs-importer/dist/src/dag-builder/buffer-importer.js
  function defaultBufferImporter(options2) {
    return async function* bufferImporter(file, blockstore) {
      let bytesWritten = 0n;
      for await (let block of file.content) {
        yield async () => {
          let unixfs2;
          const opts = {
            codec: src_exports5,
            cidVersion: options2.cidVersion,
            onProgress: options2.onProgress
          };
          if (options2.rawLeaves) {
            opts.codec = raw_exports;
            opts.cidVersion = 1;
          } else {
            unixfs2 = new UnixFS({
              type: options2.leafType,
              data: block
            });
            block = encode13({
              Data: unixfs2.marshal(),
              Links: []
            });
          }
          const cid = await persist(block, blockstore, opts);
          bytesWritten += BigInt(block.byteLength);
          options2.onProgress?.(new CustomProgressEvent("unixfs:importer:progress:file:write", {
            bytesWritten,
            cid,
            path: file.path
          }));
          return {
            cid,
            unixfs: unixfs2,
            size: BigInt(block.length),
            block
          };
        };
      }
    };
  }

  // node_modules/ipfs-unixfs-importer/dist/src/errors.js
  var InvalidParametersError5 = class _InvalidParametersError extends Error {
    static name = "InvalidParametersError";
    static code = "ERR_INVALID_PARAMS";
    name = _InvalidParametersError.name;
    code = _InvalidParametersError.code;
    constructor(message2 = "Invalid parameters") {
      super(message2);
    }
  };
  var InvalidContentError = class _InvalidContentError extends Error {
    static name = "InvalidContentError";
    static code = "ERR_INVALID_CONTENT";
    name = _InvalidContentError.name;
    code = _InvalidContentError.code;
    constructor(message2 = "Invalid content") {
      super(message2);
    }
  };

  // node_modules/ipfs-unixfs-importer/dist/src/dag-builder/dir.js
  var defaultDirBuilder = async (dir, blockstore, options2) => {
    const unixfs2 = new UnixFS({
      type: "directory",
      mtime: dir.mtime,
      mode: dir.mode
    });
    const block = encode13(prepare({ Data: unixfs2.marshal() }));
    const cid = await persist(block, blockstore, options2);
    const path = dir.path;
    return {
      cid,
      path,
      unixfs: unixfs2,
      size: BigInt(block.length),
      originalPath: dir.originalPath,
      block
    };
  };

  // node_modules/ipfs-unixfs-importer/dist/src/dag-builder/file.js
  async function* buildFileBatch(file, blockstore, options2) {
    let count = -1;
    let previous;
    for await (const entry of parallelBatch(options2.bufferImporter(file, blockstore), options2.blockWriteConcurrency)) {
      count++;
      if (count === 0) {
        previous = {
          ...entry,
          single: true
        };
        continue;
      } else if (count === 1 && previous != null) {
        yield {
          ...previous,
          block: void 0,
          single: void 0
        };
        previous = void 0;
      }
      yield {
        ...entry,
        block: void 0
      };
    }
    if (previous != null) {
      yield previous;
    }
  }
  function isSingleBlockImport(result) {
    return result.single === true;
  }
  var reduce = (file, blockstore, options2) => {
    const reducer = async function(leaves) {
      if (leaves.length === 1 && isSingleBlockImport(leaves[0]) && options2.reduceSingleLeafToSelf) {
        const leaf = leaves[0];
        let node2 = leaf.block;
        if (isSingleBlockImport(leaf) && (file.mtime !== void 0 || file.mode !== void 0)) {
          leaf.unixfs = new UnixFS({
            type: "file",
            mtime: file.mtime,
            mode: file.mode,
            data: leaf.block
          });
          node2 = { Data: leaf.unixfs.marshal(), Links: [] };
          leaf.block = encode13(prepare(node2));
          leaf.cid = await persist(leaf.block, blockstore, {
            ...options2,
            cidVersion: options2.cidVersion
          });
          leaf.size = BigInt(leaf.block.length);
        }
        options2.onProgress?.(new CustomProgressEvent("unixfs:importer:progress:file:layout", {
          cid: leaf.cid,
          path: leaf.originalPath
        }));
        return {
          cid: leaf.cid,
          path: file.path,
          unixfs: leaf.unixfs,
          size: leaf.size,
          originalPath: leaf.originalPath
        };
      }
      const f2 = new UnixFS({
        type: "file",
        mtime: file.mtime,
        mode: file.mode
      });
      const links2 = leaves.filter((leaf) => {
        if (leaf.cid.code === code3 && leaf.size > 0) {
          return true;
        }
        if (leaf.unixfs != null && leaf.unixfs.data == null && leaf.unixfs.fileSize() > 0n) {
          return true;
        }
        return Boolean(leaf.unixfs?.data?.length);
      }).map((leaf) => {
        if (leaf.cid.code === code3) {
          f2.addBlockSize(leaf.size);
          return {
            Name: "",
            Tsize: Number(leaf.size),
            Hash: leaf.cid
          };
        }
        if (leaf.unixfs?.data == null) {
          f2.addBlockSize(leaf.unixfs?.fileSize() ?? 0n);
        } else {
          f2.addBlockSize(BigInt(leaf.unixfs.data.length));
        }
        return {
          Name: "",
          Tsize: Number(leaf.size),
          Hash: leaf.cid
        };
      });
      const node = {
        Data: f2.marshal(),
        Links: links2
      };
      const block = encode13(prepare(node));
      const cid = await persist(block, blockstore, options2);
      options2.onProgress?.(new CustomProgressEvent("unixfs:importer:progress:file:layout", {
        cid,
        path: file.originalPath
      }));
      return {
        cid,
        path: file.path,
        unixfs: f2,
        size: BigInt(block.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)),
        originalPath: file.originalPath,
        block
      };
    };
    return reducer;
  };
  var defaultFileBuilder = async (file, block, options2) => {
    return options2.layout(buildFileBatch(file, block, options2), reduce(file, block, options2));
  };

  // node_modules/ipfs-unixfs-importer/dist/src/dag-builder/index.js
  function isIterable2(thing) {
    return Symbol.iterator in thing;
  }
  function isAsyncIterable16(thing) {
    return Symbol.asyncIterator in thing;
  }
  function contentAsAsyncIterable(content) {
    try {
      if (content instanceof Uint8Array) {
        return (async function* () {
          yield content;
        })();
      } else if (isIterable2(content)) {
        return (async function* () {
          yield* content;
        })();
      } else if (isAsyncIterable16(content)) {
        return content;
      }
    } catch {
      throw new InvalidContentError("Content was invalid");
    }
    throw new InvalidContentError("Content was invalid");
  }
  function defaultDagBuilder(options2) {
    return async function* dagBuilder(source, blockstore) {
      for await (const entry of source) {
        let originalPath;
        if (entry.path != null) {
          originalPath = entry.path;
          entry.path = entry.path.split("/").filter((path) => path != null && path !== ".").join("/");
        }
        if (isFileCandidate(entry)) {
          const file = {
            path: entry.path,
            mtime: entry.mtime,
            mode: entry.mode,
            content: (async function* () {
              let bytesRead = 0n;
              for await (const chunk of options2.chunker(options2.chunkValidator(contentAsAsyncIterable(entry.content)))) {
                const currentChunkSize = BigInt(chunk.byteLength);
                bytesRead += currentChunkSize;
                options2.onProgress?.(new CustomProgressEvent("unixfs:importer:progress:file:read", {
                  bytesRead,
                  chunkSize: currentChunkSize,
                  path: entry.path
                }));
                yield chunk;
              }
            })(),
            originalPath
          };
          const fileBuilder = options2.fileBuilder ?? defaultFileBuilder;
          yield async () => fileBuilder(file, blockstore, options2);
        } else if (entry.path != null) {
          const dir = {
            path: entry.path,
            mtime: entry.mtime,
            mode: entry.mode,
            originalPath
          };
          const dirBuilder = options2.dirBuilder ?? defaultDirBuilder;
          yield async () => dirBuilder(dir, blockstore, options2);
        } else {
          throw new Error("Import candidate must have content or path or both");
        }
      }
    };
  }
  function isFileCandidate(entry) {
    return entry.content != null;
  }

  // node_modules/ipfs-unixfs-importer/dist/src/dag-builder/validate-chunks.js
  var defaultChunkValidator = () => {
    return async function* validateChunks(source) {
      for await (const content of source) {
        if (content.length === void 0) {
          throw new InvalidContentError("Content was invalid");
        }
        if (typeof content === "string" || content instanceof String) {
          yield fromString2(content.toString());
        } else if (Array.isArray(content)) {
          yield Uint8Array.from(content);
        } else if (content instanceof Uint8Array) {
          yield content;
        } else {
          throw new InvalidContentError("Content was invalid");
        }
      }
    };
  };

  // node_modules/ipfs-unixfs-importer/dist/src/layout/balanced.js
  var DEFAULT_MAX_CHILDREN_PER_NODE = 174;
  function balanced(options2) {
    const maxChildrenPerNode = options2?.maxChildrenPerNode ?? DEFAULT_MAX_CHILDREN_PER_NODE;
    return async function balancedLayout(source, reduce2) {
      const roots = [];
      for await (const chunked of src_default15(source, maxChildrenPerNode)) {
        roots.push(await reduce2(chunked));
      }
      if (roots.length > 1) {
        return balancedLayout(roots, reduce2);
      }
      return roots[0];
    };
  }

  // node_modules/ipfs-unixfs-importer/dist/src/dir.js
  var Dir = class {
    options;
    root;
    dir;
    path;
    dirty;
    flat;
    parent;
    parentKey;
    unixfs;
    mode;
    mtime;
    cid;
    size;
    nodeSize;
    constructor(props, options2) {
      this.options = options2 ?? {};
      this.root = props.root;
      this.dir = props.dir;
      this.path = props.path;
      this.dirty = props.dirty;
      this.flat = props.flat;
      this.parent = props.parent;
      this.parentKey = props.parentKey;
      this.unixfs = props.unixfs;
      this.mode = props.mode;
      this.mtime = props.mtime;
    }
  };
  var CID_V0 = CID.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn");
  var CID_V1 = CID.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi");

  // node_modules/ipfs-unixfs-importer/dist/src/dir-flat.js
  var DirFlat = class extends Dir {
    _children;
    constructor(props, options2) {
      super(props, options2);
      this._children = /* @__PURE__ */ new Map();
    }
    async put(name9, value2) {
      this.cid = void 0;
      this.size = void 0;
      this.nodeSize = void 0;
      this._children.set(name9, value2);
    }
    async get(name9) {
      return Promise.resolve(this._children.get(name9));
    }
    childCount() {
      return this._children.size;
    }
    directChildrenCount() {
      return this.childCount();
    }
    onlyChild() {
      return this._children.values().next().value;
    }
    *eachChildSeries() {
      for (const [key, child] of this._children.entries()) {
        yield {
          key,
          child
        };
      }
    }
    estimateNodeSize() {
      if (this.nodeSize !== void 0) {
        return this.nodeSize;
      }
      this.nodeSize = 0;
      for (const [name9, child] of this._children.entries()) {
        if (child.size != null && child.cid != null) {
          this.nodeSize += name9.length + (this.options.cidVersion === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength);
        }
      }
      return this.nodeSize;
    }
    async *flush(block) {
      const links2 = [];
      for (const [name9, child] of this._children.entries()) {
        let result = child;
        if (child instanceof Dir) {
          for await (const entry of child.flush(block)) {
            result = entry;
            yield entry;
          }
        }
        if (result.size != null && result.cid != null) {
          links2.push({
            Name: name9,
            Tsize: Number(result.size),
            Hash: result.cid
          });
        }
      }
      const unixfs2 = new UnixFS({
        type: "directory",
        mtime: this.mtime,
        mode: this.mode
      });
      const node = { Data: unixfs2.marshal(), Links: links2 };
      const buffer2 = encode13(prepare(node));
      const cid = await persist(buffer2, block, this.options);
      const size = buffer2.length + node.Links.reduce(
        /**
         * @param {number} acc
         * @param {PBLink} curr
         */
        (acc, curr) => acc + (curr.Tsize ?? 0),
        0
      );
      this.cid = cid;
      this.size = size;
      yield {
        cid,
        unixfs: unixfs2,
        path: this.path,
        size: BigInt(size)
      };
    }
  };

  // node_modules/ipfs-unixfs-importer/dist/src/dir-sharded.js
  async function hamtHashFn(buf2) {
    return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
  }
  var HAMT_HASH_CODE = BigInt(34);
  var DEFAULT_FANOUT_BITS = 8;
  var DirSharded = class extends Dir {
    _bucket;
    constructor(props, options2) {
      super(props, options2);
      this._bucket = createHAMT({
        hashFn: hamtHashFn,
        bits: options2.shardFanoutBits ?? DEFAULT_FANOUT_BITS
      });
    }
    async put(name9, value2) {
      this.cid = void 0;
      this.size = void 0;
      this.nodeSize = void 0;
      await this._bucket.put(name9, value2);
    }
    async get(name9) {
      return this._bucket.get(name9);
    }
    childCount() {
      return this._bucket.leafCount();
    }
    directChildrenCount() {
      return this._bucket.childrenCount();
    }
    onlyChild() {
      return this._bucket.onlyChild();
    }
    *eachChildSeries() {
      for (const { key, value: value2 } of this._bucket.eachLeafSeries()) {
        yield {
          key,
          child: value2
        };
      }
    }
    estimateNodeSize() {
      if (this.nodeSize !== void 0) {
        return this.nodeSize;
      }
      this.nodeSize = calculateSize2(this._bucket, this, this.options);
      return this.nodeSize;
    }
    async *flush(blockstore) {
      for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
        yield {
          ...entry,
          path: this.path
        };
      }
    }
  };
  var dir_sharded_default = DirSharded;
  async function* flush(bucket, blockstore, shardRoot, options2) {
    const children = bucket._children;
    const padLength = (bucket.tableSize() - 1).toString(16).length;
    const links2 = [];
    let childrenSize = 0n;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children.get(i2);
      if (child == null) {
        continue;
      }
      const labelPrefix = i2.toString(16).toUpperCase().padStart(padLength, "0");
      if (child instanceof Bucket2) {
        let shard;
        for await (const subShard of flush(child, blockstore, null, options2)) {
          shard = subShard;
        }
        if (shard == null) {
          throw new Error("Could not flush sharded directory, no subshard found");
        }
        links2.push({
          Name: labelPrefix,
          Tsize: Number(shard.size),
          Hash: shard.cid
        });
        childrenSize += shard.size;
      } else if (isDir(child.value)) {
        const dir2 = child.value;
        let flushedDir;
        for await (const entry of dir2.flush(blockstore)) {
          flushedDir = entry;
          yield flushedDir;
        }
        if (flushedDir == null) {
          throw new Error("Did not flush dir");
        }
        const label = labelPrefix + child.key;
        links2.push({
          Name: label,
          Tsize: Number(flushedDir.size),
          Hash: flushedDir.cid
        });
        childrenSize += flushedDir.size;
      } else {
        const value2 = child.value;
        if (value2.cid == null) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size2 = value2.size;
        links2.push({
          Name: label,
          Tsize: Number(size2),
          Hash: value2.cid
        });
        childrenSize += BigInt(size2 ?? 0);
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: BigInt(bucket.tableSize()),
      hashType: HAMT_HASH_CODE,
      mtime: shardRoot?.mtime,
      mode: shardRoot?.mode
    });
    const node = {
      Data: dir.marshal(),
      Links: links2
    };
    const buffer2 = encode13(prepare(node));
    const cid = await persist(buffer2, blockstore, options2);
    const size = BigInt(buffer2.byteLength) + childrenSize;
    yield {
      cid,
      unixfs: dir,
      size
    };
  }
  function isDir(obj) {
    return typeof obj.flush === "function";
  }
  function calculateSize2(bucket, shardRoot, options2) {
    const children = bucket._children;
    const padLength = (bucket.tableSize() - 1).toString(16).length;
    const links2 = [];
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children.get(i2);
      if (child == null) {
        continue;
      }
      const labelPrefix = i2.toString(16).toUpperCase().padStart(padLength, "0");
      if (child instanceof Bucket2) {
        const size = calculateSize2(child, null, options2);
        links2.push({
          Name: labelPrefix,
          Tsize: Number(size),
          Hash: options2.cidVersion === 0 ? CID_V0 : CID_V1
        });
      } else if (typeof child.value.flush === "function") {
        const dir2 = child.value;
        const size = dir2.nodeSize();
        links2.push({
          Name: labelPrefix + child.key,
          Tsize: Number(size),
          Hash: options2.cidVersion === 0 ? CID_V0 : CID_V1
        });
      } else {
        const value2 = child.value;
        if (value2.cid == null) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size = value2.size;
        links2.push({
          Name: label,
          Tsize: Number(size),
          Hash: value2.cid
        });
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: BigInt(bucket.tableSize()),
      hashType: HAMT_HASH_CODE,
      mtime: shardRoot?.mtime,
      mode: shardRoot?.mode
    });
    const buffer2 = encode13(prepare({
      Data: dir.marshal(),
      Links: links2
    }));
    return buffer2.length;
  }

  // node_modules/ipfs-unixfs-importer/dist/src/flat-to-shard.js
  async function flatToShard(child, dir, threshold, options2) {
    let newDir = dir;
    if (dir instanceof DirFlat && dir.estimateNodeSize() > threshold) {
      newDir = await convertToShard(dir, options2);
    }
    const parent = newDir.parent;
    if (parent != null) {
      if (newDir !== dir) {
        if (child != null) {
          child.parent = newDir;
        }
        if (newDir.parentKey == null) {
          throw new Error("No parent key found");
        }
        await parent.put(newDir.parentKey, newDir);
      }
      return flatToShard(newDir, parent, threshold, options2);
    }
    return newDir;
  }
  async function convertToShard(oldDir, options2) {
    const newDir = new dir_sharded_default({
      root: oldDir.root,
      dir: true,
      parent: oldDir.parent,
      parentKey: oldDir.parentKey,
      path: oldDir.path,
      dirty: oldDir.dirty,
      flat: false,
      mtime: oldDir.mtime,
      mode: oldDir.mode
    }, options2);
    for (const { key, child } of oldDir.eachChildSeries()) {
      await newDir.put(key, child);
    }
    return newDir;
  }

  // node_modules/ipfs-unixfs-importer/dist/src/utils/to-path-components.js
  var toPathComponents2 = (path = "") => {
    return path.split(/(?<!\\)\//).filter(Boolean);
  };

  // node_modules/ipfs-unixfs-importer/dist/src/tree-builder.js
  async function addToTree(elem, tree2, options2) {
    const pathElems = toPathComponents2(elem.path ?? "");
    const lastIndex = pathElems.length - 1;
    let parent = tree2;
    let currentPath = "";
    for (let i2 = 0; i2 < pathElems.length; i2++) {
      const pathElem = pathElems[i2];
      currentPath += `${currentPath !== "" ? "/" : ""}${pathElem}`;
      const last2 = i2 === lastIndex;
      parent.dirty = true;
      parent.cid = void 0;
      parent.size = void 0;
      if (last2) {
        await parent.put(pathElem, elem);
        tree2 = await flatToShard(null, parent, options2.shardSplitThresholdBytes, options2);
      } else {
        let dir = await parent.get(pathElem);
        if (dir == null || !(dir instanceof Dir)) {
          dir = new DirFlat({
            root: false,
            dir: true,
            parent,
            parentKey: pathElem,
            path: currentPath,
            dirty: true,
            flat: true,
            mtime: dir?.unixfs?.mtime,
            mode: dir?.unixfs?.mode
          }, options2);
        }
        await parent.put(pathElem, dir);
        parent = dir;
      }
    }
    return tree2;
  }
  async function* flushAndYield(tree2, blockstore) {
    if (!(tree2 instanceof Dir)) {
      if (tree2.unixfs?.isDirectory() === true) {
        yield tree2;
      }
      return;
    }
    yield* tree2.flush(blockstore);
  }
  function defaultTreeBuilder(options2) {
    return async function* treeBuilder(source, block) {
      let tree2 = new DirFlat({
        root: true,
        dir: true,
        path: "",
        dirty: true,
        flat: true
      }, options2);
      let rootDir;
      let singleRoot = false;
      for await (const entry of source) {
        if (entry == null) {
          continue;
        }
        const dir = `${entry.originalPath ?? ""}`.split("/")[0];
        if (dir != null && dir !== "") {
          if (rootDir == null) {
            rootDir = dir;
            singleRoot = true;
          } else if (rootDir !== dir) {
            singleRoot = false;
          }
        }
        tree2 = await addToTree(entry, tree2, options2);
        if (entry.unixfs?.isDirectory() !== true) {
          yield entry;
        }
      }
      if (options2.wrapWithDirectory || singleRoot && tree2.childCount() > 1) {
        yield* flushAndYield(tree2, block);
      } else {
        for (const unwrapped of tree2.eachChildSeries()) {
          if (unwrapped == null) {
            continue;
          }
          yield* flushAndYield(unwrapped.child, block);
        }
      }
    };
  }

  // node_modules/ipfs-unixfs-importer/dist/src/index.js
  async function* importer2(source, blockstore, options2 = {}) {
    let candidates;
    if (Symbol.asyncIterator in source || Symbol.iterator in source) {
      candidates = source;
    } else {
      candidates = [source];
    }
    const wrapWithDirectory = options2.wrapWithDirectory ?? false;
    const shardSplitThresholdBytes = options2.shardSplitThresholdBytes ?? 262144;
    const shardFanoutBits = options2.shardFanoutBits ?? 8;
    const cidVersion = options2.cidVersion ?? 1;
    const rawLeaves = options2.rawLeaves ?? true;
    const leafType = options2.leafType ?? "file";
    const fileImportConcurrency = options2.fileImportConcurrency ?? 50;
    const blockWriteConcurrency = options2.blockWriteConcurrency ?? 10;
    const reduceSingleLeafToSelf = options2.reduceSingleLeafToSelf ?? true;
    const chunker = options2.chunker ?? fixedSize();
    const chunkValidator = options2.chunkValidator ?? defaultChunkValidator();
    const buildDag = options2.dagBuilder ?? defaultDagBuilder({
      chunker,
      chunkValidator,
      wrapWithDirectory,
      layout: options2.layout ?? balanced(),
      bufferImporter: options2.bufferImporter ?? defaultBufferImporter({
        cidVersion,
        rawLeaves,
        leafType,
        onProgress: options2.onProgress
      }),
      blockWriteConcurrency,
      reduceSingleLeafToSelf,
      cidVersion,
      onProgress: options2.onProgress,
      dirBuilder: options2.dirBuilder,
      fileBuilder: options2.fileBuilder
    });
    const buildTree = options2.treeBuilder ?? defaultTreeBuilder({
      wrapWithDirectory,
      shardSplitThresholdBytes,
      shardFanoutBits,
      cidVersion,
      onProgress: options2.onProgress
    });
    for await (const entry of buildTree(parallelBatch(buildDag(candidates, blockstore), fileImportConcurrency), blockstore)) {
      yield {
        cid: entry.cid,
        path: entry.path,
        unixfs: entry.unixfs,
        size: entry.size
      };
    }
  }
  async function importFile(content, blockstore, options2 = {}) {
    const result = await src_default10(importer2([content], blockstore, options2));
    if (result == null) {
      throw new InvalidParametersError5("Nothing imported");
    }
    return result;
  }
  async function importBytes(buf2, blockstore, options2 = {}) {
    return importFile({
      content: buf2
    }, blockstore, options2);
  }
  async function importByteStream(bufs, blockstore, options2 = {}) {
    return importFile({
      content: bufs
    }, blockstore, options2);
  }

  // node_modules/@helia/unixfs/dist/src/commands/add.js
  var defaultImporterSettings = {
    cidVersion: 1,
    rawLeaves: true,
    layout: balanced({
      maxChildrenPerNode: 1024
    }),
    chunker: fixedSize({
      chunkSize: 1048576
    })
  };
  async function* addAll(source, blockstore, options2 = {}) {
    yield* importer2(source, blockstore, {
      ...defaultImporterSettings,
      ...options2
    });
  }
  async function addBytes(bytes, blockstore, options2 = {}) {
    const { cid } = await importBytes(bytes, blockstore, {
      ...defaultImporterSettings,
      ...options2
    });
    return cid;
  }
  async function addByteStream(bytes, blockstore, options2 = {}) {
    const { cid } = await importByteStream(bytes, blockstore, {
      ...defaultImporterSettings,
      ...options2
    });
    return cid;
  }
  async function addFile(file, blockstore, options2 = {}) {
    if (file.path == null) {
      throw new InvalidParametersError4("path is required");
    }
    if (file.content == null) {
      throw new InvalidParametersError4("content is required");
    }
    const result = await src_default14(addAll([file], blockstore, {
      ...defaultImporterSettings,
      ...options2,
      wrapWithDirectory: true
    }));
    if (result == null) {
      throw new InvalidParametersError4("Nothing imported");
    }
    return result.cid;
  }
  async function addDirectory(dir, blockstore, options2 = {}) {
    if (dir.content != null) {
      throw new InvalidParametersError4("Directories cannot have content, use addFile instead");
    }
    const ord = dir.path == null ? src_default10 : src_default14;
    const result = await ord(addAll([{
      ...dir,
      path: dir.path ?? "-"
    }], blockstore, {
      ...defaultImporterSettings,
      ...options2,
      wrapWithDirectory: dir.path != null
    }));
    if (result == null) {
      throw new InvalidParametersError4("Nothing imported");
    }
    return result.cid;
  }

  // node_modules/@helia/unixfs/dist/src/commands/utils/add-link.js
  var import_sparse_array3 = __toESM(require_sparse_array(), 1);

  // node_modules/@helia/unixfs/dist/src/constants.js
  var DEFAULT_CID_VERSION = 1;
  var DEFAULT_SHARD_SPLIT_THRESHOLD_BYTES = 262144;

  // node_modules/@helia/unixfs/dist/src/commands/utils/consumable-hash.js
  function wrapHash2(hashFn2) {
    function hashing(value2) {
      if (value2 instanceof InfiniteHash2) {
        return value2;
      } else {
        return new InfiniteHash2(value2, hashFn2);
      }
    }
    return hashing;
  }
  var InfiniteHash2 = class {
    _value;
    _hashFn;
    _depth;
    _availableBits;
    _currentBufferIndex;
    _buffers;
    constructor(value2, hashFn2) {
      if (!(value2 instanceof Uint8Array)) {
        throw new Error("can only hash Uint8Arrays");
      }
      this._value = value2;
      this._hashFn = hashFn2;
      this._depth = -1;
      this._availableBits = 0;
      this._currentBufferIndex = 0;
      this._buffers = [];
    }
    async take(bits2) {
      let pendingBits = bits2;
      while (this._availableBits < pendingBits) {
        await this._produceMoreBits();
      }
      let result = 0;
      while (pendingBits > 0) {
        const hash = this._buffers[this._currentBufferIndex];
        const available = Math.min(hash.availableBits(), pendingBits);
        const took = hash.take(available);
        result = (result << available) + took;
        pendingBits -= available;
        this._availableBits -= available;
        if (hash.availableBits() === 0) {
          this._currentBufferIndex++;
        }
      }
      return result;
    }
    untake(bits2) {
      let pendingBits = bits2;
      while (pendingBits > 0) {
        const hash = this._buffers[this._currentBufferIndex];
        const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
        hash.untake(availableForUntake);
        pendingBits -= availableForUntake;
        this._availableBits += availableForUntake;
        if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
          this._depth--;
          this._currentBufferIndex--;
        }
      }
    }
    async _produceMoreBits() {
      this._depth++;
      const value2 = this._depth > 0 ? concat([this._value, Uint8Array.from([this._depth])]) : this._value;
      const hashValue = await this._hashFn(value2);
      const buffer2 = new ConsumableBuffer2(hashValue);
      this._buffers.push(buffer2);
      this._availableBits += buffer2.availableBits();
    }
  };
  var START_MASKS2 = [
    255,
    254,
    252,
    248,
    240,
    224,
    192,
    128
  ];
  var STOP_MASKS2 = [
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255
  ];
  var ConsumableBuffer2 = class {
    _value;
    _currentBytePos;
    _currentBitPos;
    constructor(value2) {
      this._value = value2;
      this._currentBytePos = value2.length - 1;
      this._currentBitPos = 7;
    }
    availableBits() {
      return this._currentBitPos + 1 + this._currentBytePos * 8;
    }
    totalBits() {
      return this._value.length * 8;
    }
    take(bits2) {
      let pendingBits = bits2;
      let result = 0;
      while (pendingBits > 0 && this._haveBits()) {
        const byte = this._value[this._currentBytePos];
        const availableBits = this._currentBitPos + 1;
        const taking = Math.min(availableBits, pendingBits);
        const value2 = byteBitsToInt2(byte, availableBits - taking, taking);
        result = (result << taking) + value2;
        pendingBits -= taking;
        this._currentBitPos -= taking;
        if (this._currentBitPos < 0) {
          this._currentBitPos = 7;
          this._currentBytePos--;
        }
      }
      return result;
    }
    untake(bits2) {
      this._currentBitPos += bits2;
      while (this._currentBitPos > 7) {
        this._currentBitPos -= 8;
        this._currentBytePos += 1;
      }
    }
    _haveBits() {
      return this._currentBytePos >= 0;
    }
  };
  function byteBitsToInt2(byte, start2, length4) {
    const mask = maskFor2(start2, length4);
    return (byte & mask) >>> start2;
  }
  function maskFor2(start2, length4) {
    return START_MASKS2[start2] & STOP_MASKS2[Math.min(length4 + start2 - 1, 7)];
  }

  // node_modules/@helia/unixfs/dist/src/commands/utils/hamt-constants.js
  var hamtHashCode = BigInt(murmur3128.code);
  var hamtBucketBits = 8;
  async function hamtHashFn2(buf2) {
    return (await murmur3128.encode(buf2)).subarray(0, 8).reverse();
  }

  // node_modules/@helia/unixfs/dist/src/commands/utils/hamt-utils.js
  var import_sparse_array2 = __toESM(require_sparse_array(), 1);

  // node_modules/@helia/unixfs/dist/src/commands/utils/persist.js
  var persist2 = async (buffer2, blockstore, options2) => {
    if (options2.codec == null) {
      options2.codec = src_exports5;
    }
    const multihash = await sha256.digest(buffer2);
    const cid = CID.create(options2.cidVersion ?? DEFAULT_CID_VERSION, options2.codec.code, multihash);
    await blockstore.put(cid, buffer2, {
      ...options2,
      signal: options2.signal
    });
    return cid;
  };

  // node_modules/@helia/unixfs/dist/src/commands/utils/dir-sharded.js
  var Dir2 = class {
    options;
    root;
    dir;
    path;
    dirty;
    flat;
    parent;
    parentKey;
    unixfs;
    mode;
    mtime;
    cid;
    size;
    nodeSize;
    constructor(props, options2) {
      this.options = options2 ?? {};
      this.root = props.root;
      this.dir = props.dir;
      this.path = props.path;
      this.dirty = props.dirty;
      this.flat = props.flat;
      this.parent = props.parent;
      this.parentKey = props.parentKey;
      this.unixfs = props.unixfs;
      this.mode = props.mode;
      this.mtime = props.mtime;
    }
  };
  var DirSharded2 = class extends Dir2 {
    _bucket;
    constructor(props, options2) {
      super(props, options2);
      this._bucket = createHAMT({
        hashFn: hamtHashFn2,
        bits: 8
      });
    }
    async put(name9, value2) {
      this.cid = void 0;
      this.size = void 0;
      this.nodeSize = void 0;
      await this._bucket.put(name9, value2);
    }
    async get(name9) {
      return this._bucket.get(name9);
    }
    childCount() {
      return this._bucket.leafCount();
    }
    directChildrenCount() {
      return this._bucket.childrenCount();
    }
    onlyChild() {
      return this._bucket.onlyChild();
    }
    async *eachChildSeries() {
      for (const { key, value: value2 } of this._bucket.eachLeafSeries()) {
        yield {
          key,
          child: value2
        };
      }
    }
    estimateNodeSize() {
      if (this.nodeSize !== void 0) {
        return this.nodeSize;
      }
      this.nodeSize = calculateSize3(this._bucket, this, this.options);
      return this.nodeSize;
    }
    async *flush(blockstore) {
      for await (const entry of flush2(this._bucket, blockstore, this, this.options)) {
        yield {
          ...entry,
          path: this.path
        };
      }
    }
  };
  async function* flush2(bucket, blockstore, shardRoot, options2) {
    const children = bucket._children;
    const links2 = [];
    let childrenSize = 0n;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children.get(i2);
      if (child == null) {
        continue;
      }
      const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
      if (child instanceof Bucket2) {
        let shard;
        for await (const subShard of flush2(child, blockstore, null, options2)) {
          shard = subShard;
        }
        if (shard == null) {
          throw new Error("Could not flush sharded directory, no sub-shard found");
        }
        links2.push({
          Name: labelPrefix,
          Tsize: Number(shard.size),
          Hash: shard.cid
        });
        childrenSize += shard.size;
      } else if (isDir2(child.value)) {
        const dir2 = child.value;
        let flushedDir;
        for await (const entry of dir2.flush(blockstore)) {
          flushedDir = entry;
          yield flushedDir;
        }
        if (flushedDir == null) {
          throw new Error("Did not flush dir");
        }
        const label = labelPrefix + child.key;
        links2.push({
          Name: label,
          Tsize: Number(flushedDir.size),
          Hash: flushedDir.cid
        });
        childrenSize += flushedDir.size;
      } else {
        const value2 = child.value;
        if (value2.cid == null) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size2 = value2.size;
        links2.push({
          Name: label,
          Tsize: Number(size2),
          Hash: value2.cid
        });
        childrenSize += BigInt(size2 ?? 0);
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: BigInt(bucket.tableSize()),
      hashType: hamtHashCode,
      mtime: shardRoot?.mtime,
      mode: shardRoot?.mode
    });
    const node = {
      Data: dir.marshal(),
      Links: links2
    };
    const buffer2 = encode13(prepare(node));
    const cid = await persist2(buffer2, blockstore, options2);
    const size = BigInt(buffer2.byteLength) + childrenSize;
    yield {
      cid,
      unixfs: dir,
      size
    };
  }
  function isDir2(obj) {
    return typeof obj.flush === "function";
  }
  function calculateSize3(bucket, shardRoot, options2) {
    const children = bucket._children;
    const links2 = [];
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children.get(i2);
      if (child == null) {
        continue;
      }
      const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
      if (child instanceof Bucket2) {
        const size = calculateSize3(child, null, options2);
        links2.push({
          Name: labelPrefix,
          Tsize: Number(size),
          Hash: options2.cidVersion === 0 ? CID_V02 : CID_V12
        });
      } else if (typeof child.value.flush === "function") {
        const dir2 = child.value;
        const size = dir2.nodeSize();
        links2.push({
          Name: labelPrefix + child.key,
          Tsize: Number(size),
          Hash: options2.cidVersion === 0 ? CID_V02 : CID_V12
        });
      } else {
        const value2 = child.value;
        if (value2.cid == null) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size = value2.size;
        links2.push({
          Name: label,
          Tsize: Number(size),
          Hash: value2.cid
        });
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: BigInt(bucket.tableSize()),
      hashType: hamtHashCode,
      mtime: shardRoot?.mtime,
      mode: shardRoot?.mode
    });
    const buffer2 = encode13(prepare({
      Data: dir.marshal(),
      Links: links2
    }));
    return buffer2.length;
  }
  var CID_V02 = CID.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn");
  var CID_V12 = CID.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi");

  // node_modules/@helia/unixfs/dist/src/commands/utils/hamt-utils.js
  var log8 = logger("helia:unixfs:commands:utils:hamt-utils");
  var toPrefix2 = (position) => {
    return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
  };
  var createShard = async (blockstore, contents, options2) => {
    const shard = new DirSharded2({
      root: true,
      dir: true,
      parent: void 0,
      parentKey: void 0,
      path: "",
      dirty: true,
      flat: false,
      mtime: options2.mtime,
      mode: options2.mode
    }, options2);
    for (let i2 = 0; i2 < contents.length; i2++) {
      await shard._bucket.put(contents[i2].name, {
        size: contents[i2].size,
        cid: contents[i2].cid
      });
    }
    const res = await src_default14(shard.flush(blockstore));
    if (res == null) {
      throw new Error("Flushing shard yielded no result");
    }
    return res;
  };
  var updateShardedDirectory = async (path, blockstore, options2) => {
    const shardRoot = UnixFS.unmarshal(path[0].node.Data ?? new Uint8Array(0));
    const fanout = BigInt(Math.pow(2, hamtBucketBits));
    path.reverse();
    let cid;
    let node;
    for (let i2 = 0; i2 < path.length; i2++) {
      const isRoot = i2 === path.length - 1;
      const segment = path[i2];
      const data = Uint8Array.from(segment.children.bitField().reverse());
      const dir = new UnixFS({
        type: "hamt-sharded-directory",
        data,
        fanout,
        hashType: hamtHashCode
      });
      if (isRoot) {
        dir.mtime = shardRoot.mtime;
        dir.mode = shardRoot.mode;
      }
      node = {
        Data: dir.marshal(),
        Links: segment.node.Links
      };
      const block = encode13(prepare(node));
      cid = await persist2(block, blockstore, options2);
      if (!isRoot) {
        const nextSegment = path[i2 + 1];
        if (nextSegment == null) {
          throw new Error("Was not operating on shard root but also had no parent?");
        }
        log8("updating link in parent sub-shard with prefix %s", nextSegment.prefix);
        nextSegment.node.Links = nextSegment.node.Links.filter((l2) => l2.Name !== nextSegment.prefix);
        nextSegment.node.Links.push({
          Name: nextSegment.prefix,
          Hash: cid,
          Tsize: segment.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), block.byteLength)
        });
      }
    }
    if (cid == null || node == null) {
      throw new Error("Noting persisted");
    }
    return { cid, node };
  };
  var recreateShardedDirectory = async (cid, fileName, blockstore, options2) => {
    const wrapped = wrapHash2(hamtHashFn2);
    const hash = wrapped(fromString2(fileName));
    const path = [];
    while (true) {
      const block = await src_default7(blockstore.get(cid, options2));
      const node = decode14(block);
      const children = new import_sparse_array2.default();
      const index = await hash.take(hamtBucketBits);
      const prefix = toPrefix2(index);
      path.push({
        prefix,
        children,
        node
      });
      let childLink;
      for (const link of node.Links) {
        const linkName2 = link.Name ?? "";
        if (linkName2.length < 2) {
          throw new Error("Invalid HAMT - link name was too short");
        }
        const position = parseInt(linkName2.substring(0, 2), 16);
        children.set(position, true);
        if (linkName2.startsWith(prefix)) {
          childLink = link;
        }
      }
      if (childLink == null) {
        log8("no link found with prefix %s for %s", prefix, fileName);
        break;
      }
      const linkName = childLink.Name ?? "";
      if (linkName.length < 2) {
        throw new Error("Invalid HAMT - link name was too short");
      }
      if (linkName.length === 2) {
        cid = childLink.Hash;
        log8("descend into sub-shard with prefix %s", linkName);
        continue;
      }
      break;
    }
    return { path, hash };
  };

  // node_modules/@helia/unixfs/dist/src/commands/utils/is-over-shard-threshold.js
  async function isOverShardThreshold(node, blockstore, threshold, options2) {
    if (node.Data == null) {
      throw new Error("DagPB node had no data");
    }
    const unixfs2 = UnixFS.unmarshal(node.Data);
    let size;
    if (unixfs2.type === "directory") {
      size = estimateNodeSize(node);
    } else if (unixfs2.type === "hamt-sharded-directory") {
      size = await estimateShardSize(node, 0, threshold, blockstore, options2);
    } else {
      throw new Error("Can only estimate the size of directories or shards");
    }
    return size > threshold;
  }
  function estimateNodeSize(node) {
    let size = 0;
    for (const link of node.Links) {
      size += (link.Name ?? "").length;
      size += link.Hash.version === 1 ? CID_V12.bytes.byteLength : CID_V02.bytes.byteLength;
    }
    return size;
  }
  async function estimateShardSize(node, current, max2, blockstore, options2) {
    if (current > max2) {
      return max2;
    }
    if (node.Data == null) {
      return current;
    }
    const unixfs2 = UnixFS.unmarshal(node.Data);
    if (!unixfs2.isDirectory()) {
      return current;
    }
    for (const link of node.Links) {
      let name9 = link.Name ?? "";
      name9 = name9.substring(2);
      current += name9.length;
      current += link.Hash.bytes.byteLength;
      if (link.Hash.code === code6) {
        const block = await src_default7(blockstore.get(link.Hash, options2));
        const node2 = decode14(block);
        current += await estimateShardSize(node2, current, max2, blockstore, options2);
      }
    }
    return current;
  }

  // node_modules/@helia/unixfs/dist/src/commands/utils/add-link.js
  var log9 = logger("helia:unixfs:components:utils:add-link");
  async function addLink(parent, child, blockstore, options2) {
    if (parent.node.Data == null) {
      throw new InvalidParametersError4("Invalid parent passed to addLink");
    }
    const meta = UnixFS.unmarshal(parent.node.Data);
    if (meta.type === "hamt-sharded-directory") {
      log9("adding link to sharded directory");
      return addToShardedDirectory(parent, child, blockstore, options2);
    }
    log9(`adding ${child.Name} (${child.Hash}) to regular directory`);
    const result = await addToDirectory(parent, child, blockstore, options2);
    if (await isOverShardThreshold(result.node, blockstore, options2.shardSplitThresholdBytes ?? DEFAULT_SHARD_SPLIT_THRESHOLD_BYTES, options2)) {
      log9("converting directory to sharded directory");
      const converted = await convertToShardedDirectory(result, blockstore);
      result.cid = converted.cid;
      result.node = decode14(await src_default7(blockstore.get(converted.cid, options2)));
    }
    return result;
  }
  var convertToShardedDirectory = async (parent, blockstore) => {
    if (parent.node.Data == null) {
      throw new InvalidParametersError4("Invalid parent passed to convertToShardedDirectory");
    }
    const unixfs2 = UnixFS.unmarshal(parent.node.Data);
    const result = await createShard(blockstore, parent.node.Links.map((link) => ({
      name: link.Name ?? "",
      size: BigInt(link.Tsize ?? 0),
      cid: link.Hash
    })), {
      mode: unixfs2.mode,
      mtime: unixfs2.mtime,
      cidVersion: parent.cid.version
    });
    log9(`converted directory to sharded directory ${result.cid}`);
    return result;
  };
  var addToDirectory = async (parent, child, blockstore, options2) => {
    const parentLinks = parent.node.Links.filter((link) => {
      const matches = link.Name === child.Name;
      if (matches && !options2.allowOverwriting) {
        throw new AlreadyExistsError();
      }
      return !matches;
    });
    parentLinks.push(child);
    if (parent.node.Data == null) {
      throw new InvalidPBNodeError("Parent node with no data passed to addToDirectory");
    }
    const node = UnixFS.unmarshal(parent.node.Data);
    let data;
    if (node.mtime != null) {
      const ms = Date.now();
      const secs = Math.floor(ms / 1e3);
      node.mtime = {
        secs: BigInt(secs),
        nsecs: (ms - secs * 1e3) * 1e3
      };
      data = node.marshal();
    } else {
      data = parent.node.Data;
    }
    parent.node = prepare({
      Data: data,
      Links: parentLinks
    });
    const buf2 = encode13(parent.node);
    const hash = await sha256.digest(buf2);
    const cid = CID.create(parent.cid.version, code6, hash);
    await blockstore.put(cid, buf2);
    return {
      node: parent.node,
      cid
    };
  };
  var addToShardedDirectory = async (parent, child, blockstore, options2) => {
    const { path, hash } = await recreateShardedDirectory(parent.cid, child.Name, blockstore, options2);
    const finalSegment = path[path.length - 1];
    if (finalSegment == null) {
      throw new Error("Invalid HAMT, could not generate path");
    }
    const prefix = finalSegment.prefix;
    const index = parseInt(prefix, 16);
    log9("next prefix for %s is %s", child.Name, prefix);
    const linkName = `${prefix}${child.Name}`;
    const existingLink = finalSegment.node.Links.find((l2) => (l2.Name ?? "").startsWith(prefix));
    if (existingLink != null) {
      log9("link %s was present in shard", linkName);
      if (existingLink.Name === linkName) {
        if (!options2.allowOverwriting) {
          throw new AlreadyExistsError();
        }
        log9("overwriting %s in sub-shard", child.Name);
        finalSegment.node.Links = finalSegment.node.Links.filter((l2) => l2.Name !== linkName);
        finalSegment.node.Links.push({
          Name: linkName,
          Hash: child.Hash,
          Tsize: child.Tsize
        });
      } else if (existingLink.Name?.length === 2) {
        throw new Error("Existing link was sub-shard?!");
      } else {
        log9("prefix %s already exists, creating new sub-shard", prefix);
        const index2 = finalSegment.node.Links.findIndex((l2) => l2.Name?.startsWith(prefix));
        const sibling = finalSegment.node.Links.splice(index2, 1)[0];
        const siblingName = (sibling.Name ?? "").substring(2);
        const wrapped = wrapHash2(hamtHashFn2);
        const siblingHash = wrapped(fromString2(siblingName));
        for (let i2 = 0; i2 < path.length; i2++) {
          await siblingHash.take(hamtBucketBits);
        }
        while (true) {
          const siblingIndex = await siblingHash.take(hamtBucketBits);
          const siblingPrefix = toPrefix2(siblingIndex);
          sibling.Name = `${siblingPrefix}${siblingName}`;
          const newIndex = await hash.take(hamtBucketBits);
          const newPrefix = toPrefix2(newIndex);
          if (siblingPrefix === newPrefix) {
            const children2 = new import_sparse_array3.default();
            children2.set(newIndex, true);
            path.push({
              prefix: newPrefix,
              children: children2,
              node: {
                Links: []
              }
            });
            continue;
          }
          const children = new import_sparse_array3.default();
          children.set(newIndex, true);
          children.set(siblingIndex, true);
          path.push({
            prefix,
            children,
            node: {
              Links: [
                sibling,
                {
                  Name: `${newPrefix}${child.Name}`,
                  Hash: child.Hash,
                  Tsize: child.Tsize
                }
              ]
            }
          });
          break;
        }
      }
    } else {
      log9("link %s was not present in sub-shard", linkName);
      child.Name = linkName;
      finalSegment.node.Links.push(child);
      finalSegment.children.set(index, true);
      log9("adding %s to existing sub-shard", linkName);
    }
    return updateShardedDirectory(path, blockstore, options2);
  };

  // node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-directory.js
  async function cidToDirectory(cid, blockstore, options2 = {}) {
    const entry = await exporter2(cid, blockstore, options2);
    if (entry.type !== "directory") {
      throw new NotADirectoryError(`${cid.toString()} was not a UnixFS directory`);
    }
    return {
      cid,
      node: entry.node
    };
  }

  // node_modules/@helia/unixfs/dist/src/commands/utils/cid-to-pblink.js
  async function cidToPBLink(cid, name9, blockstore, options2) {
    const sourceEntry = await exporter2(cid, blockstore, options2);
    if (sourceEntry.type !== "directory" && sourceEntry.type !== "file" && sourceEntry.type !== "raw") {
      throw new NotUnixFSError3(`${cid.toString()} was not a UnixFS node`);
    }
    return {
      Name: name9,
      Tsize: sourceEntry.node instanceof Uint8Array ? sourceEntry.node.byteLength : dagNodeTsize(sourceEntry.node),
      Hash: cid
    };
  }
  function dagNodeTsize(node) {
    const linkSizes = node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0);
    return encode13(node).byteLength + linkSizes;
  }

  // node_modules/@helia/unixfs/dist/src/commands/utils/resolve.js
  var log10 = logger("helia:unixfs:components:utils:resolve");
  async function resolve7(cid, path, blockstore, options2) {
    if (path == null || path === "") {
      return { cid };
    }
    const p2 = `/ipfs/${cid}${path == null ? "" : `/${path}`}`;
    const segments = await src_default11(walkPath(p2, blockstore, options2));
    if (segments.length === 0) {
      throw new DoesNotExistError("Could not find path in directory");
    }
    log10("resolved %s to %c", path, cid);
    return {
      cid: segments[segments.length - 1].cid,
      path,
      segments
    };
  }
  async function updatePathCids(cid, result, blockstore, options2) {
    if (result.segments == null || result.segments.length === 0) {
      return cid;
    }
    let child = result.segments.pop();
    if (child == null) {
      throw new Error("Insufficient segments");
    }
    child.cid = cid;
    result.segments.reverse();
    for (const parent of result.segments) {
      const [directory, pblink] = await Promise.all([
        cidToDirectory(parent.cid, blockstore, options2),
        cidToPBLink(child.cid, child.name, blockstore, options2)
      ]);
      const result2 = await addLink(directory, pblink, blockstore, {
        ...options2,
        allowOverwriting: true,
        cidVersion: cid.version
      });
      cid = result2.cid;
      parent.cid = cid;
      child = parent;
    }
    return cid;
  }

  // node_modules/@helia/unixfs/dist/src/commands/cat.js
  async function* cat(cid, blockstore, options2 = {}) {
    const resolved = await resolve7(cid, options2.path, blockstore, options2);
    const result = await exporter2(resolved.cid, blockstore, options2);
    if (result.type !== "file" && result.type !== "raw") {
      throw new NotAFileError();
    }
    if (result.content == null) {
      throw new NoContentError2();
    }
    yield* result.content(options2);
  }

  // node_modules/@helia/unixfs/dist/src/commands/chmod.js
  var log11 = logger("helia:unixfs:chmod");
  async function chmod(cid, mode, blockstore, options2 = {}) {
    const resolved = await resolve7(cid, options2.path, blockstore, options2);
    log11("chmod %c %d", resolved.cid, mode);
    if (options2.recursive === true) {
      const root = await pipe(
        async function* () {
          for await (const entry of recursive(resolved.cid, blockstore, options2)) {
            let metadata2;
            let links3 = [];
            if (entry.type === "raw") {
              metadata2 = new UnixFS({ type: "file", data: entry.node });
            } else if (entry.type === "file" || entry.type === "directory") {
              metadata2 = entry.unixfs;
              links3 = entry.node.Links;
            } else {
              throw new NotUnixFSError3();
            }
            metadata2.mode = mode;
            const node = {
              Data: metadata2.marshal(),
              Links: links3
            };
            yield {
              path: entry.path,
              content: node
            };
          }
        },
        // @ts-expect-error cannot combine progress types
        (source) => importer2(source, blockstore, {
          ...options2,
          dagBuilder: async function* (source2, block2) {
            for await (const entry of source2) {
              yield async function() {
                const node = entry.content;
                const buf2 = encode13(node);
                const updatedCid2 = await persist2(buf2, block2, {
                  ...options2,
                  cidVersion: cid.version
                });
                if (node.Data == null) {
                  throw new InvalidPBNodeError(`${updatedCid2} had no data`);
                }
                const unixfs2 = UnixFS.unmarshal(node.Data);
                return {
                  cid: updatedCid2,
                  size: BigInt(buf2.length),
                  path: entry.path,
                  unixfs: unixfs2
                };
              };
            }
          }
        }),
        async (nodes) => src_default14(nodes)
      );
      if (root == null) {
        throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`);
      }
      return updatePathCids(root.cid, resolved, blockstore, options2);
    }
    const block = await src_default7(blockstore.get(resolved.cid, options2));
    let metadata;
    let links2 = [];
    if (resolved.cid.code === code3) {
      metadata = new UnixFS({ type: "file", data: block });
    } else {
      const node = decode14(block);
      if (node.Data == null) {
        throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`);
      }
      links2 = node.Links;
      metadata = UnixFS.unmarshal(node.Data);
    }
    metadata.mode = mode;
    const updatedBlock = encode13({
      Data: metadata.marshal(),
      Links: links2
    });
    const hash = await sha256.digest(updatedBlock);
    const updatedCid = CID.create(resolved.cid.version, code6, hash);
    await blockstore.put(updatedCid, updatedBlock);
    return updatePathCids(updatedCid, resolved, blockstore, options2);
  }

  // node_modules/@helia/unixfs/dist/src/commands/cp.js
  var log12 = logger("helia:unixfs:cp");
  async function cp(source, target, name9, blockstore, options2 = {}) {
    if (name9.includes("/")) {
      throw new InvalidParametersError4("Name must not have slashes");
    }
    const [directory, pblink] = await Promise.all([
      cidToDirectory(target, blockstore, options2),
      cidToPBLink(source, name9, blockstore, options2)
    ]);
    log12('Adding %c as "%s" to %c', source, name9, target);
    const result = await addLink(directory, pblink, blockstore, {
      allowOverwriting: options2.force,
      cidVersion: target.version,
      ...options2
    });
    return result.cid;
  }

  // node_modules/@helia/unixfs/dist/src/commands/ls.js
  async function* ls(cid, blockstore, options2 = {}) {
    const resolved = await resolve7(cid, options2.path, blockstore, options2);
    const result = await exporter2(resolved.cid, blockstore, {
      ...options2,
      extended: true
    });
    if (result.type === "file" || result.type === "raw") {
      if (options2.extended === false) {
        const basic = {
          name: result.name,
          path: result.path,
          cid: result.cid
        };
        yield basic;
      } else {
        yield result;
      }
      return;
    }
    if (result.content == null) {
      throw new NoContentError2();
    }
    if (result.type !== "directory") {
      throw new NotADirectoryError();
    }
    yield* result.content(options2);
  }

  // node_modules/@helia/unixfs/dist/src/commands/mkdir.js
  var log13 = logger("helia:unixfs:mkdir");
  async function mkdir(parentCid, dirname, blockstore, options2 = {}) {
    if (dirname.includes("/")) {
      throw new InvalidParametersError4("Path must not have slashes");
    }
    const entry = await exporter2(parentCid, blockstore, options2);
    if (entry.type !== "directory") {
      throw new NotADirectoryError(`${parentCid.toString()} was not a UnixFS directory`);
    }
    log13("creating %s", dirname);
    const metadata = new UnixFS({
      type: "directory",
      mode: options2.mode,
      mtime: options2.mtime
    });
    const node = {
      Data: metadata.marshal(),
      Links: []
    };
    const buf2 = encode13(node);
    const hash = await sha256.digest(buf2);
    const emptyDirCid = CID.create(options2.cidVersion ?? DEFAULT_CID_VERSION, code6, hash);
    await blockstore.put(emptyDirCid, buf2);
    const [directory, pblink] = await Promise.all([
      cidToDirectory(parentCid, blockstore, options2),
      cidToPBLink(emptyDirCid, dirname, blockstore, options2)
    ]);
    log13("adding empty dir called %s to %c", dirname, parentCid);
    const result = await addLink(directory, pblink, blockstore, {
      ...options2,
      allowOverwriting: options2.force
    });
    return result.cid;
  }

  // node_modules/@helia/unixfs/dist/src/commands/utils/remove-link.js
  var log14 = logger("helia:unixfs:utils:remove-link");
  async function removeLink(parent, name9, blockstore, options2) {
    if (parent.node.Data == null) {
      throw new InvalidPBNodeError("Parent node had no data");
    }
    const meta = UnixFS.unmarshal(parent.node.Data);
    if (meta.type === "hamt-sharded-directory") {
      log14(`removing ${name9} from sharded directory`);
      const result = await removeFromShardedDirectory(parent, name9, blockstore, options2);
      if (!await isOverShardThreshold(result.node, blockstore, options2.shardSplitThresholdBytes ?? DEFAULT_SHARD_SPLIT_THRESHOLD_BYTES, options2)) {
        log14("converting shard to flat directory %c", parent.cid);
        return convertToFlatDirectory(result, blockstore, options2);
      }
      return result;
    }
    log14(`removing link ${name9} regular directory`);
    return removeFromDirectory(parent, name9, blockstore, options2);
  }
  var removeFromDirectory = async (parent, name9, blockstore, options2) => {
    parent.node.Links = parent.node.Links.filter((link) => {
      return link.Name !== name9;
    });
    const parentBlock = encode13(parent.node);
    const parentCid = await persist2(parentBlock, blockstore, {
      ...options2,
      cidVersion: parent.cid.version
    });
    log14(`Updated regular directory ${parentCid}`);
    return {
      node: parent.node,
      cid: parentCid
    };
  };
  var removeFromShardedDirectory = async (parent, name9, blockstore, options2) => {
    const { path } = await recreateShardedDirectory(parent.cid, name9, blockstore, options2);
    const finalSegment = path[path.length - 1];
    if (finalSegment == null) {
      throw new Error("Invalid HAMT, could not generate path");
    }
    const linkName = finalSegment.node.Links.filter((l2) => (l2.Name ?? "").substring(2) === name9).map((l2) => l2.Name).pop();
    if (linkName == null) {
      throw new Error("File not found");
    }
    const prefix = linkName.substring(0, 2);
    const index = parseInt(prefix, 16);
    finalSegment.node.Links = finalSegment.node.Links.filter((link) => link.Name !== linkName);
    finalSegment.children.unset(index);
    if (finalSegment.node.Links.length === 1) {
      while (true) {
        if (path.length === 1) {
          break;
        }
        const segment = path[path.length - 1];
        if (segment == null || segment.node.Links.length > 1) {
          break;
        }
        path.pop();
        const nextSegment = path[path.length - 1];
        if (nextSegment == null) {
          break;
        }
        const link = segment.node.Links[0];
        nextSegment.node.Links = nextSegment.node.Links.filter((l2) => !(l2.Name ?? "").startsWith(nextSegment.prefix));
        nextSegment.node.Links.push({
          Hash: link.Hash,
          Name: `${nextSegment.prefix}${(link.Name ?? "").substring(2)}`,
          Tsize: link.Tsize
        });
      }
    }
    return updateShardedDirectory(path, blockstore, options2);
  };
  var convertToFlatDirectory = async (parent, blockstore, options2) => {
    if (parent.node.Data == null) {
      throw new InvalidParametersError4("Invalid parent passed to convertToFlatDirectory");
    }
    const rootNode = {
      Links: []
    };
    const dir = await exporter2(parent.cid, blockstore);
    if (dir.type !== "directory") {
      throw new Error("Unexpected node type");
    }
    for await (const entry of dir.content()) {
      let tsize = 0;
      if (entry.node instanceof Uint8Array) {
        tsize = entry.node.byteLength;
      } else {
        tsize = encode13(entry.node).length;
      }
      rootNode.Links.push({
        Hash: entry.cid,
        Name: entry.name,
        Tsize: tsize
      });
    }
    const oldUnixfs = UnixFS.unmarshal(parent.node.Data);
    rootNode.Data = new UnixFS({ type: "directory", mode: oldUnixfs.mode, mtime: oldUnixfs.mtime }).marshal();
    const block = encode13(prepare(rootNode));
    const cid = await persist2(block, blockstore, {
      codec: src_exports5,
      cidVersion: parent.cid.version,
      signal: options2.signal
    });
    return {
      cid,
      node: rootNode
    };
  };

  // node_modules/@helia/unixfs/dist/src/commands/rm.js
  var log15 = logger("helia:unixfs:rm");
  async function rm(target, name9, blockstore, options2 = {}) {
    if (name9.includes("/")) {
      throw new InvalidParametersError4("Name must not have slashes");
    }
    const directory = await cidToDirectory(target, blockstore, options2);
    log15("Removing %s from %c", name9, target);
    const result = await removeLink(directory, name9, blockstore, {
      ...options2,
      cidVersion: target.version
    });
    return result.cid;
  }

  // node_modules/@helia/unixfs/dist/src/commands/stat.js
  var DEFAULT_DIR_MODE = 1877;
  var DEFAULT_FILE_MODE2 = 1604;
  var log16 = logger("helia:unixfs:stat");
  async function stat(cid, blockstore, options2 = {}) {
    const resolved = await resolve7(cid, options2.path, blockstore, options2);
    log16("stat %c", resolved.cid);
    const result = await exporter2(resolved.cid, blockstore, options2);
    if (result.type === "raw") {
      if (options2.extended === true) {
        return createExtendedRawStats(result);
      }
      return createRawStats(result);
    } else if (result.type === "file" || result.type === "directory") {
      if (options2.extended === true) {
        return createExtendedStats(result, blockstore, options2.filter ?? new ScalableCuckooFilter({ filterSize: 1024 }), options2);
      }
      return createStats(result);
    }
    throw new NotUnixFSError3();
  }
  function createStats(entry) {
    return {
      type: entry.type,
      cid: entry.cid,
      unixfs: entry.unixfs,
      mode: entry.unixfs.mode ?? (entry.unixfs.isDirectory() ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE2),
      mtime: entry.unixfs.mtime,
      size: entry.unixfs.fileSize()
    };
  }
  async function createExtendedStats(entry, blockstore, filter2, options2) {
    const stats = await inspectDag(entry.cid, blockstore, false, filter2, options2);
    return {
      type: entry.type,
      cid: entry.cid,
      unixfs: entry.unixfs,
      size: entry.unixfs.isDirectory() ? stats.dirSize : entry.unixfs.fileSize(),
      mode: entry.unixfs.mode ?? (entry.unixfs.isDirectory() ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE2),
      mtime: entry.unixfs.mtime,
      localSize: stats.localSize,
      dagSize: stats.dagSize,
      deduplicatedDagSize: stats.deduplicatedDagSize,
      blocks: stats.blocks,
      uniqueBlocks: stats.uniqueBlocks
    };
  }
  function createRawStats(entry) {
    return {
      type: entry.type,
      cid: entry.cid,
      unixfs: void 0,
      mode: DEFAULT_FILE_MODE2,
      mtime: void 0,
      size: BigInt(entry.node.byteLength)
    };
  }
  function createExtendedRawStats(entry) {
    return {
      type: entry.type,
      cid: entry.cid,
      unixfs: void 0,
      mode: DEFAULT_FILE_MODE2,
      mtime: void 0,
      size: BigInt(entry.node.byteLength),
      localSize: BigInt(entry.node.byteLength),
      dagSize: BigInt(entry.node.byteLength),
      deduplicatedDagSize: BigInt(entry.node.byteLength),
      blocks: 1n,
      uniqueBlocks: 1n
    };
  }
  async function inspectDag(cid, blockstore, isFile2, filter2, options2) {
    const results = {
      dirSize: 0n,
      localSize: 0n,
      dagSize: 0n,
      deduplicatedDagSize: 0n,
      blocks: 0n,
      uniqueBlocks: 0n
    };
    try {
      const alreadyTraversed = filter2.has(cid.bytes);
      filter2.add(cid.bytes);
      const block = await src_default7(blockstore.get(cid, options2));
      results.blocks++;
      results.dagSize += BigInt(block.byteLength);
      if (!alreadyTraversed) {
        results.uniqueBlocks++;
        results.deduplicatedDagSize += BigInt(block.byteLength);
      }
      if (cid.code === code3) {
        results.localSize += BigInt(block.byteLength);
        if (isFile2) {
          results.dirSize += BigInt(block.byteLength);
        }
      } else if (cid.code === code6) {
        const pbNode = decode14(block);
        let unixfs2;
        if (pbNode.Data != null) {
          unixfs2 = UnixFS.unmarshal(pbNode.Data);
        }
        if (pbNode.Links.length > 0) {
          for (const link of pbNode.Links) {
            const linkResult = await inspectDag(link.Hash, blockstore, linkIsFile(link, unixfs2), filter2, options2);
            results.localSize += linkResult.localSize;
            results.dagSize += linkResult.dagSize;
            results.deduplicatedDagSize += linkResult.deduplicatedDagSize;
            results.blocks += linkResult.blocks;
            results.uniqueBlocks += linkResult.uniqueBlocks;
            results.dirSize += linkResult.dirSize;
          }
          if (isFile2 && unixfs2 != null) {
            results.dirSize += unixfs2.fileSize();
          }
        } else {
          if (unixfs2 == null) {
            throw new InvalidPBNodeError(`PBNode ${cid.toString()} had no data`);
          }
          if (unixfs2.data != null) {
            results.localSize += BigInt(unixfs2.data.byteLength ?? 0);
          }
          if (isFile2) {
            results.dirSize += unixfs2.fileSize();
          }
        }
      } else {
        throw new UnknownError(`${cid.toString()} was neither DAG_PB nor RAW`);
      }
    } catch (err2) {
      if (err2.name !== "NotFoundError" || options2.offline !== true) {
        throw err2;
      }
    }
    return results;
  }
  function linkIsFile(link, parent) {
    if (parent == null) {
      return false;
    }
    const name9 = link.Name;
    if (name9 == null) {
      return false;
    }
    if (parent.type === "directory") {
      return true;
    } else if (parent.type === "hamt-sharded-directory" && name9.length > 2) {
      return true;
    }
    return false;
  }

  // node_modules/@helia/unixfs/dist/src/commands/touch.js
  var log17 = logger("helia:unixfs:touch");
  async function touch(cid, blockstore, options2 = {}) {
    const resolved = await resolve7(cid, options2.path, blockstore, options2);
    const mtime = options2.mtime ?? {
      secs: BigInt(Math.round(Date.now() / 1e3)),
      nsecs: 0
    };
    log17("touch %c %o", resolved.cid, mtime);
    if (options2.recursive) {
      const root = await pipe(
        async function* () {
          for await (const entry of recursive(resolved.cid, blockstore)) {
            let metadata2;
            let links3;
            if (entry.type === "raw") {
              metadata2 = new UnixFS({ data: entry.node });
              links3 = [];
            } else if (entry.type === "file" || entry.type === "directory") {
              metadata2 = entry.unixfs;
              links3 = entry.node.Links;
            } else {
              throw new NotUnixFSError3();
            }
            metadata2.mtime = mtime;
            const node = {
              Data: metadata2.marshal(),
              Links: links3
            };
            yield {
              path: entry.path,
              content: node
            };
          }
        },
        // @ts-expect-error blockstore types are incompatible
        (source) => importer2(source, blockstore, {
          ...options2,
          dagBuilder: async function* (source2, block2) {
            for await (const entry of source2) {
              yield async function() {
                const node = entry.content;
                const buf2 = encode13(node);
                const updatedCid2 = await persist2(buf2, block2, {
                  ...options2,
                  cidVersion: cid.version
                });
                if (node.Data == null) {
                  throw new InvalidPBNodeError(`${updatedCid2} had no data`);
                }
                const unixfs2 = UnixFS.unmarshal(node.Data);
                return {
                  cid: updatedCid2,
                  size: BigInt(buf2.length),
                  path: entry.path,
                  unixfs: unixfs2
                };
              };
            }
          }
        }),
        async (nodes) => src_default14(nodes)
      );
      if (root == null) {
        throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`);
      }
      return updatePathCids(root.cid, resolved, blockstore, options2);
    }
    const block = await src_default7(blockstore.get(resolved.cid, options2));
    let metadata;
    let links2 = [];
    if (resolved.cid.code === code3) {
      metadata = new UnixFS({ data: block });
    } else {
      const node = decode14(block);
      links2 = node.Links;
      if (node.Data == null) {
        throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`);
      }
      metadata = UnixFS.unmarshal(node.Data);
    }
    metadata.mtime = mtime;
    const updatedBlock = encode13({
      Data: metadata.marshal(),
      Links: links2
    });
    const hash = await sha256.digest(updatedBlock);
    const updatedCid = CID.create(resolved.cid.version, code6, hash);
    await blockstore.put(updatedCid, updatedBlock);
    return updatePathCids(updatedCid, resolved, blockstore, options2);
  }

  // node_modules/@helia/unixfs/dist/src/unixfs.js
  var UnixFS2 = class {
    components;
    constructor(components) {
      this.components = components;
    }
    async *addAll(source, options2 = {}) {
      yield* addAll(source, this.components.blockstore, options2);
    }
    async addBytes(bytes, options2 = {}) {
      return addBytes(bytes, this.components.blockstore, options2);
    }
    async addByteStream(bytes, options2 = {}) {
      return addByteStream(bytes, this.components.blockstore, options2);
    }
    async addFile(file, options2 = {}) {
      return addFile(file, this.components.blockstore, options2);
    }
    async addDirectory(dir = {}, options2 = {}) {
      return addDirectory(dir, this.components.blockstore, options2);
    }
    async *cat(cid, options2 = {}) {
      yield* cat(cid, this.components.blockstore, options2);
    }
    async chmod(cid, mode, options2 = {}) {
      return chmod(cid, mode, this.components.blockstore, options2);
    }
    async cp(source, target, name9, options2 = {}) {
      return cp(source, target, name9, this.components.blockstore, options2);
    }
    async *ls(cid, options2 = {}) {
      yield* ls(cid, this.components.blockstore, options2);
    }
    async mkdir(cid, dirname, options2 = {}) {
      return mkdir(cid, dirname, this.components.blockstore, options2);
    }
    async rm(cid, path, options2 = {}) {
      return rm(cid, path, this.components.blockstore, options2);
    }
    async stat(cid, options2 = {}) {
      return stat(cid, this.components.blockstore, options2);
    }
    async touch(cid, options2 = {}) {
      return touch(cid, this.components.blockstore, options2);
    }
  };

  // node_modules/@helia/unixfs/dist/src/index.js
  function unixfs(helia2) {
    return new UnixFS2(helia2);
  }

  // node_modules/token-types/lib/index.js
  var ieee754 = __toESM(require_ieee754(), 1);

  // node_modules/@borewit/text-codec/lib/index.js
  var WINDOWS_1252_EXTRA = {
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178"
  };
  var WINDOWS_1252_REVERSE = {};
  for (const [code8, char] of Object.entries(WINDOWS_1252_EXTRA)) {
    WINDOWS_1252_REVERSE[char] = Number.parseInt(code8);
  }
  function textDecode(bytes, encoding = "utf-8") {
    switch (encoding.toLowerCase()) {
      case "utf-8":
      case "utf8":
        if (typeof globalThis.TextDecoder !== "undefined") {
          return new globalThis.TextDecoder("utf-8").decode(bytes);
        }
        return decodeUTF8(bytes);
      case "utf-16le":
        return decodeUTF16LE(bytes);
      case "ascii":
        return decodeASCII(bytes);
      case "latin1":
      case "iso-8859-1":
        return decodeLatin1(bytes);
      case "windows-1252":
        return decodeWindows1252(bytes);
      default:
        throw new RangeError(`Encoding '${encoding}' not supported`);
    }
  }
  function decodeUTF8(bytes) {
    let out = "";
    let i2 = 0;
    while (i2 < bytes.length) {
      const b1 = bytes[i2++];
      if (b1 < 128) {
        out += String.fromCharCode(b1);
      } else if (b1 < 224) {
        const b2 = bytes[i2++] & 63;
        out += String.fromCharCode((b1 & 31) << 6 | b2);
      } else if (b1 < 240) {
        const b2 = bytes[i2++] & 63;
        const b3 = bytes[i2++] & 63;
        out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
      } else {
        const b2 = bytes[i2++] & 63;
        const b3 = bytes[i2++] & 63;
        const b4 = bytes[i2++] & 63;
        let cp2 = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
        cp2 -= 65536;
        out += String.fromCharCode(55296 + (cp2 >> 10 & 1023), 56320 + (cp2 & 1023));
      }
    }
    return out;
  }
  function decodeUTF16LE(bytes) {
    let out = "";
    for (let i2 = 0; i2 < bytes.length; i2 += 2) {
      out += String.fromCharCode(bytes[i2] | bytes[i2 + 1] << 8);
    }
    return out;
  }
  function decodeASCII(bytes) {
    return String.fromCharCode(...bytes.map((b) => b & 127));
  }
  function decodeLatin1(bytes) {
    return String.fromCharCode(...bytes);
  }
  function decodeWindows1252(bytes) {
    let out = "";
    for (const b of bytes) {
      if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
        out += WINDOWS_1252_EXTRA[b];
      } else {
        out += String.fromCharCode(b);
      }
    }
    return out;
  }

  // node_modules/token-types/lib/index.js
  function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
  }
  var UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value2) {
      dv(array).setUint8(offset, value2);
      return offset + 1;
    }
  };
  var UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setUint16(offset, value2, true);
      return offset + 2;
    }
  };
  var UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value2) {
      dv(array).setUint16(offset, value2);
      return offset + 2;
    }
  };
  var UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setUint32(offset, value2, true);
      return offset + 4;
    }
  };
  var UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value2) {
      dv(array).setUint32(offset, value2);
      return offset + 4;
    }
  };
  var INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value2) {
      dv(array).setInt32(offset, value2);
      return offset + 4;
    }
  };
  var UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value2) {
      dv(array).setBigUint64(offset, value2, true);
      return offset + 8;
    }
  };
  var StringType = class {
    constructor(len, encoding) {
      this.len = len;
      this.encoding = encoding;
    }
    get(data, offset = 0) {
      const bytes = data.subarray(offset, offset + this.len);
      return textDecode(bytes, this.encoding);
    }
  };

  // node_modules/strtok3/lib/stream/Errors.js
  var defaultMessages = "End-Of-Stream";
  var EndOfStreamError = class extends Error {
    constructor() {
      super(defaultMessages);
      this.name = "EndOfStreamError";
    }
  };
  var AbortError8 = class extends Error {
    constructor(message2 = "The operation was aborted") {
      super(message2);
      this.name = "AbortError";
    }
  };

  // node_modules/strtok3/lib/stream/AbstractStreamReader.js
  var AbstractStreamReader = class {
    constructor() {
      this.endOfStream = false;
      this.interrupted = false;
      this.peekQueue = [];
    }
    async peek(uint8Array, mayBeLess = false) {
      const bytesRead = await this.read(uint8Array, mayBeLess);
      this.peekQueue.push(uint8Array.subarray(0, bytesRead));
      return bytesRead;
    }
    async read(buffer2, mayBeLess = false) {
      if (buffer2.length === 0) {
        return 0;
      }
      let bytesRead = this.readFromPeekBuffer(buffer2);
      if (!this.endOfStream) {
        bytesRead += await this.readRemainderFromStream(buffer2.subarray(bytesRead), mayBeLess);
      }
      if (bytesRead === 0 && !mayBeLess) {
        throw new EndOfStreamError();
      }
      return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @returns Number of bytes read
     */
    readFromPeekBuffer(buffer2) {
      let remaining = buffer2.length;
      let bytesRead = 0;
      while (this.peekQueue.length > 0 && remaining > 0) {
        const peekData = this.peekQueue.pop();
        if (!peekData)
          throw new Error("peekData should be defined");
        const lenCopy = Math.min(peekData.length, remaining);
        buffer2.set(peekData.subarray(0, lenCopy), bytesRead);
        bytesRead += lenCopy;
        remaining -= lenCopy;
        if (lenCopy < peekData.length) {
          this.peekQueue.push(peekData.subarray(lenCopy));
        }
      }
      return bytesRead;
    }
    async readRemainderFromStream(buffer2, mayBeLess) {
      let bytesRead = 0;
      while (bytesRead < buffer2.length && !this.endOfStream) {
        if (this.interrupted) {
          throw new AbortError8();
        }
        const chunkLen = await this.readFromStream(buffer2.subarray(bytesRead), mayBeLess);
        if (chunkLen === 0)
          break;
        bytesRead += chunkLen;
      }
      if (!mayBeLess && bytesRead < buffer2.length) {
        throw new EndOfStreamError();
      }
      return bytesRead;
    }
  };

  // node_modules/strtok3/lib/stream/WebStreamReader.js
  var WebStreamReader = class extends AbstractStreamReader {
    constructor(reader2) {
      super();
      this.reader = reader2;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };

  // node_modules/strtok3/lib/stream/WebStreamByobReader.js
  var WebStreamByobReader = class extends WebStreamReader {
    /**
     * Read from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param mayBeLess - If true, may fill the buffer partially
     * @protected Bytes read
     */
    async readFromStream(buffer2, mayBeLess) {
      if (buffer2.length === 0)
        return 0;
      const result = await this.reader.read(new Uint8Array(buffer2.length), { min: mayBeLess ? void 0 : buffer2.length });
      if (result.done) {
        this.endOfStream = result.done;
      }
      if (result.value) {
        buffer2.set(result.value);
        return result.value.length;
      }
      return 0;
    }
  };

  // node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
  var WebStreamDefaultReader = class extends AbstractStreamReader {
    constructor(reader2) {
      super();
      this.reader = reader2;
      this.buffer = null;
    }
    /**
     * Copy chunk to target, and store the remainder in this.buffer
     */
    writeChunk(target, chunk) {
      const written = Math.min(chunk.length, target.length);
      target.set(chunk.subarray(0, written));
      if (written < chunk.length) {
        this.buffer = chunk.subarray(written);
      } else {
        this.buffer = null;
      }
      return written;
    }
    /**
     * Read from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param mayBeLess - If true, may fill the buffer partially
     * @protected Bytes read
     */
    async readFromStream(buffer2, mayBeLess) {
      if (buffer2.length === 0)
        return 0;
      let totalBytesRead = 0;
      if (this.buffer) {
        totalBytesRead += this.writeChunk(buffer2, this.buffer);
      }
      while (totalBytesRead < buffer2.length && !this.endOfStream) {
        const result = await this.reader.read();
        if (result.done) {
          this.endOfStream = true;
          break;
        }
        if (result.value) {
          totalBytesRead += this.writeChunk(buffer2.subarray(totalBytesRead), result.value);
        }
      }
      if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
        throw new EndOfStreamError();
      }
      return totalBytesRead;
    }
    abort() {
      this.interrupted = true;
      return this.reader.cancel();
    }
    async close() {
      await this.abort();
      this.reader.releaseLock();
    }
  };

  // node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
  function makeWebStreamReader(stream) {
    try {
      const reader2 = stream.getReader({ mode: "byob" });
      if (reader2 instanceof ReadableStreamDefaultReader) {
        return new WebStreamDefaultReader(reader2);
      }
      return new WebStreamByobReader(reader2);
    } catch (error) {
      if (error instanceof TypeError) {
        return new WebStreamDefaultReader(stream.getReader());
      }
      throw error;
    }
  }

  // node_modules/strtok3/lib/AbstractTokenizer.js
  var AbstractTokenizer = class {
    /**
     * Constructor
     * @param options Tokenizer options
     * @protected
     */
    constructor(options2) {
      this.numBuffer = new Uint8Array(8);
      this.position = 0;
      this.onClose = options2?.onClose;
      if (options2?.abortSignal) {
        options2.abortSignal.addEventListener("abort", () => {
          this.abort();
        });
      }
    }
    /**
     * Read a token from the tokenizer-stream
     * @param token - The token to read
     * @param position - If provided, the desired position in the tokenizer-stream
     * @returns Promise with token data
     */
    async readToken(token, position = this.position) {
      const uint8Array = new Uint8Array(token.len);
      const len = await this.readBuffer(uint8Array, { position });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(uint8Array, 0);
    }
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */
    async peekToken(token, position = this.position) {
      const uint8Array = new Uint8Array(token.len);
      const len = await this.peekBuffer(uint8Array, { position });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(uint8Array, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
    async readNumber(token) {
      const len = await this.readBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(this.numBuffer, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
    async peekNumber(token) {
      const len = await this.peekBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new EndOfStreamError();
      return token.get(this.numBuffer, 0);
    }
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */
    async ignore(length4) {
      if (this.fileInfo.size !== void 0) {
        const bytesLeft = this.fileInfo.size - this.position;
        if (length4 > bytesLeft) {
          this.position += bytesLeft;
          return bytesLeft;
        }
      }
      this.position += length4;
      return length4;
    }
    async close() {
      await this.abort();
      await this.onClose?.();
    }
    normalizeOptions(uint8Array, options2) {
      if (!this.supportsRandomAccess() && options2 && options2.position !== void 0 && options2.position < this.position) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      return {
        ...{
          mayBeLess: false,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        },
        ...options2
      };
    }
    abort() {
      return Promise.resolve();
    }
  };

  // node_modules/strtok3/lib/ReadStreamTokenizer.js
  var maxBufferSize = 256e3;
  var ReadStreamTokenizer = class extends AbstractTokenizer {
    /**
     * Constructor
     * @param streamReader stream-reader to read from
     * @param options Tokenizer options
     */
    constructor(streamReader, options2) {
      super(options2);
      this.streamReader = streamReader;
      this.fileInfo = options2?.fileInfo ?? {};
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */
    async readBuffer(uint8Array, options2) {
      const normOptions = this.normalizeOptions(uint8Array, options2);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options2);
      }
      if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      this.position += bytesRead;
      if ((!options2 || !options2.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError();
      }
      return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */
    async peekBuffer(uint8Array, options2) {
      const normOptions = this.normalizeOptions(uint8Array, options2);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes));
          return bytesRead - skipBytes;
        }
        if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
        } catch (err2) {
          if (options2?.mayBeLess && err2 instanceof EndOfStreamError) {
            return 0;
          }
          throw err2;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError();
        }
      }
      return bytesRead;
    }
    async ignore(length4) {
      const bufSize = Math.min(maxBufferSize, length4);
      const buf2 = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length4) {
        const remaining = length4 - totBytesRead;
        const bytesRead = await this.readBuffer(buf2, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };

  // node_modules/strtok3/lib/BufferTokenizer.js
  var BufferTokenizer = class extends AbstractTokenizer {
    /**
     * Construct BufferTokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options Tokenizer options
     */
    constructor(uint8Array, options2) {
      super(options2);
      this.uint8Array = uint8Array;
      this.fileInfo = { ...options2?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
    async readBuffer(uint8Array, options2) {
      if (options2?.position) {
        this.position = options2.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options2);
      this.position += bytesRead;
      return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
    async peekBuffer(uint8Array, options2) {
      const normOptions = this.normalizeOptions(uint8Array, options2);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new EndOfStreamError();
      }
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
      return bytes2read;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(position) {
      this.position = position;
    }
  };

  // node_modules/strtok3/lib/core.js
  function fromWebStream(webStream, options2) {
    const webStreamReader = makeWebStreamReader(webStream);
    const _options = options2 ?? {};
    const chainedClose = _options.onClose;
    _options.onClose = async () => {
      await webStreamReader.close();
      if (chainedClose) {
        return chainedClose();
      }
    };
    return new ReadStreamTokenizer(webStreamReader, _options);
  }
  function fromBuffer(uint8Array, options2) {
    return new BufferTokenizer(uint8Array, options2);
  }

  // node_modules/fflate/esm/browser.js
  var u8 = Uint8Array;
  var u16 = Uint16Array;
  var i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start2) {
    var b = new u16(31);
    for (var i2 = 0; i2 < 31; ++i2) {
      b[i2] = start2 += 1 << eb[i2 - 1];
    }
    var r2 = new i32(b[30]);
    for (var i2 = 1; i2 < 30; ++i2) {
      for (var j = b[i2]; j < b[i2 + 1]; ++j) {
        r2[j] = j - b[i2] << 5 | i2;
      }
    }
    return { b, r: r2 };
  };
  var _a3 = freb(fleb, 2);
  var fl = _a3.b;
  var revfl = _a3.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0);
  var fd = _b.b;
  var revfd = _b.r;
  var rev = new u16(32768);
  for (i2 = 0; i2 < 32768; ++i2) {
    x = (i2 & 43690) >> 1 | (i2 & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i2] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var x;
  var i2;
  var hMap = (function(cd, mb, r2) {
    var s2 = cd.length;
    var i2 = 0;
    var l2 = new u16(mb);
    for (; i2 < s2; ++i2) {
      if (cd[i2])
        ++l2[cd[i2] - 1];
    }
    var le = new u16(mb);
    for (i2 = 1; i2 < mb; ++i2) {
      le[i2] = le[i2 - 1] + l2[i2 - 1] << 1;
    }
    var co;
    if (r2) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i2 = 0; i2 < s2; ++i2) {
        if (cd[i2]) {
          var sv = i2 << 4 | cd[i2];
          var r_1 = mb - cd[i2];
          var v = le[cd[i2] - 1]++ << r_1;
          for (var m2 = v | (1 << r_1) - 1; v <= m2; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s2);
      for (i2 = 0; i2 < s2; ++i2) {
        if (cd[i2]) {
          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
        }
      }
    }
    return co;
  });
  var flt = new u8(288);
  for (i2 = 0; i2 < 144; ++i2)
    flt[i2] = 8;
  var i2;
  for (i2 = 144; i2 < 256; ++i2)
    flt[i2] = 9;
  var i2;
  for (i2 = 256; i2 < 280; ++i2)
    flt[i2] = 7;
  var i2;
  for (i2 = 280; i2 < 288; ++i2)
    flt[i2] = 8;
  var i2;
  var fdt = new u8(32);
  for (i2 = 0; i2 < 32; ++i2)
    fdt[i2] = 5;
  var i2;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a2) {
    var m2 = a2[0];
    for (var i2 = 1; i2 < a2.length; ++i2) {
      if (a2[i2] > m2)
        m2 = a2[i2];
    }
    return m2;
  };
  var bits = function(d2, p2, m2) {
    var o2 = p2 / 8 | 0;
    return (d2[o2] | d2[o2 + 1] << 8) >> (p2 & 7) & m2;
  };
  var bits16 = function(d2, p2) {
    var o2 = p2 / 8 | 0;
    return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >> (p2 & 7);
  };
  var shft = function(p2) {
    return (p2 + 7) / 8 | 0;
  };
  var slc = function(v, s2, e2) {
    if (s2 == null || s2 < 0)
      s2 = 0;
    if (e2 == null || e2 > v.length)
      e2 = v.length;
    return new u8(v.subarray(s2, e2));
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt) {
    var e2 = new Error(msg || ec[ind]);
    e2.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e2, err);
    if (!nt)
      throw e2;
    return e2;
  };
  var inflt = function(dat, st, buf2, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf2 || new u8(0);
    var noBuf = !buf2;
    var resize = noBuf || st.i != 2;
    var noSt = st.i;
    if (noBuf)
      buf2 = new u8(sl * 3);
    var cbuf = function(l3) {
      var bl = buf2.length;
      if (l3 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l3));
        nbuf.set(buf2);
        buf2 = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
          if (t2 > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + l2);
          buf2.set(dat.subarray(s2, t2), bt);
          st.b = bt += l2, st.p = pos = t2 * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i2 = 0; i2 < hcLen; ++i2) {
            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i2 = 0; i2 < tl; ) {
            var r2 = clm[bits(dat, pos, clbmsk)];
            pos += r2 & 15;
            var s2 = r2 >> 4;
            if (s2 < 16) {
              ldt[i2++] = s2;
            } else {
              var c2 = 0, n2 = 0;
              if (s2 == 16)
                n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];
              else if (s2 == 17)
                n2 = 3 + bits(dat, pos, 7), pos += 3;
              else if (s2 == 18)
                n2 = 11 + bits(dat, pos, 127), pos += 7;
              while (n2--)
                ldt[i2++] = c2;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c2 = lm[bits16(dat, pos) & lms], sym = c2 >> 4;
        pos += c2 & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c2)
          err(2);
        if (sym < 256)
          buf2[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add2 = sym - 254;
          if (sym > 264) {
            var i2 = sym - 257, b = fleb[i2];
            add2 = bits(dat, pos, (1 << b) - 1) + fl[i2];
            pos += b;
          }
          var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
          if (!d2)
            err(3);
          pos += d2 & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + 131072);
          var end = bt + add2;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf2[bt] = dict[shift + bt];
          }
          for (; bt < end; ++bt)
            buf2[bt] = buf2[bt - dt];
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt != buf2.length && noBuf ? slc(buf2, 0, bt) : buf2.subarray(0, bt);
  };
  var et = /* @__PURE__ */ new u8(0);
  var gzs = function(d2) {
    if (d2[0] != 31 || d2[1] != 139 || d2[2] != 8)
      err(6, "invalid gzip data");
    var flg = d2[3];
    var st = 10;
    if (flg & 4)
      st += (d2[10] | d2[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d2[st++])
      ;
    return st + (flg & 2);
  };
  var gzl = function(d2) {
    var l2 = d2.length;
    return (d2[l2 - 4] | d2[l2 - 3] << 8 | d2[l2 - 2] << 16 | d2[l2 - 1] << 24) >>> 0;
  };
  var zls = function(d2, dict) {
    if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
      err(6, "invalid zlib data");
    if ((d2[1] >> 5 & 1) == +!dict)
      err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
    return (d2[1] >> 3 & 4) + 2;
  };
  function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  function gunzipSync(data, opts) {
    var st = gzs(data);
    if (st + 8 > data.length)
      err(6, "invalid gzip data");
    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
  }
  function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  function decompressSync(data, opts) {
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e2) {
  }

  // node_modules/@tokenizer/inflate/lib/index.js
  var import_debug = __toESM(require_browser3(), 1);

  // node_modules/@tokenizer/inflate/lib/ZipToken.js
  var Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  var DataDescriptor = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        compressedSize: UINT32_LE.get(array, 8),
        uncompressedSize: UINT32_LE.get(array, 12)
      };
    },
    len: 16
  };
  var LocalFileHeaderToken = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 8),
        compressedSize: UINT32_LE.get(array, 18),
        uncompressedSize: UINT32_LE.get(array, 22),
        filenameLength: UINT16_LE.get(array, 26),
        extraFieldLength: UINT16_LE.get(array, 28),
        filename: null
      };
    },
    len: 30
  };
  var EndOfCentralDirectoryRecordToken = {
    get(array) {
      return {
        signature: UINT32_LE.get(array, 0),
        nrOfThisDisk: UINT16_LE.get(array, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array, 10),
        sizeOfCd: UINT32_LE.get(array, 12),
        offsetOfStartOfCd: UINT32_LE.get(array, 16),
        zipFileCommentLength: UINT16_LE.get(array, 20)
      };
    },
    len: 22
  };
  var FileHeader = {
    get(array) {
      const flags = UINT16_LE.get(array, 8);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 10),
        compressedSize: UINT32_LE.get(array, 20),
        uncompressedSize: UINT32_LE.get(array, 24),
        filenameLength: UINT16_LE.get(array, 28),
        extraFieldLength: UINT16_LE.get(array, 30),
        fileCommentLength: UINT16_LE.get(array, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
        filename: null
      };
    },
    len: 46
  };

  // node_modules/@tokenizer/inflate/lib/index.js
  function signatureToArray(signature) {
    const signatureBytes = new Uint8Array(UINT32_LE.len);
    UINT32_LE.put(signatureBytes, 0, signature);
    return signatureBytes;
  }
  var debug = (0, import_debug.default)("tokenizer:inflate");
  var syncBufferSize = 256 * 1024;
  var ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  var eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
  var ZipHandler = class {
    constructor(tokenizer) {
      this.tokenizer = tokenizer;
      this.syncBuffer = new Uint8Array(syncBufferSize);
    }
    async isZip() {
      return await this.peekSignature() === Signature.LocalFileHeader;
    }
    peekSignature() {
      return this.tokenizer.peekToken(UINT32_LE);
    }
    async findEndOfCentralDirectoryLocator() {
      const randomReadTokenizer = this.tokenizer;
      const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
      const buffer2 = this.syncBuffer.subarray(0, chunkLength);
      await this.tokenizer.readBuffer(buffer2, { position: randomReadTokenizer.fileInfo.size - chunkLength });
      for (let i2 = buffer2.length - 4; i2 >= 0; i2--) {
        if (buffer2[i2] === eocdSignatureBytes[0] && buffer2[i2 + 1] === eocdSignatureBytes[1] && buffer2[i2 + 2] === eocdSignatureBytes[2] && buffer2[i2 + 3] === eocdSignatureBytes[3]) {
          return randomReadTokenizer.fileInfo.size - chunkLength + i2;
        }
      }
      return -1;
    }
    async readCentralDirectory() {
      if (!this.tokenizer.supportsRandomAccess()) {
        debug("Cannot reading central-directory without random-read support");
        return;
      }
      debug("Reading central-directory...");
      const pos = this.tokenizer.position;
      const offset = await this.findEndOfCentralDirectoryLocator();
      if (offset > 0) {
        debug("Central-directory 32-bit signature found");
        const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
        const files = [];
        this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
        for (let n2 = 0; n2 < eocdHeader.nrOfEntriesOfSize; ++n2) {
          const entry = await this.tokenizer.readToken(FileHeader);
          if (entry.signature !== Signature.CentralFileHeader) {
            throw new Error("Expected Central-File-Header signature");
          }
          entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
          await this.tokenizer.ignore(entry.extraFieldLength);
          await this.tokenizer.ignore(entry.fileCommentLength);
          files.push(entry);
          debug(`Add central-directory file-entry: n=${n2 + 1}/${files.length}: filename=${files[n2].filename}`);
        }
        this.tokenizer.setPosition(pos);
        return files;
      }
      this.tokenizer.setPosition(pos);
    }
    async unzip(fileCb) {
      const entries = await this.readCentralDirectory();
      if (entries) {
        return this.iterateOverCentralDirectory(entries, fileCb);
      }
      let stop2 = false;
      do {
        const zipHeader = await this.readLocalFileHeader();
        if (!zipHeader)
          break;
        const next = fileCb(zipHeader);
        stop2 = !!next.stop;
        let fileData = void 0;
        await this.tokenizer.ignore(zipHeader.extraFieldLength);
        if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
          const chunks = [];
          let len = syncBufferSize;
          debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
          let nextHeaderIndex = -1;
          while (nextHeaderIndex < 0 && len === syncBufferSize) {
            len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
            nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
            const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
            if (next.handler) {
              const data = new Uint8Array(size);
              await this.tokenizer.readBuffer(data);
              chunks.push(data);
            } else {
              await this.tokenizer.ignore(size);
            }
          }
          debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
          if (next.handler) {
            await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
          }
        } else {
          if (next.handler) {
            debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
            fileData = new Uint8Array(zipHeader.compressedSize);
            await this.tokenizer.readBuffer(fileData);
            await this.inflate(zipHeader, fileData, next.handler);
          } else {
            debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
            await this.tokenizer.ignore(zipHeader.compressedSize);
          }
        }
        debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
        if (zipHeader.dataDescriptor) {
          const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
          if (dataDescriptor.signature !== 134695760) {
            throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
          }
        }
      } while (!stop2);
    }
    async iterateOverCentralDirectory(entries, fileCb) {
      for (const fileHeader of entries) {
        const next = fileCb(fileHeader);
        if (next.handler) {
          this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
          const zipHeader = await this.readLocalFileHeader();
          if (zipHeader) {
            await this.tokenizer.ignore(zipHeader.extraFieldLength);
            const fileData = new Uint8Array(fileHeader.compressedSize);
            await this.tokenizer.readBuffer(fileData);
            await this.inflate(zipHeader, fileData, next.handler);
          }
        }
        if (next.stop)
          break;
      }
    }
    inflate(zipHeader, fileData, cb) {
      if (zipHeader.compressedMethod === 0) {
        return cb(fileData);
      }
      debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
      const uncompressedData = decompressSync(fileData);
      return cb(uncompressedData);
    }
    async readLocalFileHeader() {
      const signature = await this.tokenizer.peekToken(UINT32_LE);
      if (signature === Signature.LocalFileHeader) {
        const header = await this.tokenizer.readToken(LocalFileHeaderToken);
        header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
        return header;
      }
      if (signature === Signature.CentralFileHeader) {
        return false;
      }
      if (signature === 3759263696) {
        throw new Error("Encrypted ZIP");
      }
      throw new Error("Unexpected signature");
    }
  };
  function indexOf(buffer2, portion) {
    const bufferLength = buffer2.length;
    const portionLength = portion.length;
    if (portionLength > bufferLength)
      return -1;
    for (let i2 = 0; i2 <= bufferLength - portionLength; i2++) {
      let found = true;
      for (let j = 0; j < portionLength; j++) {
        if (buffer2[i2 + j] !== portion[j]) {
          found = false;
          break;
        }
      }
      if (found) {
        return i2;
      }
    }
    return -1;
  }
  function mergeArrays(chunks) {
    const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
    const mergedArray = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      mergedArray.set(chunk, offset);
      offset += chunk.length;
    }
    return mergedArray;
  }

  // node_modules/uint8array-extras/index.js
  var cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  var cachedEncoder2 = new globalThis.TextEncoder();
  var byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
  function getUintBE(view) {
    const { byteLength } = view;
    if (byteLength === 6) {
      return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
    }
    if (byteLength === 5) {
      return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
    }
    if (byteLength === 4) {
      return view.getUint32(0);
    }
    if (byteLength === 3) {
      return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
    }
    if (byteLength === 2) {
      return view.getUint16(0);
    }
    if (byteLength === 1) {
      return view.getUint8(0);
    }
  }

  // node_modules/file-type/util.js
  function stringToBytes2(string2) {
    return [...string2].map((character) => character.charCodeAt(0));
  }
  function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
    const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
    if (Number.isNaN(readSum)) {
      return false;
    }
    let sum = 8 * 32;
    for (let index = offset; index < offset + 148; index++) {
      sum += arrayBuffer[index];
    }
    for (let index = offset + 156; index < offset + 512; index++) {
      sum += arrayBuffer[index];
    }
    return readSum === sum;
  }
  var uint32SyncSafeToken = {
    get: (buffer2, offset) => buffer2[offset + 3] & 127 | buffer2[offset + 2] << 7 | buffer2[offset + 1] << 14 | buffer2[offset] << 21,
    len: 4
  };

  // node_modules/file-type/supported.js
  var extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx"
  ];
  var mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/vnd.apache.arrow.file",
    "video/mp4",
    "audio/midi",
    "video/matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    // RFC 4337
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "font/collection",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    // Non-standard
    "application/x.ms.shortcut",
    // Invented by us
    "application/x.apple.alias",
    // Invented by us
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/vnd.apache.parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    // Invented by us
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    // Invented by us
    "application/x-lz4",
    // Invented by us
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-word.template.macroenabled.12",
    "application/vnd.ms-powerpoint.template.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/java-archive",
    "application/vnd.rn-realmedia"
  ];

  // node_modules/file-type/core.js
  var reasonableDetectionSizeInBytes = 4100;
  async function fileTypeFromBuffer(input, options2) {
    return new FileTypeParser(options2).fromBuffer(input);
  }
  function getFileTypeFromMimeType(mimeType) {
    mimeType = mimeType.toLowerCase();
    switch (mimeType) {
      case "application/epub+zip":
        return {
          ext: "epub",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.text":
        return {
          ext: "odt",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.text-template":
        return {
          ext: "ott",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.spreadsheet":
        return {
          ext: "ods",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.spreadsheet-template":
        return {
          ext: "ots",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.presentation":
        return {
          ext: "odp",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.presentation-template":
        return {
          ext: "otp",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.graphics":
        return {
          ext: "odg",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.graphics-template":
        return {
          ext: "otg",
          mime: mimeType
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
        return {
          ext: "ppsx",
          mime: mimeType
        };
      case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
        return {
          ext: "xlsx",
          mime: mimeType
        };
      case "application/vnd.ms-excel.sheet.macroenabled":
        return {
          ext: "xlsm",
          mime: "application/vnd.ms-excel.sheet.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
        return {
          ext: "xltx",
          mime: mimeType
        };
      case "application/vnd.ms-excel.template.macroenabled":
        return {
          ext: "xltm",
          mime: "application/vnd.ms-excel.template.macroenabled.12"
        };
      case "application/vnd.ms-powerpoint.slideshow.macroenabled":
        return {
          ext: "ppsm",
          mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
        return {
          ext: "docx",
          mime: mimeType
        };
      case "application/vnd.ms-word.document.macroenabled":
        return {
          ext: "docm",
          mime: "application/vnd.ms-word.document.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
        return {
          ext: "dotx",
          mime: mimeType
        };
      case "application/vnd.ms-word.template.macroenabledtemplate":
        return {
          ext: "dotm",
          mime: "application/vnd.ms-word.template.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.template":
        return {
          ext: "potx",
          mime: mimeType
        };
      case "application/vnd.ms-powerpoint.template.macroenabled":
        return {
          ext: "potm",
          mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
        return {
          ext: "pptx",
          mime: mimeType
        };
      case "application/vnd.ms-powerpoint.presentation.macroenabled":
        return {
          ext: "pptm",
          mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
        };
      case "application/vnd.ms-visio.drawing":
        return {
          ext: "vsdx",
          mime: "application/vnd.visio"
        };
      case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
        return {
          ext: "3mf",
          mime: "model/3mf"
        };
      default:
    }
  }
  function _check(buffer2, headers, options2) {
    options2 = {
      offset: 0,
      ...options2
    };
    for (const [index, header] of headers.entries()) {
      if (options2.mask) {
        if (header !== (options2.mask[index] & buffer2[index + options2.offset])) {
          return false;
        }
      } else if (header !== buffer2[index + options2.offset]) {
        return false;
      }
    }
    return true;
  }
  var FileTypeParser = class {
    constructor(options2) {
      this.options = {
        mpegOffsetTolerance: 0,
        ...options2
      };
      this.detectors = [
        ...options2?.customDetectors ?? [],
        { id: "core", detect: this.detectConfident },
        { id: "core.imprecise", detect: this.detectImprecise }
      ];
      this.tokenizerOptions = {
        abortSignal: options2?.signal
      };
    }
    async fromTokenizer(tokenizer) {
      const initialPosition = tokenizer.position;
      for (const detector of this.detectors) {
        const fileType = await detector.detect(tokenizer);
        if (fileType) {
          return fileType;
        }
        if (initialPosition !== tokenizer.position) {
          return void 0;
        }
      }
    }
    async fromBuffer(input) {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buffer2 = input instanceof Uint8Array ? input : new Uint8Array(input);
      if (!(buffer2?.length > 1)) {
        return;
      }
      return this.fromTokenizer(fromBuffer(buffer2, this.tokenizerOptions));
    }
    async fromBlob(blob) {
      return this.fromStream(blob.stream());
    }
    async fromStream(stream) {
      const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
      try {
        return await this.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async toDetectionStream(stream, options2) {
      const { sampleSize = reasonableDetectionSizeInBytes } = options2;
      let detectedFileType;
      let firstChunk;
      const reader2 = stream.getReader({ mode: "byob" });
      try {
        const { value: chunk, done } = await reader2.read(new Uint8Array(sampleSize));
        firstChunk = chunk;
        if (!done && chunk) {
          try {
            detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
          } catch (error) {
            if (!(error instanceof EndOfStreamError)) {
              throw error;
            }
            detectedFileType = void 0;
          }
        }
        firstChunk = chunk;
      } finally {
        reader2.releaseLock();
      }
      const transformStream = new TransformStream({
        async start(controller) {
          controller.enqueue(firstChunk);
        },
        transform(chunk, controller) {
          controller.enqueue(chunk);
        }
      });
      const newStream = stream.pipeThrough(transformStream);
      newStream.fileType = detectedFileType;
      return newStream;
    }
    check(header, options2) {
      return _check(this.buffer, header, options2);
    }
    checkString(header, options2) {
      return this.check(stringToBytes2(header), options2);
    }
    // Detections with a high degree of certainty in identifying the correct file type
    detectConfident = async (tokenizer) => {
      this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
      if (tokenizer.fileInfo.size === void 0) {
        tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
      }
      this.tokenizer = tokenizer;
      await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
      if (this.check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (this.check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
      if (this.check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (this.check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if (this.check([37, 33])) {
        await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
        if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (this.check([31, 160]) || this.check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (this.check([199, 113])) {
        return {
          ext: "cpio",
          mime: "application/x-cpio"
        };
      }
      if (this.check([96, 234])) {
        return {
          ext: "arj",
          mime: "application/x-arj"
        };
      }
      if (this.check([239, 187, 191])) {
        this.tokenizer.ignore(3);
        return this.detectConfident(tokenizer);
      }
      if (this.check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (this.check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (this.check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (this.check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (this.checkString("ID3")) {
        await tokenizer.ignore(6);
        const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
        if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        await tokenizer.ignore(id3HeaderLength);
        return this.fromTokenizer(tokenizer);
      }
      if (this.checkString("MP+")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (this.check([255, 216, 255])) {
        if (this.check([247], { offset: 3 })) {
          return {
            ext: "jls",
            mime: "image/jls"
          };
        }
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (this.check([79, 98, 106, 1])) {
        return {
          ext: "avro",
          mime: "application/avro"
        };
      }
      if (this.checkString("FLIF")) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if (this.checkString("8BPS")) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (this.checkString("MPCK")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (this.checkString("FORM")) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (this.checkString("icns", { offset: 0 })) {
        return {
          ext: "icns",
          mime: "image/icns"
        };
      }
      if (this.check([80, 75, 3, 4])) {
        let fileType;
        await new ZipHandler(tokenizer).unzip((zipHeader) => {
          switch (zipHeader.filename) {
            case "META-INF/mozilla.rsa":
              fileType = {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
              return {
                stop: true
              };
            case "META-INF/MANIFEST.MF":
              fileType = {
                ext: "jar",
                mime: "application/java-archive"
              };
              return {
                stop: true
              };
            case "mimetype":
              return {
                async handler(fileData) {
                  const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                  fileType = getFileTypeFromMimeType(mimeType);
                },
                stop: true
              };
            case "[Content_Types].xml":
              return {
                async handler(fileData) {
                  let xmlContent = new TextDecoder("utf-8").decode(fileData);
                  const endPos = xmlContent.indexOf('.main+xml"');
                  if (endPos === -1) {
                    const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                    if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                      fileType = getFileTypeFromMimeType(mimeType);
                    }
                  } else {
                    xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                    const firstPos = xmlContent.lastIndexOf('"');
                    const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                },
                stop: true
              };
            default:
              if (/classes\d*\.dex/.test(zipHeader.filename)) {
                fileType = {
                  ext: "apk",
                  mime: "application/vnd.android.package-archive"
                };
                return { stop: true };
              }
              return {};
          }
        });
        return fileType ?? {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (this.checkString("OggS")) {
        await tokenizer.ignore(28);
        const type = new Uint8Array(8);
        await tokenizer.readBuffer(type);
        if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
          return {
            ext: "opus",
            mime: "audio/ogg; codecs=opus"
          };
        }
        if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (_check(type, [127, 70, 76, 65, 67])) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (this.checkString("MThd")) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (this.checkString("DSD ")) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      }
      if (this.checkString("LZIP")) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (this.checkString("fLaC")) {
        return {
          ext: "flac",
          mime: "audio/flac"
        };
      }
      if (this.check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (this.checkString("wvpk")) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (this.checkString("%PDF")) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (this.check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (this.check([73, 73])) {
        const fileType = await this.readTiffHeader(false);
        if (fileType) {
          return fileType;
        }
      }
      if (this.check([77, 77])) {
        const fileType = await this.readTiffHeader(true);
        if (fileType) {
          return fileType;
        }
      }
      if (this.checkString("MAC ")) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (this.check([26, 69, 223, 163])) {
        async function readField() {
          const msb = await tokenizer.peekNumber(UINT8);
          let mask = 128;
          let ic = 0;
          while ((msb & mask) === 0 && mask !== 0) {
            ++ic;
            mask >>= 1;
          }
          const id = new Uint8Array(ic + 1);
          await tokenizer.readBuffer(id);
          return id;
        }
        async function readElement() {
          const idField = await readField();
          const lengthField = await readField();
          lengthField[0] ^= 128 >> lengthField.length - 1;
          const nrLength = Math.min(6, lengthField.length);
          const idView = new DataView(idField.buffer);
          const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
          return {
            id: getUintBE(idView),
            len: getUintBE(lengthView)
          };
        }
        async function readChildren(children) {
          while (children > 0) {
            const element = await readElement();
            if (element.id === 17026) {
              const rawValue = await tokenizer.readToken(new StringType(element.len));
              return rawValue.replaceAll(/\00.*$/g, "");
            }
            await tokenizer.ignore(element.len);
            --children;
          }
        }
        const re = await readElement();
        const documentType = await readChildren(re.len);
        switch (documentType) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/matroska"
            };
          default:
            return;
        }
      }
      if (this.checkString("SQLi")) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (this.check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (this.checkString("Cr24")) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (this.checkString("MSCF") || this.checkString("ISc(")) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (this.check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (this.check([197, 208, 211, 198])) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      if (this.check([40, 181, 47, 253])) {
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      }
      if (this.check([127, 69, 76, 70])) {
        return {
          ext: "elf",
          mime: "application/x-elf"
        };
      }
      if (this.check([33, 66, 68, 78])) {
        return {
          ext: "pst",
          mime: "application/vnd.ms-outlook"
        };
      }
      if (this.checkString("PAR1") || this.checkString("PARE")) {
        return {
          ext: "parquet",
          mime: "application/vnd.apache.parquet"
        };
      }
      if (this.checkString("ttcf")) {
        return {
          ext: "ttc",
          mime: "font/collection"
        };
      }
      if (this.check([207, 250, 237, 254])) {
        return {
          ext: "macho",
          mime: "application/x-mach-binary"
        };
      }
      if (this.check([4, 34, 77, 24])) {
        return {
          ext: "lz4",
          mime: "application/x-lz4"
          // Invented by us
        };
      }
      if (this.check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (this.checkString("#!AMR")) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (this.checkString("{\\rtf")) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (this.check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (this.checkString("IMPM")) {
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      }
      if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      }
      if (this.check([0, 0, 1, 186])) {
        if (this.check([33], { offset: 4, mask: [241] })) {
          return {
            ext: "mpg",
            // May also be .ps, .mpeg
            mime: "video/MP1S"
          };
        }
        if (this.check([68], { offset: 4, mask: [196] })) {
          return {
            ext: "mpg",
            // May also be .mpg, .m2p, .vob or .sub
            mime: "video/MP2P"
          };
        }
      }
      if (this.checkString("ITSF")) {
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      }
      if (this.check([202, 254, 186, 190])) {
        return {
          ext: "class",
          mime: "application/java-vm"
        };
      }
      if (this.checkString(".RMF")) {
        return {
          ext: "rm",
          mime: "application/vnd.rn-realmedia"
        };
      }
      if (this.checkString("DRACO")) {
        return {
          ext: "drc",
          mime: "application/vnd.google.draco"
          // Invented by us
        };
      }
      if (this.check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (this.checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (this.checkString("solid ")) {
        return {
          ext: "stl",
          mime: "model/stl"
        };
      }
      if (this.checkString("AC")) {
        const version3 = new StringType(4, "latin1").get(this.buffer, 2);
        if (version3.match("^d*") && version3 >= 1e3 && version3 <= 1050) {
          return {
            ext: "dwg",
            mime: "image/vnd.dwg"
          };
        }
      }
      if (this.checkString("070707")) {
        return {
          ext: "cpio",
          mime: "application/x-cpio"
        };
      }
      if (this.checkString("BLENDER")) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (this.checkString("!<arch>")) {
        await tokenizer.ignore(8);
        const string2 = await tokenizer.readToken(new StringType(13, "ascii"));
        if (string2 === "debian-binary") {
          return {
            ext: "deb",
            mime: "application/x-deb"
          };
        }
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (this.checkString("WEBVTT") && // One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
      ["\n", "\r", "	", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
        return {
          ext: "vtt",
          mime: "text/vtt"
        };
      }
      if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(INT32_BE),
            type: await tokenizer.readToken(new StringType(4, "latin1"))
          };
        }
        do {
          const chunk = await readChunkHeader();
          if (chunk.length < 0) {
            return;
          }
          switch (chunk.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
        return {
          ext: "arrow",
          mime: "application/vnd.apache.arrow.file"
        };
      }
      if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (this.checkString("gimp xcf ")) {
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      }
      if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
        const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
          case "avis":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (this.check([82, 73, 70, 70])) {
        if (this.checkString("WEBP", { offset: 8 })) {
          return {
            ext: "webp",
            mime: "image/webp"
          };
        }
        if (this.check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (this.check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/wav"
          };
        }
        if (this.check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      }
      if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader2() {
          const guid = new Uint8Array(16);
          await tokenizer.readBuffer(guid);
          return {
            id: guid,
            size: Number(await tokenizer.readToken(UINT64_LE))
          };
        }
        await tokenizer.ignore(30);
        while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
          const header = await readHeader2();
          let payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const typeId = new Uint8Array(16);
            payload -= await tokenizer.readBuffer(typeId);
            if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            }
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      }
      if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      }
      if (this.check([255, 79, 255, 81])) {
        return {
          ext: "j2c",
          mime: "image/j2c"
        };
      }
      if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        await tokenizer.ignore(20);
        const type = await tokenizer.readToken(new StringType(4, "ascii"));
        switch (type) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      }
      if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      }
      if (this.check([254, 255])) {
        if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
          return {
            ext: "xml",
            mime: "application/xml"
          };
        }
        return void 0;
      }
      if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.check([97, 99, 115, 112], { offset: 36 })) {
        return {
          ext: "icc",
          mime: "application/vnd.iccprofile"
        };
      }
      if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
        return {
          ext: "ace",
          mime: "application/x-ace-compressed"
        };
      }
      if (this.checkString("BEGIN:")) {
        if (this.checkString("VCARD", { offset: 6 })) {
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        }
        if (this.checkString("VCALENDAR", { offset: 6 })) {
          return {
            ext: "ics",
            mime: "text/calendar"
          };
        }
      }
      if (this.checkString("FUJIFILMCCD-RAW")) {
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      }
      if (this.checkString("Extended Module:")) {
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      }
      if (this.checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
        const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
        if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
          try {
            const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
            const json = JSON.parse(header);
            if (json.files) {
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
            }
          } catch {
          }
        }
      }
      if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (this.checkString("SCRM", { offset: 44 })) {
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      }
      if (this.check([71]) && this.check([71], { offset: 188 })) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (this.check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      }
      if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      }
      if (this.checkString("Kaydara FBX Binary  \0")) {
        return {
          ext: "fbx",
          mime: "application/x.autodesk.fbx"
          // Invented by us
        };
      }
      if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (this.check([255, 254])) {
        if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
          return {
            ext: "xml",
            mime: "application/xml"
          };
        }
        if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
          return {
            ext: "skp",
            mime: "application/vnd.sketchup.skp"
          };
        }
        return void 0;
      }
      if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      }
    };
    // Detections with limited supporting data, resulting in a higher likelihood of false positives
    detectImprecise = async (tokenizer) => {
      this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (this.check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (this.check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (this.check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
        for (let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth) {
          const type = this.scanMpeg(depth);
          if (type) {
            return type;
          }
        }
      }
    };
    async readTiffTag(bigEndian) {
      const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
      this.tokenizer.ignore(10);
      switch (tagId) {
        case 50341:
          return {
            ext: "arw",
            mime: "image/x-sony-arw"
          };
        case 50706:
          return {
            ext: "dng",
            mime: "image/x-adobe-dng"
          };
        default:
      }
    }
    async readTiffIFD(bigEndian) {
      const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
      for (let n2 = 0; n2 < numberOfTags; ++n2) {
        const fileType = await this.readTiffTag(bigEndian);
        if (fileType) {
          return fileType;
        }
      }
    }
    async readTiffHeader(bigEndian) {
      const version3 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
      const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
      if (version3 === 42) {
        if (ifdOffset >= 6) {
          if (this.checkString("CR", { offset: 8 })) {
            return {
              ext: "cr2",
              mime: "image/x-canon-cr2"
            };
          }
          if (ifdOffset >= 8) {
            const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
            const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
            if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
              return {
                ext: "nef",
                mime: "image/x-nikon-nef"
              };
            }
          }
        }
        await this.tokenizer.ignore(ifdOffset);
        const fileType = await this.readTiffIFD(bigEndian);
        return fileType ?? {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (version3 === 43) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
    }
    /**
    	Scan check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE).
    
    	@param offset - Offset to scan for sync-preamble.
    	@returns {{ext: string, mime: string}}
    	*/
    scanMpeg(offset) {
      if (this.check([255, 224], { offset, mask: [255, 224] })) {
        if (this.check([16], { offset: offset + 1, mask: [22] })) {
          if (this.check([8], { offset: offset + 1, mask: [8] })) {
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        if (this.check([2], { offset: offset + 1, mask: [6] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (this.check([4], { offset: offset + 1, mask: [6] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (this.check([6], { offset: offset + 1, mask: [6] })) {
          return {
            ext: "mp1",
            mime: "audio/mpeg"
          };
        }
      }
    }
  };
  var supportedExtensions = new Set(extensions);
  var supportedMimeTypes = new Set(mimeTypes);

  // node_modules/@helia/verified-fetch/dist/src/utils/content-type-parser.js
  var defaultMimeType = "application/octet-stream";
  function checkForSvg(text) {
    return /^(<\?xml[^>]+>)?[^<^\w]+<svg/ig.test(text);
  }
  async function checkForJson(text) {
    try {
      JSON.parse(text);
      return true;
    } catch (err2) {
      return false;
    }
  }
  function getText(bytes) {
    const decoder = new TextDecoder("utf-8", { fatal: true });
    try {
      return decoder.decode(bytes);
    } catch (err2) {
      return null;
    }
  }
  async function checkForHtml(text) {
    return /^\s*<(?:!doctype\s+html|html|head|body)\b/i.test(text);
  }
  async function contentTypeParser(bytes, fileName) {
    const detectedType = (await fileTypeFromBuffer(bytes))?.mime;
    if (detectedType != null) {
      if (detectedType === "application/xml" && fileName?.toLowerCase().endsWith(".svg")) {
        return "image/svg+xml";
      }
      return detectedType;
    }
    if (fileName == null) {
      const text = getText(bytes);
      if (text != null) {
        if (checkForSvg(text)) {
          return "image/svg+xml";
        } else if (await checkForJson(text)) {
          return "application/json";
        } else if (await checkForHtml(text)) {
          return "text/html; charset=utf-8";
        } else {
          return "text/plain; charset=utf-8";
        }
      }
      return defaultMimeType;
    }
    switch (fileName.split(".").pop()) {
      case "css":
        return "text/css";
      case "html":
        return "text/html; charset=utf-8";
      case "js":
        return "application/javascript";
      case "json":
        return "application/json";
      case "txt":
        return "text/plain";
      case "woff2":
        return "font/woff2";
      // see bottom of https://github.com/SgtPooki/file-type#supported-file-types
      case "svg":
        return "image/svg+xml";
      case "csv":
        return "text/csv";
      case "doc":
        return "application/msword";
      case "xls":
        return "application/vnd.ms-excel";
      case "ppt":
        return "application/vnd.ms-powerpoint";
      case "msi":
        return "application/x-msdownload";
      default:
        return defaultMimeType;
    }
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/type-guards.js
  function isPromise6(p2) {
    return p2?.then != null;
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/get-content-type.js
  async function getContentType({ bytes, path, contentTypeParser: contentTypeParser2, log: log18, defaultContentType = "application/octet-stream", filename: filenameParam }) {
    let contentType;
    if (contentTypeParser2 != null) {
      try {
        let fileName;
        if (filenameParam == null) {
          fileName = path?.split("/").pop()?.trim();
          fileName = fileName === "" || fileName?.split(".").length === 1 ? void 0 : fileName;
        } else {
          fileName = filenameParam;
        }
        const parsed = contentTypeParser2(bytes, fileName);
        if (isPromise6(parsed)) {
          const result = await parsed;
          if (result != null) {
            contentType = result;
          }
        } else if (parsed != null) {
          contentType = parsed;
        }
        log18.trace("contentTypeParser returned %s", contentType);
      } catch (err2) {
        log18.error("error parsing content type", err2);
      }
    }
    if (contentType === defaultMimeType) {
      contentType = defaultContentType;
    }
    return contentType ?? defaultContentType;
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/get-stream-from-async-iterable.js
  async function getStreamFromAsyncIterable(iterator, path, logger2, options2) {
    const log18 = logger2.newScope("get-stream-from-async-iterable");
    const reader2 = iterator[Symbol.asyncIterator]();
    const { value: firstChunk, done } = await reader2.next();
    if (done === true) {
      log18.error('no content found for path "%s"', path);
      throw new NoContentError();
    }
    const stream = new ReadableStream({
      async start(controller) {
        options2?.onProgress?.(new CustomProgressEvent("verified-fetch:request:progress:chunk"));
        controller.enqueue(firstChunk);
      },
      async pull(controller) {
        const { value: value2, done: done2 } = await reader2.next();
        if (options2?.signal?.aborted) {
          controller.error(new AbortError(options2.signal.reason ?? "signal aborted by user"));
          controller.close();
          return;
        }
        if (done2 === true) {
          if (value2 != null) {
            options2?.onProgress?.(new CustomProgressEvent("verified-fetch:request:progress:chunk"));
            controller.enqueue(value2);
          }
          controller.close();
          return;
        }
        options2?.onProgress?.(new CustomProgressEvent("verified-fetch:request:progress:chunk"));
        controller.enqueue(value2);
      }
    });
    return {
      stream,
      firstChunk
    };
  }

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-dag-pb.js
  var DagPbPlugin = class extends BasePlugin {
    id = "dag-pb-plugin";
    codes = [code6];
    canHandle({ cid, accept, pathDetails, byteRangeContext }) {
      if (pathDetails == null) {
        return false;
      }
      if (byteRangeContext == null) {
        return false;
      }
      if (accept != null && accept.mimeType !== "application/octet-stream") {
        return false;
      }
      return cid.code === code6;
    }
    /**
     * @see https://specs.ipfs.tech/http-gateways/path-gateway/#use-in-directory-url-normalization
     */
    getRedirectUrl(context) {
      const { resource, path } = context;
      const redirectCheckNeeded = path === "" ? !resource.toString().endsWith("/") : !path.endsWith("/");
      if (redirectCheckNeeded) {
        try {
          const url = new URL(resource.toString());
          if (url.pathname.endsWith("/")) {
            return null;
          }
          url.pathname = `${url.pathname}/`;
          return url.toString();
        } catch (err2) {
          return `${resource.toString()}/`;
        }
      }
      return null;
    }
    async handle(context) {
      const { cid, options: options2, pathDetails, query } = context;
      const { contentTypeParser: contentTypeParser2, helia: helia2, getBlockstore } = this.pluginOptions;
      const log18 = this.log;
      let resource = context.resource;
      let path = context.path;
      let redirected = false;
      const byteRangeContext = context.byteRangeContext;
      const ipfsRoots = pathDetails.ipfsRoots;
      const terminalElement = pathDetails.terminalElement;
      let resolvedCID = terminalElement.cid;
      const fs = unixfs({ ...helia2, blockstore: getBlockstore(context.cid, context.resource, options2?.session ?? true, options2) });
      if (terminalElement?.type === "directory") {
        const dirCid = terminalElement.cid;
        const redirectUrl = this.getRedirectUrl(context);
        if (redirectUrl != null) {
          log18.trace("directory url normalization spec requires redirect...");
          if (options2?.redirect === "error") {
            log18('could not redirect to %s as redirect option was set to "error"', redirectUrl);
            throw new TypeError("Failed to fetch");
          } else if (options2?.redirect === "manual") {
            log18("returning 301 permanent redirect to %s", redirectUrl);
            return movedPermanentlyResponse(resource, redirectUrl);
          }
          log18("following redirect to %s", redirectUrl);
          resource = redirectUrl;
          redirected = true;
        }
        const rootFilePath = "index.html";
        try {
          log18.trace("found directory at %c/%s, looking for index.html", cid, path);
          const entry = await context.serverTiming.time("exporter-dir", "", exporter2(`/ipfs/${dirCid}/${rootFilePath}`, helia2.blockstore, {
            signal: options2?.signal,
            onProgress: options2?.onProgress
          }));
          log18.trace("found root file at %c/%s with cid %c", dirCid, rootFilePath, entry.cid);
          path = rootFilePath;
          resolvedCID = entry.cid;
        } catch (err2) {
          if (options2?.signal?.aborted) {
            throw new AbortError(options2?.signal?.reason);
          }
          this.log.error("error loading path %c/%s - %e", dirCid, rootFilePath, err2);
          context.isDirectory = true;
          context.directoryEntries = [];
          context.modified++;
          this.log.trace("attempting to get directory entries because index.html was not found");
          for await (const dirItem of fs.ls(dirCid, { signal: options2?.signal, onProgress: options2?.onProgress, extended: false })) {
            context.directoryEntries.push(dirItem);
          }
          return null;
        } finally {
          options2?.onProgress?.(new CustomProgressEvent("verified-fetch:request:end", { cid: dirCid, path: rootFilePath }));
        }
      }
      try {
        const stat2 = await fs.stat(resolvedCID, { extended: true, signal: AbortSignal.timeout(500) });
        byteRangeContext.setFileSize(stat2.size);
      } catch (err2) {
        log18.error("error getting exact file size for %c/%s - %e", cid, path, err2);
        byteRangeContext.setFileSize(pathDetails.terminalElement.size);
        log18.trace("using terminal element size of %d for %c/%s", pathDetails.terminalElement.size, cid, path);
      }
      try {
        const entry = await context.serverTiming.time("exporter-file", "", exporter2(resolvedCID, helia2.blockstore, {
          signal: options2?.signal,
          onProgress: options2?.onProgress
        }));
        let firstChunk;
        let contentType;
        if (byteRangeContext.isValidRangeRequest) {
          contentType = await this.handleRangeRequest(context, entry);
        } else {
          const asyncIter = entry.content({
            signal: options2?.signal,
            onProgress: options2?.onProgress
          });
          log18("got async iterator for %c/%s", cid, path);
          const streamAndFirstChunk = await context.serverTiming.time("stream-and-chunk", "", getStreamFromAsyncIterable(asyncIter, path, this.pluginOptions.logger, {
            onProgress: options2?.onProgress,
            signal: options2?.signal
          }));
          const stream = streamAndFirstChunk.stream;
          firstChunk = streamAndFirstChunk.firstChunk;
          contentType = await context.serverTiming.time("get-content-type", "", getContentType({ filename: query.filename, bytes: firstChunk, path, contentTypeParser: contentTypeParser2, log: log18 }));
          byteRangeContext.setBody(stream);
        }
        const response = okRangeResponse(resource, byteRangeContext.getBody(contentType), { byteRangeContext, log: log18 }, {
          redirected
        });
        response.headers.set("Content-Type", byteRangeContext.getContentType() ?? contentType);
        setIpfsRoots(response, ipfsRoots);
        return response;
      } catch (err2) {
        if (options2?.signal?.aborted) {
          throw new AbortError(options2?.signal?.reason);
        }
        log18.error("error streaming %c/%s - %e", cid, path, err2);
        if (byteRangeContext.isRangeRequest && err2.code === "ERR_INVALID_PARAMS") {
          return badRangeResponse(resource);
        }
        return badGatewayResponse(resource, "Unable to stream content");
      }
    }
    async handleRangeRequest(context, entry) {
      const { path, byteRangeContext, options: options2 } = context;
      const { contentTypeParser: contentTypeParser2 } = this.pluginOptions;
      const log18 = this.log;
      const asyncIter = entry.content({
        signal: options2?.signal,
        onProgress: options2?.onProgress,
        offset: 0,
        // 8kb in order to determine the content type
        length: 8192
      });
      const { firstChunk } = await getStreamFromAsyncIterable(asyncIter, path ?? "", this.pluginOptions.logger, {
        onProgress: options2?.onProgress,
        signal: options2?.signal
      });
      const contentType = await context.serverTiming.time("get-content-type", "", getContentType({ bytes: firstChunk, path, contentTypeParser: contentTypeParser2, log: log18 }));
      byteRangeContext?.setBody((range) => {
        if (options2?.signal?.aborted) {
          throw new AbortError(options2?.signal?.reason ?? "aborted while streaming");
        }
        return entry.content({
          signal: options2?.signal,
          onProgress: options2?.onProgress,
          offset: range.start ?? 0,
          length: byteRangeContext.getLength(range)
        });
      }, contentType);
      return contentType;
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/constants.js
  var CODEC_IDENTITY = 0;

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-dag-walk.js
  var DagWalkPlugin = class extends BasePlugin {
    id = "dag-walk-plugin";
    /**
     * Return false if the path has already been walked, otherwise return true if
     * the CID is encoded with a codec that supports pathing.
     */
    canHandle(context) {
      const { pathDetails, cid } = context;
      if (pathDetails != null) {
        return false;
      }
      return cid.code === code6 || cid.code === code4 || cid.multihash.code === CODEC_IDENTITY;
    }
    async handle(context) {
      const { cid, resource, options: options2 } = context;
      const { getBlockstore } = this.pluginOptions;
      const blockstore = getBlockstore(cid, resource, options2?.session ?? true, options2);
      const pathDetails = await context.serverTiming.time("path-walking", "", handlePathWalking({ ...context, blockstore, log: this.log }));
      if (pathDetails instanceof Response) {
        this.log.trace("path walking failed");
        if (pathDetails.status === 404) {
          return pathDetails;
        }
        return null;
      }
      context.modified++;
      context.pathDetails = pathDetails;
      return null;
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/utils/get-peer-id-from-string.js
  function getPeerIdFromString(peerIdString) {
    if (peerIdString.charAt(0) === "1" || peerIdString.charAt(0) === "Q") {
      return peerIdFromString(peerIdString);
    }
    return peerIdFromCID(CID.parse(peerIdString));
  }

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-ipns-record.js
  var IpnsRecordPlugin = class extends BasePlugin {
    id = "ipns-record-plugin";
    codes = [];
    canHandle({ resource, accept, query, path, byteRangeContext }) {
      if (byteRangeContext == null) {
        return false;
      }
      return accept?.mimeType === "application/vnd.ipfs.ipns-record" || query.format === "ipns-record";
    }
    async handle(context) {
      const { resource, path, query, options: options2 } = context;
      const { ipnsResolver: ipnsResolver2 } = this.pluginOptions;
      context.reqFormat = "ipns-record";
      if (path !== "" || !(resource.startsWith("ipns://") || resource.includes(".ipns.") || resource.includes("/ipns/"))) {
        this.log.error('invalid request for IPNS name "%s" and path "%s"', resource, path);
        return badRequestResponse(resource, new Error("Invalid IPNS name"));
      }
      let peerId;
      try {
        let peerIdString;
        if (resource.startsWith("ipns://")) {
          peerIdString = resource.replace("ipns://", "");
        } else if (resource.includes("/ipns/")) {
          peerIdString = resource.split("/ipns/")[1].split("/")[0].split("?")[0];
        } else {
          peerIdString = resource.split(".ipns.")[0].split("://")[1];
        }
        this.log.trace('trying to parse peer id from "%s"', peerIdString);
        peerId = getPeerIdFromString(peerIdString);
      } catch (err2) {
        this.log.error("could not parse peer id from IPNS url %s", resource, err2);
        return badRequestResponse(resource, err2);
      }
      query.filename = query.filename ?? `${peerId}.bin`;
      query.download = true;
      const result = await ipnsResolver2.resolve(peerId, options2);
      const buf2 = marshalIPNSRecord(result.record);
      context.byteRangeContext.setBody(buf2);
      const response = okRangeResponse(resource, context.byteRangeContext.getBody("application/vnd.ipfs.ipns-record"), { byteRangeContext: context.byteRangeContext, log: this.log });
      response.headers.set("content-type", context.byteRangeContext.getContentType() ?? "application/vnd.ipfs.ipns-record");
      response.headers.set("content-length", buf2.byteLength.toString());
      response.headers.set("x-ipfs-roots", result.cid.toV1().toString());
      return response;
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-json.js
  var JsonPlugin = class extends BasePlugin {
    id = "json-plugin";
    codes = [code5, code2];
    canHandle({ cid, accept, byteRangeContext }) {
      if (byteRangeContext == null) {
        return false;
      }
      if (accept?.mimeType === "application/vnd.ipld.dag-json" && cid.code !== code4) {
        return true;
      }
      return code5 === cid.code || code2 === cid.code;
    }
    async handle(context) {
      const { path, resource, cid, accept, options: options2 } = context;
      const { getBlockstore } = this.pluginOptions;
      const session = options2?.session ?? true;
      this.log.trace("fetching %c/%s", cid, path);
      const terminalCid = context.pathDetails?.terminalElement.cid ?? context.cid;
      const blockstore = getBlockstore(terminalCid, resource, session, options2);
      const block = await src_default7(blockstore.get(terminalCid, options2));
      let body;
      if (accept?.mimeType === "application/vnd.ipld.dag-cbor" || accept?.mimeType === "application/cbor") {
        try {
          const obj = decode13(block);
          body = encode10(obj);
        } catch (err2) {
          this.log.error("could not transform %c to application/vnd.ipld.dag-cbor", err2);
          return notAcceptableResponse(resource);
        }
      } else {
        body = block;
      }
      let contentType;
      if (accept == null) {
        if (code5 === cid.code) {
          contentType = "application/vnd.ipld.dag-json";
        } else {
          contentType = "application/json";
        }
      } else {
        contentType = accept?.mimeType.split(";")[0];
      }
      context.byteRangeContext.setBody(body);
      const response = okRangeResponse(resource, context.byteRangeContext.getBody(contentType), { byteRangeContext: context.byteRangeContext, log: this.log });
      response.headers.set("content-type", context.byteRangeContext.getContentType() ?? contentType);
      if (!context.byteRangeContext.isValidRangeRequest) {
        response.headers.set("content-length", body.length.toString());
      }
      return response;
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-raw.js
  var RAW_HEADERS = [
    "application/vnd.ipld.dag-json",
    "application/vnd.ipld.raw",
    "application/octet-stream"
  ];
  function getOverriddenRawContentType({ headers, accept }) {
    const acceptHeader = accept?.mimeType ?? new Headers(headers).get("accept") ?? "";
    const acceptHeaders = acceptHeader.split(",").map((s2) => s2.split(";")[0]).map((s2) => s2.trim());
    for (const mimeType of acceptHeaders) {
      if (mimeType === "*/*") {
        return;
      }
      if (RAW_HEADERS.includes(mimeType ?? "")) {
        return mimeType;
      }
    }
  }
  var RawPlugin = class extends BasePlugin {
    id = "raw-plugin";
    codes = [code3, identity.code];
    canHandle({ cid, accept, query, byteRangeContext }) {
      if (byteRangeContext == null) {
        return false;
      }
      return accept?.mimeType === "application/vnd.ipld.raw" || query.format === "raw";
    }
    async handle(context) {
      const { path, resource, cid, accept, query, options: options2 } = context;
      const { getBlockstore, contentTypeParser: contentTypeParser2 } = this.pluginOptions;
      const session = options2?.session ?? true;
      const log18 = this.log;
      if (accept?.mimeType === "application/vnd.ipld.raw" || query.format === "raw") {
        context.reqFormat = "raw";
        context.query.download = true;
        context.query.filename = context.query.filename ?? `${cid.toString()}.bin`;
        log18.trace("set content disposition to force download");
      } else {
        log18.trace("did not set content disposition, raw block will display inline");
      }
      if (path !== "" && cid.code === code3) {
        log18.trace("404-ing raw codec request for %c/%s", cid, path);
        return notFoundResponse(resource);
      }
      const terminalCid = context.pathDetails?.terminalElement.cid ?? context.cid;
      const blockstore = getBlockstore(terminalCid, resource, session, options2);
      const result = await src_default7(blockstore.get(terminalCid, options2));
      context.byteRangeContext.setBody(result);
      const contentType = await getContentType({
        filename: query.filename,
        bytes: result,
        path,
        defaultContentType: getOverriddenRawContentType({ headers: options2?.headers, accept }),
        contentTypeParser: contentTypeParser2,
        log: log18
      });
      const response = okRangeResponse(resource, context.byteRangeContext.getBody(contentType), { byteRangeContext: context.byteRangeContext, log: log18 }, {
        redirected: false
      });
      response.headers.set("content-type", context.byteRangeContext.getContentType() ?? contentType);
      response.headers.set("x-ipfs-roots", terminalCid.toV1().toString());
      if (!context.byteRangeContext.isRangeRequest) {
        response.headers.set("content-length", result.byteLength.toString());
      }
      return response;
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/utils/get-e-tag.js
  var getPrefix = ({ weak, reqFormat }) => {
    if (reqFormat === "tar" || reqFormat === "car" || reqFormat === "ipns-record" || weak === true) {
      return "W/";
    }
    return "";
  };
  var getFormatSuffix = ({ reqFormat }) => {
    if (reqFormat == null) {
      return "";
    }
    if (reqFormat === "tar") {
      return ".x-tar";
    }
    return `.${reqFormat}`;
  };
  function getETag({ cid, reqFormat, weak, rangeStart, rangeEnd, contentPrefix }) {
    const prefix = getPrefix({ weak, reqFormat });
    let suffix = getFormatSuffix({ reqFormat });
    if (rangeStart != null || rangeEnd != null) {
      suffix += `.${rangeStart ?? "0"}-${rangeEnd ?? "N"}`;
    }
    return `${prefix}"${contentPrefix ?? ""}${cid.toString()}${suffix}"`;
  }

  // node_modules/it-tar/dist/src/extract-headers.js
  var ZERO_OFFSET = "0".charCodeAt(0);
  var USTAR_MAGIC = fromString2("ustar\0", "binary");
  var GNU_MAGIC = fromString2("ustar ", "binary");
  var GNU_VER = fromString2(" \0", "binary");

  // node_modules/it-tar/dist/src/pack.js
  var import_iso_constants = __toESM(require_index_browser(), 1);

  // node_modules/it-tar/dist/src/pack-headers.js
  var ZEROS = "0000000000000000000";
  var SEVENS = "7777777777777777777";
  var ZERO_OFFSET2 = "0".charCodeAt(0);
  var USTAR_MAGIC2 = fromString2("ustar\0", "binary");
  var USTAR_VER = fromString2("00", "binary");
  var MASK = parseInt("7777", 8);
  var MAGIC_OFFSET = 257;
  var VERSION_OFFSET = 263;
  var toTypeflag = function(flag) {
    switch (flag) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
      default:
        return 0;
    }
  };
  var cksum = function(block) {
    let sum = 8 * 32;
    for (let i2 = 0; i2 < 148; i2++)
      sum += block[i2];
    for (let j = 156; j < 512; j++)
      sum += block[j];
    return sum;
  };
  var encodeOct = function(val, n2) {
    const str = val.toString(8);
    if (str.length > n2) {
      return fromString2(SEVENS.slice(0, n2) + " ");
    }
    return fromString2(ZEROS.slice(0, n2 - str.length) + str + " ");
  };
  var addLength = function(str) {
    const len = fromString2(str).byteLength;
    let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits)) {
      digits++;
    }
    return `${len + digits}${str}`;
  };
  function encodePax(opts) {
    let result = "";
    if (opts.name != null) {
      result += addLength(" path=" + opts.name + "\n");
    }
    if (opts.linkname != null) {
      result += addLength(" linkpath=" + opts.linkname + "\n");
    }
    const pax = opts.pax;
    if (pax != null) {
      for (const key in pax) {
        if (Object.prototype.hasOwnProperty.call(pax, key)) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
    }
    return fromString2(result);
  }
  function encode15(opts) {
    const buf2 = new Uint8Array(512);
    let name9 = opts.name;
    let prefix = "";
    if (opts.typeflag === 5 && name9[name9.length - 1] !== "/") {
      name9 += "/";
    }
    if (fromString2(name9).byteLength !== name9.length) {
      return null;
    }
    while (fromString2(name9).byteLength > 100) {
      const i2 = name9.indexOf("/");
      if (i2 === -1) {
        return null;
      }
      prefix += prefix !== "" ? "/" + name9.slice(0, i2) : name9.slice(0, i2);
      name9 = name9.slice(i2 + 1);
    }
    if (fromString2(name9).byteLength > 100 || fromString2(prefix).byteLength > 155) {
      return null;
    }
    if (opts.linkname != null && fromString2(opts.linkname).byteLength > 100) {
      return null;
    }
    buf2.set(fromString2(name9), 0);
    buf2.set(encodeOct(opts.mode & MASK, 6), 100);
    buf2.set(encodeOct(opts.uid, 6), 108);
    buf2.set(encodeOct(opts.gid, 6), 116);
    buf2.set(encodeOct(opts.size, 11), 124);
    buf2.set(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
    buf2[156] = ZERO_OFFSET2 + toTypeflag(opts.type);
    if (opts.linkname != null) {
      buf2.set(fromString2(opts.linkname), 157);
    }
    buf2.set(USTAR_MAGIC2, MAGIC_OFFSET);
    buf2.set(USTAR_VER, VERSION_OFFSET);
    if (opts.uname != null) {
      buf2.set(fromString2(opts.uname), 265);
    }
    if (opts.gname != null) {
      buf2.set(fromString2(opts.gname), 297);
    }
    buf2.set(encodeOct(opts.devmajor ?? 0, 6), 329);
    buf2.set(encodeOct(opts.devminor ?? 0, 6), 337);
    if (prefix != null) {
      buf2.set(fromString2(prefix), 345);
    }
    buf2.set(encodeOct(cksum(buf2), 6), 148);
    return buf2;
  }

  // node_modules/it-tar/dist/src/pack.js
  var { S_IFMT, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK } = import_iso_constants.default;
  var DMODE = parseInt("755", 8);
  var FMODE = parseInt("644", 8);
  var END_OF_TAR = new Uint8Array(1024);
  function modeToType(mode = 0) {
    switch (mode & S_IFMT) {
      case S_IFBLK:
        return "block-device";
      case S_IFCHR:
        return "character-device";
      case S_IFDIR:
        return "directory";
      case S_IFIFO:
        return "fifo";
      case S_IFLNK:
        return "symlink";
      default:
        return "file";
    }
  }
  function getPadding(size) {
    size &= 511;
    if (size !== 0) {
      return END_OF_TAR.subarray(0, 512 - size);
    }
    return new Uint8Array(0);
  }
  function encode16(header) {
    if (header.pax == null) {
      const encoded = encode15(header);
      if (encoded != null) {
        return encoded;
      }
    }
    return encodePax2(header);
  }
  function encodePax2(header) {
    const paxHeader = encodePax(header);
    const newHeader = {
      name: "PaxHeader",
      mode: header.mode,
      uid: header.uid,
      gid: header.gid,
      size: paxHeader.length,
      mtime: header.mtime,
      type: "pax-header",
      linkname: header.linkname,
      uname: header.uname,
      gname: header.gname,
      devmajor: header.devmajor,
      devminor: header.devminor
    };
    return new Uint8ArrayList(encode15(newHeader) ?? new Uint8Array(0), paxHeader, getPadding(paxHeader.length), encode15({ ...newHeader, size: header.size, type: header.type }) ?? new Uint8Array(0)).subarray();
  }
  function pack() {
    return async function* (source) {
      for await (let { header: partialHeader, body } of source) {
        const header = {
          ...partialHeader,
          size: partialHeader.type === "symlink" ? 0 : partialHeader.size ?? 0,
          type: partialHeader.type ?? modeToType(partialHeader.mode),
          mode: partialHeader.mode ?? (partialHeader.type === "directory" ? DMODE : FMODE),
          uid: partialHeader.uid ?? 0,
          gid: partialHeader.gid ?? 0,
          mtime: partialHeader.mtime ?? /* @__PURE__ */ new Date()
        };
        if (typeof body === "string") {
          body = fromString2(body);
        }
        if (body instanceof Uint8Array || isUint8ArrayList(body)) {
          header.size = body.length;
          yield encode16(header);
          yield isUint8ArrayList(body) ? body.subarray() : body;
          yield getPadding(header.size);
          continue;
        }
        if (header.type === "symlink" && header.linkname == null) {
          if (body == null) {
            throw new Error("type was symlink but no linkname or body specified");
          }
          header.linkname = toString2(await src_default7(body));
          yield encode16(header);
          continue;
        }
        yield encode16(header);
        if (header.type !== "file" && header.type !== "contiguous-file") {
          continue;
        }
        let written = 0;
        for await (const chunk of body ?? []) {
          written += chunk.length;
          yield isUint8ArrayList(chunk) ? chunk.subarray() : chunk;
        }
        if (written !== header.size) {
          throw new Error(`size mismatch, wrote ${written} of ${header.size} bytes`);
        }
        yield getPadding(header.size);
      }
      yield END_OF_TAR;
    };
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/get-tar-stream.js
  var EXPORTABLE = ["file", "raw", "directory"];
  function toHeader(file) {
    let mode;
    let mtime;
    if (file.type === "file" || file.type === "directory") {
      mode = file.unixfs.mode;
      mtime = file.unixfs.mtime != null ? new Date(Number(file.unixfs.mtime.secs * 1000n)) : void 0;
    }
    return {
      name: file.path,
      mode,
      mtime,
      size: Number(file.size),
      type: file.type === "directory" ? "directory" : "file"
    };
  }
  function toTarImportCandidate(entry) {
    if (!EXPORTABLE.includes(entry.type)) {
      throw new NotUnixFSError3(`${entry.type} is not a UnixFS node`);
    }
    const candidate = {
      header: toHeader(entry)
    };
    if (entry.type === "file" || entry.type === "raw") {
      candidate.body = entry.content();
    }
    return candidate;
  }
  async function* tarStream(ipfsPath, blockstore, options2) {
    const file = await exporter2(ipfsPath, blockstore, options2);
    if (file.type === "file" || file.type === "raw") {
      yield* pipe([toTarImportCandidate(file)], pack());
      return;
    }
    if (file.type === "directory") {
      yield* pipe(recursive(ipfsPath, blockstore, options2), (source) => src_default5(source, (entry) => toTarImportCandidate(entry)), pack());
      return;
    }
    throw new NotUnixFSError3("Not a UnixFS node");
  }

  // node_modules/@helia/verified-fetch/dist/src/plugins/plugin-handle-tar.js
  var TarPlugin = class extends BasePlugin {
    id = "tar-plugin";
    codes = [];
    canHandle({ cid, accept, query, byteRangeContext }) {
      if (byteRangeContext == null) {
        return false;
      }
      return accept?.mimeType === "application/x-tar" || query.format === "tar";
    }
    async handle(context) {
      const { cid, path, resource, options: options2, pathDetails } = context;
      const { getBlockstore } = this.pluginOptions;
      const terminusElement = pathDetails?.terminalElement.cid ?? cid;
      if (terminusElement.code !== code6 && terminusElement.code !== code3) {
        return notAcceptableResponse("only UnixFS data can be returned in a TAR file");
      }
      context.reqFormat = "tar";
      context.query.download = true;
      context.query.filename = context.query.filename ?? `${terminusElement.toString()}.tar`;
      const blockstore = getBlockstore(terminusElement, resource, options2?.session, options2);
      const stream = itToBrowserReadableStream(tarStream(`/ipfs/${cid}/${path}`, blockstore, options2));
      context.byteRangeContext.setBody(stream);
      const response = okRangeResponse(resource, context.byteRangeContext.getBody("application/x-tar"), { byteRangeContext: context.byteRangeContext, log: this.log });
      response.headers.set("content-type", context.byteRangeContext.getContentType() ?? "application/x-tar");
      response.headers.set("etag", getETag({ cid: terminusElement, reqFormat: context.reqFormat, weak: true }));
      return response;
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/utils/parse-url-string.js
  var URL_REGEX = /^(?<protocol>ip[fn]s):\/\/(?<cidOrPeerIdOrDnsLink>[^/?]+)\/?(?<path>[^?]*)\??(?<query>.*)$/;
  var PATH_REGEX = /^\/(?<protocol>ip[fn]s)\/(?<cidOrPeerIdOrDnsLink>[^/?]+)\/?(?<path>[^?]*)\??(?<query>.*)$/;
  var PATH_GATEWAY_REGEX = /^https?:\/\/(.*[^/])\/(?<protocol>ip[fn]s)\/(?<cidOrPeerIdOrDnsLink>[^/?]+)\/?(?<path>[^?]*)\??(?<query>.*)$/;
  var SUBDOMAIN_GATEWAY_REGEX = /^https?:\/\/(?<cidOrPeerIdOrDnsLink>[^/?]+)\.(?<protocol>ip[fn]s)\.([^/?]+)\/?(?<path>[^?]*)\??(?<query>.*)$/;
  function matchUrlGroupsGuard(groups) {
    const protocol = groups?.protocol;
    if (protocol == null) {
      return false;
    }
    const cidOrPeerIdOrDnsLink = groups?.cidOrPeerIdOrDnsLink;
    if (cidOrPeerIdOrDnsLink == null) {
      return false;
    }
    const path = groups?.path;
    const query = groups?.query;
    return ["ipns", "ipfs"].includes(protocol) && typeof cidOrPeerIdOrDnsLink === "string" && (path == null || typeof path === "string") && (query == null || typeof query === "string");
  }
  function matchURLString(urlString) {
    for (const pattern of [SUBDOMAIN_GATEWAY_REGEX, URL_REGEX, PATH_GATEWAY_REGEX, PATH_REGEX]) {
      const match = urlString.match(pattern);
      if (matchUrlGroupsGuard(match?.groups)) {
        const groups = match.groups;
        if (groups.path != null) {
          groups.path = decodeURIComponent(groups.path);
        }
        if (pattern === SUBDOMAIN_GATEWAY_REGEX && groups.protocol === "ipns" && isInlinedDnsLink(groups.cidOrPeerIdOrDnsLink)) {
          groups.cidOrPeerIdOrDnsLink = dnsLinkLabelDecoder(groups.cidOrPeerIdOrDnsLink);
        }
        return groups;
      }
    }
    throw new TypeError(`Invalid URL: ${urlString}, please use ipfs://, ipns://, or gateway URLs only`);
  }
  var dnsLabelRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/;
  function isInlinedDnsLink(label) {
    return dnsLabelRegex.test(label) && label.includes("-") && !label.includes(".");
  }
  function dnsLinkLabelDecoder(linkLabel) {
    return linkLabel.replace(/--/g, "%").replace(/-/g, ".").replace(/%/g, "-");
  }

  // node_modules/@helia/verified-fetch/dist/src/url-resolver.js
  var CODEC_LIBP2P_KEY = 114;
  function toQuery(query) {
    if (query == null) {
      return {};
    }
    const params = new URLSearchParams(query);
    const output = {};
    for (const [key, value2] of params.entries()) {
      output[key] = value2;
      if (value2 === "true") {
        output[key] = true;
      }
      if (value2 === "false") {
        output[key] = false;
      }
    }
    return output;
  }
  var URLResolver = class {
    components;
    constructor(components) {
      this.components = components;
    }
    async resolve(resource, options2 = {}) {
      if (typeof resource === "string") {
        return this.parseUrlString(resource, options2);
      }
      const cid = CID.asCID(resource);
      if (cid != null) {
        return this.resolveCIDResource(cid, "", {}, options2);
      }
      throw new TypeError(`Invalid resource. Cannot determine CID from resource: ${resource}`);
    }
    async parseUrlString(urlString, options2 = {}) {
      const { protocol, cidOrPeerIdOrDnsLink, path, query } = matchURLString(urlString);
      if (protocol === "ipfs") {
        const cid = CID.parse(cidOrPeerIdOrDnsLink);
        return this.resolveCIDResource(cid, path ?? "", toQuery(query), options2);
      }
      if (protocol === "ipns") {
        let peerId;
        try {
          peerId = peerIdFromString(cidOrPeerIdOrDnsLink);
        } catch {
          return this.resolveDNSLink(cidOrPeerIdOrDnsLink, path ?? "", toQuery(query), options2);
        }
        return this.resolveIPNSName(cidOrPeerIdOrDnsLink, peerId, path ?? "", toQuery(query), options2);
      }
      throw new TypeError(`Invalid resource. Cannot determine CID from resource: ${urlString}`);
    }
    async resolveCIDResource(cid, path, query, options2 = {}) {
      if (cid.code === CODEC_LIBP2P_KEY) {
        return this.resolveIPNSName(cid.toString(), peerIdFromCID(cid), path, query, options2);
      }
      return {
        cid,
        protocol: "ipfs",
        query,
        path,
        ttl: 29030400,
        // 1 year for ipfs content
        ipfsPath: `/ipfs/${cid}${path === "" ? "" : `/${path}`}`
      };
    }
    async resolveDNSLink(domain, path, query, options2) {
      const results = await this.components.timing.time("dnsLink.resolve", `Resolve DNSLink ${domain}`, this.components.dnsLink.resolve(domain, options2));
      const result = results?.[0];
      if (result == null) {
        throw new TypeError(`Invalid resource. Cannot resolve DNSLink from domain: ${domain}`);
      }
      if (result.namespace === "ipns") {
        return this.resolveIPNSName(domain, result.peerId, path, query, options2);
      }
      if (result.namespace !== "ipfs") {
        throw new TypeError(`Invalid resource. Unexpected DNSLink namespace ${result.namespace} from domain: ${domain}`);
      }
      return {
        cid: result.cid,
        path: concatPaths(result.path, path),
        // dnslink is mutable so return 'ipns' protocol so we do not include immutable in cache-control header
        protocol: "ipns",
        ttl: result.answer.TTL,
        query,
        ipfsPath: `/ipns/${domain}${path === "" ? "" : `/${path}`}`
      };
    }
    async resolveIPNSName(resource, key, path, query, options2) {
      const result = await this.components.timing.time("ipns.resolve", `Resolve IPNS name ${key}`, this.components.ipnsResolver.resolve(key, options2));
      return {
        cid: result.cid,
        path: concatPaths(result.path, path),
        query,
        protocol: "ipns",
        // IPNS ttl is in nanoseconds, convert to seconds
        ttl: Number((result.record.ttl ?? 0n) / BigInt(1e9)),
        ipfsPath: `/ipns/${resource}${path === "" ? "" : `/${path}`}`
      };
    }
  };
  function concatPaths(...paths) {
    return `${paths.filter((p2) => p2 != null && p2 !== "").join("/").replaceAll(/(\/+)/g, "/").replace(/^(\/)+/, "").replace(/(\/)+$/, "/")}`;
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/error-to-object.js
  function isAggregateError2(err2) {
    return err2 instanceof AggregateError || err2?.name === "AggregateError" && Array.isArray(err2?.errors);
  }
  function errorToObject(err2) {
    let errors;
    if (isAggregateError2(err2)) {
      errors = err2.errors.map((err3) => errorToObject(err3));
    }
    return {
      name: err2.name,
      message: err2.message,
      stack: err2.stack,
      errors
    };
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/get-content-disposition-filename.js
  function getContentDispositionFilename(filename) {
    const asciiOnly = replaceNonAsciiCharacters(filename);
    if (asciiOnly === filename) {
      return `filename="${filename}"`;
    }
    return `filename="${asciiOnly}"; filename*=UTF-8''${encodeURIComponent(filename)}`;
  }
  function replaceNonAsciiCharacters(filename) {
    return filename.replace(/[^\x00-\x7F]/g, "_");
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/select-output-type.js
  var CID_TYPE_MAP = {
    [code4]: [
      "application/json",
      "application/vnd.ipld.dag-cbor",
      "application/cbor",
      "application/vnd.ipld.dag-json",
      "application/octet-stream",
      "application/vnd.ipld.raw",
      "application/vnd.ipfs.ipns-record",
      "application/vnd.ipld.car",
      "text/html"
    ],
    [code5]: [
      "application/json",
      "application/vnd.ipld.dag-cbor",
      "application/cbor",
      "application/vnd.ipld.dag-json",
      "application/octet-stream",
      "application/vnd.ipld.raw",
      "application/vnd.ipfs.ipns-record",
      "application/vnd.ipld.car"
    ],
    [code2]: [
      "application/json",
      "application/vnd.ipld.dag-cbor",
      "application/cbor",
      "application/vnd.ipld.dag-json",
      "application/octet-stream",
      "application/vnd.ipld.raw",
      "application/vnd.ipfs.ipns-record",
      "application/vnd.ipld.car"
    ],
    [code6]: [
      "application/octet-stream",
      "application/json",
      "application/vnd.ipld.dag-cbor",
      "application/cbor",
      "application/vnd.ipld.dag-json",
      "application/vnd.ipld.raw",
      "application/vnd.ipfs.ipns-record",
      "application/vnd.ipld.car",
      "application/x-tar"
    ],
    [code3]: [
      "application/octet-stream",
      "application/vnd.ipld.raw",
      "application/vnd.ipfs.ipns-record",
      "application/vnd.ipld.dag-json",
      "application/vnd.ipld.car",
      "application/x-tar"
    ]
  };
  function selectOutputType(cid, accept) {
    const cidMimeTypes = CID_TYPE_MAP[cid.code];
    if (accept != null) {
      return chooseMimeType(accept, cidMimeTypes);
    }
  }
  function chooseMimeType(accept, validMimeTypes) {
    const requestedMimeTypes = accept.split(",").map((s2) => {
      const parts = s2.trim().split(";");
      const options2 = {
        q: "0"
      };
      for (let i2 = 1; i2 < parts.length; i2++) {
        const [key, value2] = parts[i2].split("=").map((s3) => s3.trim());
        options2[key] = value2;
      }
      return {
        mimeType: `${parts[0]}`.trim(),
        options: options2
      };
    }).sort((a2, b) => {
      if (a2.options.q === b.options.q) {
        return 0;
      }
      if (a2.options.q > b.options.q) {
        return -1;
      }
      return 1;
    });
    for (const headerFormat of requestedMimeTypes) {
      for (const mimeType of validMimeTypes) {
        if (headerFormat.mimeType.includes(mimeType)) {
          return headerFormat;
        }
        if (headerFormat.mimeType === "*/*") {
          return {
            mimeType,
            options: headerFormat.options
          };
        }
        if (headerFormat.mimeType.startsWith("*/") && mimeType.split("/")[1] === headerFormat.mimeType.split("/")[1]) {
          return {
            mimeType,
            options: headerFormat.options
          };
        }
        if (headerFormat.mimeType.endsWith("/*") && mimeType.split("/")[0] === headerFormat.mimeType.split("/")[0]) {
          return {
            mimeType,
            options: headerFormat.options
          };
        }
      }
    }
  }
  var FORMAT_TO_MIME_TYPE = {
    raw: "application/vnd.ipld.raw",
    car: "application/vnd.ipld.car",
    "dag-json": "application/vnd.ipld.dag-json",
    "dag-cbor": "application/vnd.ipld.dag-cbor",
    json: "application/json",
    cbor: "application/cbor",
    "ipns-record": "application/vnd.ipfs.ipns-record",
    tar: "application/x-tar"
  };
  function queryFormatToAcceptHeader(format3) {
    if (format3 != null) {
      return FORMAT_TO_MIME_TYPE[format3];
    }
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/is-accept-explicit.js
  function isExplicitAcceptHeader(headers) {
    const incomingAcceptHeader = headers.get("accept");
    if (incomingAcceptHeader == null) {
      return false;
    }
    return Object.values(FORMAT_TO_MIME_TYPE).some((mimeType) => incomingAcceptHeader.includes(mimeType));
  }
  function isExplicitFormatQuery(query) {
    const formatQuery = query?.format;
    if (formatQuery != null && Object.keys(FORMAT_TO_MIME_TYPE).includes(formatQuery)) {
      return true;
    }
    return false;
  }
  function isExplicitIpldAcceptRequest({ query, headers }) {
    return isExplicitAcceptHeader(headers) || isExplicitFormatQuery(query);
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/get-resolved-accept-header.js
  function getResolvedAcceptHeader({ query, headers, logger: logger2 }) {
    const log18 = logger2.forComponent("helia:verified-fetch:get-resolved-accept-header");
    const requestHeaders = new Headers(headers);
    const incomingAcceptHeader = requestHeaders.get("accept") ?? void 0;
    if (incomingAcceptHeader != null) {
      log18('incoming accept header "%s"', incomingAcceptHeader);
    }
    if (!isExplicitIpldAcceptRequest({ query, headers: requestHeaders })) {
      log18("no explicit IPLD content-type requested, returning incoming accept header %s", incomingAcceptHeader);
      return incomingAcceptHeader;
    }
    const queryFormatMapping = queryFormatToAcceptHeader(query?.format);
    if (query?.format != null) {
      log18('incoming query format "%s", mapped to %s', query.format, queryFormatMapping);
    }
    let acceptHeader = incomingAcceptHeader;
    if (!isExplicitAcceptHeader(requestHeaders) && isExplicitFormatQuery(query)) {
      log18("accept header not recognized, but query format provided, setting accept header to %s", queryFormatMapping);
      acceptHeader = queryFormatMapping;
    }
    log18('resolved accept header to "%s"', acceptHeader);
    return acceptHeader;
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/handle-redirects.js
  function maybeAddTrailingSlash(path) {
    if (path.match(/\.[a-zA-Z0-9]{1,4}$/) != null) {
      return path;
    }
    return path.endsWith("/") ? path : `${path}/`;
  }
  async function getRedirectResponse({ resource, options: options2, logger: logger2, cid, fetch: fetch3 = globalThis.fetch }) {
    const log18 = logger2.forComponent("helia:verified-fetch:get-redirect-response");
    if (typeof resource !== "string" || options2 == null || ["ipfs://", "ipns://"].some((prefix) => resource.startsWith(prefix))) {
      return null;
    }
    const headers = new Headers(options2?.headers);
    const forwardedHost = headers.get("x-forwarded-host");
    const headerHost = headers.get("host");
    const forwardedFor = headers.get("x-forwarded-for");
    if (forwardedFor == null && forwardedHost == null && headerHost == null) {
      log18.trace("no redirect info found in headers");
      return null;
    }
    log18.trace("checking for redirect info");
    try {
      const urlParts = matchURLString(resource);
      const reqUrl = new URL(resource);
      const actualHost = forwardedHost ?? reqUrl.host;
      const subdomainUrl = new URL(reqUrl);
      if (urlParts.protocol === "ipfs" && cid.version === 0) {
        subdomainUrl.host = `${cid.toV1()}.ipfs.${actualHost}`;
      } else {
        subdomainUrl.host = `${urlParts.cidOrPeerIdOrDnsLink}.${urlParts.protocol}.${actualHost}`;
      }
      if (headerHost?.includes(urlParts.protocol) === true && subdomainUrl.host.includes(headerHost)) {
        log18.trace("request was for a subdomain already, not setting location header");
        return null;
      }
      if (headerHost != null && !subdomainUrl.host.includes(headerHost)) {
        log18.trace("host header is not the same as the subdomain url host, not setting location header");
        return null;
      }
      if (reqUrl.host === subdomainUrl.host) {
        log18.trace("req url is the same as the subdomain url, not setting location header");
        return null;
      }
      subdomainUrl.pathname = maybeAddTrailingSlash(reqUrl.pathname.replace(`/${urlParts.cidOrPeerIdOrDnsLink}`, "").replace(`/${urlParts.protocol}`, ""));
      log18.trace("subdomain url %s", subdomainUrl.href);
      const pathUrl = new URL(reqUrl, `${reqUrl.protocol}//${actualHost}`);
      pathUrl.pathname = maybeAddTrailingSlash(reqUrl.pathname);
      log18.trace("path url %s", pathUrl.href);
      try {
        const subdomainTest = await fetch3(subdomainUrl, { method: "HEAD" });
        if (subdomainTest.ok) {
          log18("subdomain supported, redirecting to subdomain");
          return movedPermanentlyResponse(resource.toString(), subdomainUrl.href);
        } else {
          log18("subdomain not supported, subdomain failed with status %s %s", subdomainTest.status, subdomainTest.statusText);
          throw new SubdomainNotSupportedError("subdomain not supported");
        }
      } catch (err2) {
        log18("subdomain not supported - %e", err2);
        if (pathUrl.href === reqUrl.href) {
          log18("path url is the same as the request url, not setting location header");
          return null;
        }
        return movedPermanentlyResponse(resource.toString(), pathUrl.href);
      }
    } catch (e2) {
      log18.error("error setting location header for x-forwarded-host", e2);
    }
    return null;
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/ipfs-path-to-string.js
  function uriEncodeIPFSPath(str) {
    return str.split("/").map((p2) => encodeURIComponent(p2)).join("/");
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/resource-to-cache-key.js
  function resourceToSessionCacheKey(url) {
    const cid = CID.asCID(url);
    if (cid != null) {
      return `ipfs://${cid}`;
    }
    try {
      return `ipfs://${CID.parse(url.toString())}`;
    } catch {
    }
    const { protocol, cidOrPeerIdOrDnsLink } = matchURLString(url.toString());
    return `${protocol}://${cidOrPeerIdOrDnsLink}`;
  }

  // node_modules/@helia/verified-fetch/dist/src/utils/server-timing.js
  var ServerTiming = class {
    headers;
    constructor() {
      this.headers = [];
    }
    getHeader() {
      return this.headers.join(",");
    }
    async time(name9, description, promise) {
      const startTime = performance.now();
      try {
        return await promise;
      } finally {
        const endTime = performance.now();
        const duration = (endTime - startTime).toFixed(1);
        this.headers.push(`${name9};dur=${duration};desc="${description}"`);
      }
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/verified-fetch.js
  var SESSION_CACHE_MAX_SIZE = 100;
  var SESSION_CACHE_TTL_MS = 60 * 1e3;
  function convertOptions(options2) {
    if (options2 == null) {
      return void 0;
    }
    let signal;
    if (options2?.signal === null) {
      signal = void 0;
    } else {
      signal = options2?.signal;
    }
    return {
      ...options2,
      signal
    };
  }
  var VerifiedFetch = class {
    helia;
    ipnsResolver;
    dnsLink;
    log;
    contentTypeParser;
    blockstoreSessions;
    withServerTiming;
    plugins = [];
    constructor(helia2, init = {}) {
      this.helia = helia2;
      this.log = helia2.logger.forComponent("helia:verified-fetch");
      this.ipnsResolver = init.ipnsResolver ?? ipnsResolver(helia2);
      this.dnsLink = init.dnsLink ?? dnsLink(helia2);
      this.contentTypeParser = init.contentTypeParser ?? contentTypeParser;
      this.blockstoreSessions = new QuickLRU({
        maxSize: init?.sessionCacheSize ?? SESSION_CACHE_MAX_SIZE,
        maxAge: init?.sessionTTLms ?? SESSION_CACHE_TTL_MS,
        onEviction: (key, store) => {
          store.close();
        }
      });
      this.withServerTiming = init?.withServerTiming ?? false;
      const pluginOptions = {
        ...init,
        logger: helia2.logger.forComponent("verified-fetch"),
        getBlockstore: (cid, resource, useSession, options2) => this.getBlockstore(cid, resource, useSession, options2),
        helia: helia2,
        contentTypeParser: this.contentTypeParser,
        ipnsResolver: this.ipnsResolver
      };
      const defaultPlugins = [
        new DagWalkPlugin(pluginOptions),
        new ByteRangeContextPlugin(pluginOptions),
        new IpnsRecordPlugin(pluginOptions),
        new CarPlugin(pluginOptions),
        new RawPlugin(pluginOptions),
        new TarPlugin(pluginOptions),
        new JsonPlugin(pluginOptions),
        new DagCborPlugin(pluginOptions),
        new DagPbPlugin(pluginOptions)
      ];
      const customPlugins = init.plugins?.map((pluginFactory) => pluginFactory(pluginOptions)) ?? [];
      if (customPlugins.length > 0) {
        const defaultPluginMap = new Map(defaultPlugins.map((plugin) => [plugin.id, plugin]));
        const customPluginMap = new Map(customPlugins.map((plugin) => [plugin.id, plugin]));
        this.plugins = defaultPlugins.map((plugin) => customPluginMap.get(plugin.id) ?? plugin);
        this.plugins.push(...customPlugins.filter((plugin) => !defaultPluginMap.has(plugin.id)));
      } else {
        this.plugins = defaultPlugins;
      }
    }
    getBlockstore(root, resource, useSession = true, options2 = {}) {
      const key = resourceToSessionCacheKey(resource);
      if (!useSession) {
        return this.helia.blockstore;
      }
      let session = this.blockstoreSessions.get(key);
      if (session == null) {
        session = this.helia.blockstore.createSession(root, options2);
        this.blockstoreSessions.set(key, session);
      }
      return session;
    }
    /**
     * The last place a Response touches in verified-fetch before being returned to the user. This is where we add the
     * Server-Timing header to the response if it has been collected. It should be used for any final processing of the
     * response before it is returned to the user.
     */
    handleFinalResponse(response, context) {
      if ((this.withServerTiming || context?.withServerTiming === true) && context?.serverTiming != null) {
        response.headers.set("Server-Timing", context?.serverTiming.getHeader());
      }
      if (response.headers.get("Transfer-Encoding") !== "chunked") {
        if (context?.byteRangeContext != null) {
          const contentLength = context.byteRangeContext.getLength();
          if (contentLength != null) {
            this.log.trace("Setting Content-Length from byteRangeContext: %d", contentLength);
            response.headers.set("Content-Length", contentLength.toString());
          }
        }
      }
      let contentDisposition;
      if (context?.query?.download === true) {
        this.log.trace("download requested");
        contentDisposition = "attachment";
      }
      if (context?.query?.filename != null) {
        this.log.trace("specific filename requested");
        if (contentDisposition == null) {
          contentDisposition = "inline";
        }
        contentDisposition = `${contentDisposition}; ${getContentDispositionFilename(context.query.filename)}`;
      }
      if (contentDisposition != null) {
        this.log.trace("content disposition %s", contentDisposition);
        response.headers.set("Content-Disposition", contentDisposition);
      }
      if (context?.cid != null && response.headers.get("etag") == null) {
        response.headers.set("etag", getETag({
          cid: context.pathDetails?.terminalElement.cid ?? context.cid,
          reqFormat: context.reqFormat,
          weak: false
        }));
      }
      if (context?.protocol != null && context.ttl != null) {
        setCacheControlHeader({
          response,
          ttl: context.ttl,
          protocol: context.protocol
        });
      }
      if (context?.ipfsPath != null) {
        response.headers.set("X-Ipfs-Path", uriEncodeIPFSPath(context.ipfsPath));
      }
      response.headers.set("Access-Control-Allow-Origin", "*");
      response.headers.set("Access-Control-Allow-Methods", "GET, HEAD, OPTIONS");
      response.headers.set("Access-Control-Allow-Headers", "Range, X-Requested-With");
      response.headers.set("Access-Control-Expose-Headers", "Content-Range, Content-Length, X-Ipfs-Path, X-Ipfs-Roots, X-Stream-Output");
      if (context?.reqFormat !== "car") {
        response.headers.set("Accept-Ranges", "bytes");
      } else {
        response.headers.set("Accept-Ranges", "none");
      }
      if (response.headers.get("Content-Type")?.includes("application/vnd.ipld.car") === true || response.headers.get("Content-Type")?.includes("application/vnd.ipld.raw") === true) {
        response.headers.set("X-Content-Type-Options", "nosniff");
      }
      if (context?.options?.method === "HEAD") {
        return new Response(null, {
          status: 200,
          headers: response.headers
        });
      }
      return response;
    }
    /**
     * Runs plugins in a loop. After each plugin that returns `null` (partial/no final),
     * we re-check `canHandle()` for all plugins in the next iteration if the context changed.
     */
    async runPluginPipeline(context, maxPasses = 3) {
      let finalResponse;
      let passCount = 0;
      const pluginsUsed = /* @__PURE__ */ new Set();
      let prevModificationId = context.modified;
      while (passCount < maxPasses) {
        this.log(`starting pipeline pass #${passCount + 1}`);
        passCount++;
        this.log.trace("checking which plugins can handle %c%s with accept %o", context.cid, context.path != null ? `/${context.path}` : "", context.accept);
        const readyPlugins = this.plugins.filter((p2) => !pluginsUsed.has(p2.id)).filter((p2) => p2.canHandle(context));
        if (readyPlugins.length === 0) {
          this.log.trace("no plugins can handle the current context, checking by CID code");
          const plugins = this.plugins.filter((p2) => p2.codes.includes(context.cid.code));
          if (plugins.length > 0) {
            readyPlugins.push(...plugins);
          } else {
            this.log.trace("no plugins found that can handle request by CID code; exiting pipeline");
            break;
          }
        }
        this.log.trace("plugins ready to handle request: %s", readyPlugins.map((p2) => p2.id).join(", "));
        let contextChanged = false;
        let pluginHandled = false;
        for (const plugin of readyPlugins) {
          try {
            this.log("invoking plugin: %s", plugin.id);
            pluginsUsed.add(plugin.id);
            const maybeResponse = await plugin.handle(context);
            this.log("plugin response %s %o", plugin.id, maybeResponse);
            if (maybeResponse != null) {
              finalResponse = maybeResponse;
              pluginHandled = true;
              break;
            }
          } catch (err2) {
            if (context.options?.signal?.aborted) {
              throw new AbortError(context.options?.signal?.reason);
            }
            this.log.error("error in plugin %s - %e", plugin.id, err2);
            return internalServerErrorResponse(context.resource, JSON.stringify({
              error: errorToObject(err2)
            }), {
              headers: {
                "content-type": "application/json"
              }
            });
          } finally {
            const newModificationId = context.modified;
            contextChanged = newModificationId !== prevModificationId;
            if (contextChanged) {
              prevModificationId = newModificationId;
            }
          }
          if (finalResponse != null) {
            this.log.trace("plugin %s produced final response", plugin.id);
            break;
          }
        }
        if (pluginHandled && finalResponse != null) {
          break;
        }
        if (!contextChanged) {
          this.log.trace("no context changes and no final response; exiting pipeline.");
          break;
        }
      }
      return finalResponse ?? notImplementedResponse(context.resource, JSON.stringify({
        error: errorToObject(new Error("No verified fetch plugin could handle the request"))
      }), {
        headers: {
          "content-type": "application/json"
        }
      });
    }
    /**
     * We're starting to get to the point where we need a queue or pipeline of
     * operations to perform and a single place to handle errors.
     *
     * TODO: move operations called by fetch to a queue of operations where we can
     * always exit early (and cleanly) if a given signal is aborted
     */
    async fetch(resource, opts) {
      this.log("fetch %s", resource);
      if (opts?.method === "OPTIONS") {
        return this.handleFinalResponse(new Response(null, { status: 200 }));
      }
      const options2 = convertOptions(opts);
      const serverTiming = new ServerTiming();
      const urlResolver = new URLResolver({
        ipnsResolver: this.ipnsResolver,
        dnsLink: this.dnsLink,
        timing: serverTiming
      });
      options2?.onProgress?.(new CustomProgressEvent("verified-fetch:request:start", { resource }));
      let parsedResult;
      try {
        parsedResult = await urlResolver.resolve(resource, options2);
      } catch (err2) {
        if (options2?.signal?.aborted) {
          throw new AbortError(options2?.signal?.reason);
        }
        this.log.error("error parsing resource %s", resource, err2);
        return this.handleFinalResponse(badRequestResponse(resource.toString(), err2));
      }
      options2?.onProgress?.(new CustomProgressEvent("verified-fetch:request:resolve", { cid: parsedResult.cid, path: parsedResult.path }));
      const acceptHeader = getResolvedAcceptHeader({ query: parsedResult.query, headers: options2?.headers, logger: this.helia.logger });
      const accept = selectOutputType(parsedResult.cid, acceptHeader);
      this.log("accept %o", accept);
      if (acceptHeader != null && accept == null) {
        this.log.error("could not fulfil request based on accept header");
        return this.handleFinalResponse(notAcceptableResponse(resource.toString()));
      }
      const responseContentType = accept?.mimeType.split(";")[0] ?? "application/octet-stream";
      const redirectResponse = await getRedirectResponse({ resource, options: options2, logger: this.helia.logger, cid: parsedResult.cid });
      if (redirectResponse != null) {
        return this.handleFinalResponse(redirectResponse);
      }
      const context = {
        ...parsedResult,
        resource: resource.toString(),
        accept,
        options: options2,
        onProgress: options2?.onProgress,
        modified: 0,
        plugins: this.plugins.map((p2) => p2.id),
        query: parsedResult.query ?? {},
        withServerTiming: Boolean(options2?.withServerTiming) || Boolean(this.withServerTiming),
        serverTiming
      };
      this.log.trace('finding handler for cid code "%s" and response content type "%s"', parsedResult.cid.code, responseContentType);
      const response = await this.runPluginPipeline(context);
      options2?.onProgress?.(new CustomProgressEvent("verified-fetch:request:end", {
        cid: parsedResult.cid,
        path: parsedResult.path
      }));
      if (response == null) {
        this.log.error("no plugin could handle request for %s", resource);
      }
      return this.handleFinalResponse(response, context);
    }
    /**
     * Start the Helia instance
     */
    async start() {
      await this.helia.start();
    }
    /**
     * Shut down the Helia instance
     */
    async stop() {
      await this.helia.stop();
    }
  };

  // node_modules/@helia/verified-fetch/dist/src/index.js
  async function createVerifiedFetch(init, options2) {
    let libp2p;
    if (!isHelia(init)) {
      const dns2 = createDns(init?.dnsResolvers);
      const libp2pConfig = getLibp2pConfig();
      libp2pConfig.dns = dns2;
      const delegatedRouters = init?.routers ?? ["https://delegated-ipfs.dev"];
      for (let index = 0; index < delegatedRouters.length; index++) {
        const routerUrl = delegatedRouters[index];
        libp2pConfig.services[`delegatedRouting${index}`] = () => createDelegatedRoutingV1HttpApiClient(routerUrl);
      }
      if (init?.libp2pConfig != null) {
        Object.assign(libp2pConfig, init.libp2pConfig);
      }
      libp2p = await createLibp2p(libp2pConfig);
      const blockBrokers = [
        bitswap()
      ];
      const routers = [
        libp2pRouting(libp2p)
      ];
      if (init?.gateways == null || init.gateways.length > 0) {
        blockBrokers.push(trustlessGateway({ allowInsecure: init?.allowInsecure, allowLocal: init?.allowLocal }));
        routers.push(httpGatewayRouting({ gateways: init?.gateways ?? ["https://trustless-gateway.link"] }));
      }
      init = await createHelia({
        libp2p,
        blockBrokers,
        dns: dns2,
        routers,
        hashers: init?.hashers
      });
      init.logger.forComponent("helia:verified-fetch").trace("created verified-fetch with libp2p config: %j", libp2pConfig);
    }
    const verifiedFetchInstance = new VerifiedFetch(init, options2);
    async function verifiedFetch(resource, options3) {
      return verifiedFetchInstance.fetch(resource, options3);
    }
    verifiedFetch.start = verifiedFetchInstance.start.bind(verifiedFetchInstance);
    verifiedFetch.stop = verifiedFetchInstance.stop.bind(verifiedFetchInstance);
    return verifiedFetch;
  }
  function isHelia(obj) {
    return obj?.blockstore != null && obj?.datastore != null && obj?.gc != null && obj?.stop != null && obj?.start != null;
  }
  function createDns(resolvers2) {
    if (resolvers2 == null) {
      return;
    }
    if (Array.isArray(resolvers2)) {
      return dns({
        resolvers: {
          ".": resolvers2
        }
      });
    }
    return dns({ resolvers: resolvers2 });
  }

  // src/Ipfs.js
  var Ipfs = class {
    #vFetch;
    async asSetHelia(helia2) {
      this.#vFetch = await createVerifiedFetch(helia2);
    }
    async asFetchCidJson(scid) {
      const cid = CID.parse(scid);
      const r2 = await this.#vFetch(cid, { signal: AbortSignal.timeout(2e4) });
      return await r2.json();
    }
    async asFetchCidImage(scid) {
      const cid = CID.parse(scid);
      const r2 = await this.#vFetch(cid, { signal: AbortSignal.timeout(2e4) });
      let blob = await r2.blob();
      return new Promise((resolve8, reject) => {
        const reader2 = new FileReader();
        reader2.onloadend = () => resolve8(reader2.result);
        reader2.onerror = reject;
        reader2.readAsDataURL(blob);
      });
    }
  };

  // src/Utilities.js
  var Utilities = class {
    isCid(s2) {
      try {
        CID.parse(s2);
        return true;
      } catch (e2) {
        return false;
      }
    }
  };

  // src/User.js
  var User = class {
    #data;
    #dPosts;
    #dIdols;
    #dMarks;
    #iconUrl;
    #ipfs = new Ipfs();
    #util = new Utilities();
    _dataSource;
    _delegate;
    constructor(data) {
      this.#data = data;
    }
    isFeed() {
      return false;
    }
    hasIdol(userId) {
      if (this.#dIdols) {
        return this.#dIdols.idols.some((i2) => i2.id == userId);
      } else {
        this._asGetOrInitIdolRoot().then((d2) => this.#onIdolsLoaded());
        return false;
      }
    }
    getId() {
      return this._getData("uuid");
    }
    getUsername() {
      return this.getId();
    }
    getProfile() {
      return this._getDataOrDefault("profile", {});
    }
    getNickname() {
      return this._getDataOrDefault("profile", {}).nickname;
    }
    getIconUrl() {
      if (this.#iconUrl) {
        return this.#iconUrl;
      } else {
        let cid = this._getDataOrDefault("profile", {}).icon_cid;
        if (cid) {
          this.#asFetchIconImage(cid).then(() => this.#onProfileLoaded());
          return null;
        } else {
          this.#iconUrl = "";
          return this.#iconUrl;
        }
      }
    }
    getLogoUrl() {
      return this.getIconUrl();
    }
    getInfoImageUrl() {
      return null;
    }
    getDomainUrl() {
      return "N/A";
    }
    getBackgroundColor() {
      return null;
    }
    getColorTheme() {
      return null;
    }
    getNIdols() {
      if (this.#dIdols) {
        return this.#dIdols.idols.length;
      } else {
        this._asGetOrInitIdolRoot().then((d2) => this.#onIdolsLoaded());
        return 0;
      }
    }
    getNFollowers() {
      return 0;
    }
    getBriefBio() {
      return "";
    }
    setDataSource(dataSource) {
      this._dataSource = dataSource;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    reset(data) {
      this._reset(data);
    }
    async asyncGetIdolIds() {
      let d2 = await this._asGetOrInitIdolRoot();
      return d2.idols.map((i2) => i2.id);
    }
    async asyncFindMark(key) {
      if (!key) {
        return null;
      }
      let d2 = await this._asGetOrInitMarkRoot();
      return await this.#asFindMark("", key, d2.marks);
    }
    async asyncLoadMorePostInfos(idRecord) {
      let dPosts = await this._asGetOrInitPostRoot();
      let segId = idRecord.getNextSegmentId();
      if (segId > 0) {
        return Promise.resolve();
      } else {
        return dPosts.posts;
      }
    }
    _hasData() {
      return !!this.#data;
    }
    _getData(name9) {
      return this.#data ? this.#data[name9] : null;
    }
    _getDataOrDefault(name9, vDefault) {
      let d2 = this._getData(name9);
      return d2 ? d2 : vDefault;
    }
    _reset(data) {
      this.#data = data;
      this.#dPosts = null;
      this.#dMarks = null;
      this.#iconUrl = null;
    }
    async _asGetOrInitIdolRoot() {
      if (!this.#dIdols) {
        let cid = this._getData("idols");
        if (this.#util.isCid(cid)) {
          this.#dIdols = await this.#ipfs.asFetchCidJson(cid);
        } else {
          this.#dIdols = { idols: [] };
        }
      }
      return this.#dIdols;
    }
    async _asGetOrInitPostRoot() {
      if (!this.#dPosts) {
        let cid = this._getData("posts");
        if (this.#util.isCid(cid)) {
          try {
            this.#dPosts = await this.#ipfs.asFetchCidJson(cid);
          } catch (e2) {
            this.#dPosts = { posts: [] };
          }
        } else {
          this.#dPosts = { posts: [] };
        }
      }
      return this.#dPosts;
    }
    async _asGetOrInitMarkRoot() {
      if (!this.#dMarks) {
        let cid = this._getData("marks");
        if (this.#util.isCid(cid)) {
          this.#dMarks = await this.#ipfs.asFetchCidJson(cid);
        } else {
          this.#dMarks = { marks: {} };
        }
      }
      return this.#dMarks;
    }
    _setData(name9, value2) {
      this.#data[name9] = value2;
    }
    #onIdolsLoaded() {
      if (this._delegate) {
        this._delegate.onWeb3UserIdolsLoaded(this);
      }
    }
    #onProfileLoaded() {
      if (this._delegate) {
        this._delegate.onWeb3UserProfileLoaded(this);
      }
    }
    async #asFindMark(prefix, suffix, dMarks) {
      if (!dMarks) {
        return null;
      }
      let key = prefix + suffix;
      if (key in dMarks) {
        return dMarks[key];
      }
      if (suffix.length > 2) {
        key = suffix.slice(0, 2);
        if (key in dMarks) {
          let cid = dMarks[key];
          let d2 = await this.#ipfs.asFetchCidJson(cid);
          return await this.#asFindMark(prefix + key, suffix.slice(2), d2.marks);
        }
      }
      return null;
    }
    async #asFetchIconImage(cid) {
      this.#iconUrl = await this.#ipfs.asFetchCidImage(cid);
    }
  };

  // src/Owner.js
  var Owner = class extends User {
    // Note: This file is version sensitive, shall be backward compatible
    static #VERSION = "1.0";
    #aPublishers = [];
    #aStorage = null;
    hasPublished() {
      return this._getDataOrDefault("edition", 0) > 0;
    }
    // TODO: Clearly define isAuthenticated
    isAuthenticated() {
      return this._hasData();
    }
    isWebOwner() {
      return this.isAuthenticated();
    }
    isFollowing(userId) {
      return this.hasIdol(userId);
    }
    isIdolOf(user) {
      return user.hasIdol(this.getId());
    }
    getId() {
      return this._getData("uuid");
    }
    getNickname() {
      return this._getDataOrDefault("profile", {}).nickname;
    }
    getUserNickname(userId, defaultName) {
      return userId;
    }
    getPreferredLanguage() {
      return null;
    }
    getPublicKey() {
      return this._dataSource.onWeb3OwnerRequestGetPublicKey(this);
    }
    setStorage(agent) {
      this.#aStorage = agent;
    }
    setPublishers(agents) {
      this.#aPublishers = agents;
    }
    asyncFollow(userId) {
      this.#asFollow(userId).then(() => this.#onProfileUpdated());
    }
    asyncUnfollow(userId) {
      this.#asUnfollow(userId).then(() => this.#onProfileUpdated());
    }
    asyncReload() {
    }
    reset(data) {
      super.reset(data);
      this.#onProfileUpdated();
    }
    loadCheckPoint() {
      let s2 = this._dataSource.onWeb3OwnerRequestLoadCheckPoint(this);
      this._reset(s2 ? JSON.parse(s2) : null);
    }
    saveCheckPoint() {
      this._delegate.onWeb3OwnerRequestSaveCheckPoint(
        this,
        JSON.stringify(this.#toLtsJsonData())
      );
    }
    async asRegister(agent, name9) {
      const msg = JSON.stringify({ id: this.getId(), name: name9 });
      const sig = await this.#asSign(msg);
      await agent.asRegister(msg, this.getPublicKey(), sig);
    }
    async asUploadFile(file) {
      const token = await this.#aStorage.asGetUploadToken(this.getId());
      const sig = await this.#asSign(token);
      let d2;
      if (file.type.startsWith("image")) {
        d2 = await this.#aStorage.asUploadImage(file, this.getId(), token, sig);
      } else {
        d2 = await this.#aStorage.asUploadFile(file, this.getId(), token, sig);
      }
      return d2.cid;
    }
    async asUploadJson(data) {
      const msg = JSON.stringify(data);
      const sig = await this.#asSign(msg);
      return await this.#aStorage.asUploadJson(msg, this.getId(), sig);
    }
    async asLike(key) {
      let d2 = await this.asyncFindMark(key);
      if (!d2) {
        d2 = { comments: [] };
      }
      if (d2.like) {
        return;
      }
      d2.like = true;
      await this.#asMark(key, d2, []);
    }
    async asUnlike(key) {
      let d2 = await this.asyncFindMark(key);
      if (!d2) {
        return;
      }
      if (!d2.like) {
        return;
      }
      d2.like = false;
      await this.#asMark(key, d2, []);
    }
    async asComment(key, postInfo, refCids) {
      let d2 = await this.asyncFindMark(key);
      if (!d2) {
        d2 = { comments: [] };
      }
      d2.comments.unshift(postInfo);
      await this.#asMark(key, d2, refCids);
    }
    async asUpdateProfile(d2, newCids) {
      this._setData("profile", d2);
      await this.#asPublish({ texts: newCids });
    }
    async asPublishPost(postInfo, refCids) {
      console.debug("Publishing post...");
      postInfo.timestamp = Date.now();
      let newCids = [...refCids];
      let dIdx = await this._asGetOrInitPostRoot();
      dIdx.posts.unshift(postInfo);
      let cid = this._getData("posts");
      console.debug("Uploading post list...");
      cid = await this.asUploadJson(dIdx);
      this._setData("posts", cid);
      newCids.push(cid);
      await this.#asPublish({ texts: newCids });
    }
    #onProfileUpdated() {
      if (this._delegate) {
        this._delegate.onWeb3OwnerProfileUpdated(this);
      }
    }
    async #asSign(msg) {
      return this._delegate.asOnWeb3OwnerRequestSign(this, msg);
    }
    #toLtsJsonData() {
      let d2 = {
        uuid: this.getId(),
        profile: this._getDataOrDefault("profile", {}),
        idols: this._getDataOrDefault("idols", null),
        posts: this._getDataOrDefault("posts", null),
        marks: this._getDataOrDefault("marks", null)
      };
      d2.version = this.constructor.#VERSION;
      d2.edition = this._getDataOrDefault("edition", 0);
      return d2;
    }
    async #asFollow(userId) {
      let idolInfo = { timestamp: Date.now(), type: "USER", id: userId, nickname: null };
      let dIdx = await this._asGetOrInitIdolRoot();
      dIdx.idols.unshift(idolInfo);
      await this.#asUpdateIdols(dIdx);
    }
    async #asUnfollow(userId) {
      let dIdx = await this._asGetOrInitIdolRoot();
      dIdx.idols = dIdx.idols.filter((i2) => i2.id != userId);
      await this.#asUpdateIdols(dIdx);
    }
    async #asMark(key, markInfo, refCids) {
      let dRoot = await this._asGetOrInitMarkRoot();
      dRoot.marks[key] = markInfo;
      let newCids = [...refCids];
      let cid = this._getData("marks");
      cid = await this.asUploadJson(dRoot);
      this._setData("marks", cid);
      newCids.push(cid);
      await this.#asPublish({ texts: newCids });
    }
    async #asUpdateIdols(dIdx) {
      let newCids = [];
      let cid = this._getData("idols");
      cid = await this.asUploadJson(dIdx);
      this._setData("idols", cid);
      newCids.push(cid);
      await this.#asPublish({ texts: newCids });
    }
    async #asPublish(newCidInfo) {
      try {
        await this.#asDoPublish(newCidInfo);
      } catch (e2) {
        this.loadCheckPoint();
        throw e2;
      }
    }
    async #asDoPublish(newCidInfo) {
      console.debug("Publishing content...");
      this._setData("edition", this._getDataOrDefault("edition", 0) + 1);
      console.debug("Uploading content...");
      let cid = await this.asUploadJson(this.#toLtsJsonData());
      this._setData("_cid", cid);
      newCidInfo.texts.push(cid);
      let sig = await this.#asSign(cid);
      console.debug("Publishing...");
      for (let a2 of this.#aPublishers) {
        await a2.asPublish(cid, this.getId(), sig);
      }
      console.debug("Pinning content...");
      const msg = JSON.stringify({ cids: newCidInfo.texts });
      sig = await this.#asSign(msg);
      await this.#aStorage.asPin(msg, this.getId(), sig);
      this.saveCheckPoint();
    }
  };
  return __toCommonJS(index_exports);
})();
/*! Bundled license information:

pvtsutils/build/index.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2024 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.es.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)

@noble/ciphers/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@peculiar/x509/build/x509.es.js:
  (*!
   * MIT License
   * 
   * Copyright (c) Peculiar Ventures. All rights reserved.
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)
*/
